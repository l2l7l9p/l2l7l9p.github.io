{"meta":{"title":"Four's","subtitle":"一鼓作气，三题暴力","description":"","author":"kqp","url":"http://kqp.world","root":"/"},"pages":[{"title":"友情链接","date":"2024-02-26T13:02:19.854Z","updated":"2022-01-26T02:06:46.000Z","comments":true,"path":"links/index.html","permalink":"http://kqp.world/links/index.html","excerpt":"","text":""},{"title":"categories","date":"2022-01-26T07:41:11.000Z","updated":"2022-01-26T07:42:26.000Z","comments":true,"path":"categories/index.html","permalink":"http://kqp.world/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2022-01-26T07:40:55.000Z","updated":"2022-01-26T07:43:46.000Z","comments":true,"path":"tags/index.html","permalink":"http://kqp.world/tags/index.html","excerpt":"","text":""},{"title":"About","date":"2025-02-10T13:19:56.031Z","updated":"2025-02-10T13:19:56.031Z","comments":true,"path":"personal/index.html","permalink":"http://kqp.world/personal/index.html","excerpt":"","text":"HKU CS PhD year 3，目前在搞的东西是 Counting and Sampling，主要是 spin system 相关 Weighted First-Order Model Counting / Sampling，及其 parameterized complexity, Uniform Graphlet Sampling (streaming ver.), $\\mathsf{\\sharp P_1}$ 这个类的 completeness、reduction、open problems. 一些许久没碰的题： Fine-Grained Complexity + Zero-Knowledge Proof, Cooperative Game Theory, Markov Equivalent DAG counting / sampling. 姑且算是有条主线叫 counting / sampling，虽然我更喜欢 complexity / cryptography。 大概从大二起，多重因素影响下（竞赛算法经历、AI 现状、对某学长的个人崇拜），选择了 TCS 的道路。稍微可惜的是选的老板并不是 complexity 背景的，我们方向重合度一般。如果有什么送给后辈的话那一定是，选老板一定不要冲动，不要看见个 PhD 就飞蛾扑火 退役竞赛选手，AF OIer+ACMer，中山大学_无人之境 (SYSU_Unhindered) 45th World Final (Dhaka) 进了但是去不成，46th World Final (Luxor) 并列 26 名。出过些许题，为 OI 和 XCPC 贡献过一点锅绵薄之力。 LoveLiver，2016 年暑假入坑，恰逢缪退役水兴起之时，大约是个水水人+前四代 dd。二次元三次元手游谷子全方位厨，会看 live，现地过星 3rd、星 4th、AZUNA 1st 、小组甲子园、2024 亚巡广州上海场，LL Days 封面好看的就会买。目前最大的期待是现地水 FL。 动画喜欢看废萌、日常、轻百合、偶像，热番和猎奇番偶尔看，高质量老番慢慢补。逛漫展会去偶像舞台应援。 不宅的时候也很阳光的，hiking 和暴走爱好者，喜欢游历山水，走街串巷，骑行或步行遍历城市，偶尔随机游走，会跑步。 有一位美丽的姑娘一起前进。 正在做的事 做 counting 并寻求合作，希望有人带带做 complexity 看 Clannad 第1季、摇曳露营第1季、海豹突击队第1季、莲之空、邪神与厨二病第1季、鬼灭第1季、Liella 第3季 争取有时间读 LL Days、美学哲学理论、文学理论 教 python 和 AI"}],"posts":[{"title":"LoveLive 系列亚巡广州上海场","slug":"lovelive_asia_tour_2024","date":"2024-10-08T07:55:58.000Z","updated":"2024-10-13T08:37:26.999Z","comments":true,"path":"lovelive_asia_tour_2024/","link":"","permalink":"http://kqp.world/lovelive_asia_tour_2024/","excerpt":"&emsp;&emsp;为什么中 nips 都没什么欲望写博客发个动态，倒是 lovelive 很想写 qaq","text":"&emsp;&emsp;为什么中 nips 都没什么欲望写博客发个动态，倒是 lovelive 很想写 qaq &emsp;&emsp;或许还是想把学术的兴奋阈值提高一点，娱乐的兴奋阈值降低一点吧，前者是 symbol 的教诲。 &emsp;&emsp;许久没有亚巡了吧。19 年的水亚巡，那时还不懂看 live，不知道为什么就看到贴吧上一群人聚集在上海，看他们排场贩像看猴儿一样。&emsp;&emsp;也不曾料到，这次亚巡有广州上海，星专场和缪水虹星四团。你缪啊你缪，2024 开启疯狂诈尸模式，音乐会、fmt 和海外 fmt、拼盘亚巡。这下可好了，20 年 fes 没去成遗憾得死去活来，24 年缪广州 fmt 没抢到票，总想着有生之年给缪补个门票，突然就时候到了。 抢票&emsp;&emsp;看什么时候有空再回来吐槽吧。。。&emsp;&emsp;总之就是，相比去日本剩下来的机票酒店钱，全部补在票钱里了。。。&emsp;&emsp;各种乱象应有尽有，根据舆论自适应定价，官牛横行，天价前排，临近开演卖不出的票还打折卖。&emsp;&emsp;发明抽票的人该死，但是联合官牛的抢票商更应碎尸万段。 广州&emsp;&emsp;广州场跟 Abby 一起来的，她帮我抢的双人票，正好带她体验一下日式 live。虽然一路奔波已经把她累坏了 qaq&emsp;&emsp;广州星专场。我习惯性地套用以前水亚巡的思路，认为就是以动画为主线，唱动画曲，幕间播动画，这样避免日语 mc。然而结果大为惊喜。&emsp;&emsp;伽黎佬组织了开场光路和星光序曲的光路，从彩虹色到最后副歌橙海，完全就是动画里缤纷的花海而后铺出金色的光辉，蔚为壮观。这是星光序曲有史以来第一次复刻动画光路，日本人都做不到的事情我们做到了！光路象征着舞台是相互的，台上的人带来歌舞，我们也给她们铺出梦幻的舞台效果。sayu 几个在台上浅浅地赞了几句，不知她们心中又是否有被震撼呢？我们可是把自己都震撼到了，赞叹民间强大的组织力。希望这载入史册的光路能进 bd。&emsp;&emsp;开场各团 op 由 Liella 唱，破企划现在沉迷换歌，乐死我们这帮 dd。&emsp;&emsp;星专场自然是星歌为主，但却并不全是动画曲，也不以动画为主线，似乎也没有主线，也是劲歌金曲大放送，哪首人气高、能热场就搞哪首。mc 也多，鲤鱼当翻译，跟水亚巡完全不一样了，我这老古董思想该改变了。&emsp;&emsp;最后唱了梦门，她们说梦门是 Liella 全体都喜欢的一首歌。缪歌源源不断地从后辈身上冒出来，追逐梦想的情怀依然在延续。&emsp;&emsp;Abby 小朋友不太会玩 call，我就一直给她讲解这是什么歌，有时候帮她切颜色。也让她感受到了应援是可以整齐而声势浩大的，同时也是非常消耗体力的。&emsp;&emsp;前面和右边坐的都是日本老哥。日本老哥的应援明显更细致，会跟台上的舞蹈动作。尝试跟右边的老哥交谈，比如问问是不是也去上海场、介绍光路企划、感叹光路企划的成功。 上海&emsp;&emsp;再也不会癫到前一天晚上看完 live 吃个海底捞还要第二天早上七八点飞上海了。。。 &emsp;&emsp;事实上前一天彩排已经剧透了一些劲爆歌单，水族馆、aao、no brand girls，已经能意识到上海场只会比广州场更加炸裂。&emsp;&emsp;第一次见如此盛大隆重的外场。四处摆摊，换谷子、送无料、展览谷子、搞签名、艺术展演、anikura……摊位可能不比日本多，但花样可是多得多。女生差不多一半都是穿的五校校服（至少有校服群），人群中有她们仿佛这里就是 LL 里的世界，五校学生出来看自家的学园偶像。男生穿得五花八门，各种痛衣法披场 T，还有搞笑标语（比如“别 nm 用老子表情了——奇卡”）。如此之隆重也看得出这场 live 在他们心中的意义。外场已然是个小型的 LL Only。 &emsp;&emsp;进场也是五校学生落座的感觉。&emsp;&emsp;水 part 的歌都是令人兴奋至极的歌。各自一首代表曲，曜竟然是厄爆水族馆，可谓正中下怀，虎啸震天，海鲜遍地，万众田夫，厄成军 call，人人都厄，不厄都是地藏了；露比是 aao，其实也见得多了，没有姐姐以及各种道具都少几分乐趣；善子是深度共鸣，每次听 kyan 的怒吼都会为之震撼。jump up high，自 5th 以来一直是压在心中的遗憾，完全想不到能听现场版，充满希望与鼓励的应援回荡，好似我们就是即将上场的奥运健将，只恨没有毛巾可甩。&emsp;&emsp;虹 part，无敌信徒可是好久好久没有听了，厂长扭动着她的孕妇装,菜宝女王风的 eutopia 加入了不少中国特别应援，还有蹦蹦跳跳不喘气的 Mia Taylor Swift。&emsp;&emsp;星 part 正常发挥。星序已经成了下一代橙海，不过毕竟从广州场过来，创造过橙海前的花海，还是广州场吊打上海场。&emsp;&emsp;缪，刚出场我甚至都没有感觉，六单练得很熟了，漫展经常玩。半首过后，我才惊醒，缪，这是缪啊！你最初的感动啊！你最早向往的美好啊！你一直求而不得的缪啊！身体忽然一阵颤抖，仿佛逐渐开始时光倒流。随着缪的自我介绍，一首接一首的缪歌，大家都一起开始穿越。&emsp;&emsp;地板都是震的，偶尔累了不里跳了，立正站好，就会被地板带着晃起来。后来才知道，连导播的镜头都是晃的，一拉近景就蹦蹦跳跳，仿佛摄影师也在打 call。&emsp;&emsp;snow halation，我们这场子多少人只闻传说而从未体验的梦寐以求的白色应援和奇迹橙海，今天我们都晋升为橙海的一员。入场极其严格的安检，还要翻包好几次，结果最后的副歌一出，人手两根化棒，那可真是火海，那是真的在跳动的火焰，亮如核爆。我也第一次敲化棒，那亮度真是无可比拟，真真正正是点亮了橙海。&emsp;&emsp;no brand girls，第一次缪水虹星四团合唱，升教旗，奏教歌。在最后的激烈与情怀中，彻底把嗓子干废，把地板震碎。那照相的动作一咔嚓，保存下新的美好瞬间。 &emsp;&emsp;华东虎展现出了中华虎群碾压性的优势。华南虎反而这两年蔫了，广州场秩序井然，也可能是上海场的歌单天然更虎。 &emsp;&emsp;整个亚巡其实歌单脉络都比较像劲歌金曲，99% 的人气歌、整活歌、燃歌、情怀歌，所以相比之下有时候更喜欢以一季动画为主题的数字 live，更有主题脉络。当然了，外国场、缪回归这几个因素加起来，亚巡必然要以人气歌和情怀歌为主的，所以尽兴就完事了，好好回味缪升教旗奏教歌的初成之欢、水高高跳起给人们带来的鼓舞、虹初出茅庐一手 ksks 单曲崭露头角的喜悦、星光序曲铺出下一代的勇气。 结束&emsp;&emsp;有一种完成愿望、补上了遗憾、再无悬念的感觉。&emsp;&emsp;lovelive 是个好故事，演唱会很好玩，但是我不需要以它为精神支柱了。以前一个人，困惑的时候就看 LL 的故事，不仅包括动画故事，还有他们一步一步走上巅峰的故事，和台下观众们一同塑造的故事。但是一直到 2023 年才有机会去看 live，所以这两年都有点报复性。&emsp;&emsp;从最初的山顶 Liella 到甲子园见到了所有人，再到这次不曾想连缪也能见到，一首一首只在 live 录像里看到的很向往又很遗憾错过的歌曲，都渐渐在现地补全了。好像 clear 了一张挑战任务表。&emsp;&emsp;Abby 小朋友改变了我很多。以前 LL 是唯一的陪跑的朋友，现在我有真正并肩前进的队友了。科研也逐渐有了点盼头，好像有属于自己的方向可以奋斗了。&emsp;&emsp;不知道接下来还会跑什么活动，可能水 fl，可能星六巡，或者更远的不知道的东西，或者这些都不去。但是，肯定不会再有这次这么癫了，短短四天通勤三地。 &emsp;&emsp;感谢这次亚巡，能见到仍然穿着演出服的 μ’s 和 Aqours，也传递了我们创造的台下之景。","categories":[{"name":"玩","slug":"玩","permalink":"http://kqp.world/categories/%E7%8E%A9/"}],"tags":[]},{"title":"2023 World Final 真·退役记","slug":"2023_WF","date":"2024-04-20T06:37:00.000Z","updated":"2024-04-24T04:24:26.241Z","comments":true,"path":"2023_WF/","link":"","permalink":"http://kqp.world/2023_WF/","excerpt":"一曲新词酒一杯，去年天气旧亭台。夕阳西下几时回？无可奈何花落去，似曾相识燕归来。小园香径独徘徊。","text":"一曲新词酒一杯，去年天气旧亭台。夕阳西下几时回？无可奈何花落去，似曾相识燕归来。小园香径独徘徊。 &emsp;&emsp;2018，symbol：“去实现你未完成的梦想。” &emsp;&emsp;2019，左左：“把 final 进了再说。” &emsp;&emsp;大概是有了这两句话，才真正意识到 XCPC 不比 OI 轻松，才坚定了本科继续打比赛的想法。&emsp;&emsp;即便去掉高三那也有 6 年 OI 了，经此一役，又不知道竞赛之路还有多长。但是长点好啊，中学的我太菜了，总算是在大学练出了个人样。 &emsp;&emsp;随着无人之境在大三出线，队友各自找实习和申请升学，我也意识到这条路很快就要走完了。只是一次又一次喊退役，又总是因各种原因出现在各种赛场上。只要这个 WF 不来，我们依然都还是选手身份，即便我们都毕业两年了，成为社畜和科研狗了。 46th World Final 谁研二还要打 final 啊~——2021 EC Final 退休游记 &emsp;&emsp;一语成谶。&emsp;&emsp;2022年，无人之境在大四毕业的暑假捡漏出线，当时意外得很，却也没放在心上，一笑了之。人都毕业了，这比赛还能打吗？ 希望孟加拉还是能去线下。——2021 EC Final 退休游记 &emsp;&emsp;一口毒奶（x&emsp;&emsp;2022 年秋天，45th WF Dhaka，因为疫情原因我们无法一起出国，遂弃，于是捡漏捡到的 46th WF 就成了万幸。 &emsp;&emsp;队友们都进公司工作了，拿着高薪却也繁忙。我继续找了个 phd 读，事情不比上班轻松多少，也要不停地读论文想题目，还有一大堆研究生要干的杂活。就这么过了一年，没有训练，偶尔打打 cf 或者 at，还有些 bytedance 清华营之类的，似乎离竞赛很遥远。&emsp;&emsp;zayin 好像在坚持打 cf，他还离竞赛很近，我有点不知道怎样才能达到他的状态，但更不确定我想不想要这个状态。我总有太多想做的事情，把自己标榜为学术人之后，空闲时间更想拿来读自己感兴趣的 textbook 和论文。 &emsp;&emsp;2023 年 9 月，phd 二年级，开始当 hku 教练，要出校队选拔题、安排日常训练、排赛站、带队去比赛，一下子又离竞赛很近了。&emsp;&emsp;46th WF 也终于敲定时间地点，11 月在埃及沙姆沙伊赫，和 47th WF 合办。那么康复训练就张罗起来了。&emsp;&emsp;教练正在热身&emsp;&emsp;能明显感觉到虽然思维能力这么多年已经练出了成熟的下界，但是码力和反应力都在下降，签到题变得磕磕绊绊，老套路开始生疏，例如长链剖分都需要重新复习好一阵子才能写了。在训练中常常被 carry。&emsp;&emsp;说实在的到了后期，这个比赛获奖对我们有用吗？没有，拿牌了队友不会升职加薪我也不会多中论文，垫底了队友不会被开除（pony.ai 除外）我也不会被退学。于我而言，这是为了体面地把一件事做完，好聚好散，风风光光。算法竞赛好玩，最后再玩一次。&emsp;&emsp;所以我们也没有定宏伟的目标，我们就是来旅游的，我们只要能把实力发挥出来，能到哪里就到哪里，拿牌捧杯的任务那是 jiangly 他们的（ &emsp;&emsp;基本上把机票签证全部安排妥当之后——巴以冲突爆发，WF 因安全问题延期。好好的一届 WF，遭受疫情和战争双重背刺。&emsp;&emsp;康复训练随即停下脚步，退役时间再推半年。&emsp;&emsp;抢 uo 特价机票，计划 4 月跟小付去关西玩。&emsp;&emsp;2024 年 1 月，宣布改在 4 月卢克索，正好撞上关西行程。所幸后来看日程安排，关西行程仅冲突了官方旅游和华为挑战赛，遂决定翘，直接来个 10 天小长假，来个关西飞埃及的半球飞行。&emsp;&emsp;康复训练在过年后重新开始。这几场用区域赛和 ucup 来练，这是当下为数不多的优质题源了。想刷点 WF 真题，毕竟一般来说 WF 整体难度比区域赛高不少，没有弱智签到，简单题都会很繁琐。但是近几年的 WF 题大家多多少少都看过做过，只剩 44th 的 WF 邀请赛可以训练，但这一场反而也是签到居多，打下来还不错。&emsp;&emsp;事实上延期的这段时间战争并没有消停，反而愈打愈烈，更多国家下场，更多区域开打，临近出发时，欧洲和中东形成了一条由北至南依次是乌克兰、约旦、加沙、红海、也门的封锁线，航班过去如同穿越火线（x&emsp;&emsp;老板：为什么你们疫情不敢去，现在战争反而敢去了？ &emsp;&emsp;在关西愉快地玩耍了三天之后，4 月 15 日跟小付从 KIX 分别，她 KIX-&gt;HKG，我 KIX-&gt;TFU-&gt;CAI-&gt;LXR。&emsp;&emsp;在 TFU 满怀期待即将登机时，一封 LICS 拒信突如其来，如地震般几秒钟摧毁了城市。至今手上唯一一篇真正的学术作品而不是灌水，唯一一篇把数学玩成工艺品的，唯一一篇理论 CCF-A，phd 前两年仅剩的发表机会，唯一一篇胜券在握的文章，死了。&emsp;&emsp;被一个垃圾 reviewer 搞死了，他给个 borderline，原因是我们工作量太大，25min 的会议 pre 不完（这nm是 review 意见？？？），希望我们把两条主线拆成两篇并投 journal（他就没懂我们的工作重点就是 bridging 这俩主线，拆nm呢）。我们商量一致决定 rebuttal 对他的意见略写，毕竟有字数限制（Ondrej 老师：如果我们略写，那 pc 也会自然地忽略掉这个 sb 意见，但如果我们详写，pc 就会觉得是不是我们心中有鬼，就会反过来觉得这个 reviewer 讲得有道理了），结果最终 comment 说我们不重视他的意见。。。他似乎就是 pc，其他俩人都评价不错就这人有牢骚，最后就是他给拒了应该。这种人应当祭天。&emsp;&emsp;虽然也不是他全责，邮件里说今年非常卷，要三个 accept 才能中，我们有一个 weak accept 喷 writing 的，那其实也是没戏了。（喷 writing 那还是我的锅啊&emsp;&emsp;跟大家达成一致转投 SODA 或 NIPS，心情好了一点，起码 CCF-A 还是有希望。&emsp;&emsp;TFU-&gt;CAI 这段就直接昏睡了，并没有干活的欲望。讨厌这种国际航班凌晨两点喊人起来吃早餐。&emsp;&emsp;飞机的航线经过黑海和以色列附近，蹭过两大战区（x &emsp;&emsp;在开罗机场体验到了埃及人蹭脸要小费，是先跟你说免费帮你然后反口要小费的那种。我坚持不给，但也变得小心翼翼，避免产生给人帮助的机会。&emsp;&emsp;Ondrej 老师认为 sampling 的文章应该在这篇 counting 中了之后再投，于是乎 KR 的 ddl 也没了，繁重的代码实现任务突然轻了一半，也就不想干活了（x &emsp;&emsp;到达卢克索已是 16 号下午，华为挑战赛结束，跟队友去补拍照片。 如果真的能去埃及，看看会不会出现“hku 教练代表 sysu 参赛”的怪事hhh。——杂写 &emsp;&emsp;跳反！我的身份牌是绿的！（大雾） &emsp;&emsp;尼罗河边的五星级酒店表面还是很豪华的，就是有蚊子苍蝇。饭菜味道挺好，但是口感真不咋地，烤鸡硬如柴，煮牛正常发挥，烤鱼柳好吃但是鱼柳毕竟不是新鲜鱼，馅饼也硬。香瓜倒是非常甜。&emsp;&emsp;这个国家很神奇，正如地图所见，只有尼罗河沿岸是绿色的，离开河流就是黄色的。热带沙漠气候展露无余，闷热，阳光毒辣。整个城市显得贫穷，房子都很破，马车汽车摩托车一起在街上跑。仅仅是在这个城市生存下去已经值得敬佩了。&emsp;&emsp;以为时差倒得挺好的，结果还是 10 点就昏昏沉沉了，第二天 7 点就醒。&emsp;&emsp;早餐的煎蛋非常好评，蛋液里加了番茄甜椒蘑菇，很清爽。早餐的芝士品种巨丰富。&emsp;&emsp;Bill 主席活像个老顽童，蹦蹦跳跳情绪高昂。热身赛入场搞得像运动员入场一样，很有气派。&emsp;&emsp;这三天午饭都是巨硬巨难啃的三明治。倒是生蔬菜不错，啃生黄瓜挺清爽的，生胡萝卜的辛辣味很提神。&emsp;&emsp;热身赛，我写了两个签到题，邓老板写了加逗号题，邓老板和 zayin 一起搞了个神秘的图论题。算是平平稳稳地度过了。后面去找 hku 发现他们做了概率题，我们的概率推得还是菜了一点。 &emsp;&emsp;到目前为止并没有感受到这是 WF，仍然觉得这不过就是一场普通的比赛，只是仪式多了些罢了。&emsp;&emsp;可能平平静静才是好的状态吧，享受比赛，痛快解题。 &emsp;&emsp;第二天的运动员入场更加流畅了，坐在里边看各校校徽，才终于有了一点“代表大家出战”的感觉。&emsp;&emsp;倒数结束，闹腾的会场迅速静了下来。&emsp;&emsp;读完 P 题，队友在推 S，突然对面桌 Oxford 大喊一声 yes，拿下全场一血，场上响起掌声。&emsp;&emsp;赶紧跟榜去读 Y，但是脑子乱了并没有思路，觉得连续两个子串相同好神秘。&emsp;&emsp;zayin 猜了 S 一个结论：去到河对岸的一定是个连续区间，并以此得到了一个 $O(n^2)$ 的 dp。但是并没有人做 S，还是先签到吧。&emsp;&emsp;zayin 看了 Y 和 P 都秒掉了（感受到我降智严重），邓老板看了交互题 W 开始尝试，我把期望题 Q 也干掉。&emsp;&emsp;W 题降智了好久，一开始是读错题以为它所有回答都是正确的，还在想抄样例的题怎么还不板刷，后面想着怎样只用 0 和 1 做询问，几乎是列举完所有只有 0 和 1 的询问方式了才意识到这是不可能的，于是把第五个询问改成 1 2 3 才把这个题干掉。&emsp;&emsp;签完 4 个题，一个半小时，排 20 上下。&emsp;&emsp;接下来跟榜开 T 和 U。T 一开始 zayin 想直接设两个金字塔底边的点为 $(x_1,y_1), (x_2, y_2)$ 然后大力推式子，我按住他说应该可以将军饮马的，果然画了画就是把金字塔侧面折平然后塔顶连线，讨论侧面往哪边折即可。U 我和邓老板讨论出在 4c 充当四个角的基础上用 8c、4c+2s、2s 来扩展，于是双双冲，但是双双失败。U 在不断地 wa 中补充了 6c+2s 和 4c 两种情况，变成了只用 4c 和 2c+2s 扩展，确信已经很难更优了，但仍然 wa。T 调了许久找不出错，于是喊邓老板帮忙看，我上机测 U 小数据却也无果。期间 R 和 V 都有些提交了，但不多，我们决定还是先调完这俩板刷题。最终，T 发现金字塔可以边相交，补上漏了的等号过了，U 一语点醒发现纯 8c 会自交，补个特判在 240min 过掉。&emsp;&emsp;花了整整四小时才签完到，却也封榜了。&emsp;&emsp;S 还是没人过，不敢写。邓老板发现 X 是个大模拟，慢慢写着。zayin 把 V 转换模型后发现是问凸包是否交两个正半轴，随即开冲，但不幸最终没调完（由于提前开赛，最后一小时 zayin 看错了时间，在悠闲地 debug，直至耳边突然响起“10min left”），遗憾 6 题离场。 &emsp;&emsp;心里也跟着像烂掉了一样，尽管周围的人都在说这不算烂。&emsp;&emsp;确实，后面滚榜发现好多强队和暴发户都是 6 题甚至 5 题，讲道理这些恼人的分类讨论和构造，要快速写对它们也绝不是一点本事都不要。但是要得不多。怎么说这两个题也是最后被板刷的题，卡了整整两个半小时，怎么看都是一种罪过。&emsp;&emsp;我们明明手中还握着 V 和 X，甚至这个 S 出场后跟 HUST 讨论了一下，我们都猜得差不多了。把能做的都做完，这不会有遗憾，但是亏题，会有巨大的遗憾，何况这还是最后一次比赛，是 WF。区域赛亏题了，还有下一场区域赛证明自己，WF 亏题了，没有下一次 WF 了。&emsp;&emsp;不停地反省 T 和 U 有没有机会做得更快一点。T 最好是让几何选手邓老板早些来看代码，但是邓老板和我一直被 U 关着。我们推出最优策略也不算慢，但是一直没发现纯 8c 是个 corner case。我不是没机会发现它，我手玩了 4c、12c 和 16c，就是玩不出 8c，也觉得不对劲，但是上机一测，4c、8c、12c、16c 全跑出来了，我的第一反应是：这才合理，这才对称而优美，从来没怀疑过代码给出的 8c 的解到底正不正确。&emsp;&emsp;有时候也做梦，如果开场把 S 莽过去了，是不是就可以解锁 WF 歪榜的成就，凭一己之力把大家都关起来，然后我们就拿牌了（x&emsp;&emsp;但更多的时候是觉得，我们真没太多机会把这些题再做快一点。这样反而还宽慰一些，不是失误，是实力就如此。&emsp;&emsp;也在想如果是两年前我们所谓的“巅峰状态”，能不能做得更好。大概率是能的，那时候也许知识储备不够，但思维敏捷度和手速都比现在高，也比现在勇敢，会尝试榜外的题，会在卡题时分一条流水线出去开新题。这次的 WF 并不如想象中那么难，难度接近国内区域赛，穷游中国式的打法（依靠前中期手速）仍然有很大的发挥空间。但是没办法啊，上班的上班，科研的科研，毕业了真不可能还像本科一样一周四训。我也羡慕有些老人队真的还在狂训，但是我菜啊，我做科研的题都不够时间。&emsp;&emsp;所以，就这样吧，本来也是来旅游的，本来出线名额都是捡来的。&emsp;&emsp;并列排名也不算难看，能混到 26，拿来骗骗外行人还是可以的。 &emsp;&emsp;后面去了帝王谷附近颁奖，真是大漠戈壁。心情本就低落，端上来的烤肉又不出所料地烤柴了，这顿饭吃得一般。&emsp;&emsp;在这里才开始关注前排。原来 MIT 和 PKU 打得如此焦灼，见证 jiangly 捧杯，所谓“jiangly 时代，沸腾期待”，时隔 13 年再次由中国捧杯。46th 和 47th 中国都各有三个队进牌区，PKU 更是一冠一亚，可以说中国的战绩相当辉煌。果然是当年把 IOI 改造成 CNOI 的那帮孩子长大以后，也要在 ICPC 掀起一场革命，我感觉革命已经悄然开始了。&emsp;&emsp;以及听闻了不少笑话，比如 47th 的 MIPT 把 infinity 写成了 infinitiy 痛失冠军，比如邓老师望着 jiangly 接受采访的白学图片。 &emsp;&emsp;后面的两天，一天去了 Luxor 博物馆，一天在开罗逛了埃及博物馆和金字塔，就溜了。再次在飞机上被凌晨两点半叫起来吃早餐（怒 退役&emsp;&emsp;最终结算，13 年。我才 24 岁，我可以说我大半辈子在玩算法竞赛（&emsp;&emsp;其实现在越来越多的老古董都是 phd 好高年级了仍然在打，得益于大家发现规则其实是每个人最多参加五届而不是入学起五年，以及被 covid 影响的三年有优惠政策。还有好多即便不是正式选手了，但是打星参赛、出题等的强度都不亚于正式选手。所以单纯比时长好像没什么意义，他们才是真爱粉。&emsp;&emsp;原先以为竞赛打这么久会很耽误他们的科研，后面才发现这些人是竞赛科研双丰收，顶尖赛场的颁奖台上有他们，各种顶会里还是他们，就算不是顶会也是很有意思的工作。&emsp;&emsp;而我现在是在两手空空、没有任何发表的状态下，来告别。&emsp;&emsp;很难不加剧愁怅啊。。。 很多觉得自己“喜欢”这个比赛，一开始并不知道这个比赛是什么，而只是听说这个比赛的奖项“可以去大公司”，“可以让自己摆脱不好的学校”，诸如此类，参加后觉得很有意思，又付出了很多努力，就“喜欢”上了这个比赛。这部分“喜欢”的人有很大一部分并不是真的“喜欢”——在比赛打的不好的时候完全控制不住自己负面情绪的人不说比比皆是也是能看到不少，而且原因大多是因为“自己的努力没有得到对应的回报”。——「深夜闲聊」我对出题工作的看法 &emsp;&emsp;Dai 老师描述的喜欢是一种非常纯粹的境界，曾经的选手是有这种境界的，现在的选手杂了些（我也是竞赛推广者，选手变杂了我也有责任）。但是我也认同 symbol 的一句话：仅凭功利心是走不下去的，走到后面必然是因为热爱。至少去到区域赛前排、进 WF 的选手，没有是为了考大学、找工作而来的吧。我们确实会因为努力没有回报而沮丧，但这个回报是我们在赛场上把实力发挥出来，而不是拿牌保研进厂。 &emsp;&emsp;所以没发挥出全部实力，就会心痛。&emsp;&emsp;但仔细想想，这么多年，哪次比赛没有遗憾？NOIP、省选、NOI，暴力分都没拿满；大一大二的区域赛，签到都签不明白；大三大四，成绩好看了，但也总差一点就能获得更好的名次。遗憾才是常态。偶尔有几次最后 15min 把囤的题清完、心满意足下班的，印象都不如有遗憾的场次深刻。 &emsp;&emsp;我们好像都退役了，又好像都还在赛场上。&emsp;&emsp;zayin 还在给各种比赛出题，邓老板是赞助商代表要去比赛现场宣讲，我是教练要带队参赛。我已经在赛场遇到过邓老板不止一次了，总觉得会有一天我们都出现在同一个赛场，以三种不同的神秘身份（x&emsp;&emsp;去年第一次坐看台，好熟悉又好陌生的场景。底下还是生机勃勃的一片，选手们在朝着各自的理想前进，看得我手痒。年轻人就是好啊，满怀希望，有想做的事情就可以做。&emsp;&emsp;多看看也是好的，让自己永远年轻，也可以凭我做教练的努力把希望之火传递下去。 &emsp;&emsp;其实哪里都有算法竞赛的影子。在 complexity 论文里看到多项式全家桶，在一阶逻辑课题里看到矩阵树定理，在流算法里发现可以用并查集优化流次数……每每这样，都会感到一丝恍惚。","categories":[{"name":"总结与游记","slug":"总结与游记","permalink":"http://kqp.world/categories/%E6%80%BB%E7%BB%93%E4%B8%8E%E6%B8%B8%E8%AE%B0/"},{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[]},{"title":"LoveLive 小组甲子园 + 横滨镰仓乱逛","slug":"koushien","date":"2024-03-12T13:59:57.000Z","updated":"2024-06-15T06:44:27.171Z","comments":true,"path":"koushien/","link":"","permalink":"http://kqp.world/koushien/","excerpt":"&emsp;&emsp;2023 下半年几乎接连地宣布了异次元歌合战和 LoveLive 小组甲子园。后者虽规模不如前者（前者 108 人东蛋两天唱了 100 首），但作为 LL 自己的拼盘，更适合 LL 单推（对外单推，对内 dd），并且最重要的是，水雪虹星日莲，消失三年的雪雪、消失两年的 sunnypa，堂堂复活。一个完成现地水水的愿望、附带现地所有现役 LL 团体的大好机会，出现了。","text":"&emsp;&emsp;2023 下半年几乎接连地宣布了异次元歌合战和 LoveLive 小组甲子园。后者虽规模不如前者（前者 108 人东蛋两天唱了 100 首），但作为 LL 自己的拼盘，更适合 LL 单推（对外单推，对内 dd），并且最重要的是，水雪虹星日莲，消失三年的雪雪、消失两年的 sunnypa，堂堂复活。一个完成现地水水的愿望、附带现地所有现役 LL 团体的大好机会，出现了。&emsp;&emsp;物是人非，把这个消息转发给以前漫展认识的雪雪哥，他却已经退坑了。。。 &emsp;&emsp;十月抢了 uo 的特价机票。必须吐槽一下我千叶飞羽田、横滨飞成田的骚操作（x UO 老母的特价机票，千叶飞羽田，横滨飞成田 &emsp;&emsp;一月跟屁兄抽选。大家都不喜欢小组 live，只有我跟屁兄同行。一张星碟拿下两天 4 张票，对于买水 bd 抽的人实在是嘲讽。&emsp;&emsp;开票，day1 七楼，day2 五楼。&emsp;&emsp;我：？？？？？？？？？？？？？？？？？？？？？？？？？？&emsp;&emsp;最速先行抽选，居然能开出山顶位来，太幽默了。&emsp;&emsp;香港群的人抽个一般抽选也是七楼，对于我们实在是嘲讽。&emsp;&emsp;后来听说还有抽水 bd 的比我们更后，对于他们实在是嘲讽到死。 &emsp;&emsp;其实物是人非的不仅有雪雪哥，还有我。对于 live 的准备几乎是没有，不背 call 谱，不 トキメキ，出发前一周仍然是完全的工作状态，要不是突然收到了颜认证通知，都意识不到下周就要出发了。&emsp;&emsp;一方面固然是熟练了远征，也就没什么要特别准备的，但根本来说还是我的生活已经变化了，像个大人一样在工作，有读不完的 paper 想不完的题，逐渐把トキメキ的来源迁到 npy 身上，有更想关心和陪伴的人。 也还是要做个出发的样子吧 出发&emsp;&emsp;史上第一次出门没带充电器。 &emsp;&emsp;前几天也是史上第一次上学忘带校卡，我觉得我老了。 &emsp;&emsp;于是一路上全无奔向旅途的期待，满是焦虑。飞机上不敢看缓存好的 b 站视频，只得继续想题。因祸得福，在飞机上想出了色多项式 -1 等于 acyclic orientation 的组合意义解释。 虹 ova 开头迎接步梦归来放炮的地方 &emsp;&emsp;上次去羽田为什么会忘记巡礼虹 2 米娅追岚珠的地方啊啊啊 &emsp;&emsp;成田机场买到了 1000jpy 的插头，顿时焦虑全无。&emsp;&emsp;坐泡芙哥推荐的又快又便宜的机场巴士到东京站，解锁了新的交通方式。成田巴士到东京站再转 JR 去横滨，全程 1.5h（巴士直飞高速只用 70min，再转 JR 20min）不到 2000jpy，吊打京成线、skyliner。&emsp;&emsp;老规矩，落地第一场，必须是拉面。这个是在东京站地下街吃的，1300jpy，汤巨浓。 东京站地下街的拉面 &emsp;&emsp;订的公寓式酒店，自助 check in，无人的。我搜 Yokohama Central Hotel，只跳出个 セントラルホステル横浜，我就一路去了哪儿。 セントラルホステル横浜，第二天早上补拍 &emsp;&emsp;三楼接待处关着门，我上五楼我的房间打不开门，还在楼道里把路过的穿着睡衣的女人吓了一跳。&emsp;&emsp;回去敲开了接待处的门，里面的大哥哥说这里不是酒店。我顿时懵逼，但也只得道歉并连忙退出去。&emsp;&emsp;风中凌乱 20 分钟。。。&emsp;&emsp;直到房东发来消息，我才意识到这里是 hostel 不是 hotel。。。&emsp;&emsp;我就这么误闯了居民楼。。。 &emsp;&emsp;再走 20min，11 点多才到了正确的酒店。&emsp;&emsp;这家还是相当舒适的，双床，有厨房洗衣机和阳台，折合下来 660hkd 一晚。楼下一片是食街和无料案内所。 Yokohama Central Hotel，一个相当舒服的公寓式酒店 &emsp;&emsp;而且很日式，不给一次性拖鞋，要进门脱鞋，房里严禁穿鞋。&emsp;&emsp;一次性牙刷居然还不带牙膏。我还寻思给牙刷不给牙膏是什么骚操作，还打算第二天出去便利店买一管，结果拆开牙刷包装一看，牙膏是已经挤好在牙刷头里了。。。（妙啊 随便逛逛横滨镰仓&emsp;&emsp;day1 的白天就在横滨逛了，横滨一带的巡礼我只知道虹有些许场景，所以还是随便逛逛就好，先去大名鼎鼎中华街，再沿海边走到会场，去横滨站跟屁兄汇合。 酒店往车站路上的小公园，有几棵樱花树开得很漂亮，一个老头儿在这油画写生 山梨白桃天下第一，集齐白桃味和草莓味，下次尝试找找葡萄味 虹 2 合宿回出现过的 Yokohama Stadium 横滨中华街 &emsp;&emsp;中华街的菜单，中国人就不要看了。。。自找无趣属于是。&emsp;&emsp;这里的中华料理大致就三类：鲍参翅肚、包子馒头、杏仁豆腐。不太懂为什么家家都卖杏仁豆腐，真这么喜欢往豆腐里加杏仁吗？&emsp;&emsp;火锅好像仅有一家。&emsp;&emsp;偶尔有几家餐厅的菜牌里有炒菜，有些麻婆豆腐之类的，品类很少，而且也是典型的出圈到日本的那几样。&emsp;&emsp;家家门前都有摆个冰糖草莓架子，但都是塑料的，假的。&emsp;&emsp;倒是靠近临善门的地方有很香的糖炒栗子味，但是找不到哪儿卖糖炒栗子。 虹 2 打排球的公园，ksks 和小静子被爱姐吃波饼 红砖仓库，里面是个商场（注意 sif 里的红砖仓库是函馆的，不是横滨的） 横滨多见红砖建筑，酒店附近的关内站也是红砖风格 横滨的海湾 远远就看到了黑压压的场贩队 横滨站 &emsp;&emsp;屁兄是松屋之王，没人比他更懂松屋。所以这两天多数的餐都是他带我吃松屋，由此体验了一把日本平民饮食，彻底改变了我对于日本餐饮物价贵的看法。（事实上在酒店附近的食街转一圈，明白了其实 1000jpy 以内的选择还是很多很多的，这么一来其实比香港都便宜，香港想找 50hkd 以内的都还难呢） 屁兄带着我吃了 4 顿松屋，早中晚、堂食外卖都有了，这是其中两餐 &emsp;&emsp;想着横滨离镰仓近，于是 day2 拉上屁兄南下镰仓。同样也只是随便逛逛，巡礼也只知道几处虹。到了才被兄弟提醒，忘记提前预习侑散步镰仓篇了。。。也没有提前把虹 2 璃奈的巡礼 app 的地点标定下来。如果有下次，我必按璃奈的 app 跑一回定向越野。 镰仓站 通往鹤冈八幡宫的小町通，虹 2 合宿回找猫的地方，侑散步也在这里逛，有各种各样不错的店 鹤冈八幡宫 小町通东边的樱花大道，如果樱花开了这里就会超级美 静子家，是乡绅官邸啊。。。 静子家往镰仓站路上的日本乡村道路 &emsp;&emsp;静子家比较偏僻，是鲜有人访问的乡村，因此才能“曲径通幽处，禅房花木深”。只有偶尔两三个身上挂着趴趴的人来到这里。&emsp;&emsp;我不禁想一个问题，脱离了动漫的指引，我能靠自己找到这种静谧悠然的地方吗？ 镰仓站附近的一家餐厅 live 会场门口的人群，在摆摊交换吧唧 &emsp;&emsp;穿过横滨站前往会场，已经感受到了人潮。既然官方都发帖劝退排场贩，我们就直接入场了。&emsp;&emsp;果然 Kーアリーナ 不容小觑，连拍花篮都十分费劲，拍花篮的队堪比小 live 的场贩队。。。&emsp;&emsp;最速先行上山（x p1、p2 是 day1 座位，p3 是 day2 座位 &emsp;&emsp;山顶无限好风光（大雾&emsp;&emsp;好处在于离解说台近，能看侑酱。 day1 座位广角，可以看到解说台 七楼外面有官方卖望远镜，好笑程度 +1000 &emsp;&emsp;两天一起写了。&emsp;&emsp;以甲子园为标题的 live，营造了非常浓烈的运动会氛围。搞解说台，运动员入场，选手宣誓，每个小组出场叫“x 回表”“x 回里”，bgm 是大阪桐荫的经典甲子园应援 bgm，观众喊的是甲子园的应援词，安可改叫延长战。 「かっせかっせかっせ、かっせかっせかっせ、かっ飛ばせ、ｘｘｘ！」 &emsp;&emsp;跟着喊几回，仿佛我就在看甲子园。&emsp;&emsp;每个小组有两首完整版歌曲，还要加 secret 和延长战，整个 live 也是很紧凑的。在每个小组有限的时间里，依然带来了巨大的惊喜。&emsp;&emsp;莲团还是很新的团，但是竟然几乎大家都会她们的 call，而且很激烈，即便她们的 call 又多又复杂。观众里莲厨比例一定不输水虹星，甚至可能超过，喊 call 的气势和开大闪的密度比虹和星都高不少。day2 从侧边看全场，每次莲歌到最后一段，燃起大闪的火海，都仿佛 snow halation 一般。然而我是几乎不熟莲的歌，唯一享受的就是 cb 的水彩世界和 holiday，简简单单小甜蜜如同结婚曲。其他俩组的歌其实略微灾难，都是现场难度很高而声优又无系统声乐培训，加之使用角色音，百分百唱得歪七扭八，也无歌词之雅和背景之深可赏。&emsp;&emsp;星每个组只有两首歌，半年唱第三次了，于我却是第一次听 catchu 和 55 的现场。dancing dancing rasberry 的旋律和编舞实在是动感，很想跟跳副歌像原地踏步一样的动作。差点认不出 sayu，她头发比以前都要凌乱，更符合影游的忧伤矛盾的情调了。k 组无论看多少次都觉得优雅。secret 发新歌给人一种强推星的感觉，可能是全场最迷惑的环节。（UPD：JJJJelly Fish!!!!!!!!!）&emsp;&emsp;虹小组这次是中规中矩，星无歌可换，你虹也跟着不换。azuna 的 blue 固然上乘，置人于美丽的海洋深处，但是还有这么多激烈的、可爱的、帅的，只展示这么两首。dd 也不换歌，奈酱都亲上未梦了，也不来点更激进的恋爱曲。r3 的魔爪女孩喊不了“捞捞捞捞”“辣炒米粉”等中国限定 call，居然有点不适应（x）。唯有 q4 换了歌，给观众更多的享受，day2 唱了荡秋千曲，左右扭动的舞姿，和轻盈摇荡的秋千，都让心情随风飘荡。但是整活还是虹强，secret 带大家做广播体操，延长战又跳健身操，把鲤鱼都给整八达岭了。我也是第一次体验健身操，真的可以玩得很嗨很嗨。&emsp;&emsp;只有水的应援气势可以跟莲一比，只有水是另一个几乎全员都会 call 的团体。如果莲的应援是粉丝对于新曲和复杂 call 的狂欢，那么水的应援则是往昔峥嵘岁月之忆的爆发，她们把时光拉回几年前，所有人都在，水还是浦女时稚嫩的水，雪还是冷酷闪耀的雪。雪穿着警服网袜的 believe again，震耳欲聋，带着 3 年归来的感动。我带着虾笼一单曜趴，台上是咻卡穿着虾笼一单唱夜空知晓一切，三个睡不着觉的孩子，就抱在我怀中。夜空全曲我举着趴趴，好似举着天线要跟咻卡产生对应信号。GK 的舞台还是会喷火，草莓猎人的火燃到今天。仍记得 2022 年萤火虫在偶像舞台看 shooting star warrior，今天同样的歌曲同样的服装，coser 却升级成了声优，有一种进化的感觉。AZALEA 再穿出了二单的粉色小天使服，姐姐的眼妆还是那么可爱，唯二的遗憾一是穿了小组专的衣服却没跳凤凰舞，二是某些歌曲永远的二缺一。 感谢群友的好奶 &emsp;&emsp;可以说，水和雪是我整场的振奋之源。2017 开始厨水，却在 7 年后才第一次现地水。以前总是忧伤我错过了很多黄金时段，一些动画名曲、重要意义的单曲，被深深刻在以前的数字 live 里，成为一个时代的专属。疫情以来一些歌曲得到回滚，得以线上观影，当时已觉至善。但没想到还能有今天，从 day1 的 believe again、草莓猎人、夜空知晓、待爱，到 day2 的近未来、银河躲猫猫、脆弱易碎，本应是水的 secret 打出了 Saint Aqours Snow，6 年之别的 ATP 把全场氛围带到巅峰。我像是拥有了一张时光入场券，回到17~19 年，解锁一段回忆。&emsp;&emsp;带了跨年棒，也合唱了跨年曲，我确信我进入了正确的时空。&emsp;&emsp;即使是感冒初愈，说好象征性喊喊就好，两天下来喉咙还是哑了。&emsp;&emsp;即便在山顶，也想要观察更多的细节。最方便看到的就是解说台，真的可以看到 hnk 全程有在挥棒子、切颜色。mc 和跨年曲大家站成一条线的时候，总是可以看到一边在唱歌和说话时另一边在贴贴。当遇到 k 组、catchu 那些富有情感的歌，仍然要多看看屏幕，欣赏表情。&emsp;&emsp;只恨没有背下来水世界的 call 谱。喊 call 是更投入、更有参与感的方式，一首热烈的歌一半是来自应援氛围，跟上一起喊了才会感受到这是大家一起完成的歌曲。近未来不会喊，能把我愧疚一整场；而 ATP 的“hi hi hi”、健身操的“全速 dreamer”、虹 op2 的“いくよせーの”喊出来了，就能感觉我也是组成烈焰的星火。 &emsp;&emsp;从异次元歌合战尝到了甜头，破企划终于学会了搞跨团唱歌。&emsp;&emsp;可能还要等 LoveLive 再壮大一段时间，才更适合合唱 sunny day song，这首学园偶像之集大成者，寓意聚天下学园偶像于一堂，共递学园偶像之快乐。 end&emsp;&emsp;想玩久一点，但是真的已经是个大人了，有事做的大人，回去之后三天内要写完论文初稿，还有一堆要读的文章。&emsp;&emsp;充分享受过后，总要回归忙碌的生活。但一定不妨碍美好的回忆生根发芽，在以后回想起忙里偷闲的幸福，和愿望一步步实现的满足。","categories":[{"name":"玩","slug":"玩","permalink":"http://kqp.world/categories/%E7%8E%A9/"}],"tags":[]},{"title":"图论多项式(Graph Polynomials)","slug":"graphpoly","date":"2024-03-08T15:32:40.000Z","updated":"2024-10-26T06:14:53.066Z","comments":true,"path":"graphpoly/","link":"","permalink":"http://kqp.world/graphpoly/","excerpt":"&emsp;&emsp;在 Weighted First-Order Model Counting (WFOMC) 的题目中经常用到图论多项式，所以学了一些东西，整理一下。","text":"&emsp;&emsp;在 Weighted First-Order Model Counting (WFOMC) 的题目中经常用到图论多项式，所以学了一些东西，整理一下。 色多项式(Chromatic Polynomial)&emsp;&emsp;这应该算是最简单的一种图论多项式了。 &emsp;&emsp;我们用 $G = (V,E)$ 表示一个无向图，其中 $|V| = n$。然后我们用 $D = (V,E)$ 表示一个有向图。&emsp;&emsp;我们可以定义各种各样的色多项式： $\\chi_G(x)$ 表示无向图 $G$ 的色多项式，当 $x$ 为正整数时，它表示用 $x$ 种颜色给点染色、使得任意一条边的两点颜色不同的方案数； $\\bar \\chi_D(x)$ 表示有向图 $D$ 的非严格色多项式，当 $x$ 为正整数时，它表示用 $x$ 种颜色给点染色、使得若有边 $u \\to v$ 则 $color(u) \\le color(v)$ 的方案数； $\\chi_D(x)$ 表示有向图 $D$ 的严格色多项式，当 $x$ 为正整数时，它表示用 $x$ 种颜色给点染色、使得若有边 $u \\to v$ 则 $color(u) &lt; color(v)$ 的方案数。 &emsp;&emsp;以下这几个不算是多项式，但也是很有用的概念： $\\chi^*_G(x)$ 表示 $G$ 的精确染色方案数（英文喜欢称为 surjective 满射），当 $x$ 为正整数时，它表示恰好用 $x$ 种颜色给点染色（即颜色 $1, \\cdots, x$ 每种至少被用一次）、使得任意一条边的两点颜色不同的方案数； $\\bar \\chi^*_D(x)$ 表示有向图 $D$ 的精确非严格染色方案数，当 $x$ 为正整数时，它表示恰好用 $x$ 种颜色给点染色、使得若有边 $u \\to v$ 则 $color(u) \\le color(v)$ 的方案数； $\\chi^*_D(x)$ 表示有向图 $D$ 的精确严格染色方案数，当 $x$ 为正整数时，它表示恰好用 $x$ 种颜色给点染色、使得若有边 $u \\to v$ 则 $color(u) &lt; color(v)$ 的方案数。 &emsp;&emsp;为什么精确的这几个不是多项式呢？因为 $x &gt; n$ 时它们的值都为 $0$，这定义不出有限度数的多项式。那一开始的三个为什么是有限度数的呢？因为显然有： Lemma 1. (精确染色方案数和色多项式的关系) \\begin{aligned} \\chi(x) &= \\sum_{i=1}^n \\binom{x}{i} \\chi^*(i) \\\\ &= \\sum_{i=1}^n \\frac{x(x-1) \\cdots (x-i+1)}{i!} \\chi^*(i). \\end{aligned} \\tag 1&emsp;&emsp;这个就可以用来说明色多项式都是关于 $x$ 的 $n$ 次多项式，并且 $n$ 次项的系数是 $\\frac{\\chi^*(n)}{n!}$。 &emsp;&emsp;色多项式的美妙之处在于它在负数点处的取值。负数点值的意义并不显然，但是能表示重要的组合意义。举两个例子。 有向图色多项式的负数点 Lemma 2. 记 $acyc(D)$ 表示 $D$ 缩环之后得到的 DAG，记 $|V(acyc(D))|$ 表示 $acyc(D)$ 的点数。对于任意 $x \\in \\mathbb R$， \\begin{aligned} \\chi_D(x) &= \\begin{cases} (-1)^n \\bar \\chi_D(-x), & D \\text{ is acyclic,} \\\\ 0, & \\text{otherwise,} \\end{cases} \\\\ \\bar \\chi_D(x) &= (-1)^{|V(acyc(D))|} \\chi_{acyc(D)}(-x). \\end{aligned}&emsp;&emsp;也就是说，如果 $D$ 是个 DAG，那么负数点的意义就是把严格转化为非严格、把非严格转化为严格；而如果 $D$ 是有环的，那么从非严格转化为严格的过程会缩环，从严格转化为非严格的过程会过滤掉有环图。 &emsp;&emsp;证明至少有两种。以下我们只需证明 $D$ 为 DAG 时的情况就好了。 证明 1： &emsp;&emsp;来自 [AB20]，从几何来理解。&emsp;&emsp;把颜色序列 $color(1), \\cdots color(n)$ 理解为 $n$ 维空间的一个点。当只允许 $color(i) \\in \\{0,1\\}$ 时，记所有可行点组成的多面体为 $\\Pi$，如果允许 $color(i) \\in \\{0,1,\\cdots,x\\}$，则该多面体变成 $x\\Pi$（即边界的每个点每一维坐标乘上 $x$）。&emsp;&emsp;我们可以发现 $\\chi_D(x)$ 表示 $(x+1)\\Pi$ 的内部整点（不含边界）数量（注意这只在 $D$ 为 DAG 时成立），而 $\\bar \\chi_D(x)$ 表示 $(x-1)\\Pi$ 的整点数量。记 $E_{\\Pi}$ 表示 $\\Pi$ 的 Ehrhart’s Polynomial（即 $E_{\\Pi}(x)$ 表示 $x\\Pi$ 的整点数量）。关于 Ehrhart’s Polynomial 有一个性质是： E_{\\Pi}(-x) = (-1)^n (x\\Pi\\text{ 的内部整点数}).&emsp;&emsp;因此 \\chi_D(x) = (-1)^n E_{\\Pi}(-x-1) = (-1)^n \\bar\\chi_D(-x). 证明 2： &emsp;&emsp;来自 [Sta70]，纯组合意义证明。所以几乎被我不看论文自己脑补出来了&emsp;&emsp;我们先给 $D$ 的节点重新标号，使得如果有边 $u \\to v$ 那么 $u&lt;v$。我们知道这样的标号方法肯定存在，而且不影响 $\\chi_D(x)$ 和 $\\bar\\chi_D(x)$，因为它们与点标号无关。这样做是为了方便下面使用拓扑序。&emsp;&emsp;下面介绍一种非严格染色方案到拓扑序的映射：每次在入度为 $0$ 的点里找颜色最小的，如果有多个点就选标号最小的点，执行 $n$ 次就得到了一个拓扑序。&emsp;&emsp;那么对于一个拓扑序 $t_1, \\cdots, t_n$，它包含的非严格染色方案如下： \\forall i>1, \\begin{cases} color(t_{i-1}) \\le color(t_i), & t_{i-1} < t_i, \\\\ color(t_{i-1}) < color(t_i), & t_{i-1} > t_i. \\end{cases}&emsp;&emsp;同理，定义一种严格染色方案到拓扑序的映射：每次在入度为 $0$ 的点里找颜色最小的，如果有多个点就选标号最大的点，执行 $n$ 次就得到了一个拓扑序。那么对于一个拓扑序 $t_1, \\cdots, t_n$，它包含的严格染色方案如下： \\forall i>1, \\begin{cases} color(t_{i-1}) < color(t_i), & t_{i-1} < t_i, \\\\ color(t_{i-1}) \\le color(t_i), & t_{i-1} > t_i. \\end{cases}&emsp;&emsp;记 $w_s$ 表示有 $s$ 对相邻元素满足 $t_{i-1}&lt;t_i$ 的拓扑序数量，则有 \\begin{aligned} \\chi_D(x) &= \\sum_{s=0}^{n-1} w_s \\binom{x+s}{n}, \\\\ \\bar\\chi_D(x) &= \\sum_{s=0}^{n-1} w_s \\binom{x-s+n-1}{n}. \\end{aligned}&emsp;&emsp;因此有 \\bar \\chi_D(-x) = (-1)^n \\chi_D(x).无向图色多项式的负数点&emsp;&emsp;关键就是要发现 $\\chi_G(x)$ 等价于先给 $G$ 无环定向然后给点染色使得如果有边从 $u$ 到 $v$ 那么 $u$ 的颜色小于 $v$ 的颜色的方案数，即 \\chi_G(x) = \\sum_{D \\text{ 是 }G\\text{ 的无环定向 }} \\chi_D(x).&emsp;&emsp;比较容易理解，因为无向图每一种染色方案都唯一对应一种无环定向方案，枚举每一种无环定向然后严格染色就可以得到所有原来的染色方案。&emsp;&emsp;所以负数点的意义，结合 Lemma 2 就是 \\chi_G(-x) = \\sum_{D \\text{ 是 }G\\text{ 的无环定向 }} \\bar \\chi_D(x). \\tag{2}应用——无向图的无环定向(Acyclic Orientation)&emsp;&emsp;记 $a_G$ 表示给定一个 $n$ 个点的无向图 $G$，给每条边定向使得该图无环的方案数。 Lemma 3. $a_G = (-1)^n \\chi_G(-1).$ &emsp;&emsp;证明多种多样，甚至有用拟阵来证的（wiki 给的文章就是），还有胡说八道的（比如 [EG21]）…… 证明 1： &emsp;&emsp;就给上面的 (2) 式代入 $x=1$ 就好了，对于任何有向图都有 $\\bar \\chi_D(1) = 1$，于是得出结论。 证明 2： &emsp;&emsp;来自 [Sta73]，不想证明直接引用的话就引用这篇。&emsp;&emsp;思路本质上跟证明 1 差不多，只不过他没有用到有向图色多项式，而是定义了一个 $\\bar \\chi_G(x)$ 表示先给 $G$ 无环定向然后给点染色使得如果有边从 $u$ 到 $v$ 那么 $u$ 的颜色小于等于 $v$ 的颜色的方案数，然后再用结构归纳法证了一个关系： \\bar\\chi_G(x) = (-1)^n \\chi_G(-x).&emsp;&emsp;最后令 $x=1$，$\\bar\\chi_G(x)$ 的意义就变成了无环定向数，于是就得出了 Lemma 3。 &emsp;&emsp;这个结构归纳证明是挺美妙的，只不过现在懂了无向图色多项式和有向图色多项式的关系之后，就会觉得这个只是在兜圈子了。 证明 3： &emsp;&emsp;参考 [EG21] 自己脑补的组合意义证明。&emsp;&emsp;[EG21] 的 8.3、8.4 节讲的就是 acyclic orientation，给了一个长长的生成函数证明，但很可惜是错的，它提出的“等价类”的概念并不 well-defined。&emsp;&emsp;不过它最后的式子 (8.26) 倒是很有启发意义——通过染色方案数的容斥来得到定向方案数。 &emsp;&emsp;回顾 Lemma 1，如果代入 $x=-1$，会得到 \\chi_G(-1) = \\sum_{i=1}^n (-1)^i \\chi^*_G(i).&emsp;&emsp;所以 Lemma 3 就变成了 a_G = \\sum_{i=1}^n (-1)^{n+i} \\chi^*_G(i). \\tag 3&emsp;&emsp;这东西看着就很容斥。因为一种精确染色方案可以唯一确定一个定向方案（比如规定边的方向是从小颜色连向大颜色），所以我们证明，每一种定向方案所对应的（精确严格）染色方案中，只有一种能留下来。&emsp;&emsp;Recall 上面 Lemma 2 那儿用到的其中一种有向图染色方案到拓扑序的映射：不妨设 $D$ 是个有标号图（没标号随便标一个即可），每次在入度为 $0$ 的点里选一个颜色最小的，如果有多个点就选择标号最小的。执行 $n$ 次，这就得到了一个拓扑序。&emsp;&emsp;在一个定向方案的所有（精确严格）染色方案中，我们保留拓扑序字典序最大的那个，这个染色方案是唯一的，且要使用所有 $n$ 种颜色（即在 (3) 式右边系数是 $1$）。其余的精确染色方案必能两两对应，且正负相消。假设 $\\sigma^*$ 是拓扑序最大的染色方案，$\\sigma^1$ 是某个拓扑序非最大的染色方案，它们的拓扑序分别为： \\begin{aligned} topo(\\sigma^*) = \\cdots, &i, \\cdots, \\cdots \\\\ topo(\\sigma^1) = \\cdots, &j, \\cdots, i, \\cdots \\end{aligned}&emsp;&emsp;其中 $j$ 所在的位置是 $topo(\\sigma^*)$ 与 $topo(\\sigma^1)$ 从左往右第一个不同的位置。 &emsp;&emsp;如果 $\\sigma^1_i$ 在 $\\sigma^1$ 里是唯一的，则构造 $\\sigma^2$ 如下：先令 $\\sigma^2 := \\sigma^1$，然后把排在 $i$ 后面的所有点的颜色减 $1$，再给 $\\sigma^2_i$ 减 $1$ 并将 $i$ 移到恰当的位置。如果 $\\sigma^1_i$ 不唯一，则构造 $\\sigma^2$ 如下：先令 $\\sigma^2 := \\sigma^1$，然后把颜色大于 $\\sigma^2_i$ 的点的颜色都加 $1$，再给 $\\sigma^2_i$ 加 $1$ 并将 $i$ 移到恰当的位置。&emsp;&emsp;可以发现，$\\sigma^2$ 经过这套变换也会变成 $\\sigma^1$，并且一个精确染色经过变换后仍然是最多使用 $n$ 种颜色的精确染色，所以所有非字典序最大的染色方案是两两对应的。并且，$\\sigma^1$ 和 $\\sigma^2$ 的颜色数正好差 $1$，所以它们正负相消。&emsp;&emsp;因此 (3) 式右边每一个定向方案只有一个系数为 $1$ 的精确染色被保留，所以得到 $a_G$。 Tutte 多项式(Tutte Polynomial) 记 $T_G(x,y)$ 表示 $G$ 的 Tutte 多项式，它的其中一种定义是这样的： T_G(x,y) = \\sum_{A \\subseteq E} (x-1)^{cc(A) - cc(E)} (y-1)^{cc(A) + |A| - n},其中 $cc(A)$ 表示图 $(V,A)$ 的连通块数。这里要求 $0^0 = 1$。 &emsp;&emsp;Tutte 多项式堪称无向图的万金油，它实在有太多的意义（多数抄自 wiki，少数抄自网上课件）： $T_G(2,1)$ 表示 $G$ 有多少子图是森林； 因为 $x-1 = 1$ 所以 $(x-1)^{cc(A)-cc(E)}$ 这一项就没了，而 $y-1 = 0$ 就要求子图必须满足 $cc(A)+|A|-n=0$，所以是森林。 $T_G(1,1)$ 表示 $G$ 有多少子图是生成森林（即连通块的数量与原图一致），当 $G$ 连通时表示 $G$ 的生成树数量； 同理，相比森林，多要求了一个 $cc(A)=cc(E)$。 $T_G(1,2)$ 表示 $G$ 的生成子图数量； 只要求 $cc(A)=cc(E)$。 …… &emsp;&emsp;负数点的意义也很神奇： $(-1)^{n-cc(E)} x^{cc(E)} T_G(1-x,0)$ 是 $G$ 的色多项式 $\\chi_G(x)$； 证明就是左边边展开之后会变成 $\\sum_{A \\subseteq E} x^{cc(A)}(-1)^{|A|}$，它就是容斥得出染色方案数。 $T_G(2,0)$ 表示 $G$ 的无环定向方案数； 上式代入 $x=-1$ 即得到。 $T_G(0,2)$ 表示 $G$ 的强连通定向方案数； $T_G(1,0)$ 表示 $G$ 的无环定向且只有一个起点的方案数（无论起点是谁），如果 $G$ 不连通则是各个连通块的方案数乘起来； $T_G(0,0)$ 判断 $G$ 是否有边； $T_G(-1,0)$ 判断 $G$ 是否是二分图； $T_G(0,-1)$ 判断 $G$ 是否是欧拉图（存在欧拉回路）； …… &emsp;&emsp;复平面点的意义也很神奇，但我不会（ &emsp;&emsp;所以显然“任意给定一个无向图，求其 Tutte 多项式”或者“任意给定一个无向图和一个平面点 $(x,y)$，求其 Tutte 多项式在 $(x,y)$ 处的值”这样的问题都是 $\\mathsf{\\sharp P}$-hard 甚至是 complete 的。 B-Polynomial&emsp;&emsp;这个是 [AB20] 提出的 Tutte 多项式在有向图上的扩展： B_D(q,y,z) = \\sum_{f: V \\to [q]} y^{|f^>|} z^{|f^","categories":[{"name":"TCS","slug":"TCS","permalink":"http://kqp.world/categories/TCS/"}],"tags":[{"name":"算法_图论","slug":"算法-图论","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E5%9B%BE%E8%AE%BA/"}]},{"title":"Far far away","slug":"sum2023","date":"2024-02-12T01:39:55.000Z","updated":"2024-10-26T05:30:32.720Z","comments":true,"path":"sum2023/","link":"","permalink":"http://kqp.world/sum2023/","excerpt":"&emsp;&emsp;记录自己每年的变化挺好玩的。。。因为自己现在确实属于转型升级的时期。想起中山市曾经的标语：“加快转型升级，建设幸福和美家园。” &emsp;&emsp;也不是很多时间，也就随便写一点了。","text":"&emsp;&emsp;记录自己每年的变化挺好玩的。。。因为自己现在确实属于转型升级的时期。想起中山市曾经的标语：“加快转型升级，建设幸福和美家园。” &emsp;&emsp;也不是很多时间，也就随便写一点了。 &emsp;&emsp;9 月 10 号发生了三件事。Liella 4th 宣布了举办 5th，当即决定不去；幻日夜羽播第 12 话，当即令口碑起死回生；Abby 发了一段消息过来，当即把我从椅子上弹了出去（x&emsp;&emsp;真的是像飞机跳伞弹射一样把我弹射出去，然后我在地上打滚（x &emsp;&emsp;一个星期之后才正式在一起的。&emsp;&emsp;还为此无限被骂为什么不是我主动表的白&emsp;&emsp;还因此触发了她的卑微。你卑微个锤子啊，你是女神好不好。我们情头是夜羽和莱拉普斯，我是夜(fu)羽大人的狗 &emsp;&emsp;这孩子是一员登山猛将，并且从中能折射出勇敢和无畏。她是医学生，保留了医学生那种勤奋自律。能说真话，不需要使劲猜心思。简简单单，平平静静，这就是我期望的。 &emsp;&emsp;也确实做到了。我觉得有了 npy 以后最大且立即的变化，就是从心底里变平静了。&emsp;&emsp;就感觉都没什么东西想要 po 上网了，包括空间和博客。这俩地方是我表达内心想法的地方，以前只有我一个人，我只有这俩说话的平台。现在多了一个说话的平台，什么话都在那里先说了，就没有再说一遍的欲望了。当然，有文学价值的（比如诗和散文），有先导和攻略意义的（比如 live report、圣地巡礼攻略）这些，以后还是会坚持写，这些是值得再说一遍的东西。&emsp;&emsp;旅游回来不会有空虚感，而是有一个家，有归属感。她说得很对，我是老旅行青蛙了。&emsp;&emsp;以前很有孤独感的事情，比如从长江路南外环一路走到博爱医院，从东校骑共享单车到白云机场，从尖沙咀一路往北走，这些曾经的壮举，如今好像不是很能再做得起来，因为孤独感少了。有没有可能带着她继续孤独？一起考个“三走狗牙岭”的牌？以前凭着孤独感就走下去了，现在是凭想要挑战的心。 &emsp;&emsp;这个跟 LoveLive 带来的精神力量有点不一样，LoveLive 是一位陪跑的朋友，这位是我要跟她合而为一的。我们是合而为一的光&emsp;&emsp;体现在，我想要给她力量，支持她的梦想。&emsp;&emsp;尽管她最近陷入了一点迷茫，她找不到梦想。人没有了梦想如同变形金刚没了火种，人就是靠希望之火走下去的。所以我必须陪她找到梦想，找到希望。我想见证她找到自己。我认为，什么样的人最有人格魅力，知道自己在干什么的人，知道自己想要干什么的人。她绝对有人格魅力的，短暂被屏蔽了而已，我来帮她拨云见日。 &emsp;&emsp;忽然间也发现，我的生活就这样匆匆改变了。&emsp;&emsp;这一年以来，特别是下半年，各种事情也不知道怎么着就变忙起来了。三个科研题（跟 Ondrej 的团队一个，跟老板和 Mauro 的一个，陆陆续续的还有之前一直投不中的一篇、其后续工作以及我的本科毕设）、两个竞赛队（无人之境在康复训练，我还要带 HKU 的队）、一个社团（宿舍的 hiking team），感觉我的时间分配突然不由己了。没时间上日语课了，没时间补番了，没时间读 LL Days 了。&emsp;&emsp;看番补番这事好解决，规定自己每天中午吃完饭休息时间就拿来看一集，还能省得这时间花在没啥意义的其他 B 站视频上。&emsp;&emsp;但我缺的真的是看番的时间吗？&emsp;&emsp;我发现，是我即将要进入一个新的生活模式了。手头上的三个科研题两个竞赛队一个社团这种正事儿只会越来越多越来越难，毕竟工作总要一步一步走上正轨；跟 Abby 是要互相陪伴的，我陪她她陪我，这些是我以前不曾分配过的时间；我们也需要出去玩，跋山涉水、吃香喝辣这些不是说为了 dating 才做的，这些本来就是人的内在需求……然后就会发现，我有点没准备好，措手不及。&emsp;&emsp;算是我没试过一下子涌入如此多的事情。以前就算有，都是短期的，肝一下就能过去，现在这些每一件事都要肝一辈子。&emsp;&emsp;非常幸运的一点是，Abby 支持我看 LL，她能理解偶像的意义。这点我心怀感恩。&emsp;&emsp;那么事情也就不难解决了。以前管看 LL、看动画、看日本音综、爬山、旅游、逛展这些事叫做“个人时间”，现在一起做就可以了。这些本不需要偷偷地自己做，光明正大一起做，她不需要非得感兴趣，她不感兴趣的不鸟我就好。我竟跟她都设想过，我们坐在一起，她看她的，我看我的。没有兴趣爱好 100% 重合的情侣，重要的是互相理解支持。&emsp;&emsp;总是有共同的时间的，就能够做共同的事情。我也能跟她去看霉霉。霉霉是歌唱家水准的，咱不能老被唱跳偶像把耳朵都磨坏了，咱还是得懂一点专业的歌唱。 &emsp;&emsp;这一年的科研，其实也很魔幻。&emsp;&emsp;最最开始的 Fine-Grained Zero-Knowledge Proof，阳了一周去隔离完了回来以后，老板就仿佛“大人，时代变了.jpg”，再也没碰过这个题。前年 12 月到去年 1 月在把新发明的 maximin security 用到 Fair Allocation 的分布式协议上并推完了大部分结果，2 月到 3 月在想 Shapley Value 的 approximation 的 query complexity 但是失败了，4 月到 5 月把它写成 paper，6 月到 8 月跟 yuyi 开了个题关于 Weighted First-Order Model Counting/Sampling，9 月攀上 Ondrej 老师把这个题往图多项式方向拓展，10 月到现在一边做这个图多项式一边跟 Mauro 做流算法和分布式。最后今年的 1 月 2 月投了 3 篇，还搞了 PhD Probation Talk，成为目前最肝的两个月。&emsp;&emsp;题是够多了，文章可预见的也够多了，不担心毕业了。这是好消息。如果这三篇开奖全中，那可以在两个月之内收获三篇 CCF A，那 paper list 就好看一点了。这是好消息。&emsp;&emsp;坏消息是什么呢？活成了“东一榔头西一棒槌”型选手。&emsp;&emsp;“我的主线是什么？”我一直问自己，也一直问别人。&emsp;&emsp;老板说，硬要说的话，就是 counting/sampling 吧。我觉得也还行，虽然进来的时候是想 complexity/cryptography 的，但这个也不差。&emsp;&emsp;老板也说，不一定非得要有个主线，可以是什么都做型选手。我不同意，那只是你的风格，我不希望活成你的样子。我永远记得大二的时候在某场讲座上听王某海教授的发言：“总结我这个人的科研吧，什么都做一点，但都做得不精。”我当时就立志不要做这样的人。&emsp;&emsp;实际上去年 11 月我把 Fine-Grained ZKP 的想法发给了 NYU 的 Marshall，问他这个题有没有价值。他说：“Building a fine-grained ZKP for any fine-grained hard problem using fine-grained hardness would be very interesting.” 很高兴，但高兴之余也能够意识到，说一个题很 interesting 是有两种含义的，一种是它很值得做，一种是它根本不可做，比如“proving P!=NP is very interesting”。再细看他的回复，基本上也就是后者的意思——直接做不太可能，用简单些的 setting 容易得多但是就比较 trivial 了。&emsp;&emsp;但是距离这封邮件也已经 3 个月过去了。从大四到现在我无数次看着这个题目一拖再拖，都麻木了。我似乎就是下一个左左，心中有一件伟大的事但是一拖再拖，直到熄灭。&emsp;&emsp;不过至少学会了自己去找外援。自家老板不行，那就靠自己出去找合作。有幸通过实验室里的题贩子 enze 认识 yuyi 然后认识 Ondrej 这边，入了一阶逻辑的坑，也算是不愧对以前跟炜麟学长玩时序逻辑。而且 Ondrej 这老头儿真的是个数学家，甚至是个艺术家，能把多项式、自然数幂和这些东西玩得行云流水，我入学以来第一次感受到如何把科研做成一件工艺品，好的数学实在是一门艺术。Model Counting 也是目前我见过最 OI 的东西，真的都是在用 OI 学过的计数技巧，比如我头一次见到矩阵树定理是真的可以用来解决问题的，以及各种递推。这是我喜欢这个题的根本原因。&emsp;&emsp;帮老板 review 的时候惊讶地发现老板跟 Elaine 合作的很多密码学题目居然是被广泛引用的，是一些很基础题目的研究。这人虽然发不了 STOC，但是可以被 STOC 引用啊，甚至是 STOC 的前序工作啊！我觉得这种才是我真正想做的，做一些基础的、为人铺路的题。总感觉老板是藏着掖着这些真正有价值的东西，我可能今年要去敲他一下，把他这些题给敲出来。&emsp;&emsp;总的来说就是，既然不愁毕业，我就必须考虑做点有价值的事了，别老是在这打工似的帮 Mauro 写 Spark 我 tm 是个理论人为什么我写了两个月的 Spark。像 wzz 说的：“要做就做大事，做能发 STOC 的题。” &emsp;&emsp;2023 年去了两次日本，第一次看了 AZUNA 和星 3，以及水虹星巡礼巡了个遍；第二次实现了周末特种兵看星 4。现在长游短炒都会了，还拿了三年多次签，就很舒畅。&emsp;&emsp;幻日夜羽落成了 2022 年最不期望的结局，故事没讲好，旧粉不断掉，新粉没吸到，成了小丑企划。骂企划不缺我一个，但除此之外，我依然是想观众朋友们麻烦静下心来看，看不懂可以先重修一下文学鉴赏（高考语文水平就可以了），角色们的心境很细腻的，不是急躁的人能品出来的。&emsp;&emsp;进了泡芙哥的群，吹了一年的水，认识了一帮群友。小群才是最舒服的网友交流地，不像大群、贴吧、B 站那样天天吵架。厨 LL 以来认识天南地北各行各业的同好，得以欣赏各自精彩的人生。 &emsp;&emsp;以后可能真的随缘更博客了。学术的东西不是很想更，单篇论文写没啥意义，像个翻译一样，所以一写就得是好多论文的总结，可是自己写论文都够累的了。也许过会儿还有两个月的康复训练，能整点竞赛题写写题解。游记还是想坚持。","categories":[{"name":"总结与游记","slug":"总结与游记","permalink":"http://kqp.world/categories/%E6%80%BB%E7%BB%93%E4%B8%8E%E6%B8%B8%E8%AE%B0/"}],"tags":[]},{"title":"【2022icpc Regional 南京 E】Color the Tree 题解","slug":"【2022icpc Regional 南京 E】Color the Tree 题解","date":"2023-10-22T13:38:04.000Z","updated":"2024-04-24T03:59:22.818Z","comments":true,"path":"【2022icpc Regional 南京 E】Color the Tree 题解/","link":"","permalink":"http://kqp.world/%E3%80%902022icpc%20Regional%20%E5%8D%97%E4%BA%AC%20E%E3%80%91Color%20the%20Tree%20%E9%A2%98%E8%A7%A3/","excerpt":"题目大意&emsp;&emsp;有一棵 $n$ 个节点的树，初始节点颜色全白，每次操作可以选择一个节点 $u$ 和一个距离 $i$，将 $u$ 子树内距离它 $i$ 的点全部染黑。一次距离为 $i$ 的操作的代价为 $a_i$。求最小代价把整棵树染黑。 &emsp;&emsp;$n \\leq 10^5,\\ \\ 1 \\leq a_i \\leq 10^9$&emsp;&emsp;多测，$\\sum n \\leq 3 \\times 10^5$，3s","text":"题目大意&emsp;&emsp;有一棵 $n$ 个节点的树，初始节点颜色全白，每次操作可以选择一个节点 $u$ 和一个距离 $i$，将 $u$ 子树内距离它 $i$ 的点全部染黑。一次距离为 $i$ 的操作的代价为 $a_i$。求最小代价把整棵树染黑。 &emsp;&emsp;$n \\leq 10^5,\\ \\ 1 \\leq a_i \\leq 10^9$&emsp;&emsp;多测，$\\sum n \\leq 3 \\times 10^5$，3s \\\\ \\\\ \\\\题解&emsp;&emsp;官方题解给了个建虚树的做法，但这题更有长链剖分的味道，长链剖分的复杂度也更优秀（确切地说，预处理 rmq 要 $O(n \\log n)$，剩余都是 $O(n)$）。 &emsp;&emsp;首先我们很容易想到一些关于深度的树形 dp：记 $dp_{x,i}$ 表示以 $x$ 为根的子树内与 $x$ 距离为 $i$ 的点全染黑的最小代价，那么就有 dp_{x, i} = \\min\\left( \\sum_{son} dp_{son, i-1}, a_i \\right).&emsp;&emsp;这种深度相关的树形 dp 看着就很能长链剖分。在长链剖分的框架下，子树合并没什么大问题，唯一的问题在于把 $dp_x$ 向 $dp_{fa_x}$ 转移的时候，需要 $\\min$ 上一些 $a_i$。&emsp;&emsp;但仔细一想，假如某个时刻 $dp_{x,i}$ 与 $a_i$ 取 $\\min$ 了，转移到 $fa_x$ 的时候这个值没有被动过（即没有跟 $fa_x$ 的其他子树合并），那么它就要 $\\min$ 上 $a_{i+1}$；如果转移到 $fa_{fa_x}$ 它还是没有被动过，那么它就要 $\\min$ 上 $a_{i+2}$……所以可以发现，如果一个 dp 值它没有被动过，最终它就会被 $\\min$ 上 $a$ 序列的一个区间最小值。那我们就不着急每次都去 $\\min$ 了，每当一个 dp 值被更新了以后，我们给它打上一个懒标记 $t$，表示它跟 $a_t$ 取 $\\min$ 了，等下次它被更新或者最终求答案的时候，假设那时它离根的距离为 $t’$，那么它就要跟 $a_t, a_{t+1}, \\cdots, a_{t’}$ 取 $\\min$，这个 rmq 一下就好了。&emsp;&emsp;有了这个懒标记，长链剖分做 dp 就是线性的了。不过很不幸预处理 rmq 还是 $O(n \\log n)$ 的。。。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include&lt;bits/stdc++.h&gt;#define fo(i,a,b) for(int i=a;i&lt;=b;i++)#define fd(i,a,b) for(int i=a;i&gt;=b;i--)using namespace std;typedef long long LL;const int maxn=1e5+5, MX=17;int n;LL a[maxn];vector&lt;int&gt; e[maxn];int Log[maxn];LL nmin[MX+2][maxn];void rmq_pre() &#123; fo(i,0,n-1) nmin[0][i]=a[i]; fo(i,2,n) Log[i]=Log[i&gt;&gt;1]+1; fo(j,1,MX) fo(i,0,n-1) nmin[j][i]=min(nmin[j-1][i],nmin[j-1][i+(1&lt;&lt;(j-1))]);&#125;LL rmq(int l,int r) &#123; int t=Log[r-l+1]; return min(nmin[t][l],nmin[t][r-(1&lt;&lt;t)+1]);&#125;int deepest[maxn],lson[maxn],st[maxn],en[maxn],tot;void dfs_link(int k,int last,int deep) &#123; deepest[k]=deep; for(int son:e[k]) if (son!=last) &#123; dfs_link(son,k,deep+1); if (deepest[son]&gt;deepest[lson[k]]) lson[k]=son; deepest[k]=max(deepest[k],deepest[son]); &#125;&#125;int dfs_index(int k,int last) &#123; st[k]=en[k]=++tot; if (lson[k]) en[k]=dfs_index(lson[k],k); for(int son:e[k]) if (son!=last &amp;&amp; son!=lson[k]) dfs_index(son,k); return en[k];&#125;LL f[maxn];int tag[maxn];void dfs(int k,int last,int deep) &#123; if (lson[k]) dfs(lson[k],k,deep+1); f[st[k]]=a[0]; tag[st[k]]=0; int sondeepest=0; for(int son:e[k]) if (son!=last &amp;&amp; son!=lson[k]) &#123; dfs(son,k,deep+1); sondeepest=max(sondeepest,deepest[son]); &#125; fo(i,deep,sondeepest) &#123; int index=st[k]+i-deep; f[index]=min(f[index],rmq(tag[index],i-deep)); tag[index]=i-deep; &#125; for(int son:e[k]) if (son!=last &amp;&amp; son!=lson[k]) &#123; fo(i,deep+1,deepest[son]) &#123; int sonindex=st[son]+i-(deep+1); f[sonindex]=min(f[sonindex],rmq(tag[sonindex],i-deep)); f[st[k]+i-deep]+=f[sonindex]; &#125; &#125;&#125;int main() &#123; int T; scanf(&quot;%d&quot;,&amp;T); while (T--) &#123; scanf(&quot;%d&quot;,&amp;n); fo(i,1,n) &#123; scanf(&quot;%lld&quot;,&amp;a[i-1]); e[i].clear(); &#125; fo(i,2,n) &#123; int u,v; scanf(&quot;%d %d&quot;,&amp;u,&amp;v); e[u].push_back(v), e[v].push_back(u); &#125; rmq_pre(); tot=0; memset(lson,0,(n+2)*sizeof(int)); dfs_link(1,0,1); dfs_index(1,0); memset(f,0,(n+2)*sizeof(LL)); memset(tag,0,(n+2)*sizeof(int)); dfs(1,0,1); LL ans=0; fo(i,1,deepest[1]) &#123; f[i]=min(f[i],rmq(tag[i],i-1)); ans+=f[i]; &#125; printf(&quot;%lld\\n&quot;,ans); &#125;&#125;","categories":[{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[{"name":"算法_树链剖分","slug":"算法-树链剖分","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/"}]},{"title":"Liella 4th 千叶场 + 一点点虹缪少歌巡礼","slug":"liella_4th_chiba","date":"2023-08-21T15:15:56.000Z","updated":"2024-04-24T03:59:22.781Z","comments":true,"path":"liella_4th_chiba/","link":"","permalink":"http://kqp.world/liella_4th_chiba/","excerpt":"これから11人のリエラ、よろしくお願いします！","text":"これから11人のリエラ、よろしくお願いします！ 前言&emsp;&emsp;4 月 28 日星团三张白卷抽选公开，冷不防是个 4th 巡演，突如其来。&emsp;&emsp;同时分了小组，可恋 vn 一组，全团唱力最好的三个人放一起，排在 4th 第一场。&emsp;&emsp;泡芙哥一查机票，UO 老母 2200 hkd 来回，心动了，但还没完全心动。&emsp;&emsp;给 b 组投稿了小组名，心想中了的话我就是 b 组的爹，就必须去看了，更心动了一点。&emsp;&emsp;被对比了虹和星的上座率、抽选热度，彻底受不住了，下决心冲。 &emsp;&emsp;于是经历了一周的思想斗争，最后决定和泡芙一起，短炒一个周末！正好也来试试如果只去一个周末只看 live，最低成本能去到多少，能否实现现地 live 常态化。&emsp;&emsp;就这一周时间 UO 老母已经升价到 2700 hkd 了&emsp;&emsp;而且这还是阴间机，星期五 8pm 起飞 1:20am 到羽田，星期一 2am 起飞 6am 到香港。省钱 + 一天假都不请 + UO 老母 = 宇宙第一夜行特种兵 &emsp;&emsp;时隔半年再次来到 LL 系列演唱会。&emsp;&emsp;其实有不少担心的，比如会不会新歌太少硬炒冷饭卖情怀，比如三期生新人才训练几个月直接上巡演，比如千叶场满座能 1.5w 人会不会上座率太差……&emsp;&emsp;但始终是期待比担心多。这次认识更热情靠谱的在日友人（id 叫邂逅个屁）帮忙抽票，不会再有忘记付款这类事情发生了，有机会内场冲神席了，上次看 3rd 还是山顶洞人，只是看了个蚁人版 Liella，这次能不能中个好席位近距离看看她们、拿些 res 呢？b 组唱力最好的三个人能给我们带来什么惊喜呢？三期生新人又会有惊喜吗？企划能不能再抽中一个 sayu 这样的 UR 素人？ b 组组名投稿&emsp;&emsp;b 组我最先想到的就是三个蓝色（3rd 的时候 vn 还是深蓝），所以打算从颜色入手起名。&emsp;&emsp;于是开始搜索有什么蓝色的生僻词，找了一堆，大概就只有 azure、cerulean 比较好，觉得 azure 太像 AZUNA 了，于是就选了 cerulean。随便写了一段，丢给 Chatgpt 改改交上去了。 Chatgpt 是真的能处！ &emsp;&emsp;结果没想到投票选项出来，竟然是个德文的 BlauLila 抢先了。同样是蓝色入手，但是他德文更洋气，还加入了花语，那不愧是他，自愧不如。&emsp;&emsp;我就每天换着 ip 给他投票，前前后后投了 20 多票。 &emsp;&emsp;最后投票结果：KALEIDOSCORE&emsp;&emsp;我：你们开心就好。 出发与到着&emsp;&emsp;星期五下班去机场搭夜机，就很有一种香港人去日本过周末的感觉。 香港机场，依着东涌，和高耸的大屿山群 到达羽田，降落了心心念念的海上跑道！！！ Episode 1 再入台场&emsp;&emsp;傍晚的 live，白天还是找点事情做，于是跟泡芙、泡芙的朋友、屁兄一起，逛台场，吃虹联动拉面。&emsp;&emsp;没想到才时隔半年，我都成台场虹巡礼导游了（x 虹经典场景：自由女神、彩虹大桥、Gamers、Chase、学校、Utopia，这些上次都去过了 JOYPOLIS，璃奈机厅 虹联动拉面，总共有六个小分馆，每去一个小分馆可以集一个章，每点一款联动拉面可以随机获得一张卡，一次点六碗可以获得一个痛勺 &emsp;&emsp;竟然在联动拉面这里遇到了猪仔包学长，他已经把六个小分馆全部吃过了，章齐了，卡齐了，勺子也有了，不愧是铁血虹厨。他很慷慨地跟我们交换卡，我抽到果林找他换了个步梦。&emsp;&emsp;六个小分馆中我们选了博多，没想到猪仔包说这就是最好吃的一个。抹茶鸡白汤拉面，味道很浓厚的。 旋转！发光！ Day 1&emsp;&emsp;坐上京叶线沿着东京湾海岸前往会场！ 京叶线海景 到达会场——幕張メッセ！ &emsp;&emsp;官网写的幕張メッセ 9~11 号馆，原来整个 11 号馆都是卖场贩和摆花篮，live 只有两个馆。。。你星果然离 1.5w 满开还是差得远啊。 场贩馆里的花篮 &emsp;&emsp;不过也好，这样也避免了 live 场馆变得特别长条，不然后排的人可就 rnm 退钱了。这场子只有一层楼，说得好听点大家都是 arena，说得不好听，这就是个大型 live house，站起来以后矮的人啥都没得看。 &emsp;&emsp;进场，座位开奖！ 席位分布图，中间是连接中心舞台的超长走道 Day1 我的座位：S4右上！ &emsp;&emsp;中心舞台席！！！！！！！！！！&emsp;&emsp;全体起立！！！！！！！！！！ &emsp;&emsp;喜极而泣，有生之年真的能抽到好席，超近距离看中心舞台和走道！当然看主舞台还是很难看到表情，但是，要啥自行车啊！！&emsp;&emsp;我和屁兄同行连坐，泡芙哥和他朋友同行连坐，他们这次到 S1 去了，上次是神席老哥，这次成了荒郊野外，侧过侧田（x&emsp;&emsp;但是看现场布置，2 区和 3 区之间的过道很宽，很可能走花车，如果是这样那 S1 倒也算是个花车席了，如果 1 区左边也走花车，那 S1 也晋升花车神席了。&emsp;&emsp;（后来事实证明，2 区和 3 区之间确实是花车道，我们 4 人都喜提花车席。） &emsp;&emsp;这场子空调跟坏了一样，一点没凉快，幸好大家出汗没有汗味。&emsp;&emsp;看着自己的席位，想到能清楚看到她们的笑容，想到可能的 res，想想就激动啊（&emsp;&emsp;跟屁兄热情聊天许久，いよいよ开场！ &emsp;&emsp;灯灭，战歌起，全体起立，切色欢迎成员。现在回归出声 live 了，却也是我第一次参加 Liella 的出声 live，我喊超大声，在周围一片好像很突出（x&emsp;&emsp;星星终于有 9+2=11 颗了，希望所有的星星都不要再受磨难了。 &emsp;&emsp;「飛び込め new world」拉开序幕。果然离主舞台还是有点距离，看不到表情。已经没有上次那种屏幕和舞台的割裂感了，可能是因为确实近了些，也可能是很明确待会她们到走道的时候一定可以看得很清楚。这首歌的服装是渐变色的，同样是蓝+粉但是比 op2 高级了很多，后裙摆很长，特别适合熊这样帅气的人。 熊的帅照（bushi &emsp;&emsp;mc 她们说“熱い”“熱気”“及时补水”之类的，现在才明白都是真话。。。真的是打两首歌大家都汗流浃背。（给爷修空调啊！！&emsp;&emsp;唱了动画二期的特典曲，终于没把这些藏着掖着了。我期待什么时候能把一期动画特典 2 补掉。&emsp;&emsp;sif 联动曲，难得的 call 比较激烈的曲子，从台上到台下都是激情四射。大家都很用力喊，体会到了以前看视频时那种响彻场馆的感觉。「大きな声で」的喊法就是生放的官方厄介喊法（x&emsp;&emsp;二专 solo，旁边屁兄被 non 搞得情迷意乱。这里最亮点的就是可堇居然是联动的，可可抱着一只布偶小熊，唱完后轻轻放在地下，堇唱完之后拾起小熊，情意传递，底下嗑倒一片。&emsp;&emsp;反而小组环节我觉得有所欠缺。虽然 K 组的深情和苦情表现得很好。也惊喜能听到一专，但是改一专改得不好，曲风成了欢快的钢琴小调，而歌词仍然是在呼喊奔向梦想的心情，追梦怎是如此轻松儿戏的基调呢？不能戏说梦想的啊！其次是短，总共 3 曲就设一个单独的 corner，戛然而止，有一种凑数的感觉，不如直接设小组 corner 三个小组都上。 &emsp;&emsp;三期生接力 symphony。正如后面 emo 的感想所说，symphony 是一首见证 Liella 成长的曲子，最初的五人欢快版，一期动画香音 solo 版，九人深情版，到 11 人欢快版，每一个版本都蕴含了不同的感情，但是奏响梦想的决心是相同的。“私のSymphony”，既有每一个“小我”各自独特的梦想，也有作为 Liella 的“大我”的梦想。&emsp;&emsp;这首歌也是初见小花的唱力，虽然 solo 不多，但是能把 symphony 首句起稳，证明至少不差。破企划运营依托答辩，选人倒是有一手。 &emsp;&emsp;再来说近距离，这是这次 live 的全新体验。&emsp;&emsp;《Killer Kyun》出第一趟花车对我来说还有点措手不及，那时还在面向舞台疯狂「キューンキューン」地喊 call，全然不知她们都到我们背后了，这才慌忙切色、挥手。后面就学会预判了，成员从主舞台上花车就开始选定要切的颜色。&emsp;&emsp;res 是真的！！！常夏花车跟 emorin 挥手，day1 在中心舞台走道跟 sayu 挥手，最后 universe 小花单独花车过来挥手！！！其实也不知道她到底是不是在跟你挥手，但 res 吧也就是这么回事，她朝你的方向挥手你就当她是了，你要较真的话那很大概率一个都不是。但最重要的，是你近距离看到她热情洋溢、一笑倾城啊！！笑容永远是治愈一切的良药。&emsp;&emsp;花车，以及中心舞台、走道，都能很清楚地看到完整的人包括表情，可以很近地观赏舞蹈和笑容，所有细节尽收眼底。只有一点不好，我们座位在中心舞台左前方，青山姐的 solo、K 组的站桩都是面向后面观众的，我们就只能看屁股（x&emsp;&emsp;好像屁兄还挺享受看青山姐和结那的屁股的&emsp;&emsp;鲤鱼 solo 花车经过泡芙哥那边的席位，本以为泡芙哥那荒郊野岭终于迎来春天了，结果鲤鱼到他们那边之后转身背对他们（x &emsp;&emsp;mc、幕间剧、最后的感想，都能听懂个七八成了（不懂的问旁边屁兄也不懂）。因此最后感想能听到很多小故事。结那和小花在诉说加入 Liella 之后的心态变化，小花也是从粉丝一路追梦追到台上去的。non 日常自卑哭泣，pay 成了纸巾大使，导播不知道有没有播到，pay 会在其他人讲话的时候给哭了的人递纸巾。emo 讲了《私のSymphony》是陪伴她们成长的一首歌。&emsp;&emsp;导播可能也没拍到左右最边上的两对人（结那和熊、emo 和小花）总是在别人说话的时候放飞自我（x &emsp;&emsp;朋友说歌单不好，不够燃，其实 Liella 的歌本身就不多 call，今天有 sif 联动曲、二专、常夏、day1 这样的歌，也算是能把大家点燃起来了。&emsp;&emsp;我是燃爽了，第一次体验到如此近的席位，以及花车。说是神席吧，可能还不够神，离舞台和花车也还有一个 block 的距离，离主舞台也远。但也无憾，能内场，甚至可能被拍到录进 BD；能打招呼拿 res；以往只有在视频里才能看到的面孔和身影清晰地出现在眼前，此亦飞之至也。 &emsp;&emsp;对明天 Day2 既期待又紧张，主要还是 sayu，今天决赛曲最后 sayu 那几嗓子以外地不错，让我觉得 sayu 又行了，对明天的死亡高音 solo 提高了不少期待。 &emsp;&emsp;就以香港远征 7 人团 + 屁兄一起恰的一顿鸟贵族结束今天吧。 Song for me, Song for you, Song for all! 山梨白桃天下第一 鸟贵族，一个不错的烤串店 Episode 2 秋叶原与东京塔少歌巡礼&emsp;&emsp;酒店住到了龟户，离秋叶原近，于是早上去秋叶原帮朋友淘旧碟，再去东京塔找一下少歌的公园。&emsp;&emsp;当然，来到了秋叶原，不可避免要去缪缪的地方参拜一下了~ UTX 神田明神，原本卖符的小亭子建起了文化交流馆，生意做大了 秋叶“原” 秋叶原一家不错的店 开始寻找神乐光！ 小光你到底在哪呀！ 终于找到你了小光！ 不要再跑了小光！ Day2&emsp;&emsp;Day2 我和屁兄的位置是 V2 后排，泡芙哥和朋友的位置是 V2 前排。 Day2 我的座位 &emsp;&emsp;有了昨天的经验，已经提前预知了今天是花车席。虽然远离了中心舞台，但是，有花车席了还要啥自行车啊！ &emsp;&emsp;今天我附近的人的喊声明显高了不少，我左前是两个厄介，后面的 block 是一群震天撼地的 call leader。 &emsp;&emsp;开场大家站起来后发现，我右前方是个高个儿，一个头足以把主舞台档掉九成。于是主舞台的歌只能大部分看屏幕，偶尔他侧头的时候我才有机会瞄两眼。这大概就是 arena 的坏处了，坐山上不会被挡住，但是坐 arena 很大概率是有 live house 效果的。&emsp;&emsp;所以今天花车拿 res 的任务就成了重中之重。&emsp;&emsp;屁兄是 non 激推，但可惜昨天 non 根本没有光顾我们这边。今天《ビタミンSUMMER》的花车，看到 non 在左边上车，我立即喊屁兄一起切色，等 non 的花车来到我们这儿即将转弯时，我俩附近只有我们是黄色，成功获得 non 酱神之一指，屁兄内心大概是当场晕阙了。&emsp;&emsp;后面 TBD 的花车，我再次拿到 sayu 和 emo 的 res。感觉还是甜妹的 res 好拿，她们很热情打招呼的，只要切她颜色，拼命挥手她就会注意到了，如果周围又恰巧只有你是她颜色，你就获得了巨大的 buff。&emsp;&emsp;花车 nako 的 res 不记得有没有了，乐观一点就当有吧（x），安可那两首歌反正都是大混战。&emsp;&emsp;只可惜中心舞台和走道非常远了，那上面的 res 不太能计入了，太牵强了。 &emsp;&emsp;我们这边才刚刚体验花车席和 res，泡芙哥已经目指集齐所有人的 res 了。毕竟他 3rd 的时候已经集到只剩鱼了，这次当然想要更进一步，他后来很兴奋地说，这次鱼的也拿到了，但很可惜小花的没有，小花在花车上是背对他的。&emsp;&emsp;人与人的差距不能一概而论啊。。。&emsp;&emsp;他教我们一个经验，花车来的时候跟着她们跳舞，这样概率就大很多了，这招对青山姐特别灵。 &emsp;&emsp;今天的二专 solo 也同样精彩。emo 的这首竟然是能 call 的，搭配 emo 的性感露肩，和激烈的词曲，成了一首燃歌。&emsp;&emsp;最为最为扣人心弦的当属 sayu 这首死亡高音曲，无敌的 sayu 竟然真的顶上去了！高音的音准达到了！稳住了！我们是漫卷棒子喜欲狂啊，仰天长啸，壮怀激烈。从 1st 20 场巡演开始，可怜的小 sayu 就已经被折磨得不轻了，嗓子每况愈下，到最近的几首 cd 已经是修音都修不好的状态了。这两日一战，昨天决赛曲 solo 稳住，今天的死亡高音也能稳住，仿佛一代战神又归来了。当然，还没有完全归来，毕竟 cd 的每况愈下还没扭转，而且 sayu 不知道什么时候学了像 non 酱那样的奇怪的倚音，唱得不干脆了。她自己说有在调整唱法，我不专业不得而知。&emsp;&emsp;solo 服装多是按照成员色来的，像 non 的黄色可爱小女孩装加一个小书包、yabu 的大红衣裙，都很衬。后来补切片才发现，sayu 的衣服上印着等待青空的谱。 &emsp;&emsp;我以前以为线上与现场的听感是一样的，现在大概明白了一点，现场的音响效果能掩盖一些瑕疵，而线上应该是她们的麦和观众麦两个声道同时传，就会让瑕疵一览无余。所以现场的效果还真是比看线上要好一些。 &emsp;&emsp;曲目编排，虽然曲目之间是没啥联系的，但大体是通过幕间剧连出一条主线了，这比之前水 6th 的要好，水 6th 总像是想起哪首就唱哪首。 &emsp;&emsp;最后感想环节遗憾说了些我不爱听的话，大概是 sayu 带起来的，后来 nako 等人都在讲，讲最初拿到自己的 solo 曲，不知道到底是怎样一种感情去唱，然后揣摩了很久，交出自己的一份答案。这说白了，就是香音、小千这些灵魂都是作词人作曲人强行塞给你的，你甚至还读不明白这歌，你压根就不是香音、小千，你没有内化她们的灵魂，你就是个发声工具。我知道现代商业歌曲制作必须是这样的，但其实你们可以少说这些话，或者把重点放在讲解歌曲的感情，这样去减少你们与角色的割裂感。 &emsp;&emsp;这是第三次参与 live 了，相比上次 AZUNA 第一次有了参与感，这次的参与感是更强烈了，最直接的原因就是位置较好，我们挥棒、喊 call，都是应援场面的重要建设力量，包括台上的人看到的场面、后排人跟 call 会看到的场面、将来 BD 可能会录进去的场面。&emsp;&emsp;一个小小的愿望，希望能参与 Liella 的光路企划。这事水水擅长，歌曲光路、安可光路都搞过，虹有动画契机但是还没搞成。其实 Liella 也有，一期动画的星光序曲，就是五条色带。光路企划是参与感最强烈的形式，也是水 5th 安可彩虹以来我一直没完成的愿望。 正宗的日本萨莉亚 End&emsp;&emsp;虽然是很想说实现现地 live 常态化的，但始终机票酒店这些花销不能无视，前期准备耗的精力也不可忽略，终究还是不能说任何想去的 live 都去。像年末的大拼盘和幻夜，还是有各种原因需要放弃掉。人应该知足，有 live 看就不错了，不需要癫到全勤所有活动。&emsp;&emsp;但总归是试验成功了，如果有很重要的 live 非常想看，短炒一周末是可行的。三年多次签证也申到了，想去只要买机票订酒店就能去，所以可以以一个很放松随意的心态去面对这些活动。 &emsp;&emsp;之前总结的“补 live -&gt; 云 live -&gt; 上映会 -&gt; 民间组织观影 -&gt; 现地烂席 -&gt; 现地好席 -&gt; 现地神席”厨力路径，经此一役，我觉得我已无欲无求，算不上最神的席，但也不用追求更神的了。 &emsp;&emsp;Liella 是值得的，心平气和地看它，你能看到很多故事，比以往的都要更现实。一二三期生都有粉丝走上台的代表，这是切切实实的追梦，是另一个版本的“大家一起实现的故事”。凡事抱以希望看，还是可以期待一下花田十一郎（继花田九辉之后的新外号）能给出一个怎样的三期故事。 &emsp;&emsp;5th 大概会是以三期动画为主题的 live 了，吸引力大很多，预计是明年中后。群友个个摩拳擦掌要来个日本团建，好啊，那就期待一手。","categories":[{"name":"玩","slug":"玩","permalink":"http://kqp.world/categories/%E7%8E%A9/"}],"tags":[]},{"title":"【STOC2018】Fine-grained Reductions from Approximate Counting to Decision","slug":"[STOC2018]Fine-grained-Reductions-from-Approximate-Counting-to-Decision","date":"2023-06-17T03:24:12.000Z","updated":"2024-04-24T03:59:22.801Z","comments":true,"path":"[STOC2018]Fine-grained-Reductions-from-Approximate-Counting-to-Decision/","link":"","permalink":"http://kqp.world/[STOC2018]Fine-grained-Reductions-from-Approximate-Counting-to-Decision/","excerpt":"&emsp;&emsp;这篇文章给了些很不错的思路，把一些问题的 approximate counting 版本归约到 decision 版本上，更具体地说，如果给定 decision 版本的 oracle，就能在很小的时间代价内（比如对于 OV 等问题是 polylog）完成 approximate counting。该方法适用于 k-SAT、OV、3-SUM 等 Fine-Grained Complexity 关注的核心问题。","text":"&emsp;&emsp;这篇文章给了些很不错的思路，把一些问题的 approximate counting 版本归约到 decision 版本上，更具体地说，如果给定 decision 版本的 oracle，就能在很小的时间代价内（比如对于 OV 等问题是 polylog）完成 approximate counting。该方法适用于 k-SAT、OV、3-SUM 等 Fine-Grained Complexity 关注的核心问题。 Idea&emsp;&emsp;这个思路 high level 来讲就是“减半”，对某个东西不停地减半，直到能暴力为止。&emsp;&emsp;k-SAT 和其他问题（OV、3-SUM、Negative-Weight-Triangle）做法稍有不一样，这里会有两种不同的“减半”思路。 k-SAT&emsp;&emsp;k-SAT 问题的“减半”思路是这样的：给 k-SAT 问题增加额外的条件，使得解数减半，直到解数足够少，能通过“暴力搜够一定的解数就停”来求出。 &emsp;&emsp;先看怎么把解数减半。&emsp;&emsp;假设原题是给定一个公式 $F$，求有多少个解 $x$（$x$ 看成是 $n$ 维 01 向量），使得 $x \\models F$。现在增加一个矩阵 $A$，大小为 $m \\times n$（$m \\le n$），$A$ 的每一行里随机选择 $s$ 个元素，这 $s$ 个元素独立随机地选择 $0$ 或 $1$，其余元素都是 $0$；再增加一个 $n$ 维 01 向量 $b$，每个元素都是独立随机。然后把原题的要求变成 $x \\models F$ 且 $Ax=b$（$\\mathbb F_2$ 下运算）。&emsp;&emsp;$A$ 的每一行相当于随机选 $s$ 个元素然后对它们的异或和作出限制，由于 $b$ 是随机的，原题的每个解满足一行限制的概率是 $\\frac 12$，满足 $m$ 行的概率就是 $\\frac{1}{2^m}$。根据期望的线性性， \\begin{aligned} \\mathbb E[\\text{新的解数}] = \\sum_{x \\models F} \\text{Pr}[Ax=b] = \\frac{\\text{原来的解数}}{2^m}. \\end{aligned}&emsp;&emsp;也就是 $A$ 的每一行都使得解数减半，$m$ 行就减成原来的 $\\frac{1}{2^m}$。&emsp;&emsp;但只有期望减半是不够的，还要 with high probability 能减半，也就是还要一个 concentration。这里用的是 Chebyshev 不等式，也就是要 bound 住它的方差。方法大约是把 $\\mathbb E[(\\text{新的解数})^2]$ 用期望线性性拆成每个解对单独考虑，然后把解对用 Hamming Distance 大小分成两组，分别 bound 住。这里比较琐碎和炫技，就不详述，可以自行看论文。&emsp;&emsp;（我感觉 $A$ 的每一行选出 $s$ 个元素之后直接把它们都赋值为 $1$ 就好了，不需要再独立随机，方差甚至能更小。） &emsp;&emsp;然后再来看“暴力搜够一定解数就停”，比如要求搜够 $a$ 个解就停。这里就要用到 decision oracle 了。&emsp;&emsp;首先，$Ax=b$ 这个限制可以变为长度为 $m2^{s-1}$ 的 $s$-CNF（$A$ 的每一行相当于规定把至多 $s$ 个变量 xor 起来的值，用 $2^{s-1}$ 个 CNF clause（可由 not DNF clause 转化而来）来枚举表示），所以原公式 $F$ 加上这个限制可以归约成 $\\max(k,s)$-SAT。&emsp;&emsp;暴力如下：枚举第一个变量为 $0$，用 oracle 判断是否有解，有就递归下去；完了之后枚举第一个变量为 $1$，用 oracle 判断是否有解，有就递归下去。搜够 $a$ 个解之后就返回（返回解数，或“解数大于 $a$”）。复杂度 $O(a)$。 &emsp;&emsp;所以整体方法就出来了：设定一个阈值 $a$，从小到大枚举 $m$，对于每个 $m$ 重复多次实验，如果“暴力搜够 $a$ 个解就停”算法返回确切解数，那么就乘 $2^m$ 然后输出，否则继续下一个 $m$。 &emsp;&emsp;正确设置参数大小，可使得最后时间复杂度为：对于任意 $\\delta&gt;0$ 以及 multiplicative error $\\epsilon$，时间复杂度为 $\\epsilon^{-2} \\cdot O(2^{(\\Delta+\\delta)n})$，其中 $O(2^{\\Delta n})$ 是 decision oracle 的复杂度。&emsp;&emsp;（我感觉这个 $m$ 甚至不用从小到大枚举，可以二分，不过鉴于复杂度是指数的，对于 $poly(n)$ 的优化似乎并不重要。。。） 二分图边数&emsp;&emsp;给定一个二分图，左右总共 $n$ 个点，你要近似出它的边数。你只有两种 oracle 来访问这个图，一是直接询问某一对点之间是否有边，二是选定一个点集问这个点集是否包含边（这一般就对应 decision oracle）。&emsp;&emsp;OV、3-SUM、Negative-Weight-Triangle 都可以归约到这个问题，所以我们只要解决这个问题就好。 &emsp;&emsp;这个问题的“减半”思路是这样的：假如这个图的一侧（假设是 $V$ 侧，另一侧是 $U$）比较平衡（即不会有少数点集中了大部分的边），那么这一侧随机选一半的点，也会使得边数减半。减下去直到点数变为 $O(\\log n)$，就可以 $\\tilde O(n)$ 暴力了。 &emsp;&emsp;Formally 来说，我们主要考虑 $V$ 侧，定义平衡为存在一个 $\\xi \\in (0,1)$，每个点的度数都不超过 $\\xi$ 倍的总边数（或者说归一化后度数不超过 $\\xi$），称之为 $\\xi$-平衡。先假设我们知道每个点的度数。&emsp;&emsp;如果 $V$ 侧的点是 $\\xi$-平衡的，那么对 $V$ 侧的点进行伯努利采样，期望会留下一半的点，边数也会变成原来的约一半。这一步的证明是简单的 concentration 应用，使用 McDiarmid 不等式。&emsp;&emsp;那如果不平衡呢，也就是 $V$ 有少数点比较菊花。解决办法就是把归一化度数超过 $\\frac{\\xi}{2}$ 的点拉出来放入点集 $S$，对 $U \\times S$ 做 Simple Random Sampling（Chernoff bound 保证概率，并且 $|S|$ 不会很大，否则 $V$ 会平衡），剩下的 $V \\setminus S$ 的点要么是度数都在 $\\xi N(V \\setminus S)$ 以内（$N(X)$ 表示 $X$ 的临集），也就是平衡的；要么存在点度数超过 $\\xi N(V \\setminus S)$，但是它不在 $S$ 里说明它度数不超过 $\\frac{\\xi}{2} N(V)$，联立起来就是 $N(V \\setminus S) \\le \\frac 12 N(V)$，即剩下的点在 $U$ 的临集大小会减半。&emsp;&emsp;（我这样写是把原文的参数简化了，便于理解） &emsp;&emsp;这里需要做两件事：1、估计出 $V$ 里每个点的度数；2、万一不平衡或者 $N(V)$ 太小需要暴力，则需要把 $N(V)$ 也找出来。&emsp;&emsp;我们可以用一个算法同时解决这两件事：设一个阈值 $y$，将 $U$ 侧的点随机打乱，每次操作用二分 + decision oracle 判定的方法找到一个 $V$ 的临集点，直到找不到了或者找满 $y$ 个点就停。这样返回的结果，如果临集大小在 $y$ 以内，就会返回精确的临集，否则会返回一个大小为 $y$ 的临集的采样。&emsp;&emsp;这个采样即可用来估计 $V$ 侧的点的归一化后的度数，准确率由 Chernoff bound 保证。 &emsp;&emsp;所以整体算法是这样的：如果 $V$ 侧只有 $O(\\log n)$ 大小，或者设定阈值 $y=\\text{poly}(\\log n)$ 用上述算法发现 $N(V) \\le y$，那么就暴力，否则用刚才得到的 $N(V)$ 的大小为 $y$ 的采样估计出每个点的归一化度数，如果是平衡的，则对 $V$ 进行伯努利采样，递归，否则挑出 $S$，对 $U \\times S$ 进行 Simple Random Sampling，对 $V \\setminus S$ 递归。 &emsp;&emsp;时间复杂度，可以看到每次递归下去，要么 $V$ 大小减半（期望减半，with high probability 减到 $\\frac 34$），要么 $N(V)$ 大小减半，且 $V$ 的大小不会增大，所以最多递归 $\\log^2 n$ 层。每层要做的就是二分 + decision oracle 判定去做采样，做 $y=\\text{poly}(\\log n)$ 次。所以总复杂度是 $O(\\epsilon^{-2} \\cdot poly(\\log n) \\cdot \\Delta)$，其中 $\\Delta$ 是 decision oracle 的时间。 Fine-Grained Complexity 核心问题 #OV 归约到二分图边数：左边 $n$ 个点表示 $n$ 个向量，右边 $n$ 个点表示 $n$ 个向量，两个点之间有边当且仅当它们正交。第一个 oracle 就是直接判定两个向量是否正交，第二个 oracle 就是框定一个子问题判断是否存在正交。 #3-SUM 归约到二分图边数：左边一排点表示第一个数集，右边一排点表示第二个数集，两个点之间有边当且仅当它们的和的相反数存在于第三个数集。第一个 oracle 就是直接判定两个数的和的相反数是否存在于第三个数集，第二个 oracle 就是框定一个子问题判断是否存在三个数和为 $0$。 #NWT 归约到二分图边数：左边一排点表示原图的点，右边一排点表示原图的边，两个点之间有边当且仅当原图这个点和边能组成负权三角形。第一个 oracle 就是直接判定一个三角形是否负权，第二个 oracle 就是框定一个子图问是否存在负权三角形。 吹水时间&emsp;&emsp;其实要读过论文才知道，虽然减半这个思路很厉害，但是真正主体的工作，是怎样用 concentration 来 bound 住这些减半，如果 bound 不住那么这就只是拍个脑袋而已了。还是得好好学 concentration，多积累不等式啊。。。","categories":[{"name":"TCS","slug":"TCS","permalink":"http://kqp.world/categories/TCS/"}],"tags":[{"name":"complexity","slug":"complexity","permalink":"http://kqp.world/tags/complexity/"}]},{"title":"Liyuu 2nd 巡演广州场","slug":"liyuu_2nd_guangzhou","date":"2023-05-15T13:12:56.000Z","updated":"2024-04-24T03:59:22.782Z","comments":true,"path":"liyuu_2nd_guangzhou/","link":"","permalink":"http://kqp.world/liyuu_2nd_guangzhou/","excerpt":"&emsp;&emsp;4 月下旬的 Liyuu 2nd 巡演最后的横滨场，宣布追加上海公演和广州公演。&emsp;&emsp;不仅仅是鲤鱼终于回国开 live 了，而且还是 live 开到家门口，这下不得不去了啊！","text":"&emsp;&emsp;4 月下旬的 Liyuu 2nd 巡演最后的横滨场，宣布追加上海公演和广州公演。&emsp;&emsp;不仅仅是鲤鱼终于回国开 live 了，而且还是 live 开到家门口，这下不得不去了啊！ 看江河，一望无边际，她说，她说，我能游过去！——《小鲤鱼历险记》OP 购票&emsp;&emsp;虽说所谓百万鲤友只是开玩笑，但是粉丝基础怎么也不算小，光是 LLer 已经贡献一大帮人了。再加上第一次回国 live，官方肯定要先拿 live house 试试水，做个摸底考试，这就造成了购票惨烈的必然性。&emsp;&emsp;上海场率先开抢，开票的瞬间就切了，开售即售罄，给大家先带来一点小小的百万鲤友震撼。我们小群里试抢上海的一个都没成功。&emsp;&emsp;广州场大概十天后开抢。我们几个人吸取经验，放弃 vip 票，专攻普票，最后群里五人上岸，一人因同时抢 vip 和普票被系统判为“身份占用”惨空，后来才被朋友送票捞起。这下是彻底给我们带来亿点小小的百万鲤友震撼了。 &emsp;&emsp;可惜事情没有这么简单。。。 &emsp;&emsp;没错，抢票这种事怎么可能少得了科技和黄牛~&emsp;&emsp;科技就不说了，毕竟只要区分不了人工操作和脚本操作，那么科技甚至是不违规的。上海场开售前闲鱼已经冒出不少代抢了，上海场开售一过，代抢瞬间涨价，到广州场开售前夕甚至说 vip 代抢已经接满了。。。&emsp;&emsp;最恶心的还是黄牛。广州场开售才几分钟，闲鱼的黄牛已经开始得瑟了。过不久甚至还出现了摩天轮的高价牛票，疑似官方黄牛。尽管售票平台秀动已经提醒入场要人证合一，但是仍有少数人硬吃天价黄牛。&emsp;&emsp;后面还有离谱的是，临近演出的几天，登记了缺票提醒的人突然收到抢票提醒。我们以为是黄牛票卖不出去回流了，有幸运鲤友蹲到了，被朋友送票的群友也蹲到了。却不想主办方否认了有余票，发表声明异常抢票的 9 个人会被退票处理，至于这个异常是怎么回事，主办方和秀动互相踢起皮球。 &emsp;&emsp;你想想真鲤友是什么心态。&emsp;&emsp;群友就是代表。这期间在群里目睹了她的起起落落，抢票失败的落魄，黄牛跳脸的愤怒，朋友送票的释然，“人证合一”规则前的焦虑不安，蹲到候补票的激动欣喜，被告知候补票异常的炸裂，直至演出当天的忐忑。 &emsp;&emsp;乱，离谱。&emsp;&emsp;仅仅是因为票少造成惨烈现状我们当然没啥说的，但是乱象丛生，一边是不断提醒入场验票的严苛，一边是若无其事的黄牛在骑脸，还有疑似官方黄牛开出天价。最后几天的异常票让鲤友们彻底失望，因为看清了主办方和售票平台摆出的很糟糕的态度。 &emsp;&emsp;（这个牌子后来排场贩的时候还被保安收走了，引得大家都笑了） &emsp;&emsp;好朋友萤火虫 staff 桑也想抢 vip 票，他更想要手渡。但是很可惜失败了。&emsp;&emsp;后来我才学到小群里的操作，因为并没有限制用什么证件买票，我和他应该各给对方一个次要证件（比如护照、港澳通行证），然后他抢两张 vip，我抢两张普通，谁中了就买谁的，就会稳得多。香港的泡芙哥可谓是排出九枚证件大网捕鱼（x 前夕&emsp;&emsp;群里上传了 call 谱。我对比了 b 站的横滨场资源，发现还是挺多对不上的。最主要就是 ppph，日本人不喊的他给标上要喊，日本人喊的他倒是不标了。&emsp;&emsp;其实鲤鱼的歌真的没啥 call 的，很少的 mix，一两个复杂的应援舞，动作也并不对应歌词，大部分适合安静听歌。我也只是关注一下 ppph，因为这个需要起头，我想我可能可以带一下。&emsp;&emsp;但是又想到了这里是广州，结合这么多次的广州观影和漫展经验，我们有自己的一套风格，主打的就是一个随心所欲，融合军 call 和厄介，节奏适合就能喊。毕竟 call 谱只是提供一套规范，整齐才是最终追求。这样一想，哪里轮得到我带 call，一群华南虎抢着上了。&emsp;&emsp;同时也会担心虎们会不会失控，毕竟这次是正经 live，还是不能把イエッタイガー、可变三连这些喊出来的吧。 Episode——CCPC Final&emsp;&emsp;5 月 14 号正好是 CCPC Final，SYSU 办。&emsp;&emsp;母校难得办这么高级的比赛啊，遂决定路过围观。&emsp;&emsp;而且还是在香岚官洲酒店，这个在东校看了四年的船一样的酒店，每到晚上金碧辉煌五光十色，真是连踏进去一步都是想都不敢想，今天居然能在这里办比赛，你鸭是富得流油了。（本来还能再夸多一点的，不巧听说了一个瓜，就不往下夸了。） 场贩&emsp;&emsp;从 CCPC 会场出来，2 点到达 live 会场，预备着排两小时场贩。（AZUNA 都只用提前两个钟，这里不至于比 AZUNA 还卷吧。。。）&emsp;&emsp;先是找到了车仔领取了无料（面基群友*1），接着看到江边的华南虎已经开始了，然后就是围观花篮一个一个送达。这段时间并没有什么队伍，场贩不见影，大家都在随机游走。&emsp;&emsp;14:40 保安一声令下，场贩排队开始，人群迅速就近插入走道，从聚在一团突然延展成场贩队列。我大概抢到路口到门口中间的位置，有群友从厕所退到了路口（&emsp;&emsp;惊喜不惊喜，在场贩队列中的位置不取决于到达时间而是取决于 14:40 时的初始站位，乐。 &emsp;&emsp;我觉得这也没什么大不了的，毕竟没有过早开始排也是防卷嘛，而且本来靠近门口的程度也是积极程度决定的，所以都还接受。&emsp;&emsp;而真正骚的操作在后面。&emsp;&emsp;保安开始把队列带到门口前的空地，一列一列形成方阵。我估摸着我前面的人流量，在日本就是 30-45min 的事情。&emsp;&emsp;好不容易等到场贩开始，保安每次抽调最右边的一列进去，然后整体往右补齐。然而广场右后方有个大雕塑，每次往右补齐会导致队伍后半被切割，于是整个方阵的后半就越发凌乱，无法跟上自己原先的列进场，挤作一团，不久就开始骚动了。保安开始补救，以“后半乱了”为由放后半优先进去，却没想到根本停不下来，后半一锅粥都自称是前两列的跟着进去，使得前半被严重阻塞，就差跟保安打起来了。原本预计开售后 30-45min 解决战斗，愣是给我排了一个半钟。 这次那个保安还是各大展会经常请的那家公司的，属于是见怪不怪。——萤火虫 staff 桑 &emsp;&emsp;期间还听说了正常花篮人士和 z8 花篮人士互撕花篮牌。到此给人的感觉就是，这 live 的组织真的是乱极了。 入场&emsp;&emsp;从场贩出来身心俱疲，但是排入场的队伍已经九曲十八弯了，不得不立刻接上龙尾，继续罚站，没饭吃，也没水喝。&emsp;&emsp;车仔早早排完场贩在队伍前列，泡芙哥和他的朋友们没排场贩也抢到了很前面。我排上入场队之后才联系到各群友们，泡芙哥过来帮我占住位，我才得以出去买瓶水喝。（面基群友*2） &emsp;&emsp;就这样继续罚站到天黑，读 call 谱熟悉歌词。有排队的人一直在放歌，我也跟着比划两下。直到入场。 &emsp;&emsp;普票入场只扫二维码不查证件，也猜到了，效率嘛，没时间查的。只不过，你官方勾结黄牛这事是越来越洗不清了，你对自己的规则啪啪打脸，你没有展示出对黄牛的态度。&emsp;&emsp;不过 vip 似乎还是严的。听说有人买了黄牛 vip 被查证件无法进场发烂渣，只能说好死。 Live！&emsp;&emsp;终于是等到进场了才能忘掉所有这些不愉快的东西。看着舞台，听着音响，给棒子装上电池，这悸动一下就上来了。进入战斗状态，百万鲤友整装待发！！ &emsp;&emsp;第一次来 live house，果然条件不怎么好，人挤人，而且我位置靠后，前面的人举起手来我就只能看个鱼头了。&emsp;&emsp;买了一支鱼棒，透明的很好看，但其实实用性一般，在舞台灯光的照射下没啥亮度。打算以后淘宝买张纸填充一下内壁看能不能变成 LL 官棒的样子。（UPD：鱼棒不可拆卸，无了） &emsp;&emsp;还没到开演时间，底下的观众已经是尽显本色了。时不时跟着节奏虎起来，大喊“开门”以及各种鲤鱼直播常见弹幕。&emsp;&emsp;好巧不巧鲤鱼迟到 20min，这下鲤友们可不得好好抓住机会，疯狂整活。这 20min 成了最疯癫的时光。&emsp;&emsp;大喊包括但不限于：“开门！开门！开门！”“你有本事来广州，你有本事开门啊！”“鲤鱼别喝喜茶了！”“アンコール！アンコール！”“rnm退钱！”&emsp;&emsp;抛起一个可可中趴和一个可可小趴，传遍全场，像抛绣球，又像打排球。&emsp;&emsp;华南虎开始军火展示，包括厄介试鸣、大闪试亮、风火轮试转、孔雀试开屏。熟悉的华南动物园和华南灯光展 &emsp;&emsp;千等万等终于灯灭，伴舞登台，鲤鱼登台！&emsp;&emsp;我们的欢呼声是一阵比一阵激烈，百万鲤友集结台下，恭贺鲤鱼王回国。&emsp;&emsp;鲤鱼的妆容很精致，远看都很美。 &emsp;&emsp;开场几首歌把热情都给激发出来了，大家里跳和欢呼都很卖力，因为是 live house 所以手都举得老高了。call 也果然是广州特色的随心所欲风，不管什么歌都会尝试带起 ppph，大家也都会跟上。ppph 这种无害的多一点也是挺好的，会把氛围带得更热闹。&emsp;&emsp;MC 鲤鱼根本说不上话。底下我们如同发弹幕一样疯狂向鲤鱼喊话，而这鲤鱼居然也像直播回弹幕一样，听鲤友说什么，然后鱼叫，然后回答，没有机会说自己准备好的内容。鲤友当然抓住这个机会整活啦，什么逆天弹幕都有：“才八点”“口水巾”“生日快乐”“新年快乐”“母亲节快乐”“我出生了”“太好听了8”“素晴らしい声の人”……大多数鲤友应该看过日本场的切片，鲤鱼喝水的时候我们都会喊“干杯”“好喝”“おいしい”，逼得鲤鱼拼命说：“说中文！”鲤鱼讲起粤语的时候，底下也一直在教粤语，教了各种各样的：“飞冰走奶”“饮茶先啦”……鲤鱼说到“喜欢你”的时候，底下也唱起了《喜欢你》，也怂恿鲤鱼唱粤语歌。甚至鲤鱼还因此提到了菜宝，说菜宝平时说得最多的就是“点解”。 &emsp;&emsp;鲤鱼的歌声很清澈也很甜美，而且很稳，连唱很多首歌都不会有疲劳感或者音准问题，不愧是 Liella 里的一把手。长音气息控制得很好，很稳定，也有注重强弱变化，我觉得这个基础是可以加一点点颤音，向更多高级技巧进发了。&emsp;&emsp;很多好听的歌现场听到了非常满足，特别喜欢两首中文特制。柠檬气泡中文版，这首很清爽，跟以前的《热爱105°的你》一样一听就很有夏天的感觉，像被鲤鱼泡在柠檬水里，鲤鱼和伴舞还真的喝上了柠檬水；胭脂镜中文版，带有一点点虚幻感，有种迷失在魔镜前被鲤鱼牵着走的感觉。&emsp;&emsp;其他的歌，讲恋爱的歌我不是很上头，但是很多旅行和探秘主题的歌我很喜欢，读歌词就会自然联想到在世界飞翔遨游（歌词特别喜欢用“飞”“天空”“云”这类词）。非常遗憾的是《カラフルホライズン》这首最正宗的旅行歌没唱，好不容易学会了应援舞呢！&emsp;&emsp;《Yellow》我觉得是被 MV 抬了一手，听这首歌脑子里都是青山姐（ &emsp;&emsp;四位伴舞小姐姐可以说是美若天仙，婀娜多姿，活力四射。她们的身体既可以柔软灵活，又可以铿锵有力，DJ 鱼环节尽展功底。 &emsp;&emsp;华南虎还是失控了，整场虎啸震天。间奏虎火发动，副歌前イエッタイガー，慢歌乱喊，各种厄介 mix，前排骑膊马，后排打 wota，还有散落各处的大闪风火轮和孔雀。正经的鲤鱼 live 活像一个地偶场。&emsp;&emsp;但是这事也得两面看，除去这些明显超规的厄介，一些无害的 call 却是实实在在地把气氛顶上去了，也极大地增加了交互感和参与感。比如 ppph，比如《Tokimeki Runners》副歌的那种喊法（我也不知道叫啥），这些是无害的，观众也都跟，连鲤鱼唱完都马上说：“你们是不是现学的这个转来转去的，好好玩啊。”鲤鱼的歌不多 call，广州风格正好与其互补，就不像横滨场，看上去静得跟鬼一样。&emsp;&emsp;其实最重要的还是鲤鱼不介意，当然我们也不知道鲤鱼到底介不介意，但鲤鱼老拉拉人老漫展人这些肯定都是见过的。她也说：“你们都好会啊，你们比我还辛苦。” &emsp;&emsp;最后安可竟然才是精华所在，唱了三首版权歌。&emsp;&emsp;铃芽主题曲中文版，可惜我没看铃芽。&emsp;&emsp;王心凌环节，本来以为也是跟上海一样唱《当你》，结果音乐响起竟然是《爱你》，这可不更燃了，鲤鱼追梦环节啊！这首歌真的已经是有“鲤鱼追梦”的象征了啊！全体大合唱。可惜我唱嗨了，忘了去看鲤鱼有没有跳出王心凌那个像蝴蝶步一样的舞蹈。&emsp;&emsp;《可愛くてごめん》，跟香菜的《恋愛サーキュレーション》呈现的效果一样，台上一只羊，台下一群狼。&emsp;&emsp;最后鲤鱼报幕地平线，结果音乐响起不是地平线，鱼一脸委屈。 &emsp;&emsp;2h 的 live，嗨到飞起，久久不能平静，真的 AZUNA 1st 都没喊哑，这次喊哑了，感觉嗓子就一直没停过，唱歌在 call，mc 在发弹幕（x Live 后&emsp;&emsp;出场首先碰到 Conan 学长，竟没想到这一万年没联系的邦邦人竟然也来看鱼了。&emsp;&emsp;然后面基泡芙、章鱼哥、车仔，以及一众香港鲤友。短暂的群友面基，算是认识了小群里的几个话痨了。小群真好啊，能畅快说话，能真正像一帮朋友一样聚一起。 &emsp;&emsp;想周一在广州再待半天的，还能跟泡芙哥喝个茶顺便试下能不能偶遇鲤鱼，但是惧于老板下午查房，还是早早赶回香港了。。。 End&emsp;&emsp;实在是一场尽显中国特色的日式 live。 &emsp;&emsp;有不少很坏的中国特色暴露了出来。&emsp;&emsp;组织的混乱，乱象丛生。票务一塌糊涂，正经鲤友抢不到票，天价黄牛有恃无恐，平台出 bug 了互相踢皮球；场贩一塌糊涂，保安没有组织排场贩的经验，队伍险些失去秩序；现场管理一塌糊涂，大家的花篮没有得到保护；场内管理也不好，保安就坐在高凳上，却管不住家虎盗摄。&emsp;&emsp;华南虎令人失望，区分不了地偶和正经 live，厄介盛行。你们加些无害的，ppph 喊一喊，副歌转一转，这都挺好，把情绪和互动感抬起来；间奏不唱歌的你们虎一虎倒也不是不能接受。但人家正经唱歌的时候你们还拉 mix，还骑膊马、打 wota、开大闪和孔雀，那就实在是没素质了。多少鲤友已经在投诉影响观感了，还得祈祷没有影响到鲤鱼。&emsp;&emsp;盗摄严重，甚至后面还上传 b 站，生怕别人不知道他盗摄了。 &emsp;&emsp;但是抛开这些瑕疵，始终还是一场难忘的 live。&emsp;&emsp;中文歌，带版权的翻唱歌，中文 mc，就跟场刊写的一样，是精心为中国鲤友准备的，我是真的感激，因为柠檬水、胭脂镜这样的中文歌真的好听，唱王心凌也是很炸场。&emsp;&emsp;我也是第一次见到放大版的鲤鱼。之前 Liella 3rd 的东京场我是山顶洞人，只能看到蚁人鲤鱼，这次是能把表情看得一清二楚，能看见妆容，能看见笑容。对于好多国内鲤友来说，这是第一次见偶像，第一次参加正式 live。这对我们都是一个厨力上升的大台阶。&emsp;&emsp;我们在见证着鲤鱼的目标一步一步实现，进入 LL，也成为个人歌手，回国开 live。偶像的力量不正是来源于此么，有一个参考让我们感受到理想是可以实现的，而且不是遥不可及的人，是身边人，真真实实从我们这个群体里走出来的人。 &emsp;&emsp;8 月，Liella 4th B 组再见！","categories":[{"name":"玩","slug":"玩","permalink":"http://kqp.world/categories/%E7%8E%A9/"}],"tags":[]},{"title":"Liella 3rd 东京场 + AZUNA 1st + 沼津台场原宿圣地巡礼！","slug":"japan202302","date":"2023-01-23T14:14:55.000Z","updated":"2024-08-04T08:13:01.975Z","comments":true,"path":"japan202302/","link":"","permalink":"http://kqp.world/japan202302/","excerpt":"流量预警：全文包含约 80MB 的图片 &emsp;&emsp;日程是 1 月 28 日至 2 月 6 日，涵盖如下内容： Liella 3rd live 东京场 day2 AZUNA 1st live day1+day2 LoveLive Sunshine 沼津圣地巡礼 LoveLive 虹咲学园学园偶像同好会 台场圣地巡礼 LoveLive Superstar 原宿圣地巡礼","text":"流量预警：全文包含约 80MB 的图片 &emsp;&emsp;日程是 1 月 28 日至 2 月 6 日，涵盖如下内容： Liella 3rd live 东京场 day2 AZUNA 1st live day1+day2 LoveLive Sunshine 沼津圣地巡礼 LoveLive 虹咲学园学园偶像同好会 台场圣地巡礼 LoveLive Superstar 原宿圣地巡礼 前言&emsp;&emsp;2021 年 10 月初，日本个人旅游签开放，惠及香港，一时间大家都开始计划去日本了。&emsp;&emsp;作为 LLer，难得去一次日本当然要找 live 的时间去啦！&emsp;&emsp;一开始计划 12 月初跟 office 的学长们一起去玩，去看 Liella 3rd 的爱知场，结果因为跟期末考试监考改卷工作撞了而废弃。&emsp;&emsp;然后计划 3 月去看水 extra live，因为计划比较临时，没有好好准备抽票，手头只有一个水费账号用作二次先行抽选，结果当然也是不中，于是废弃。&emsp;&emsp;没过多久楠木灯宣布辞职，突然间 AZUNA 1st 成了老雪菜毕业 live，于是找到了在日本留学的猪仔包学长想一起抽票。几番周折，拿下了。&emsp;&emsp;想着来都来了怎么也得多看一点，于是也拜托学长把前一周的 Liella 3rd 东京场抽了。期间也是波折不断，比如抽选申请 ddl 前 5min 才拿到抽选码；比如中票后学长忘记付款了……幸好星目前人气低，有卖一般发售和当日券，得以补救。所以运营稀烂人气低迷实在是一件令人既高兴又不高兴的事情。 &emsp;&emsp;于是计划就这么敲定啦！行程为：原宿 -&gt; Liella 3rd -&gt; 沼津 -&gt; 台场 -&gt; AZUNA 1st！ 前期准备&emsp;&emsp;参考这篇沼津圣地巡礼笔记做出行前的准备。这里我也列一下我前期准备用到的 app 和工具。&emsp;&emsp;我是从香港过去的。广东一片的朋友们可以考虑从香港走，一般来说廉航机票要便宜得多，有船可以从内地港口直达香港机场。当然像 JAL/ANA/国泰 这样的其实还是广州深圳便宜（因为这些正价航空专杀香港人）。 机票：携程、trip.com（携程国际版）、各航司官网，以及所有常用的购票平台慢慢对比。特别提醒，有些平台每次关闭重开就会加价，因此需要小心关闭网页，或者清 cookie 不知道有没有用。推荐一个新开的航空公司叫大湾区航空，便宜而且时间很阳间。（UPD：这公司经过两年的发展已经成了把自己当作正价航空收费的廉航了） 酒店：携程、trip.com、jalan、agoda。但是有些网站（点名 agoda）表面价格较便宜，实际除酒店价格外有大约 20% 的手续费，甚至还有货币转换费之类的暗费，并且点进付款页面又关闭重开可能会加价 200。 实用 app：乗換案内（查交通用的，可以规划路线、查询班次）、google map。 live 相关：eplus。相信大家都会用了，注意买一般发售票和当日票是需要短信认证的（也就是注册账号用一次性手机号的就不要买了），正常抽票的会发邮件让你上传照片以人脸识别入场。 买抽选券：yahoo japan（俗称日拍）。如果是 BD 抽选，一般直接买抽选券会比买碟便宜，但缺点是它只能在日本付款或最终通过日本发行的银行卡付款，必须有在日友人辅助，淘宝代付店不接。 巡礼相关：舞台めぐり（常用的圣地巡礼 app，个别有偏差和不全）、上面那篇圣地巡礼笔记以及网上能找到的巡礼笔记和 vlog、てくてく Aqours、侑散歩、Liella のドコいく、LoveLive Days 里的风景和店铺、水广播剧推荐的店铺（UPD：有些广播推荐真的看看就行了，详见本文沼津部分）。 &emsp;&emsp;Mastercard 用户记得绑定 Mastercard Travel Reward 赚点返现（x 说明&emsp;&emsp;为了整体观感以及流量友好，下面放的图片都是缩小压缩过的，从新标签页打开图片可以看大图。&emsp;&emsp;图片的记载不完全按照时间顺序或地点顺序，会以逻辑顺序加以整理归类。 出发与到着&emsp;&emsp;早上 5 点就起床去赶飞机了。本希望在机场看日出，但是值机排队巨多人，值机值完了整个日出。。。&emsp;&emsp;香港机场没有拍照，因为第一感觉是香港机场不如广州机场宏伟（x 补一张一个月后在大屿山上拍的香港机场一角 &emsp;&emsp;飞机上补完了侑散步第 2 季、四团新春生放，真希望她们一直这样玩下去。&emsp;&emsp;入境并没有查核酸，也没有人做核酸，岸田的入境政策权当放屁（x 来看看美丽的成田机场吧 &emsp;&emsp;从成田机场到东京有至少两种坐法，一个是便宜的京成线慢慢悠悠晃过去，一个是贵三倍以上的 skyliner 飞速到达（也就少了一个小时）。（UPD：两年后知道了第三种方法是又快又便宜的机场巴士，秒杀前面两种。）我去人工窗口买票，打开乗換案内指给 staff 看，等到付完款才发现买了 skyliner，可把我心疼了一番。。。&emsp;&emsp;好好赏一下景吧，田野配上天空还是很开阔的。路过江户川区的河（p3），2018 年的时候就在河畔的筱崎公园看花火大会。 skyliner 从成田空港到日暮里 路过哲♂学圣地 &emsp;&emsp;酒店靠近新宿站是为了方便去武藏野。&emsp;&emsp;按照惯例，落地第一餐要去找拉面吃，而且不能是大牌连锁店的。歌舞伎町这一片区想找个廉价的不是大连锁店的拉面档还真不容易，好几家还要排长队。最终找到了这家博多豚骨拉面，味道和分量超级棒，价钱与广州的博多一幸舍差不多。 小小的拉面店 楼上就是风俗店 原宿&emsp;&emsp;原宿的巡礼事实上从抵达东京当晚就开始了。本来只是打算吃完拉面之后出来逛逛街，找一下 AtCoder 总部， 圣地巡礼 AtCoder 总部（大雾） &emsp;&emsp;没想到扭头一看，路牌是熟悉的名字： 西↑部↓呀↑卡↓农！ &emsp;&emsp;走到这我可不困了啊！&emsp;&emsp;而且这栋尖尖的楼也很熟悉，还记得 Liella 最早几期生放有一期是虚拟逛原宿的吗？堇的出生地点就是这个楼！&emsp;&emsp;新宿原宿相当近，新宿南边就是原宿，歌舞伎町到原宿站也就 3km，走路快的半个小时就走到了。&emsp;&emsp;于是第一晚去把需要夜景的干掉，第二天 live 前把日景的干掉，日景没干完的 AZUNA day1 下午来补！（以下大致按地点顺序来记） 宣传画，梦开始的地方（表参道） 一期一话标题位置（表参道） 5555~太↑好↓听↑了↓8（表参道） 你好谢谢小笼包再见（表参道） 可香天桥，这是可香手拉手看日出的地方（表参道） 可可家（表参道） 堇家（穏田神社） 原宿 Gamers，有好多签名和留言（表参道南边小巷） 香音家（竹下通）、她家门前附近优美的小径、小径尽头的名场景 竹下通入口 堇吃的可丽饼好小一个煎饼果子（竹下通），这里也是《未来予報ハレルヤ》香音独唱的地方 《未来は風のように》开头的个人画面，恋的第二镜头已经被拆了 &emsp;&emsp;《未来は風のように》的画面事实上是 AZUNA day1 才补的。一开始并没有收集这个，但是在台场把《未来ハーモニー》收集了之后，就想别的团也得收集一首歌玩玩，水已经没机会了因为离开沼津了，于是专门又从台场跑来原宿一趟。这玩意还挺难收集，场景分布在表参道南北的小巷里，舞台めぐり有大部分，少一个堇的和一个恋的。堇少的叫 Garland，恋少的已经被拆掉了。。。并且补拍是在周六下午，人巨多，与第一个周日（1 月 29 日）早上完全不一样，像可可第二个镜头，蹲了差不多 5min 才蹲到它腾出空位来；像小千第二个镜头，小千坐的那桌子就有人在那吃饭，我就没办法拍到 pv 里那个角度了。。。 小星星，p3 大概是堇绊倒电线的地方（代々木公園侧边） 一期堇跑步以及二期 chance day chance way（神宫外苑银杏道）。最后一幅图最具代表性的场景果然还是唐诱第二集堇骂可可（粤配：咁多人死点解唔见你去死啊！） &emsp;&emsp;这里也放些吃的图。下面第一张是东横 INN 酒店的自助早餐，第二三张是歌舞伎町随便找的一家小餐厅，因为想着东京吃海鲜肯定不如沼津好，所以在东京就不点鱼生了，就点焼き鳥吧。 Liella 3rd 东京场 Day2&emsp;&emsp;入坑 6 年半以来第一场现地 live！！！第一场现地给到以动画为主题的数字 live，而且是我还挺喜欢的 Liella，从这点来说很值。&emsp;&emsp;不值的是什么呢，因为买的是一般发售票，所以位置极差，山顶洞人，4 楼第 5 排（x &emsp;&emsp;一怒之下决定不买棒子，用 fes+跨年凑合凑合过去，反正我在 4 楼没人看见我。到时候等三期生进来了再去补色。&emsp;&emsp;我右手边的老哥后半程一直在用望远镜观察。我没想到“上山要用望远镜”的传闻竟然是真的，更没想到我居然成了明知故犯。。。&emsp;&emsp;还有一点遗憾的就是这场 live 是最后一场不能出声的 live，非常可惜。（实际上大家也就是 call 不喊，mc 笑得可大声了。） &emsp;&emsp;live 的内容在巡演第一站宫城的线上直播已经看过了，这次自然也是大同小异，整体按动画二期的节奏走，插入一些一期的歌曲改编成 9 人版，中途两首 vn。有哪些亮点也心里有数，因此更加期待 live 上能亲眼见到，也清楚什么时候该关注什么地方。 &emsp;&emsp;灯灭，星战歌起，全体起立，切色欢迎成员。正式的感觉一下就上来了，只要台上有人台下就必须站着。上一次站着打 call 的 live 已经是水 5th 了，现在民间组织观影讲究舒适享受，全程坐着，影院皮椅，舒服但总归是少些感觉。&emsp;&emsp;再次灯灭，《We Will》亮起响起，9 人阵显现。此刻，如同修行一生的僧人一步一磕头地朝觐终于到达圣地，手脚颤抖，心中涌出一股激流，热泪盈眶。两年来一直在荧幕上关注的可爱的小百合、nako、non，帅气的青山、yabu、熊，搞怪的 pay、彩妹，羡慕不已的粉丝头子鲤鱼，现在就在眼前！！&emsp;&emsp;我见到偶像真人了！！！&emsp;&emsp;我终于见到她们活着现场表演了！！！&emsp;&emsp;LoveLive 不是一场梦！！！&emsp;&emsp;但是！！&emsp;&emsp;但是！！&emsp;&emsp;为什么她们这么小啊！！！！！！！！！！ &emsp;&emsp;大概从中心舞台后面开始，无论位置高低，只能看到主舞台的身子，不能看到脸，要看脸只能看屏幕。但是她们灿烂的笑容和丰富的表情变化本身就是 live 的重要部分啊！因此只能像一个单核处理器执行多进程任务一样，时间片轮转，一会儿看人，一会儿看屏幕，还要时不时看下 arena 的老哥以跟 call。&emsp;&emsp;但是这样观看会产生割裂感——会感觉所有的内容都从屏幕里来，台上只是找了 9 个替身来模仿伴舞。甚至 mc 的时候，因为只能看见身体动作，会感觉这些话不是从她们口中说出来的。&emsp;&emsp;因此全程看表演的同时也在努力克服这个割裂感，让自己相信台上和屏幕上的实际上是一回事。&emsp;&emsp;其实后面她们跑到中心舞台来会好一点，离我们近了一些，能更清楚看到合鲤身高差，但是看清脸和表情还是有难度。&emsp;&emsp;像 vn 这样的，就必须盯着屏幕看。妆容美丽，眼睛下面画两个可爱的图案，表情变化丰富，笑容极其甜美，相较而言舞蹈动作是次要的了，她最打动人的还是表情。 &emsp;&emsp;不过相比只能看屏幕的线上直播，时刻拥有 9 人全局视角还是有很多优势的。首先是需要关注队形的歌曲，比如ビタミンSUMMER、chance day chance way，这两首歌好看的是队形、变化以及整齐的多人动作；比如决赛歌，结尾摆星星造型，这个也要从高处看才好看；比如第一话插入歌最后きなこ出来见前辈、ed 喂草莓，这是有顺序的一个接一个的动作，全局视角更适合看这种有顺序的动作。其次是可以见识传说中的“LoveLive 的优势——二次元与三次元的同步”，动画曲第一段主屏幕都播动画 live 画面，就可以对比（然而同步程度也就那样）。然后是导播以外的视角以及导播没播的小动作，比如鲤鱼和 nako 对着摄像机扔纸银杏叶；比如 vn 的歌有舞台边框灯光效果非常好看；比如 ed 喂草莓可以看到不是所有人站成一条直线的，后面的人是迫不及待围到前面去的；比如 pay 宝冲过去递纸巾然后回来被 nako 摸头；比如最终 mc 可以看 non 酱在鲤鱼讲话的时候总去前面拿纸巾回来转过去抹眼泪。 &emsp;&emsp;全场最傻逼的体验是花车。花车在两侧行进的时候，我们这边的花车居然是完全被挡住的，4 楼第一排还能向前走一走挥挥手，中高处只能看对面的花车。想象一下，你对花车过街充满期待，这是你最接近偶像的时刻，结果花车运行到你下方，而你却看不见它，你只能看到对面的车，车上的人背对着你，在跟对面的人打招呼，这是多么傻逼。因此花车也成了伤我最深的环节，怀着憧憬，成为路人，本来是深入群众的交流环节，现在告诉我这跟我山顶洞人没关系，关系还是疏远了（x&emsp;&emsp;顺便一提，出发前在香港转播群认识了一个与我行程几乎相同的老哥，他是两日参战，两天都是神席，两天都靠近后花车道，车上的人自然平视之处。他说，除了鲤鱼一直在车上发呆，其他 8 个人都跟他打过招呼了。。。（arena 的观众要永远铭记，你们其中有一张票是我贡献的，要不是我忘记付款qaq） &emsp;&emsp;call 非常整齐，这就是霓虹专业的粉丝团队。从 4 楼望下去，arena 是整齐划一，而且很有力道。虽然他们的 call 也不一定合乎规律，不少适合里打的地方全用前挥、快挥代替了，全程没有里打，不过很有默契地一同打出前挥快挥，也是很漂亮的。有时候我按自己的节奏打，发现跟他们不一样，我也会为了整齐去跟他们的 call。&emsp;&emsp;而且他们变色非常及时，花车来了会变成相应的成员色。可堇 liella 之歌的时候，总是可以看到 arena 从正中间分成两半，一边蓝色一边绿色，可堇在后方换花车以后，気づいたら蓝方和绿方已经完成交换了。多人花车的时候，车上的成员色总是会在那一片区成为主要颜色。不过这些都是越往楼上就会越摆，到四楼顶端基本都不 care 了。&emsp;&emsp;我前面一个老哥总是欲风火轮又止&emsp;&emsp;全场唯一的两只十棒孔雀在 arena 那个神席老哥前面，后来被举报出警了。 &emsp;&emsp;歌唱水平，还是老样子，小百合和几位二期生还是不稳，其他人比较稳，结那水平高。现场听声音的效果跟线上听的效果是一样的。&emsp;&emsp;遗憾最终还是没能还原 chance day chance way 的衣服。 &emsp;&emsp;第一次现地，也这样带着激动和些许遗憾结束了。&emsp;&emsp;第一次参加 live 活动是水 5th 上映会，那时还是懵懵懂懂，如今 3 年半了。那时我总结说，我的厨力路径是“补 live -&gt; 云 live -&gt; 上映会（当前阶段）-&gt; lv -&gt; 现地”，现在应该变成“补 live -&gt; 云 live -&gt; 上映会 -&gt; 民间组织观影 -&gt; 现地烂席（当前阶段）-&gt; 现地神席”。回头看这也是逐步在实现梦想了，而且是有付出努力的，出题赚钱、高薪 PhD 实现了经济自由；啃完两本标日初阶初步实现了交流通畅；高的个人出行能力使我在没有支持和陪同的情况下一样能计划行程。&emsp;&emsp;下周 AZUNA，争取一步到位，厨力登顶！ 沼津Day1：初见沼津&emsp;&emsp;周一到周四，四天三夜的沼津之行，意外地与神席老哥（id 叫泡芙）行程一致，于是就一起了。&emsp;&emsp;去沼津的方法也有两种，一个是便宜的东海道线慢慢悠悠晃过去，另一个是贵大概 3 倍的新干线飞过去（当然都是要到三岛转东海道本线）。泡芙是铁路迷，难得有机会坐新干线他不想错过，我就想也行吧，贵但是快，还能看看海（flag×1）。于是一起买了新干线。&emsp;&emsp;猜猜发生了什么？ &emsp;&emsp;坐上几乎啥站都不停的のぞみ号快车直奔名古屋去了！&emsp;&emsp;新干线列车共有三种：のぞみ、ひかり、こだま，其中后两者都会经停三岛，只有第一个不停。我们买的是自由席票，没有车次和座位，又被泡芙的朋友忽悠了“东京出发没有不停三岛的车”，于是错上了のぞみ，飞向名古屋。。。&emsp;&emsp;善良的乘务员直接打印了一张车次单子给我们，教我们去到名古屋坐哪班车往回走。所幸名古屋往回倒不需要出站，因此不需要支付 1w+ 的巨额车票。我们早上 10 点出发，到沼津已经下午 4 点了。。。&emsp;&emsp;欢迎乘坐新开发的游车河路线：东京 -&gt; 沼津（经停名古屋），现在没有人比我们更懂去沼津了。&emsp;&emsp;不仅如此，新干线还几乎看不到海景！&emsp;&emsp;仔细观察地图可以发现，沿着海走的有两条铁轨，外侧的是东海道线，内侧的是新干线，这直接导致，新干线每次看到海不超过 3 秒，就会钻进山洞里，或者外景被土坡、植被、建筑挡住。。。 新干线的海景不超过 3s &emsp;&emsp;信念坚定，回程必须坐东海道线，又便宜又有海景，也就慢个一小时，咱又不是急急国王。&emsp;&emsp;不幸中的万幸是，沿途的日式村落和小镇也还是好看的，给人一种很安逸的感觉，也还是值得游车河的。（顾着享受忘记拍照了x） 到达沼津！ &emsp;&emsp;到达沼津 check in 完已是四五点的样子了。日本天黑特别快，四五点就是“夕阳无限好”了，六点以前会完全黑下来。本来打算第一天下午把善子逃跑路线（全程 4km）走一遍然后吃沼津バーガー的，看要天黑了就放弃了。决定第一天晚上去 gamers 买集章本（这是沼津店铺集章企划），第二天去内浦和淡岛，第三天市区，第四天走人。&emsp;&emsp;住进沼津河畔酒店（River Side Hotel），善子家隔壁，出来就是狩野川。三晚才 877 hkd，是个人都会推荐住这家。 来看看美丽的狩野川吧，以及河对面的香贯山，夕阳时整座山会变成红色。 河畔酒店，二楼还有善子获得荣誉市民称号的展厅。我住的这间房窗户向西，能望到沼津海岸线和富士山。 沼津 Gamers 当晚与泡芙吃烤肉 &emsp;&emsp;那天前后刚好有发售《Find Our 沼津》，但看了电子版扫图发现全是熟悉的图，就是每一期 LLDays 的这一版块拼起来而已，遂决定不买。 Day2：淡岛+内浦&emsp;&emsp;河畔酒店的早餐，挺和式的，有沼津特色鱼干。可以看到我挺喜欢鸡蛋的，玉子烧、温泉蛋、炒蛋我全都拿了。最令我眼前一亮的是抹茶布丁，尝到抹茶布丁的这一刻，我决定お土産就买它了。 河畔酒店早餐 &emsp;&emsp;早上赶第一班痛巴前往内浦。这里的巴士居然可以用 Suica，方便极了。 痛巴，到了重要站点会由水成员来播报，我们这辆车是鞠莉播报。 码头售票处，由此前往淡岛 痛船以及签名 到达淡岛！ 淡岛的海。远处的雪山还是很多的，可惜富士山被云封了 果南家，カエル館 鞠莉家，淡岛酒店，可惜不住里面连花园都不让进 隧道 淡岛神社，最后一幅图是台阶上不知谁放了个みかん 優しい世界 （登山路上共 4 张牌，第一张没拍，写的是“がんばって”。） 应该是てくてくAqours里三年级玩过的动物馆 一个在 sif 里经常出现的场景 环岛一周还是很漂亮的，只是富士山没救了 小商店 淡岛唯一能吃饭的一家咖啡馆 &emsp;&emsp;岛很小，环绕一周大概也就十来分钟。&emsp;&emsp;非常可惜的是富士山今天不给面子，不肯露脸，上面照片里高耸而被云封着的就是富士山。 &emsp;&emsp;从淡岛出来之后，就是内浦了！ 松月，可惜没开门 梨子家 梨子信仰之跃！ 千歌家，安田屋旅馆 安田屋对开的海滩，水水宣传画，梦开始的地方 水水人特有的见到沙滩就要写字 算上我们这沙滩上总共写了三个Aqours（x 伊豆三津海洋乐园。可惜没进去，里面名场景很多，逢田鱼雷、腔棘鱼、曜白学水母屏…… 一单二单都出现的隧道 长浜站，也是《Find Our 沼津》里的场景了。 内浦路上到处可见蜜柑林 到学校了！以及学校底下的长堤，长堤对面的巴士站忘记拍了 浦之星女学院！这个长井崎学校不是说真的废校了吗？结果我们来拍的时候一堆学生放学出来打棒球，我们根本不方便拍。。。 内浦还是很漂亮的 &emsp;&emsp;从学校出来就已经是下午 4 点多了，一天时间悠闲地逛淡岛+内浦还是刚刚好的，再走快一点可能能把伊豆三津海洋乐园也走一遍。&emsp;&emsp;要留意开往市区的末班车大概是 6 点钟左右，错过这班车就要步行 12km 回市区了。 &emsp;&emsp;决定当晚必须大吃一顿海鲜。来日本第四天了，一顿海鲜都没吃！在东京忍了这么久，不就是为了今天吗？&emsp;&emsp;泡芙的朋友推荐了这家餐厅，说是沼津鱼市场直接拿货来杀的，非常好吃。这家店在车站旁边的商城就有分店，它店面也确实是这么写的。 &emsp;&emsp;3300jpy 包括一盘骏河湾刺身拼盘加一碗螃蟹味噌汤，再 2880jpy 一盘寿司拼盘。&emsp;&emsp;无敌新鲜！无敌好吃！&emsp;&emsp;强烈推荐！！&emsp;&emsp;新鲜到什么程度呢？刺身拼盘左上角有一个鱼头，端上来的时候，鱼头还在跳。&emsp;&emsp;肉非常鲜甜有弹性。鱼头旁边带鱼皮的小肉条是鱼肉里最脆的，右下角白色的花枝黏黏糯糯（不清楚是花枝还是鱿鱼，泡芙说我对于质感的描述更像花枝，这是比鱿鱼更高级的），红色的鱼肉有甜味。味噌汤把螃蟹煮得软烂，喝下去有螃蟹的鲜甜味。&emsp;&emsp;是真的点多了，单人的话，其实 3300 买一盘刺身拼盘加这一大碗汤就够炫的了，那盘寿司没有必要。两个人这样点可能差不多。可惜泡芙不吃鱼生，他只能点てんぷら丼，但是 1700jpy 的丼里面有 12 块てんぷら你敢信！ Day3：市区&emsp;&emsp;市区可以以善子逃跑路线来组织，全长 4-5 km，约 1-2h，从善子家开始，到水门结束，涵盖大部分市区内动画场景了。下面就按这条路线来记录场景。（尽管我们不是这么走的，我们第一天已经去了 gamers，然后这天又在车站集合，逛了商店街，再开始善子路线，最后从港口回来才去ラクーン，就很蠢，别学我们。）&emsp;&emsp;泡芙本来打算拍 vlog 的，嫌太麻烦了，改用谷歌地图录屏（笑死）。 善子逃跑路线 善子家，跟河畔酒店是紧挨着的 沼津街头，挂满 sif 日服七周年 UR 的旗 然后收到了 sif 关服的消息。感受一下什么叫痛城，别人痛衣痛包痛车，我们痛一座城，沼津已经完全是水水的形状了（x 上土商店街，てくてくAqours 一年级在这买饼吃 ラクーン大楼，楼顶是唱《Brightest Melody》的地方 沼津站，p1 p2 是南口，p3 p4 是北口，p5 是北口找到的一个拍富士山的角度。注意南口和北口不能穿车站过（否则要买票入闸出闸），要绕一段路从铁轨下面穿过去的。 仲見世商店街。好多店铺关了，花丸书店也关了。商店街里有大部分《僕らの走ってきた道は…》的舞蹈场景，p3 就是一个，认得这个香香坊。商店街里还有一家叫香香饭店，也是卖中华料理的，中华料理在这边还挺好卖的。（注意这都是魔改过的中国菜，只能说名字叫中华料理，跟中华可能没啥关系了x） 僕走道里出现过的つじ写真馆 一路上有好多角度能拍富士山 沼津バーガー！本来计划第一天到沼津就吃的店，拖到今天。点了てくてくAqours同款深海鱼堡（来沼津当然吃深海鱼啦），店里还有卖堕天使の涙，其实就是炸鱿鱼，肉还挺弹的，不怎么辣其实，我广东人都能轻易承受的辣。 新鲜馆，里面是吃饭的小店和卖お土産的地方，上过水水广播剧。这里是新鲜馆内的一家小店，老板是丸推。 沼津鱼市场 水门，富士山依然不给面子。 水门里有介绍沼津渔业，也提到了沼津优越的地理条件使其成为干物（鱼干之类的）名产地。专业晒咸鱼的广东沿海人笑出了声。 &emsp;&emsp;善子路线早上逛和下午逛各有优势，早上逛完在午饭时间到达沼津港一带，吃的特别多，很多店铺晚上不开的；下午逛完到达水门正好是黄昏，可以复刻动画里的场景。 &emsp;&emsp;我们午饭在沼津バーガー解决，吃完后上水门发现这里是观富士山的好地方，于是就在等那片云离开，还等了挺久的，结果那云不但没走还越积越多。。。本来打算下午这么有空可以去爬香贯山和走走千本浜公园（两个都是沼津景胜，非动画相关，但是也是《Find Our 沼津》常见的取景地），但由于在水门等太久了，遂放弃，决定去曜家，有时间再找找剧场版里的新学校和四单开头花丸所在的房子（后来这俩都没去，回车站找ラクーン了）。 &emsp;&emsp;（UPD：四单花丸的房子就在水门附近的芹泽文学馆。。。wtf 我居然这都没去） 去曜家路上的景，以及曜家边上的狩野川堤 曜家，欧兰陀馆 &emsp;&emsp;第一眼以为 p6 窗边手办我居然两个都有同款！仔细想想才发现右边那个我的动作和它还是不同的，我的那个是用手扶着帽子的，但衣服是同一套。&emsp;&emsp;服务员老婆婆非常热情，不仅跟街坊邻居谈笑风生，也对我们热情款待，临走付款的时候还问我们从哪里来。&emsp;&emsp;事实上我学了这么多日语一直在找机会跟日本人交流一下，用上一点高级的句式和词汇。但奈何餐厅或商店的服务员都太忙，搭不上话的；酒店入住又含有太多重要信息必须用英文。这个老婆婆就是一个最好的机会，又热情，又不算很忙，还能借着曜家这个场所聊点死宅话题。然而，我回答了“僕らは中国からです。ラブライブサンシャインのファンです。”之后，我还在想接下来搭些什么话，她已经笑着进入结账环节了。。。&emsp;&emsp;于是这个绝佳的聊天机会就错过了。。。&emsp;&emsp;后面走回去的路上我才把语言组织好，我明明可以跟她感叹一下满屋子的曜谷的。。。 &emsp;&emsp;晚上选择的餐厅是水水广播剧里推荐的鱼河岸丸天（上面的新鲜馆也是来自这个广播剧）。 鱼河岸丸天 &emsp;&emsp;因为在曜家吃了下午茶了，在这里就点少些，点了个分量少些的刺身拼盘，螃蟹味噌汤，以及泡芙点一盘煮金目鲷。&emsp;&emsp;结论：建议下架该广播剧。&emsp;&emsp;果然是“海鲜卖不出去，水水帮帮我们”是吧，这跟昨天的魚がし鮨完全不是一个档次的啊！&emsp;&emsp;首先是螃蟹汤，喝进去一股苦味，完全没有螃蟹的味道，跟昨天的汤是天差地别。咬一下螃蟹壳就知道了，昨天那个是煲到蟹壳都软掉的，所以才入味，今天这个螃蟹还很硬。&emsp;&emsp;然后是没拍照的煮金目鲷，点完之后只过了一会儿就端上来了，显然是提前煮好放着等人来再热一下的。至于肉质，老，柴，硬。&emsp;&emsp;刺身端上来那个鱼头不跳的，那它就只是个装饰，不能说明食材有多新鲜了。肉质倒是还行，仅仅稍劣于昨天，红色的肉也还是够甜，但其他大部分较昨天更软更糯，换句话说昨天的更加紧实有弹性。螺肉片倒是不错，很脆很爽口，昨天没有螺肉片。&emsp;&emsp;总之这家店不会作为我们的推荐了。要问在沼津吃海鲜去哪里，我们目前的回答仍然是魚がし鮨。 &emsp;&emsp;晚上回去在罗森买到了花丸爱吃的のっぽパン。里面是有奶酪夹心的，还不错。 Episode 江之岛！&emsp;&emsp;为什么突然插入了一个江之岛的行程呢？是因为泡芙想去巡礼孤独摇滚。&emsp;&emsp;但其实我是还没看孤独摇滚的，没法巡礼。但是我正好看过这个：小百合一个人的旅行。日本人都心心念念的地方，那应当是好地方了吧。于是就跟他一起去了。早上江之岛，下午回东京台场。 终于最后一天早上在沼津河畔酒店拍到了漂亮的富士山。。。 坐东海道线前往江之岛，终于有海景了。。。 路过国府津站，底下的海就是 μ's 宣布解散并且哭的地方 藤泽换乘江之岛电车，果真如小百合说的那般在城市里穿行 过桥上江之岛！ 江之岛名物，たこせんべい，吃起来感觉没有章鱼味 江之岛的神社 岛外面一家挺好吃的餐厅，实物完全如图 &emsp;&emsp;江之岛就只是简单地玩了一下，逛完神社就走了，因为下午泡芙还要去镰仓。我就一个人先去台场了，之后基本上就分别了。非常有幸认识这位朋友，香港 LLer，奇妙地跟我行程重叠了一大段。 片濑江ノ島站 回程路过一个很臭的地方（x 台场&emsp;&emsp;我是以为 JR 东日本、JR 东海以及杂七杂八的铁路线这些已经够复杂的了，没想到东京地铁更加庞大更加离谱。。。&emsp;&emsp;2018 年第一次来东京的时候买了地铁 72h 任乘券，感觉是因此避开了许多麻烦。。。这次刷的 Suica，就碰到麻烦了。&emsp;&emsp;乗換案内让我在银座下车换到银座一丁目，去坐有楽町線。我从银座下来，懵逼地发现根本没有通往银座一丁目的路，只能出闸。我就很慌，乗換案内不会出错了吧？&emsp;&emsp;盯着 app 上写的“地上换乘”，我猜测可能就是要出闸再入闸换乘的。但是不敢肯定啊，万一真的是要收两趟车钱怎么办？于是打开地铁图开始寻找下一个换乘点。&emsp;&emsp;几乎绕了皇居大半圈。。。&emsp;&emsp;到达下一个换乘点发现仍然需要出站，再下一个换乘点就真绕皇居一圈了。于是谷歌搜“地上换乘”是什么意思，还真就搜到说，出闸后一小时内入下一个闸，算作换乘，票价按全程来算。。。&emsp;&emsp;于是气冲冲又绕皇居大半圈回到银座，出闸，在路上走到银座一丁目，入闸，前往丰州。。。&emsp;&emsp;三点钟到的新宿，四点半才到丰州。。。&emsp;&emsp;我满脑子都是“边条粉肠设计的日本交通系统！！！” &emsp;&emsp;酒店还是订远了，距离 AZUNA 会场（東京ガーデンシアター）2.2km，距离台场更是 3km 多。不过酒店就在步梦家附近，晚上不知道有没有幽灵进来夹脚（x&emsp;&emsp;第一晚只来到了虹咲学校（东京国际展示场）。 虹咲学园 &emsp;&emsp;在里面找古战场（上原步梦在楼下）、动画二期一话岚珠抱步梦、Eutopia 等名场面，古战场找不到，后面的找到了一些，一看已经天黑了，拍照光线也不好，晚上还有 sif2 生放，于是匆忙找地方吃饭，溜回酒店。 &emsp;&emsp;第二天逛一整天台场，可惜白天是个大阴天。。。以下有些照片是第三天第四天补的。 首先依然是虹咲学园。台场离羽田空港非常近，所以这里的飞机都很低很大，称之为“虹咲国际机场”是有道理的。 p1-p4 都是动画二期一话岚珠抱步梦的场景，p5 是 Eutopia，p6 二楼那个厕所大概就是虹咲学园偶像同好会的活动室了吧 找不到古战场，这个已经是最像的了 临海线国际展示场站，现在是虹咲学园前站，这个牌子对着的就是二期五话步梦捉奸的地方 台场 Gamers，自行车选手从这里爱上雪菜（大雾）。这个 Gamers 好怪，里面的签名和留言全都不允许拍照。 东京湾彩虹大桥，追求天气所以是第三天补拍的。p3 还有另一个身份，就是 op1 开头爷洗脚的画面。 自由女神像 艾玛合照的石像 二期十话（或者十一话）三年级提出开 1st 的想法的地方 爱姐名场面，也在侑散步里出现过的 AQOUA CITY 与富士电视台。因为这天是阴天，就没上那个球去看蓝蓝的天大大的海，毕竟要 700jpy 的门票。后面两天晴天也没时间上去了。 米娅汉堡店，KUA AINA！汉堡真的超大个，我反正得拆开吃。。。然后表扬它这个薯条，非常脆，冷了都还脆。 たこ焼き街，动画一期艾玛与果林放学后来的地方，たこ焼き好吃的 &emsp;&emsp;（UPD：仍然清晰地记得我赞美这个たこ焼き“きれいだね”之后，店员一脸尬笑。回去学了标日初级 47 课尊他语，才发现我这话说得是多么傲慢无礼。。。不知道是不是这个原因） 岚珠家，希尔顿酒店，p2 是 op2 里岚珠经过的地方（详见侑散步 2） 高达，晚上还挺炫酷的 Chase！以及从台阶上看高达 步侑约会凳 侑散步里提到的黄色大尖柱，实际上是日法友好纪念柱 摩天轮遗址 青海南码头公园。p1 是 op2 栞子洗手机的地方，p2 是侑散步 2 里提到的穿西装的地方，p3 p4 是公园里好看的景，p5 p6 是从码头望向羽田空港，特别近（已经能看到塔台和地上的飞机了）。 《未来ハーモニー》每个成员的第一个单人画面。每人的第二画面以及双人画面都是第一画面换个角度，就不额外拍了。其中要说明的是，果林的画面已经随摩天轮一起拆掉了，她是在一个圆形广场的东半边（谷歌地图街景还能看见），只能以西半边代替一下了；然后霞的站在桥上的画面我显然是不可能拍到的，只能以临海线从桥下走的照片代替一下了。 步梦家 &emsp;&emsp;未来八毛二非常难找，手上只有几个没标地点的 b 站视频，和一个因为没有微博账号所以打不开的微博台场圣巡指南，只知道这些场景应该都局限于台场范围，整套东西找起来就像定向越野一样。也正是这首歌的寻找，激起了我收集其他歌曲的愿望，星的未来如风，水的僕走道，但是水已经没有机会了。。。&emsp;&emsp;第二天已经基本把该逛的都逛完了。第三天第四天就是 live 日了。每天早起排场贩，经人提醒才发现排场贩的地方就是动画二期开 1st live 的地方。 我们都是场贩人 &emsp;&emsp;台场就是美食荒漠了，基本上都吃的萨莉亚和すき家。萨莉亚只能说，在世界范围内都是 yyds。 p1 是摇曳露营的志摩凛同款泡面，p2 是 2 月 3 号节分日去便利店买的惠方卷，p3 是すき家的定食。 AZUNA 1st Day1 那一天，我变成了光。 &emsp;&emsp;这大概就是今天最深刻的感受了。&emsp;&emsp;回想第一次产生强烈的参加 live 的欲望，是水 5th 看到了安可彩虹，他们都化身成了光。从那一刻起，我想要成为光路的一员，去创造 live 中的重要景色，在企划中留下足迹，组成“みんなで叶える物語”。&emsp;&emsp;今天我做到了。幕间剧安排了官方光路企划，将观众分为三个颜色区，我在步梦色区二楼的边缘。我也是三色光路的创造者、贡献者了。&emsp;&emsp;今天也是疫情以来第一场出声 live。不仅我的颜色参与了 live 的创作，我的声音、我的动作，全部变成了 live 的一部分。&emsp;&emsp;如果说上周的星场因为位置太偏，感受还只是一个小看客身份，那么这场，获得的新感受就是参与感。 p4 是来自中国某粉丝团体的花篮，萤火虫 staff 桑楠木酸菜鱼在上面 &emsp;&emsp;这是我的第二场现地。相比 Liella 3rd 东京，首先是席位进步了，在 2 楼第三排，舞台近了很多，台上的终于是正常人而不是蚁人了，真正能感受到她们就在前面，尽管看表情还是有难度（也有眼镜的因素，最新配的眼镜还没到）；其次是出声 live，憋了三年的人们终于迎来了爆发，能喊出来整个人的感受是高一个档次的。&emsp;&emsp;其实经过上一场就已经能明白，事实上一场 live 的好席位是非常有限的，差不多就是围着舞台的几圈以及花车位是好位，称为神席是真不为过，其他都是“見えにくい席”。曾经我一心想要去大场，想着只有巨蛋这种级别才能产生最好的氛围，现在注意到场子越大越是难以抽到好席这一事实，反而喜欢上小场 live 了。 &emsp;&emsp;事实上这场 live 我是冲着楠木灯来的，AZUNA 的歌并不对我的风格所以之前不怎么听。AZUNA 一单、煮饭歌感觉过于儿歌，猫歌过于可爱不宜多听，动画二期插入歌风格太乱，唯一觉得很厉害的就是 maze town(妹子汤)，新出的四单只是听过一遍，感受还不深。这直接导致，live 上好多 AZUNA 的歌如同听新歌，call 根本不会，手忙脚乱，跟着 arena 和旁边的猪仔包学长依葫芦画瓢。&emsp;&emsp;这里就不得不说，近一两年 LL 出的歌就只有虹的 call 最激烈，很有老缪的风格，mix 和做特殊动作都很多。水和星都很安静，观众主要是听歌看表演，call 的动作都是普通动作，出声解禁对于虹的作用大于对水和星的作用。我不仅对 AZUNA 的 call 不熟，对虹团歌和其他 solo 其实也不算熟练，一专悸动跑路人和三专夹死比利算是简单的，但也有一些 mix 没喊出来；二专最可怕的就是副歌的动作，转几圈棒子打开然后 yes，我只在线上看到过这套动作，等到唱到这里的时候我才突然意识到要实战了，也是手忙脚乱，疯狂打到两边的棒子（x&emsp;&emsp;正好喉咙康复还没完全，开头几首歌扯俩嗓子差点没把我咳死，就以这个为借口跳过了不熟悉的 mix（ &emsp;&emsp;所以相比之下，solo 部分就是我最享受的部分了。&emsp;&emsp;静子的四专武士曲，也是 call 十分激烈的一首歌，一边看前田手刃一边要跟着如同武士一般吼着。&emsp;&emsp;雪菜的 chase，红色火焰的绝唱，是整场 live 最核心的一首。全体观众化身火海，如同喷涌而出的岩浆赤焰，吞噬了一个又一个侑酱。上举强而有力，里打是窜动的焰尖，里跳呐喊震耳欲聋。灯的最后的 chase 了，没有楠木蹬，但是气势依旧足，穿上这身衣服她就是心中充满热爱与激情的优木雪菜。最后的高音没有冲到位，灯的表情是尽力后满足的笑容。&emsp;&emsp;步梦的韩风四专，飒爽帅气。如果兔把音准唱到位，会更帅。&emsp;&emsp;接着还有三首动画曲，属静子这首最好，主要是故事情节、歌词内容和装束，与另一个我的对话。 &emsp;&emsp;小组四单的伴舞很好看，有点比下面的偶像还好。（日常思考：下面的偶像你们的唱功配得上这个伴舞吗？）&emsp;&emsp;三个人穿的白丝 prpr&emsp;&emsp;day1 日常烂麦，音量调了几首歌都没调对，收音也是出问题。&emsp;&emsp;我们期望的 AZUNA 版的缭乱并没有出现。。。&emsp;&emsp;时长只有 2h 多一点点，收了比 3h live 还贵的票价，定价的可能不是人。 &emsp;&emsp;day1 结束没有悲伤的气氛，大家都是喜笑颜开、兴高采烈的，包括结尾 mc。没有过早地哭出来太好了，但是这也衬托着 day2 的危险，不知道明天结束会不会全体崩溃决堤。 AZUNA 1st Day2&emsp;&emsp;座位相比昨天更上一层楼（x &emsp;&emsp;人是坐得远了一点，但好在这场子很小，依旧看到了正常大小的人。 &emsp;&emsp;内容一样的，就直接说说感想吧。&emsp;&emsp;非常有幸今天坐到雪菜色区。众所周知今天最大的意义莫过于是楠木灯最后一场 live，可以在最后一天以雪菜色告别灯，实在是幸福得很。&emsp;&emsp;雪菜的 solo 仍然是 chase，那么今天就是最后一次灯版 chase 了。这首歌仍然是所有里跳喊得最亢奋的，只不过可能少了一点激动和惊喜，因为大家都知道今天有 chase。我们依旧看到的是，心中充满热爱与激情，坚韧不屈的优木雪菜，在操控着红色的火海。最后高音冲上去了，余音绕梁，欢呼雀跃。&emsp;&emsp;chase 我棒子疯狂打到前排的头&emsp;&emsp;今天其实 call 谱没熟悉很多，但是一股老油条感上来了，我就按我的节奏打，上举前挥的切换什么的我行我素了，我不会的 mix 也直接跳过。我左边的老哥看上去也是不怎么会 call 的，大家都是随随便便凑合一下（&emsp;&emsp;但是 AZUNA 的歌确实熟悉了不少。开演前查了 AZUNA 的 song list，至少清楚了哪些歌出自什么专、哪些歌是谁的 cw。感觉四单意外地好听，三个人在海洋里自由自在地玩耍的感觉，旋律不错的。以及几个小组单的 cw，发现我还挺喜欢这几个旋律的，特别是新的四单 cw。以前可能对 AZUNA 还是有些 stereotype 了，总觉得她们是唱儿歌的，现在让我重新认识了 AZUNA，活泼而俏皮的曲风是很棒的。&emsp;&emsp;一个小细节，四单新衣服，灯是平底鞋，其他两人的鞋跟 5 公分起步。有时候这些细节很能体会到世界的温柔。同时也是因为鞋跟的原因，146 看上去并没有这么矮，跟灯灯是几乎持平的。&emsp;&emsp;结尾 mc，也是很真实的感情流露。灯是最害怕因为自己使得气氛变得悲伤无比的，所以反而是不会表现出离别的伤感的，她表达出来的情绪核心是开心与幸福，别人在说悲伤的东西的时候她会去打断，会如同没事人一样“生气”别人渲染氛围。所以你可以看到这趟 mc，灯是笑着的，其他两人却是忍着泪的，最后灯是被两人带哭了。 &emsp;&emsp;楠木灯，年龄只比我小 5 天的人，也是你拉第一个比我小的人。&emsp;&emsp;她笑起来真的很奔放很灿烂。&emsp;&emsp;我们无法想象灯会不会是忍着怎样的痛苦在完成两天的 live 的。如果是的话，她是以怎样强大的信念支撑她完成了这场高强度演出。&emsp;&emsp;这也是雪菜性格的一部分吧，对热爱的东西，会执著不屈。最后能把这点体现出来，是一个很棒的告别了。 &emsp;&emsp;我对虹的参与度高了不少，即便是 AZUNA 这样不算很熟悉的，也现地了两天，然后喜欢上了她们一些歌。&emsp;&emsp;也同样有些许遗憾，难得有 call 很激烈的场，却因为不熟练而玩得不够开。不然如果更加全身心地投入，很自然地把词喊出来，那就会是一次融入更深的体验了。&emsp;&emsp;有幸听到了绝版的 chase，也可以盖过所有的遗憾了。&emsp;&emsp;“补 live -&gt; 云 live -&gt; 上映会 -&gt; 民间组织观影 -&gt; 现地烂席 -&gt; 现地好席（当前阶段）-&gt; 现地神席”，进步了一点点，以后还要继续，要得到所有人的 res 为止。&emsp;&emsp;前途光明未来可期，对大家都是。&emsp;&emsp;菜宝什么时候带队来香港开 live 啊 离开&emsp;&emsp;最后一天就是坐京成线慢慢悠悠地晃过去坐飞机了。飞机沿着海岸线飞，从飞机上眺望一下富士山、东京湾、江之岛吧（看看你们能不能找到了）。 依次是：东京湾+富士山、东京湾、江之岛 End&emsp;&emsp;告诉家人这趟行程我将独自出行之后，家人们都表示十分担心，纷纷劝我放弃。&emsp;&emsp;事实证明，我拥有独自出行日本的能力，他们大可以放心了。 &emsp;&emsp;我也尝试带同学一起来，尝试邀请过同学。最后考虑到，这趟行程实在是太 LL 了，总归还是我一个人好，孤独就孤独一点，至少 blog 是我的分享地，也还有朋友愿意接受我的图片轰炸。&emsp;&emsp;有时候同学们问起我，以及家人问起我，你这趟去日本到底是要玩些什么，我都有点怪不好意思，怎么给他们解释圣地巡礼呢？就是很有名的动画取景地想去探访一下吧。&emsp;&emsp;泡芙也是，他的朋友也笑他，大老远跑来日本就为了拍几个楼梯几面墙。&emsp;&emsp;他们不懂，这就是文化内涵。就好比大老远去安徽黄山，非要找一棵迎客松，明明到处都是松树；就好比佛山古村落里每间屋子都差不多，但我就非要参观某一间屋子，因为它是康有为故居。为什么岳阳楼、滕王阁这样的楼阁，是我唯一宁愿排队也要去的大众景点，就是因为有诗词作品赋予了它们文化内涵，登上去体会的是古仁人的心境。动画作品也一样，它讲了好的故事，它带给你感动，它引起你的思考，你也是到动画中的场景来，重新体会。&emsp;&emsp;再加上咱们看 live，那这趟行程下来我们确实已经无敌了。 &emsp;&emsp;遗憾也还是有的，live 的席位还不够好，没有去爬香贯山（对于 hiking 爱好者来说，近在咫尺一座山不爬，好比中了一百万彩票不去兑奖），也没能与日本人来一次使用高级句式和词汇的交流（反证法证明这样的场景不存在，假设某场景我即将要使用高级句式和词汇，在此之前一定会先因为听不懂对方说的话，而把对话转成英语，从而场景不存在）。&emsp;&emsp;留一点遗憾也是好的，这样就会对未来继续抱有期待，只有对未来有所期待，生活才会变得光明。 &emsp;&emsp;水 7th，虹 6th，星 4th，哪次再见呢？","categories":[{"name":"玩","slug":"玩","permalink":"http://kqp.world/categories/%E7%8E%A9/"}],"tags":[]},{"title":"未来は風のように","slug":"sum2022","date":"2023-01-17T15:39:54.000Z","updated":"2024-04-24T03:59:22.795Z","comments":true,"path":"sum2022/","link":"","permalink":"http://kqp.world/sum2022/","excerpt":"&emsp;&emsp;本来这篇去年就该写的了，上一篇年终总结已经是 2020 的了。2021 也发生了很多事，都是决定人生前途的大事，但是因为过年前忙着搭这个新博客，搞着搞着就把年终总结咕了。。。咕了足足一年。&emsp;&emsp;今年这个就给这两年一起记个流水账。&emsp;&emsp;标题与上一篇年终总结遥相呼应的。放在去年其实最合适不过了，然而现在都已经放第二季的歌了","text":"&emsp;&emsp;本来这篇去年就该写的了，上一篇年终总结已经是 2020 的了。2021 也发生了很多事，都是决定人生前途的大事，但是因为过年前忙着搭这个新博客，搞着搞着就把年终总结咕了。。。咕了足足一年。&emsp;&emsp;今年这个就给这两年一起记个流水账。&emsp;&emsp;标题与上一篇年终总结遥相呼应的。放在去年其实最合适不过了，然而现在都已经放第二季的歌了 &emsp;&emsp;2021 和 2022，是疫情的第二年和第三年。疫情改变了很多很多，2020 年所有人面对很多事情都是慌乱无措，这两年逐渐恢复有序，却也夹杂着不少荒诞滑稽。 竞赛&emsp;&emsp;众所周知，2020 年底的济南赛区，无人之境出线了。&emsp;&emsp;所以从 2021 年开始，我打比赛的心态也改变了。归根结底是少了一份焦虑，毕竟竞赛是很花时间的，放在大三升大四这个升学关键点，仍然一周四训却摸不着实在的东西的话，我会感觉很不踏实，但现在踏实了，终于完成了三年前 symbol 说的“实现你中学时未完成的梦想”、两年前左左说的“把 final 进了再说”，可以开始更长远的规划了。&emsp;&emsp;实际上，这是第一个被疫情拉长的赛季，全国上下都老老实实地，一直保持着一定强度的训练，以不变应万变。也因如此，我们在 4 月的昆明赛区仍有好的状态，进入出线区。&emsp;&emsp;然后就是 EC、毛营、华为营，题目都有难度，只能说表现得勉勉强强。&emsp;&emsp;到了 CCPC Final，因为一个老套路构造题不会做，最终丢了一个题以及浪费了大量时间，不幸打银。这时候才发现，昆明以后，我们确实有些疏于训练了，作业多了起来，我也在忙着搞 HKU 的面试，全然只是靠着两个 camp 维持一下水平。这成为整个赛季我们最差的一次比赛，却成为学校报导最狠的比赛（x&emsp;&emsp;大三就这样结束了，我们也各自有了前途，我有书读了，邓老板去华为实习，zayin 去 google 实习。本以为大家就这样把大四度过去，最后还是为了给学校救场，又续了一年。区域赛有训练，等邓老板和 zayin 都结束实习之后也还有一周四训，但也是打得勉勉强强，甚至还落了个铜。后面做毕设以后更是一点没训练了，仅仅是时不时打一下各大 oj 的比赛，EC 前康复一下，就去了 EC 和 CCPC Final，没想到发挥还不错，意外又捞到一个出线和一个前十。至此，无人之境也成了两年都出线的队伍了。&emsp;&emsp;WF Dhaka 因为疫情没有去成，白给一次。&emsp;&emsp;到此，本科的竞赛生活算是全部结束了，尽管它一直持续到了大四毕业的暑假。但是竞赛仍然还没有结束，还要一直等到 2023 下半年的 WF Egypt 才是真正的句号。算一算，从 2011 年暑假开始学编程，竞赛一共要玩 12 年。这大概是我目前做过最长久的事情了吧。 &emsp;&emsp;12 年，想想小学的时候写出了“输入圆的半径，求圆的面积”，得意洋洋，其实现在也还是的，推出很牛逼的多项式题或者数据结构题还是会得意洋洋。&emsp;&emsp;体验了各种各样的比赛，也遇到了各种各样的人。中学大家都是并肩作战的朋友，但是到了考场上其实都是竞争关系。大学又是另一种体验，真真正正是团队三人一起往前走，同甘共苦的。像无人之境这个团队，风风雨雨两年，试过三个月狂训，群聊从竞赛到功课到人生到各种吹水，时不时就一起出差到处跑，彼此思维互相了解，很难说不是兄弟了。 &emsp;&emsp;大三大四也更多地以出题人的身份参与中学和大学的竞赛了，也不仅仅是出题人，也是组题人和负责人了，从另一个视角来体验竞赛。老实说，出题的心态也是会变的，一开始的时候，觉得出题很好玩，可以分享绝妙的 idea，可以报复社会，但是随着越来越多的出题任务，一次又一次的出锅，被选手喷，热情也会被消磨的，到最后退隐的想法会愈发强烈，尽管越到后面越要负责更多的题目。&emsp;&emsp;组题人视角真的是令人体会颇深，你会发现你绝不能随意听信出题人对于某个题的得分分布设计，绝不能臆想选手水平，绝不能有意或无意地把出题搞成炫技，绝对要严格遵守繁长的验题流程。你更能懂得选手与出题人如何通过题面来交流，更能理解打比赛时出题人的种种失误，更能珍惜一份好题的来之不易。&emsp;&emsp;出题的过程也是类似科研的，都是在一片未知里探索，脑中蹦出一个 idea，谁也不知道可不可行，也是拼命地去想办法解决它、优化它，拼命地修改题目条件以找到这个 idea 的适用场景。 &emsp;&emsp;如今还是会上网打比赛，codeforces，atcoder，挑中国时间场，睡觉优先。WF Dhaka 也跟人一起打了同步赛。当比赛不能成为主业的时候，当业余爱好也是很好的。这也是许多前辈们延续对竞赛热爱的一贯做法。 科研&emsp;&emsp;读研是一早就决定了的，那么 2021 年，稳了 final 之后，自然这事就成了重中之重。&emsp;&emsp;一开始又找了万法师和炜麟学长，想蹭一下文章。于是搞起了 Linear Temporal Logic(LTL)。3 月很积极，每天认真读论文，4 月由于各种事情开始变得咕了，后面就越来越咕了（x &emsp;&emsp;4 月，打破了原来只想在国内读研的想法，开始了解外国学校和老师。恰好华为给我推荐了一个 HKU 数学系老师，我就顺势了解了 HKU CS，得知他们的提前批快要开始了，就想着申一个先练练手，为暑假去各大高校夏令营做准备。当时主要目标还是清叉的。&emsp;&emsp;套了 zhiyi，得到了模板回复。&emsp;&emsp;提前批面试阶段，zhiyi 并没有找我，反而 Hubert 给我发了邮件，粗略地看了看他的 paper list 感觉还行，隐约看到好多 complexity 字样的东西好开心，于是就约了面试。&emsp;&emsp;第一次面试，绝对人生耻辱。纯英文，问啥啥不会，我说我算法好，他说你讲讲网络流吧，我坑坑巴巴讲个 dinic 讲不清楚；他说，你讲讲暴力增广网络流吧，我讲一大通漏了反向弧被他质问半天；他说，你证一下最大流最小割定理吧，我说用对偶来证，然后发现根本不会对偶；他说，你讲讲有了最大流怎样求一个割吧，我口胡了个假做法被他当场揭穿；他说，你做一下这个题吧，我脑子空了完全没有思路（事后才反应过来他问的是最大密度子图）；他说，咱换一个，你说你数论好，你讲讲 RSA 吧，我急忙掏出课件却因为时间太久生疏了讲了一堆错被他质问；他说，你证一下 gcd 的复杂度吧，我证出来了，这成了我全场唯一答上来的问题。&emsp;&emsp;无数次想要直接关掉 Skype 结束痛苦。&emsp;&emsp;善良的 Hubert 给了我三天后第二次面试的机会。这三天绝对是我最愤怒而拼命的时间，我的心态很冰凉，即便最后你可能只是为了善意给我二面但其实一面已经一票否决了，但我还是一定要全力以赴，必须让你知道，竞赛生是绝对不会证不出最大流最小割定理，绝对不会连最大密度子图都不会做的。&emsp;&emsp;二面，给他证了 1h 的最大流最小割定理，又给他讲了 1h 的最大密度子图，他极其抠细节，每一个细节都认真检查。当听到“You proved these things. That’s fine. I’ll give you the offer”，心是终于落下来了。 &emsp;&emsp;后面把流程走完，HKU 基本就稳了。然而这也带来一个很大的弊端，就是经过这一轮面试的折磨，且成功拿到 offer 以后，整个人就变懒了，NJU、IIIS 的夏令营也不想报名了，国外的老师也懒得套瓷、申暑研了。此时对 Hubert 的印象大多还是靠想象以及被他一些文章标题骗了的，以为他的 TCS 血统比大陆高校的老师更加纯正，全然不知道这个人其实没啥很纯的东西，做的东西很杂很偏，complexity 更是想都别想。再加上暑假发生了很悲伤的事，一整个暑假没有动力去套瓷和暑研，基本上也就只剩 HKU 了。&emsp;&emsp;Hubert 其实人很好，5 月给了系 offer 之后他说，给你 4 个月时间申美国，不成功再来 HKU 读，9 月再来找你。9 月他如期来找我，我很惭愧地跟他说其实这 4 个月啥也没干。。。&emsp;&emsp;后面套了 UCSD 也是模板回复，于是也就弃了。至此，大概是确定今后就是 HKU 了。&emsp;&emsp;暑假以及后面的申请季这么晃荡过去实在是有些荒唐，但实际上我又无时无刻不忐忑，我是纯竞赛选手，除了奖牌和一次 WF 资格（还只是资格）以外一无所有，没有 paper，没有在做的成熟的课题，没有学术后台背景和推荐信，这么申外国哪敢啊！ &emsp;&emsp;于此同时，我也粗略地看了 Fine-Grained Complexity(FGC) 的 introduction，立即对这个东西产生了兴趣。当 Hubert 问我以后想做什么的时候，我张口就来，Fine-Grained Complexity。他说好啊，那你就先跟着这个 UCB 的 Simons Institute 学吧。&emsp;&emsp;于是 9 月给炜麟学长最后讨论了一次 LTL 之后，我就专心开始搞 FGC 了。以 Ryan William 的课以及他的大作业 reading list 为起点，为了结合 Hubert 在 cryptography 方面的优势，初步选择了 FGC+cryptography 的道路，恰好就有那么个方向叫 Fine-Grained Cryptography，就是用 fine-grained hardness 去搞密码学。10 月人生第一次完整读完了一篇 STOC paper，也是在这个方向读完的第一篇 paper，搞懂作者在里面用了多点求值和快速插值之后，感到又要回归熟悉的多项式血雨腥风，不忍苦笑了很久。毕设选题毫不犹豫选了 FGC+cryptography，1 月受到论文启发突然想到了搞 Fine-Grained Zero-knowledge Proof，想到这个可高兴了，complexity、cryptography、ZKP 三大愿望同时实现。&emsp;&emsp;只可惜这方向是真的没人带，找 Hubert 讨论，虽然他说很 interesting 但实际上也没能提供什么指导，两次讨论感觉都不是有效讨论，感觉他只能作为一个 check 细节的工具人。于是整个 2-4 月就是我一个人单干，自己啃论文，自己拍脑袋，想了些很 trivial 的东西也假装我提出了很厉害的概念（x&emsp;&emsp;4 月提交了初稿之后其实自己又查出了一个 bug，直接把结论拉低了一个档次。本想着后面好好修修，然后继续加强，争取开学之前搞出点像样的东西来。然而实际上后面也很摸，一边浅浅恢复竞赛水平，一边趁本科最后的时机在玩耍，一边想着除课题外还有很多 TCS 基础要补（比如 complexity 教科书），5-6 月也是晃荡过去了，7-8 月的暑假则是疯狂在出题，也没有搞课题…… &emsp;&emsp;开学了，有了 Hubert 正式的参与，研究也变得正式了很多，开始有正规的 literature research 了，把基础的 ZKP 都学了一遍，也能讨论方向了。这课题大概就是，大方向把握在我手中，小方向由他给建议（总感觉应该反过来才正常）。只不过三个月后，进展仍不顺利，总是有东西无从下手。同时，Hubert 发的一篇 proposal 中了一百万，因此里面的 cooperative game theory 就不得不做下去，于是我和学长和 Hubert 三个人又一起在 12 月份开了这个新题。新题目有老板指挥，每天推式子算期望，有看得见摸得着的进展，相比起我那 Fine-Grained ZKP 的大饼，这个还是更让人心里踏实一点。 &emsp;&emsp;这两年，特别是 2022 年，可以说，最主要的进程就是完成由竞赛生到科研者的转变。比如思维方式的转变，说白了就是许多做竞赛题的套路要放下了，而做科研题的套路要开始学了，举个例子，要证某个东西的 lower bound，就要很快地想到是用反证法，假设我可以做到比这个 lower bound 更优，我能利用它做出一个厉害的算法，违背某些 hardness，那么使用哪些 hardness，比如某个问题的直接求解的 hardness，或是 approximation hardness，或是 average case hardness，而这些 hardness 有没有可靠的论文支持，都要变得熟悉而敏感起来；或者说要设计协议让某个过程大概率按我设想的去执行，那么就要想到用 chernoff bound 或类似物去把概率给 bound 住。还有是学习方式的转变，竞赛某个新知识点通常内容不多，很容易就有整理好的资料（大佬们的博客），在科研里，基本上需要自己去跟进最新的论文以及有持久影响力的老论文，自己做整理，还不能确保它们有用。&emsp;&emsp;很多时候能切实体会到竞赛相比于科研确实是比较短平快的。写博客就是很好的例子，一般一个有难度的竞赛题就是一篇完整的内容，适合单开一篇博客，偶尔再把相似做法的题整理在一起形成套路。但是读论文就不太一样了，往往一篇论文技术细节很多很值得写一篇文章记下来，但是考虑内容完整性它通常又不够，因为它往往只是解决一个问题的一个小部分，总是要好几篇文章加起来才能很清晰地说明一件事情。所以开学以来，博客更新量明显少了，不是不想写，而是碍于完整性我不知从何构建。今后可能也会很咕~&emsp;&emsp;上面说了科研跟竞赛出题是类似的，最大的不同应该就是在于意义的考虑了。出题可以随便附加条件，树上版本、在线版本、参数范围，随意变动。科研的时候，你必须讲得出这个条件的意义，哪怕是理论研究也不能随意添加或修改问题条件。&emsp;&emsp;科研更像是上班，作息时间、工作模式也向上班靠拢了。这里没有我想象的那么肝，学长学姐们都很会玩，有很多娱乐活动，日常摸鱼时间也很多。我问他们会不会担心将来论文不够，他们的回答都是，TCS 急不来的，idea 没来再肝都没用（x &emsp;&emsp;也跟左左达成了共识，哪怕作为学生，也必须把课题主动权掌握在自己手中，不可以做纯粹听命令完成任务的工具人。这两年我观察到的是，绝大部分学生去找导师都是看看导师有什么题，然后挑一个题跟着做，导师也不含糊，直接抛出他目前在做的题目，让学生挑一个。我跟 Hubert 是例外，我是抱着自己的题去找他的，我问他他有什么在做的题我能跟着做的，他总是回避，反问我想做什么题。左左也是例外，他找的合作学生总是“等你啥时候想出来好东西了叫我来给你排列组合”，他抱怨开会时学生讲的内容很明显是开会前一小时推出来的。&emsp;&emsp;这其实就是在说思维的惰性吧，完全把科研当作上班领任务了。我们认为，硕士还情有可原，你可以说并不打算把自己打造成会自己找方向、对课题有非常深入的思考、想要提出建设性意见的人，而只是想做优秀的任务执行者。如果是博士，这样做就是持续依靠老板，最终不能独当一面的，也就达不到“能独立做研究”的博士毕业要求。 LoveLive&emsp;&emsp;要说到 2021, 2022 年，那首先得是 Liella，这个也一起从 2021 年成长起来的团队。&emsp;&emsp;疫情元年完成了选拔与投票，认识了鲤鱼姐。2021 年初第一场生放拉开序幕。进度飞快，第一场生放当场播一单试听，4 月发售一单，举行一单发售 live，七月播动画，十月直接 1st live 20 场巡演，年底上三团跨年。&emsp;&emsp;有很多传承，比如故事风格、初期曲风、发展节奏，跟水是类似的，就感觉 LL 隔代遗传，缪的节奏遗传虹，水的节奏遗传星。也有很多创新，主要还是企划首次的五人团队，创造很多奇妙的羁绊。弊端也很明显，1st 巡演分摊下来强度过高，声乐培训不到位，直接废了某位的嗓子。我们当时说，20 场过后，小百合要么成神，要么报废，如今看来很不幸是后者。但总的来说，小风小浪，平平稳稳，也算是作为第四代团打开了局面。像是小星星、nonfiction 和一众 cw 好曲，还是收获了不少人气。&emsp;&emsp;风浪从 2022 年开始。4 月底突然宣布加一组二期生共 4 人，直接斩获全年最迷惑操作。一时间天下大乱，骂街的骂街，哭丧的哭丧，吵架的吵架，退坑的退坑。一期生的 2nd 最后一场，也被冠以“老五人 final live”的名称。自此星团风评急转直下，观众老爷对待 7 月的第二季动画自然也是怀着失望的基调。好巧不巧第二季动画不孚众望，节奏赶，商业味浓，情节主线处理不当，歌曲游离于剧情之外，还时不时踩一下暴躁观众的雷，值得赏析的部分全部被盖住了，使得星团失去大部分口碑。动画播完，宣布招三期生，再往伤口撒盐。如今星团人气是如何样子，看 3rd 巡演抽选抽了就中、每一场都能卖一般追加票和当日券，就知道了。（参考：水 extra 和 AZUNA 1st 的 CD 抽选都不低于 10 中 1） &emsp;&emsp;要说我第一个从头到尾看着长大的孩子，如今被人口诛笔伐，那是当然难受的。现在留下来的人都是接受度高的，能感受到新四人的可爱与付出，尽管她们配音水平和歌唱水平实在有待提高。我当然是很 DD 的了，尽管我也被加人的消息震惊了很久，那时还是毕设答辩前夕，痛苦极了。我始终认为，核心的核心，是绝不能让开新团和加人成为溃口，放混子进来。如今进来的新人无一不是浓度极高的老粉，也是粉丝走上台，演绎新的故事，这也是“大家一起实现的故事”。自觉传承并发扬 LL 的精神核心，目前大家都能做到，因此三团跨年 26 人站上台的时候，感受到的是香火延续，人丁兴旺，子孙满堂，而不是鱼龙混杂，浑水摸鱼。在此之上，更大的愿望是他能好好培养每一个人，增加配音指导和声乐指导，追求高质量动画、歌曲和 live。像雪雪这种开了 1st 之后直接雪藏两年的行为，就如同 4 个 2 拆两对 pair 来打，鼎铛玉石，金块珠砾，弃掷逦迤。&emsp;&emsp;当然，大家也还是要提升鉴赏力，星的动画真不难懂，没有那么多奇怪的逻辑问题，角色塑造还是有好的地方的，像香音这种双性格角色的刻画，还是十分精彩的。永远希望大家能心平气和地看番听歌，多听听官方生放和一些客观的动画鉴赏，不要求你同意但至少要引起你的思考。 &emsp;&emsp;提到加人，就不得不说加人成功的典范，虹咲。r3 也是 AS 剧情地狱开局，到现在却是生机勃勃，万物向好。其一，优秀的动画制作是杀手锏，有虹一季各种姛和扭曲打底，有三次元的逆输入，有精良的歌曲画面，有高厨力制作组各种融梗，剧情主线、矛盾、铺垫等处理较好，能让人看完动画直接爱上虹。其二，加人经过漫长的铺垫，有时间的沉淀，不是突然加塞的，而是让人慢慢喜欢上的。其三，声优本身吸引人，萌 p 是老熟人了，秀和菜宝都是外国人，人设新颖。其四，歌曲加分，虽然我不喜欢 r3 纯耍帅没内容的团曲，但它确实能吸引很多观众，而动画曲表现就很好了，岚珠一首 Eutopia 以其狂傲不羁直接把动画拉高了一个台阶，米娅 Stars We Chase 令其化身 Mia Taylor Swift。星没按 r3 的节奏走，但是可以借鉴经验力挽狂澜。 &emsp;&emsp;水水这两年倒是平静，2021 年的主要任务是把没完成的小组 live 搞完，2022 年的主要任务则是 6th 蛋巡，以及宣布幻日夜羽。数据显示水的动员力比虹星加起来都要高，果然老家伙积累的人气不是吹的。并且有了幻日夜羽，至少水这个团队是能续很久了。 &emsp;&emsp;再说我自己。自 2020 年随组织看了两场水的线上 live 之后，厨力算是又提升了一个水平，会追 live 了。这两年线上白嫖 live 逐渐成熟，三团跨年后还知道了华南群这样的大规模民间组织，因此算是达到了国内看 live 的巅峰状态了。国内民间组织看 live 是真的优势独特，方便，便宜，能出声喊 call。当然以前的官方上映会也还是正式些，唱歌时还要站起来的。&emsp;&emsp;有幸认识了萤火虫 staff 楠木酸菜鱼，现在是无话不聊的好朋友了，经常一起看 live，线上白嫖也会连麦看。&emsp;&emsp;学会了逛漫展，跟 LL coser 集邮很快乐，在偶像舞台厄介应援也很快乐，大家一起玩的气氛跟自己玩还是有点不一样的。&emsp;&emsp;逐渐有了经济能力，能买杂志、棒子和写真集了。读 LL Days 等杂志是很棒的体验，等 sif1 关服之后，如果 sif2 玩不下去，这时间就用来读杂志。&emsp;&emsp;老实说，LL 成了我考虑读研学校的一个选择因素，虽然不该这样，但选 HK 确实也有一个原因是离 LL 近一点。甚至之前套美帝的时候，也是上官网确认了水 5th 在 San Diego 有转播才给 UCSD 的老师发邮件的。。。有条件的话，学 Bingkai 去东京大学自力更生搞个大新闻好像也挺好？&emsp;&emsp;现在我也确乎离 LL 更近了。随着疫情好转，日本签证和入境开放，我也终于迎来了赴日机会。2023 年 1 月底 2 月初，我将现地 Liella 3rd 东京场和 AZUNA 1st，加上沼津台场原宿圣地巡礼。这将是我厨力再上一层的重要里程碑，欢迎大家围观！ end&emsp;&emsp;暂时就先写这么多，想到什么再补充什么吧。&emsp;&emsp;以 2020 为疫情元年，今年是疫情四年了，其实随着国内开闸泄洪，疫情也是走到趋于结束的地步了。恢复经济，恢复有序生活，我们都这么盼望着。&emsp;&emsp;WF Egypt，ZKP，Cooperative Game Theory，complexity，现地 live，圣地巡礼，找女朋友，我们还有很多事情要做。 未来は風のように僕らを呼んでるんだ何が待ち受けてるか誰も知らない——未来は風のように","categories":[{"name":"总结与游记","slug":"总结与游记","permalink":"http://kqp.world/categories/%E6%80%BB%E7%BB%93%E4%B8%8E%E6%B8%B8%E8%AE%B0/"}],"tags":[]},{"title":"Orthogonal Vectors Problem 相关","slug":"OV","date":"2022-10-27T08:01:11.000Z","updated":"2024-04-24T03:59:22.788Z","comments":true,"path":"OV/","link":"","permalink":"http://kqp.world/OV/","excerpt":"&emsp;&emsp;Fine-Grained Complexity 四大基础问题中的一个。","text":"&emsp;&emsp;Fine-Grained Complexity 四大基础问题中的一个。 &emsp;&emsp;这里推荐的资料是 MIT 的一门课的第 6、7 讲。 Task&emsp;&emsp;Orthogonal Vectors Problem (OV)：&emsp;&emsp;给定 $n$ 个 $d$ 维的 01 向量 $v_1,\\cdots,v_n \\in \\{0,1\\}^d$，问是否存在两个向量 $v_i, v_j$ 是正交的，即 $\\langle v_i, v_j \\rangle = 0$。 &emsp;&emsp;这个问题的暴力是 $O(n^2d)$ 的，枚举两个向量，然后每一维去验证。且在 $d$ 比较小的时候（$d \\le 2\\log n$ 时），可以用 $O(2^d)$ 的各种算法解决。&emsp;&emsp;但是在 $d=\\omega(\\log n)$ 时，我们很难找到 $O(n^{2-\\epsilon}d^c)$ 的算法，因此猜想它是 $n^2$-hard 的。事实上，它可以由 SAT 问题归约而来，因此 SAT 的困难性猜想 Strong Exponential Time Hypothesis (SETH) 可以推出 OV 问题的 $n^2$-hardness。 &emsp;&emsp;这个问题有许多变式： 给定两个集合 $A,B$，每个集合有 $n$ 个 $d$ 维的 01 向量，问是否存在 $v_1 \\in A, v_2 \\in B$ 使得 $v_1,v_2$ 正交。（易证这个版本跟上述版本是等价的） 计数版本，求有多少对向量是正交的。也可以继续拓展，做近似计数、sampling。 不再是 01 向量，而是某个域下的 $d$ 维向量。 k-OV，给定 n 个向量，问是否存在 k 个向量，内积为 0。困难性猜想为不存在 $O(n^{k-\\epsilon})$ 的做法。 比较好的解法&emsp;&emsp;该解法来自 [AWY15]，可以做到 $O(n^{2-1/O(\\log (d/\\log n))})$。思路是，给向量分组（每 $s$ 个一组，分为 $\\frac ns$ 组），转化成“对于每一个组对 $(A,B)$，是否能在 $A$ 找一个向量，在 $B$ 找一个向量，使其正交”的子问题。每个组对的任务写成一个逻辑公式，并用一些 trick 变成比较好的多项式，然后使用矩阵乘法的 trick 让所有组对同时计算这个多项式。 &emsp;&emsp;先有几个 trick： Lemma1：如果要计算 $y_1 \\lor y_2 \\lor \\cdots \\lor y_m$，那么可以选择一个正整数 $t$，对于每个 $1 \\le i \\le t$，选择一个随机子集 $s_i \\subseteq \\{1,\\cdots,m\\}$，令 $Y_i = \\bigoplus_{j \\in s_i} y_j$，则只需计算 $Y_1 \\lor \\cdots \\lor Y_t$ 即可。 &emsp;&emsp;证明：&emsp;&emsp;如果原式为假，则 $Y_1 \\lor \\cdots \\lor Y_t$ 肯定为假。&emsp;&emsp;如果原式为真，令 $s_{true} = \\{y_i | y_i=true\\}$，则每次生成随机子集 $s_i$ 时，在 $s_{true}$ 中选中奇数个元素的概率是 $\\frac 12$，所以 $P[Y_1 \\lor \\cdots \\lor Y_t=0]=\\frac{1}{2^t}$。 Lemma1.5：如果要计算 $y_1 \\land y_2 \\land \\cdots \\land y_m$，那么可以选择一个正整数 $t$，对于每个 $1 \\le i \\le t$，选择一个随机子集 $s_i \\subseteq \\{1,\\cdots,m\\}$，令 $Y_i = \\lnot \\left( \\bigoplus_{j \\in s_i} \\lnot y_j \\right)$，则只需计算 $Y_1 \\land \\cdots \\land Y_t$ 即可。 &emsp;&emsp;证明同理，如果原式为真，则 $Y_1 \\land \\cdots \\land Y_t$ 肯定为真；如果原式为假，则 $Y_1 \\land \\cdots \\land Y_t$ 只有 $\\frac{1}{2^t}$ 的概率为真。 Lemma2：有一个 $\\mathbb F_2$（即模 $2$ 意义）下的多项式 $P(x_1,\\cdots,x_d,y_1,\\cdots,y_d)$，其展开后是 $m$ 个单项式的和。现有 $n$ 种 $x$ 变量的赋值 $a_1,\\cdots,a_n \\in \\{0,1\\}^d$，以及 $n$ 种 $y$ 变量的赋值 $b_1,\\cdots,b_n \\in \\{0,1\\}^d$，我们需要对每一对 $(a_i,b_j)$ 都求出 $P$ 的值。若 $m \\le n^{0.1}$，这个时间只需要 $\\tilde O(n^2)$。 &emsp;&emsp;证明：令矩阵 $M$ 大小为 $n \\times m$，$M_{ij}$ 表示第 $j$ 个单项让 $x$ 变量的取值为 $a_i$、$y$ 变量的取值全为 $1$ 时得到的值，同理令矩阵 $N$ 大小为 $m \\times n$，$N_{ij}$ 表示第 $i$ 个单项让 $x$ 变量取值全为 $1$、$y$ 变量取值为 $b_j$ 时得到的值，则 $M\\cdot N$ 就会得到每一对 $(a_i,b_j)$ 下 $P$ 的值。使用优秀的矩阵乘法技术，当 $m \\le n^{0.1}$ 时，矩阵乘法的复杂度只需要 $\\tilde O(n^2)$。 &emsp;&emsp;现在可以来做题了。&emsp;&emsp;先给向量分组，每 $s$ 个一组，分成 $\\frac ns$ 组。那么对于每一组，我们要求的东西可以写成一个逻辑表达式： \\bigvee_{i,j \\in [s]^2} \\bigwedge_{k \\in [d]} (\\lnot v_{ik} \\lor \\lnot v_{jk})&emsp;&emsp;我们希望把逻辑公式转化为 $\\mathbb{F}_2$ 下的多项式，$\\land$ 是乘法，$\\oplus$ 是加法，$\\lnot$ 是加 $1$，$\\lor$ 用德摩根律转化为 $a \\lor b = (1+a)(1+b)+1$。&emsp;&emsp;对最外层的或使用德摩根律+Lemma1.5，参数 $t=2$： {\\Large(} 1+\\underbrace{(\\bigwedge_{k \\in [d]})+(\\bigwedge_{k \\in [d]})+\\cdots+(\\bigwedge_{k \\in [d]})}_{O(s^2)\\text{个}} {\\Large)} {\\Large(} 1+\\underbrace{(\\bigwedge_{k \\in [d]})+(\\bigwedge_{k \\in [d]})+\\cdots+(\\bigwedge_{k \\in [d]})}_{O(s^2)\\text{个}} {\\Large)}+1&emsp;&emsp;对每个 $(\\bigwedge_{k \\in [d]})$，使用 Lemma1.5，参数 $t=3 \\log s$： {\\Large(} 1+\\underbrace{(v_{ik}v_{jk})+(v_{ik}v_{jk})+\\cdots +(v_{ik}v_{jk})}_{O(d)\\text{个}} {\\Large)} {\\Large(} 1+()+()+\\cdots+() {\\Large)} \\overbrace{\\cdots}^{3 \\log s\\text{个}} {\\Large(} 1+()+()+\\cdots+() {\\Large)}&emsp;&emsp;这就是我们的多项式 $P$，共 $2sd$ 个变量。给定一个向量组对，通过这个多项式就可以算出这个组对是否有正交向量。By union bound，错误率不高于 $\\frac 14+s^2\\frac{1}{s^3} = \\frac 14+\\frac 1s$。&emsp;&emsp;现在来算一下单项式数量 $m$。把每个 $(\\bigwedge_{k \\in [d]})$ 展开以后，看上去有 $(d+1)^{3 \\log s}$ 个单项，但实际上，每个单项形如 $v_{ik_1}v_{jk_1}v_{ik_2}v_{jk_2}\\cdots v_{ik_{3 \\log s}}v_{jk_{3 \\log s}}$，由于是在 $\\mathbb F^2$ 下运算，重复的 $k$ 可以只保留一个，因此这样的单项的数量只有 $\\binom{d+1}{3 \\log s}$ 个。再把最外层的括号展开，就共有 $m=\\left(s^2\\binom{d+1}{3 \\log s}\\right)^2$ 个单项。&emsp;&emsp;代入 $s=2^{\\epsilon \\log n / \\log (d / \\log n)}$，其中 $\\epsilon$ 是足够小的常数，经过巧妙且艰难的不等式放缩，就可以得到： 多项式 $P$ 对于单个组对的错误率不高于 $\\frac 13$； $m \\le n^{0.1}$。 &emsp;&emsp;因此就可以用 Lemma2 同时对 $(\\frac ns)^2$ 个组对算出 $P$ 的值了，最终只要有一个组对返回 $1$ 那答案就是 $1$。由于现在每个组对的错误率是常数，那么就把整个过程重复 $O(\\log n)$ 次（即随机产生多个 $P$），每个组对取众数。By Chernoff bound and union bound，错误率就变成 $\\frac{1}{poly(n)}$ 了。 &emsp;&emsp;总结一下，算法流程是 给向量分组，每 $s$ 个一组，共 $\\frac ns$ 组； 随机生成多项式 $P$，并写成单项式的和的形式；（$O(m)$） 根据 $P$ 预处理矩阵 $M, N$（矩阵的大小是 $\\frac ns \\cdot m$ 的）；（$O(\\frac ns \\cdot m \\cdot sd) = O(nmd)$） 计算 $M \\cdot N$；（$\\tilde O(\\frac{n^2}{s^2})$） 重复 2-4，统计每个组对的答案众数。 &emsp;&emsp;时间复杂度分析。瓶颈在于第 4 步，复杂度是 $\\tilde O(\\frac{n^2}{s^2})$，代入 $s$ 会得到 $\\tilde O(n^{2-1/O(\\log (d/\\log n))})$。重复 2-4 的次数是 $O(\\log n)$ 的，对 $\\tilde O$ 无影响。&emsp;&emsp;因此，如果 $d$ 等于常数倍的 $\\log n$，那这个算法就是 subquadratic 的了。这也提醒我们在使用 OV 问题的困难性的时候，$d$ 不能太小，必须是 $d=\\omega(\\log n)$ 的。 &emsp;&emsp;甚至还可以在有解的时候快速求出方案。因为我们锁定了答案在哪个组对里，所以只需要 $O(s^2)$ 暴力就可以了。 Approximate Counting&emsp;&emsp;然后看 OV 的近似计数版本。&emsp;&emsp;首先它肯定难于直接判定 OV 有无解，因为 approximate counting 结果是否为 $0$ 就表示了原问题有无解。但是难多少？&emsp;&emsp;[DL18] 给出了 approximate counting 到 decision 的归约，告诉我们仅是难了 polylog factors。&emsp;&emsp;由于这篇文章还有很多更 general 的 idea，所以单开一篇写了，看这里。 Average-Case Hardness&emsp;&emsp;很遗憾，OV 并不是 average-case hard 的，详见 [KW19]。&emsp;&emsp;就连其计数版本也不是。[DLW20]&emsp;&emsp;那为什么还要讲 average-case hardess 呢？因为 OV 的一些变式还是 average-case hard 的，比如 OV 计数版本的式子 fOV(U,V) = \\sum_{i,j \\in [n]} \\prod_{l \\in [d]}(1-u_{il}v_{jl})如果拓展到 $\\mathbb F_p$，那就是 average-case hard 的了[BRSV17]。这篇文章普遍被视为 Fine-Grained Cryptography 的开端，正是因为它首先讨论了 average-case hardness。&emsp;&emsp;以及 [DLW20] 里面一堆奇奇怪怪的变形也是 average-case hard 的。 Completeness&emsp;&emsp;慢慢填坑。OV 似乎在 First-Oder Problems 中是完全的。具有完全性的问题有很大的价值，比如设计协议，给一个完全问题搞了某种协议以后，这一类问题就都拥有这种协议了。 Reference [AWY15] Amir Abboud, Ryan Williams, and Huacheng Yu. More Applications of the Polynomial Method to Algorithm Design. In SODA 2015. [BRSV17] Marshall Ball, Alon Rosen, Manuel Sabin, and Prashant Nalini Vasudevan. Average-case fine-grained hardness. In STOC 2017. [DL18] Holger Dell, and John Lapinskas. Fine-grained Reductions from Approximate Counting to Decision. In STOC 2018. [DLw20] Mina Dalirrooyfard, Andrea Lincoln, and Virginia Vassilevska Williams. New techniques for proving fine-grained average-case hardness. In FOCS 2020. [KW19] Daniel Kane and Ryan Williams. The orthogonal vectors conjecture for branching programs and formulas. In ITCS 2019.","categories":[{"name":"TCS","slug":"TCS","permalink":"http://kqp.world/categories/TCS/"}],"tags":[{"name":"complexity","slug":"complexity","permalink":"http://kqp.world/tags/complexity/"}]},{"title":"零知识证明大整理","slug":"ZKP","date":"2022-09-14T03:30:10.000Z","updated":"2024-04-24T03:59:22.800Z","comments":true,"path":"ZKP/","link":"","permalink":"http://kqp.world/ZKP/","excerpt":"&emsp;&emsp;学的内容多了，就可以搞个总结整理了。&emsp;&emsp;慢慢填坑。","text":"&emsp;&emsp;学的内容多了，就可以搞个总结整理了。&emsp;&emsp;慢慢填坑。 &emsp;&emsp;推荐一个 2019 年的 camp 可以学到多数 ZKP 经典内容。&emsp;&emsp;其他参考资料：Sanjeev Arora 的经典教材《Computational Complexity: A Modern Approach》，以及各类密码学教材。 初始 Fundamental&emsp;&emsp;Princeton 的这个 lec15 和 lec16 是非常好入门教程。 &emsp;&emsp;怎么说明一个输入 $x$ 属于一个语言 $L$ 呢？通常来说，就是写出来一个数学证明（通常就是给出 $x$ 的 witness），谁想知道谁就来看。但缺点就是把 witness 公开出来了，有没有不公开的方法呢？比如有一个门禁，门禁里有一个大整数 $n$，我的“钥匙”就是 $n$ 的质因数分解。如果我直接显式地输入 $n$ 的质因数分解，那就会被人偷看偷听了，有没有方法使得我既能让门禁相信我知道 $n$ 的质因数分解，又能不说出任何关于 $n$ 质因数分解的信息呢？ &emsp;&emsp;零知识证明(Zero-Knowledge Proof, ZKP)是一个交互协议，交互双方为 Prover、Verifier，其中 Verifier 计算能力有限（通常假设它只有多项式时间）。它们会得到一个输入 $x$，Prover 想让 Verifier 相信 $x$ 属于某个语言 $L$。这个交互协议满足如下条件： Completeness：如果 $x \\in L$，那么 Verifier 以高概率接受； Soundness：如果 $x \\not \\in L$，那么 Verifier 以高概率拒绝； Zero-Knowledge：Verifier 经过交互以后没有得到额外的信息，即，整个交互过程可以被 Verifier 自己模拟出来。更确切地说，存在一个算法 Simulator，它可以模拟出一个 Verifier 的 view，该 view 与真实交互中 Verifier 的 view 是不可区分的。（不可区分可以是完美/统计/计算不可区分） &emsp;&emsp;给非 CS 背景的人科普时可以举的通俗易懂的例子：如下图，Alice 想要给 Bob 证明她拥有这个门的钥匙，但不能直接把钥匙给她看。方法是，Bob 站在顶上通道处，每次随机喊“左”或“右”，Alice 就必须从下方走到对应位置。过程重复若干次，如果 Alice 总是能成功，Bob 就能确信 Alice 拥有钥匙了。但 Bob 没有亲自看到这把钥匙或是开门过程。 &emsp;&emsp;给非 CS 背景的人科普时可以让他看的视频。（油管链接，需科学上网） &emsp;&emsp;给 CS 背景的人科普时可以举的例子：图同构。有两幅图 $A$ 和 $B$，Prover 希望 Verifier 相信 $A$ 和 $B$ 同构。每次操作 Prover 给 Verifier 发送一个新图 $C$（由 $A$ 点标号随机打乱而来），声称 $A,B,C$ 同构，Verifier 要么询问 $A$ 和 $C$ 之间的点标号映射，要么询问 $B$ 和 $C$ 的点标号映射。操作重复若干次，Verifier 接受当且仅当每次 Prover 都能正确回答问题。&emsp;&emsp;如果 $A,B$ 真的同构，那么 Prover 总是能正确回答。如果 $A$ 和 $B$ 不同构，那么 Prover 每次最多只有 $\\frac 12$ 的概率回答正确，重复若干次以后概率无限小。直观理解，Verifier 每次只是知道了 $A$ 或 $B$ 其中一幅图的点标号重排结果，从中并不能推断出更有用的信息。 &emsp;&emsp;想要细学的话需要了解的例子：二次剩余、3-Coloring、哈密顿回路。 更多框架随机自归约(Random Self-Reducible)问题的ZKP&emsp;&emsp;如果你发现二次剩余、离散对数、图同构的 ZKP 都长得很像，那么 [TW87] 这篇文章就可以告诉你，这不是巧合。它们都是 random self-reducible 的，于是可以设计出统一的 ZKP 框架，并且是 perfect ZKP 的： 输入：$x$，诚实的 Prover 拥有其 witness $y$。 Prover 随机生成一个 $r \\in \\{0,1\\}^*$，将 $(x,y)$ 用 $r$ 随机归约成 $(x’,y’)$，发送 $x’$。 Verifier 发送一个随机提问 $b \\gets_R \\{0,1\\}$。 若 $b=0$，Prover 发送 $r$，Verifier 检验“$x$ 用 $r$ 归约成 $x’$”；若 $b=1$，Prover 发送 $y’$，Verifier 检验“$y’$ 是 $x’$ 的 witness”。 &emsp;&emsp;例如，在二次剩余中，$x \\equiv y^2 \\pmod n, x’ \\equiv x \\cdot r^2 \\pmod n, y’ \\equiv yr \\pmod n$；在离散对数中，$x \\equiv g^y, x’ \\equiv g^{y+r}, y’ \\equiv y+r$。 &emsp;&emsp;其实不仅是 random self-reducible，只要能把 $A$ 问题随机归约到 $B$ 问题，就能对 $A$ 问题采用这个框架。 &emsp;&emsp;这个东西的一个很重要的意义在于，结合后续一系列推导（包括 $\\mathsf{SZK \\subseteq coAM}$、$\\mathsf{NP\\subseteq coAM} \\Rightarrow \\text{polynomial hierarchy collapses}$），可以得到 $\\mathsf{NPC}$ 问题不能拥有 SZK，又或者拥有 SZK 的问题（比如 random self-reducible 的问题）不能是 $\\mathsf{NPC}$。 $\\sum$-Protocol带各种特性的零知识证明常数轮零知识证明 Constant-Round Zero-Knowledge Proof&emsp;&emsp;传统的 ZKP 是把一个协议串行执行很多次来降低 soundness，因此自然会想如果把它改成并行，就变成常数轮了。但简单的并行会使得 simulator 的时间复杂度爆炸。（例如很多 ZKP 是让 verifier 发送两种询问中的一种，simulator 原本只需要期望 $2$ 步猜对询问然后往下走，现在 $n$ 个询问并行，那么就变成期望 $2^n$ 步才能同时猜对然后往下走。）&emsp;&emsp;[GK96] 的 idea 是：还是并行，但让 verifier 先把询问加密发送给 prover，再执行原协议，到该询问的时候让 verifier 解密。这样 simulator 就不用猜询问了，一直发垃圾等 verifier 自己解密了询问再时间倒流即可。具体来说（以哈密顿回路的 3 轮协议为例）： Verifier 将询问串用 computationally binding, perfectly hiding 的 commitment scheme 加密发送给 Prover。 Prover 发送原协议第一步的消息。 Verifier 解密询问串。 Prover 回答。 细节分析很复杂，因为要考虑各种不遵守协议 halt 的情况，如果不明白某些步骤的意义，可以参考 《Tutorials on the Foundations of Cryptography》6.5.4 节的讲解。 &emsp;&emsp;[GK96] 的缺点就是不遵守协议 halt 的情况太复杂，其中有一个分析就是由于 simulator 会倒车，导致 verifier 有至少两次解密询问，如果每次成功解密的概率不一样，就会使得 simulator 期望倒车次数爆炸。&emsp;&emsp;[Ros04] 这篇仍然是让 verifier 先发送询问（假设叫 $\\sigma$），但是额外生成了 $\\sigma_i^0,\\sigma_i^1$ 使得 $\\sigma_i^0 \\oplus \\sigma_i^1=\\sigma$。它让 prover 解密 $\\sigma_i^0,\\sigma_i^1$ 中的其中一个，这对 prover 来说是没有用的，但是 simulator 可以在这里倒车获得询问，这样就没有“每次成功解密的概率不一样”的问题，因而期望倒车次数是常数。&emsp;&emsp;由于发送询问的方式更复杂了，所以轮数变成了 7 轮，没有达到最优，但是分析简单了很多。 非交互零知识证明 Non-Interactive Zero-Knowledge Proof&emsp;&emsp;把 ZKP 做成非交互的当然是一个美好的愿景了，这样可以大大提升 ZKP 的效率，从而提高实用性。 &emsp;&emsp;但如果就简单地只是让 Prover 发条消息给 Verifier，这是不可能的。 Lemma: 如果问题 $L$ 存在一个 ZKP 只是让 Prover 发一条消息给 Verifier，那么 $L \\in \\mathsf{BPP}$。 &emsp;&emsp;证明：对于输入 $x$，直接让 simulator 模拟一个 Prover 消息，用 Verifier 验证，这就得到了 $L$ 的概率多项式算法。 &emsp;&emsp;事实上，不只是一轮不行，参考 Lower Bound of ZKP，黑盒 simulator 的情况下三轮都不行。 &emsp;&emsp;因此要实现非交互，必须借助一些外部工具。一个可行的方法就是 Common Reference String (CRS)，从天上来了一个可信第三方，给出了一个符合特定分布的字符串，Prover 和 Verifier 都无条件相信这个字符串是符合特定分布的。这个信任，就可以用来实现非交互。&emsp;&emsp;下表是使用 CRS 的一些经典方法的总结。 Paper Problem Extra Property CRS represents Assumption Completeness Soundness ZK len of CRS [KT92] 3-Coloring 2 numbers for each edge hardness of Quadratic Residuosity $1$ $0$ computational $16k$ [FLS99] Hamiltonian - a cycle One-Way Permutation with hard-core predicate $1$ $neg$ computational $n^7k^2m$ [FLS99] Hamiltonian argument One-Way Trapdoor Permutation [FLS99] $\\mathsf{NPC}$ multiple provers random $y$ and original CRS Psseudorandom Generator (from $n$-bit to $2n$-bit) $2n + \\vert CRS \\vert$ [KP98] 3-SAT-5 wild strings and random strings Hidden Bit Model $1-neg$ $neg$ computational $O(kn \\log (n/\\epsilon))$ [GOS12] circuit SAT commitment scheme Homomorphic Commitment Scheme $1$ $0$ computational $O(1)$ [WP22] Linear Problems, circuit SAT commitment scheme in matrix $\\mathsf{NC^1 \\subsetneq \\oplus L/poly}$ $1$ $0$ $\\mathsf{NC^1}$ computational $\\lambda^2$ &emsp;&emsp;另一种方法是 Fiat-Shamir Transform，即如果 verifier 发的消息全都是随机字符串，那么就用一个伪随机函数来代替掉它，伪随机函数的输入就是之前的所有消息。 非黑盒零知识证明 Non-Black-Box Zero-Knowledge Proof理论相关Lower Bound of ZKPZKP and One-Way Function&emsp;&emsp;[Ost91] 及后续工作 [Ost93] 提出的思路，我猜是在考虑怎么用 simulator 产生的 view 来设计判定 $x \\in L$ 的算法的时候，捣鼓出了这个玩意。&emsp;&emsp;如果一个问题 $L$ 是属于 $\\mathsf{SZK}$ 的，并且是 hard on average 的，那么就可以通过这个 SZK 构造出 one-way function。这个 one-way function 的输入是 SZK 里的 simulator 所需的 random tape，输出是 simulator 产生的 view of verifier。&emsp;&emsp;证明大致是，假设这个函数不是 one-way 的，即输入 view 可以快速求出 random tape。那么用 simulator 充当 prover，与 verifier 交互（每得到一条 verifier 的消息就重新算 random tape，再用 simulator 计算出 prover 要发的消息），这样就得到了 $L$ 的快速判定算法，从而 $L$ 不是 hard on average。&emsp;&emsp;为什么限定是 SZK 呢？因为 SZK 证明 correctness 的时候会方便很多。后续论文 [Ost93] 把这个思想拓展到一般 ZKP 上了。&emsp;&emsp;为什么是 hard on average 呢？我认为这个条件是不准确的，它用反证法推翻的结论是“$L$ 没有高效的概率算法”，所以应该跟 [ZKP-OWF] 一样，是“不属于 $\\mathsf{BPP}$”。 $\\mathsf{SZK}$ and $\\mathsf{coAM}$Reference [FLS99] Uriel Feige, Dror Lapidot, and Adi Shamir. Multiple noninteractive zero knowledge proofs under general assumptions. In SIAM Journal on computing 1999. [GK96] Oded Goldreich, and Ariel Kahan. How to Construct Constant-Round Zero-Knowledge Proof Systems for NP. In Journal of Cryptography 1996. [GOS12] Jens Groth, Rafail Ostrovsky, and Amit Sahai. New techniques for noninteractive zero-knowledge. In Journal of the ACM 2012. [KP98] Joe Kilian, and Erez Petrank. An efficient noninteractive zero-knowledge proof system for NP with general assumptions. In Journal of Cryptology 1998. [KT92] Kaoru Kurosawa, and Kenichi Takai. A comment on NIZK for 3 colorability. In ICCS/ISITA `92. [Ost91] Rafail Ostrovsky. One-Way Functions, Hard on Average Problems, and Statistical Zero-Knowledge Proofs. In CCC 1991. [Ost93] Rafail Ostrovsky, and Avi Wigderson. One-Way Functions are Essential for Non-Trivial Zero-Knowledge. In Israel Symposium on Theory and Computing Systems 1993. [Ros04] Alon Rosen. A Note on Constant-Round Zero-Knowledge Proofs for NP. In Theory of Cryptography 2004. [TW87] Martin Tompa, and Heather Woll. Random Self-Reducibility and Zero Knowledge Interactive Proofs of Possession of Information. In STOC 1987. [WP22] Yuyu Wang, and Jiaxin Pan. Non-Interactive Zero-Knowledge Proofs with Fine-Grained Security. In EUROCRYPT 2022.","categories":[{"name":"TCS","slug":"TCS","permalink":"http://kqp.world/categories/TCS/"}],"tags":[{"name":"ZKP","slug":"ZKP","permalink":"http://kqp.world/tags/ZKP/"}]},{"title":"虹咲5th live","slug":"nijigaku_5th_live","date":"2022-09-10T13:43:58.000Z","updated":"2024-04-24T03:59:22.784Z","comments":true,"path":"nijigaku_5th_live/","link":"","permalink":"http://kqp.world/nijigaku_5th_live/","excerpt":"&emsp;&emsp;众所周知虹动画第 2 季制作组厨力拉满，呈现出了一部精彩绝伦、细节可赏、值得每周期待的作品。那么以虹动画第 2 季为主题的虹 5th live 会怎么样呢？","text":"&emsp;&emsp;众所周知虹动画第 2 季制作组厨力拉满，呈现出了一部精彩绝伦、细节可赏、值得每周期待的作品。那么以虹动画第 2 季为主题的虹 5th live 会怎么样呢？ Day1&emsp;&emsp;来到 HK 之后的第一场 live。满心欢喜加了去年跨年的 HK 转播群，但发现没人组织。最后跟萤火虫 staff 桑连麦看。&emsp;&emsp;本来打算用实验室里的卡拉 ok 音响加上 4k 屏来看的，结果下午老板还来查房。为了安全起见，还是溜回宿舍用笔记本看了。 &emsp;&emsp;live 开始前大约期待的几个亮点：一是光路企划，有好几个光路要还原，比如侑弹钢琴时的彩虹展开、璃奈 solo 时的璃奈板；二是第 2 季的各种新歌，op、ed、Eutopia、Stars We Chase、缭乱；三是侑的再次上台。 &emsp;&emsp;开场发现舞台很小，不会有庞大的走位了。&emsp;&emsp;整场 live 节奏按照动画来走，op 开场，岚珠露一手给你们看看，然后一路直到 13 话那首歌，ed 结束正场。安可后是缭乱，小组曲 cw，接几首全员曲。一开始我们感觉节奏太快，时长太短，但是整场 live 下来也接近 3h，造成一开始有短的感觉原因有二：一是 mc 少，全场只有开头结尾两次 mc，歌曲数量数下来估计是不少的；二是安可的位置摆得很中间，换句话说安可后的内容十分多，而正场的内容就纯动画，不像别的团有插入各种特典曲、小组曲、liella 之歌什么的。&emsp;&emsp;值得期待的歌曲基本都出来了。op 的衣服应该很热，披肩依然是毛茸茸的。菜宝打头阵，可惜麦克风有大问题，好几个词都漏了，后面的夜明珠更是漏了一整句。一开始“もっと熱く高く 光よりもはやく”用力很猛，气势非常够，甚至过头了。菜宝的声音仍然能听出中后期有明显的气息急促，所以体力还是有欠缺（与此同时你的舞蹈还是最激烈之一的），但是很惊奇的是在这样疲累的状态下她能将所有的高音冲到位，在高音的音准上没有出问题，就好像把所剩无几的力气全部用在了刀刃上。这样的话，可能要点名水和星某些疲累状态下会产生严重音准问题的人了（没错说的就是你 sayu 和 sww）。dd 组两个人撩来撩去。Stars We Chase 这里展现出了一个战神秀秀，音准体力各方面都稳得很，堪称 Mia Taylor Swift。安可后第一首就是缭乱，然后全员长衫+光剑，像星战一样，是酸菜世界以外的另一种生草。146 耍剑耍得跟孙悟空似的。&emsp;&emsp;很遗憾没有看到光路还原，导播没播，观众估计也没摆出来，看切米的表情不像是有光路。AZUNA 也没有弹射出场（大雾）&emsp;&emsp;侑爷来了，侑爷再次弹钢琴了，这次是笑容满面，自信满满。侑脱离粉丝定位了，上台一起唱歌了，不过没关系了，随着粉丝对侑爷的代入感越来越小，其实好多人反而越来越希望 hnk 上台，不要埋没这一人才。后面 ed 的时候侑拿个篮子来回收花朵，最恰当的词语来形容她应当是 采 花 大 盗（x&emsp;&emsp;其他的看点大概就是 C&amp;R 的时候的鸡兔大战、萌p和兔子两大美腿了。衣服的话，r3 新衣服都不错，op 衣服很还原（就是担心热死）但可惜只跳个 op 就换掉了。 &emsp;&emsp;读研了，身份逐渐学者了，看到这些还是很悸动，希望能一直悸动下去。&emsp;&emsp;第一场体验很棒，期待后面有没有大新闻了。 Day2&emsp;&emsp;歌单基本没换。其实也没什么能换的，至少安可前的部分一首都换不了。&emsp;&emsp;关于菜宝：Eutopia 最后一节副歌的第一句，跟它前一句“follow me”重叠了，这必然是有一句唱的有一句播的，这就说明无敌万能的虹虹其实也是有垫音的，打破了“虹全开麦”的传说。虽然情有可原，因为原曲这里就是重叠的，你可以说这是因为追求原曲效果不得不这么做。但是，鉴于他现在的垫音技术真的垫到神不知鬼不觉了（可能就是开场前录了一遍无修音的，而不是垫 CD，要不是重叠，真的锤不出来），那么“即便是疲惫也能将所有的高音冲到位”这个能力，就值得怀疑了。 Day3&emsp;&emsp;偷跑了永远一瞬？？这首有资格成为大毒曲的，如果放在更合适的位置（比如放在合适的动画剧情后），就会毒死人了。&emsp;&emsp;秀战神今天的音准很有问题，像是累了。&emsp;&emsp;场地大了，能放花车了。有在日留学群友现地抽中过道位，本以为会有侑酱经过的，结果侑酱的路线偏了 QAQ&emsp;&emsp;厂长在缭乱的时候被 staff 烟封了（x Day4&emsp;&emsp;先说一些细节，比如开头 C&amp;R 的时候果林施展调虎离山之计，先把步梦拉到角落然后去抱侑酱（x&emsp;&emsp;萌p和秀秀，都很累的样子。萌p solo 的声音很虚，秀秀音准比昨天好些，但后面也控不好。 &emsp;&emsp;然后就是万众瞩目的大新闻了，都期待虹能不能出第三季。如果有，说明学园偶像这个本职的故事是能打持久战的（而不是靠跳槽异世界续命）。&emsp;&emsp;新闻出来是虹四格的动画化，带侑爷，明年一月番，虽然是 TV 动画，但是是 short。&emsp;&emsp;稍微比期待的低了一丢丢。&emsp;&emsp;但是并没有关系，反而是有好处的。因为这样一来，其实说明虹的主线进程开始放慢节奏了。回想水和星，其实都很赶，水是按老缪的节奏走的，走完了发现无路可走了，加之疫情，闲置下来了；星的话，两季 tv 的间隔缩短到正好一年，live 是赶鸭子上架，不仅间隔短，还超级加倍巡演。现在日程表密集得很，事实上下周还有“感谢祭+游戏重大发表+星10话+星生放”这样的连续轰炸，我是不喜欢的。放缓一点来，提高企划寿命，也让人能喘口气，更重要地，让每一次活动（动画也好，live 也好，出书出综艺也好）准备充分，提升质量，这样才值得回味，也有时间回味。 &emsp;&emsp;后面还有二次返场。不过没有发表额外的感想，就是唱一首歌就跑了，属于只是浅浅地回来一下。也是契合氛围的。 总&emsp;&emsp;头一次是几乎把 4 场全看完，没想到厨虹没那么深的我，看 live 的程度超过了其他所有团（x 有没有可能就是你摸鱼摸得太厉害了，赶紧读论文去好不好&emsp;&emsp;虹真的蛮好的，有不同于传统 LL 的设定因此很多地方可以搞创新施展拳脚，有一个高厨力动画制作组，现在逐渐有了历史积淀，也可以拿出些情怀来了。&emsp;&emsp;我的感受就像是，有个朋友能够继续陪跑下去了。感觉很好啊，值不值得追一辈子呢？ &emsp;&emsp;星也是值得期待的后辈，只能真切地希望大家心平气和地、不要带着怨气地去看星，不要学一些 up 主脑子都不转一下就开始锐评。要是本来鉴赏能力就不怎么好，还心浮气躁地看，那真是浪费他们给你讲的故事，也浪费你听故事的时间。","categories":[{"name":"玩","slug":"玩","permalink":"http://kqp.world/categories/%E7%8E%A9/"}],"tags":[]},{"title":"Liella 第二季随笔","slug":"Liella_S2","date":"2022-08-01T15:21:06.000Z","updated":"2024-04-24T03:59:22.781Z","comments":true,"path":"Liella_S2/","link":"","permalink":"http://kqp.world/Liella_S2/","excerpt":"&emsp;&emsp;纯粹是杂写里面占篇幅太长了，所以拉出来单开一篇。&emsp;&emsp;但为了一部番单开一篇 blog 实在是有点。。。","text":"&emsp;&emsp;纯粹是杂写里面占篇幅太长了，所以拉出来单开一篇。&emsp;&emsp;但为了一部番单开一篇 blog 实在是有点。。。 &emsp;&emsp;最近在看星Ⅱ，随时发表一下感受。 感受&emsp;&emsp;前三话来看，是一部特别写实的番，如果把 LoveLive 大赛换成 XCPC，那完全就是我们集训队的真实写照。前三话每一话都表达了一个特别的主题，或者说矛盾。第一话的矛盾是要不要加人，加人的问题曾经讨论了很多，三次元加人可能问题比较大，动画剧情里的加人那完全就是正常的社团招新，相比起缪水前辈，她们更多地是作为传播学园偶像快乐的社团，而非封闭团体。第二话的矛盾是招新时如何平衡高团体目标与训练强度的问题，这是同类社团绕不开的问题，做过招新工作就会知道，你必须思考如何既能展现团队最终潜在的高成就及其道阻且长，又不能过分表达过程的艰苦来劝退新人，新人来了以后还有一个循序渐进的过程要怎么做，事实上头疼得很。香音她们的探索是降低训练强度，改变活动理念，但最终还是推翻了。第三话的矛盾是优胜的意义和信心，比赛如果成绩不好，你会心有不甘，产生信心问题；但优胜了以后又会有别的问题，sunnypa 的梦想是卫冕，Liella 的梦想是夺冠，这是互斥的，一个梦想的实现一定会使得另一个梦想的破灭。每年 OI/XCPC 没拿好牌的人，都会痛苦面具，他们在退役感言里真实地抒发他们的遗憾。而当进了省队/国集/区域赛出线，回头看看一同作战的其他队伍伙伴们，因为省队1/3线、出线队每校只能一支等各种原因被卡掉的伙伴们，你很难不会怀疑你到底在做什么。算法竞赛选手大部分时候足够冷血，坚信菜是原罪，没进队没出线就是自己菜，LoveLive 呢？&emsp;&emsp;所以说怪就怪在 LoveLive 是个比赛，使得学园偶像变成了竞赛。竞赛人看着很爽，其他人恐怕不行，还是得多看看虹，办 school idol festival，“不要参加 LoveLive，会变得不幸”。&emsp;&emsp;塑造出来的香音的内心是这样的，即便是有第一季最终话那样的场景使得她拥有坚定的信念，仍然会随着时间的推移、外界的各种反应，而使得信心下降，飘忽不定，怀疑自己。说明她不是神仙，内心跟我们一样，都不是强大到完美、强大到完全不受干扰的。 \\\\ \\\\&emsp;&emsp;8.27 的生放对于第 4 5 6 话的解读的几处亮点节选： “虽然前面夏美一直在赚钱，但其实是用赚钱来掩饰自己实现不了其他梦想，只有赚钱不会骗自己。” “从前是大家帮助了香音，让她能重新唱歌。现在香音想要去帮助大家。一个帮一个，把梦想传递下去，这就是连结。” “不是只有二期生在引导夏美，一期生也一直在影响夏美，夏美是在 8 人的帮助下找到梦想入队的。” \\\\ \\\\&emsp;&emsp;到第八话为止所有的 TV 插入曲情调都很统一，都是欢快的。所以会出现一个问题：单看每首歌曲都挺好，放在 TV 里就不见得合适了，因为跟情节不太相关，像是纯粹为了插首歌一样。在这方面做得好的是缪，缪的每一首动画插入歌都是紧扣主题的（start dash、万圣、婚礼、数星星等等，你想想是不是都有一整话或者一大段的铺垫），从曲风到歌词。水虹也相对较好，情调是对得上的（比如第一季海滩上捡垃圾完了之后紧接梦夜空，配合孔明灯）。星Ⅱ这里，相关性体现不出来。&emsp;&emsp;其实更像是一部竞赛番了，全篇更多的笔墨在于如何努力训练参加比赛，但并没有把这个过程融入到曲子当中。&emsp;&emsp;我似乎是逐渐成为香哥哥厨了。无他，就是觉得香哥哥内心同时具有害羞迷茫与坚定强大两种特质，能看到她不断地在用后者去努力克服前者，可以在关键时刻表现出来飒爽的姿态，给人很能依靠的感觉。中途也有无法决策的时候，这时候她跟小千就是互相替补，你犹豫了我坚决，我犹豫了你做主。 \\\\ \\\\&emsp;&emsp;来谈谈第 9 话吧，感情上的小巅峰。&emsp;&emsp;第一感受是：你们还是能写出像样的感情戏的嘛！&emsp;&emsp;堇主动当坏人，为了让可可留下，她要做的牺牲很大，就是忍受队友的误解，甚至是永久的（如果没人出来解释的话）。可可自己扛下了一切也是猛得很，可可现在才是最焦虑的，但她要反过来安慰堇。别看可可最后抱堇一副稳得一批的宠爱，猜都能猜到回国的问题根本没解决，后面还要怎么扛？完全是打心态仗了，梭哈自己能赢。感受一下，这两个人不是香哥哥渐渐成长的强大，而是在突然爆发的事件中霸气侧漏。&emsp;&emsp;感到惊奇的一点是一年级四人去找堇的时候，传达她们主动放弃上台的心意，用的是一段和声。虽然这个和声的旋律我听不出什么东西（需要请专业人来分析），不知道这能不能表达她们的感情。&emsp;&emsp;后面可可抱堇哭的时候，喊了两遍“嫌いだ”，然后接一个“大好き”。有没有觉得很熟悉？没错就是香音的《青空を待ってる》，唱了三段的“嫌いだ”再突然转变接一段“大好き”。这首歌我当初喷它小百合套着一个半熟不熟的理解就开始唱了，歌词隐晦得很，很难抒发真正的感情。在第九话里套用了这个格式，播到这里，我就想，这首歌给可可唱一遍会怎样，但是发现不太行，因为可可对堇没有根本的嫌い，堇不是对可可造成了什么长期伤害的。所以可能只是套用了个格式，换了一种感情。&emsp;&emsp;从第七八话过渡到第九话会有点突然，感情上是突然上了一大个台阶。如果能把这话拆成两话，用一话时间慢慢把感情铺上去，又会好很多。感情戏以细腻为佳，突然爆发的话得有足够的伏笔才能精彩。&emsp;&emsp;比较主要的问题（也是之前的问题一路继承下来）是，已经不仅仅是把偶像番写成竞赛番了，这个 vn 一来，快要把竞赛番变成战斗番了。sunnypa 被 vn 杀掉，以及幽灵般地向香音喊话，这个 vn 拉满一股神秘大 boss 的味道。sunnypa 惨死区域赛的剧情我熟不熟？可太熟了，19 沈阳万众瞩目的隐练一年的业余门槛突然就被假题杀掉了，21 广州我们队滚到铜牌区了，22 两场中国 Final 一滚榜把一众强队和暴发户都刷掉了（逆十字甚至因为设备原因退赛了）……大家惊讶的眼神不就跟看到 sunnypa 没出线是一样的吗？竞赛党这些是见得多了，但是学园偶像真的要这么玩吗？毕竟我们的目的可以是赢得比赛，但是你们的目的是传递真感情，你们太过功利，就什么都传递不出来了。&emsp;&emsp;如果有人被竞赛剧情吸引了，想要体验一把团结一致冲击比赛的快(tong)乐(ku)，欢迎来玩中学信息学奥林匹克竞赛和大学生程序设计竞赛！（x \\\\ \\\\&emsp;&emsp;9.16 生放，解读 7 8 话。&emsp;&emsp;多看看 non 酱这个细节鬼才吧，她是真的会观察，会分析。 “恋酱的沉迷游戏，反衬出她以前严肃的一面，让我惊叹她以前到底是个多认真的人。” “慌张被抓的人都献出培根蛋面包。” 还有各种对比和衬托的应用 &emsp;&emsp;讲到了很多关于第八话歌的祭り感。挑出来两个画面很好地表达了这首歌的感情，一个是香哥哥飒爽的笑容，体现的是浓厚的欢乐的祭り氛围，另一个是小千的跳跃，拉出全队的满满自信。&emsp;&emsp;我时刻提醒自己，我们千万不要用“我比声优和制作组还懂动画”的态度来发表评论。这不是说他们的分析和评价不可反驳，而是从他们视角出来的东西，应当引起重视和思考。 \\\\ \\\\&emsp;&emsp;第 10 和 11 话可以放在一起，和 vn 正面对刚探讨 lovelive 和歌唱的意义。我非常期待这个的，并且也很期待在面对弱 motivation 而强能力者的时候，她们要怎么办。编剧的回答是，赢下来，并且赢得十分坚定，香哥哥这次没有犹豫了，正面指出 vn 的歌曲不如她们能传达“连结大家，分享喜悦”的内涵。&emsp;&emsp;小千和香哥哥在比赛后找 vn 的行为以及她们的想法，也都体现出结丘精神，不会放弃任何一个人的梦想，就像当初无论输赢也不能不让一年级上场一样。这里其实是对这种精神的扩大了，不仅是对于队内人，还是对于对手，与她们无关的人。&emsp;&emsp;那么一个巨大的矛盾点就再次出现了（这不是第一次出现了）：梦想的互斥。第一次是 sunnypa 要卫冕冠军，光荣而退，只可惜半路被 vn 杀掉。这次是第二次，要么 liella 代表全体结丘学生一起胜利而 vn 没学上，要么 liella 失败而 vn 成功上学。你看，编剧其实够大胆的，在这种团结一致的结丘精神下，接二连三出现这样的互斥事件，用残酷的比赛框架，去捶打考验结丘精神。所以说这部剧现实得很对吧，你总是要思考这些问题，这些时时刻刻、无处不发生的问题。 \\\\ \\\\&emsp;&emsp;9-12 话的生放讨论找个时间把熟肉补了再一次过发吧，日语不好，看生肉只看懂个大概。（挖个坑在这里） \\\\ \\\\&emsp;&emsp;12 话了，终于完结了。然而，大家的感受，包括我的感受都是“终于解放了”，而不是“呜呜呜没有 13 话我要死了”。很多因素，包括动画的质量下降了，评论恶臭了，每周上贴吧 b 站 q 群什么的都是一群牛鬼蛇神在声讨。我虽然努力去让每一次看动画都是心态稳健平和的，但是评论环境实在太糟糕，多多少少是影响了自己的观看和思考的。所以我也要庆祝，与其三个月每周忍受不堪入目的评论，不如早点结束，你好我好大家好，大家重新对下一项作品充满期待，回到正轨。&emsp;&emsp;先说 12 话。我的感受是不算很好。主要原因是这是最终话，一个故事的结尾，要求当然跟中间是不一样的，中间的作用是推动情节发展，烘托氛围，塑造人物形象，到了结尾，你铺垫的就该结束了，感情就该有收尾的样子了，但是这次最后的 Lovelive 决赛并没有赢出感觉来。&emsp;&emsp;先从感情来分析。横向对比往届的 Lovelive 决赛就知道了，不难发现，任何一个团（包括星团）在决赛之中都会掺入比赛之外的感情，缪是成员毕业、团队即将解散，水是学校关闭，以及对未来的迷茫，其感情都是留念、不舍，对曾经一起度过的生活道别；星这里则是为了不落下香音和 vn 的梦想，要暂停 9 人团队，有些许不舍，也有对决赛胜利从而实现她们梦想的信念。显然编剧也意识到了，光有一个比赛目标的话对于感情来说是绝对不够的，而附加一些别的感情在上面，就是最为有效的打造感情的方式。但问题是什么？是铺垫。感情以细腻为佳，一条连贯而不断发展的感情线会非常重要。我认为缪和水都做得非常好。水采用了最简单的方法——长度，把感情线拉长，她们大概集数过半就已经确定废校了，也就是说有将近一半的时间用来表现失落、苦闷、迷茫、探索、重新找到自己的价值，中间还插入了两话的雪的失败，两份失落叠加（一个额外的效果是借此把两位妹妹的成长塑造得淋漓尽致）。在这之中，每一处停顿都感觉时间像停下来了的样子，这就是感情氛围起作用了。缪真正开始她们的矛盾其实很晚，也同样差不多第 10 话才开始，也到 11 话结尾才把解散点出来，但是她们主要告别的是她们作为 μ’s 团体所度过的时光，所以前面 4-7 话的个人日常回、8-9 话的团体挑战，都是与矛盾相关的，就能起到很好的铺垫作用，这样让整个感情线流畅地呈指数函数形状发展，在 11 话迎来爆发，然后两话收尾。来到星这边，注意到星的附加矛盾其实是比较转折的，是突然间来了个 vn 跟你说你被 MIT 录取了，并且我要依附于你才能上学，前面的主线则是 Liella 一行人承载学校大家的梦想一起努力，因此对这个突然出现的矛盾点就没有铺垫，也就是说，这份附加的感情总共就出现了两三话，加之“维也纳音乐学院”这个音乐界 MIT 相关的剧情都有点荒诞不自然，感情当然也就不够细腻。&emsp;&emsp;然后是歌。这是星 2 老问题了，歌曲曲风、歌词、感情基调都与剧情弱相关，到了决赛这里，放一首抒情慢歌，那么它自然也表达不了决赛或者是最终话应有的感情高潮。这首歌更适合作为平常的插入歌，并且最好是不以比赛的形式展现，增加一点音乐剧的样子，会非常好。横向对比缪水也是同样的，水的决赛歌是水蓝，歌词和舞蹈动作是很强烈的“告别过去，向新的未来进发”的寓意，这就是对将近半季的失落苦闷迷茫探索的回答，作为最终曲目是一个完美的总结；缪的是 kirakira session，单论这首歌我觉得其实也不算很好，歌词是合适的但曲调则是偏平静了，没有非常契合 11 话强烈的感情，但缪的亮点我认为不是这首决赛曲，而是紧接其后的安可，亮出 op1，这才是从音乐上对决赛感情的升华，两首歌结合，有慢有快，有静有烈，op1 也是适合 call 的曲，所以能把气氛抬起来。&emsp;&emsp;基本上就是这两个最大的问题了。&emsp;&emsp;也还有些其他问题，比如小千笑着流泪竟然只是请求；比如 vn 直接向现状屈服，不再打算通过自己的努力去获得入学资格了。&emsp;&emsp;这个开放结尾，如果你要现实，我甚至可以说留学中止是因为疫情原因（x 关于别人&emsp;&emsp;顺便说一下贴吧b站的追番评价。&emsp;&emsp;可以说我大部分评价跟他们很不同。他们的文学鉴赏能力，从吐槽 Aqours 的剧情不合理就可见一斑了，大抵是高中语文也没有好好学，基本的意识流心理描写都不会读。很多时候给点整活就说是神回，剧情平淡一些、live 没有优胜就说是烂回，咬死一个人设，觉得人物性格不可更改不可成长（夸一夸大学语文老师反驳“文学作品忌讳人设崩塌”的精彩发言），夸张和心理现实主义写法被喷为不合逻辑。能从感情矛盾、人物塑造、表现手法等来分析的实在是少数。&emsp;&emsp;我一直认为，如果不会赏析，就翻一下高考语文练习册，复习一下高考语文阅读理解，应该任意一本练习册都有提供一套详细的框架和套路的。这实在是最简单通用的、拿来就用的方法了，不需要你再去学更高级的文学理论，各种主义和体系的分析，也不需要你学哲学和美学，去参透更深层的思想。但明明大家都是考过高考语文的人了，甚至都在瞧不起高考应试套路了，却连一套赏析方法都没能掌握，怪。&emsp;&emsp;也有自诩看番无数的“老二次元”以自己的资历为支撑来开喷。但看番资历不应成为评价理由，资历培养出来的观感若不能转化成成体系的分析和评价标准，那其实还是自己的感情和主观认识在主导，它不能叫评价，说白了就是你看番时心情不好。 \\\\ \\\\&emsp;&emsp;第五话第六话确实出了一些问题，但我觉得各大平台的环境噪音影响太大了。将来需要找个时间从头到尾地重看一遍星Ⅱ。 &emsp;&emsp;发现对于“人设”的评价属实有点泛滥了。我仍然坚持大学语文老师的观点，不要在评论中引入“人设有没有崩”这种东西，扼杀人物形象性格多样性实在荒谬得很，你顶多能分析分析多种形象性格是不是没有很好地衔接。 \\\\ \\\\&emsp;&emsp;本来只是简单地觉得这届观众应该好好看看 2022.8.27 的生放对于第 4 5 6 话的解读，但是看到 10 组熟肉下的评论，竟然充满着“聊天和来信都是第 4 话的，第 5 6 话都没有，可想而知这两话有多烂”这样的言论。我终于明白，这些人连看生放熟肉都是有眼无珠的，星Ⅱ期间再也不要看 lovelive 吧和 b 站视频的评论了，充斥着瞎 jb 看两眼就大放阙词的人。 \\\\ \\\\&emsp;&emsp;搞半天原来大家还有“声优盾”这个想法在，这可能是大家从根本上看不进去生放的原因了。我觉得，你们最好是拿出些能锤的证据来，不然如此随意地揣测别人的想法，你们不觉得很不尊重人吗？为什么可以这么随意地用自己心中恶心的想法来代表别人？&emsp;&emsp;并且最最重要的，不论她们到底是不是真心给出的分析和讨论，她们说出来的话对不对才是重点吧？那她们的分析和来信写的难道不正确吗？没有那些细节吗？这些不足以引导你去读懂这部番吗？ end&emsp;&emsp;这部剧到这里算是落下帷幕了。&emsp;&emsp;它是一部正常普通的番，可赏之处很多，直面了很多现实问题，引起我很大量的思考。&emsp;&emsp;网友们指出的一些问题是存在的，比如香音小千二人主导了过多事情导致团队内的羁绊塑造较弱，以及我这长篇大论总结的一些问题，导致它不会成为一部很优秀的番。总的来说，商业气味很浓，浓过头了，最主要的体现就是歌曲和剧情的弱相关，像是上头对编剧说，你这话要插一首歌，至于歌曲是什么，我不知道，可能还没写好，但你这里要插首歌。所以最方便的做法，就是比赛，比赛，不停地比赛，以比赛这个万金油平台，把歌曲都塞进去。&emsp;&emsp;追番过程实在是艰难，太多被迫激起的激昂和思考了，于是有了这篇博客。其实明知这样是不好的，应该整部番看完一并评论，而不是看一话就发表一话评论，这样才有更全局整体的思考。&emsp;&emsp;反正确定第三季了，第二季给我最大的教训就是，以后绝对不能冲动地看完一话就来看大家评论了。当然如果完全不在乎评论的话那就甚至不需要追番，缓冲一下几话几话地看，应该效果更好。&emsp;&emsp;倒也感谢这些评论，鞭策我看完了第一本美学哲学教材，也确定了接下来的美学哲学读本和文学理论的读本了。 外部链接&emsp;&emsp;推荐这个关于香音的分析，以及这位 up 主的其他投稿。这位 up 是有认真分析的，关于香音的双重性格讲得很棒。","categories":[{"name":"玩","slug":"玩","permalink":"http://kqp.world/categories/%E7%8E%A9/"}],"tags":[]},{"title":"2021 EC Final 退休游记","slug":"2021_EC_Final","date":"2022-07-22T06:37:00.000Z","updated":"2024-04-24T03:59:22.772Z","comments":true,"path":"2021_EC_Final/","link":"","permalink":"http://kqp.world/2021_EC_Final/","excerpt":"“你们不是已经毕业了吗？” ——遇到的所有熟人","text":"“你们不是已经毕业了吗？” ——遇到的所有熟人 &emsp;&emsp;其实得知我们要去 EC 是一点都不惊奇的，毕竟大四这个赛季打也打了，金也拿了，我校也还没在区域赛出线，所以必然要被抓壮丁，且被寄予出线的厚望的（x&emsp;&emsp;反正本科的课业全部结束了，无人之境也没有晋级、荣誉的压力，所以去比赛也不过是娱乐消遣、毕业旅行。我们三个人好像都已经把竞赛当闲时爱好了，心态上很放松，也没训练。就是可怜 zayin 请假几千几千地亏，邓老板牺牲了跟同学去青海的机会，亮亮损失了在成都陪女朋友的时光，nurivf 一直在修论文，好像只有我游手好闲（？&emsp;&emsp;本来我校是5个正式+2个打星，结果后来打星也转正了，变成7支队伍浩浩荡荡，一个大军团，占 EC 总队伍数的约 2% 7.12~7.17&emsp;&emsp;EC 前的一周集训，华为请我们去松山湖训练，题还是我们自己找，但吃住是他们负责的，顺便让他们给我们插点宣传。&emsp;&emsp;于是就二刷了松山湖欧洲小镇。这次是深度游览，体验园区内的饮食，坐小火车上下班。住的酒店非常豪华，还能免费洗衣服。不过不包晚餐，要我们自己去各饭堂体验，对于完全不想花钱的我并不友好，宁可他晚餐也发盒饭。。。&emsp;&emsp;问华为员工推荐食堂，宣讲嘉宾说吃多了都没意思，左左说不知道，yxuanwkeith 夫人说 KFC（&emsp;&emsp;华为 ICT 搞的这个 Auto Driving Network，总有点标题党的感觉。。。&emsp;&emsp;去年在欧洲小镇泡了一天，就有了相当的欧气一发抽出 AC1 黛，这次浸润 3 天之后，僕光Ⅱ、ns 一年级一上线就开抽，十分顺利地抽出了 4 个 20n 复读机配件，平均 125 心一张卡。给欧洲小镇点赞。 &emsp;&emsp;做了 5 套题，一套签到练习，两套省赛，两套外国自闭场，康复效果不错。最后的午餐去打 bytecamp，感受了一下，都是好题，他们那是真正的 camp。 &emsp;&emsp;见证了西安临危不惧镇定从容地把疫情处理干净，也见证了从广州到东莞之后广州、东莞疫情相继炸开。换在精准防控时代以前，我们这趟行程就是各种勇闯毒区。&emsp;&emsp;从东莞回来是 17 号下午，正值广州萤火虫漫展，遂快乐逛外场，与 staff 朋友见最后一面。一开始校队还商量 18 号白天先逛了萤火虫晚上再去西安来着（x 7.18&emsp;&emsp;飞机是中午的，不用挤地铁，好评。&emsp;&emsp;在西安的高速出口被拦截，工作人员一看行程码，说：“广东省广州市，广东省东莞市，全是中高风险。”于是做了一大票登记，花费半小时。&emsp;&emsp;发现酒店是去年华为晚宴的酒店，感觉不祥。不过环境挺好，房间表面上也不错的，开房的时候看到标双价格是 800+ 一晚。当晚的晚餐是在围栏处领取盒饭，外面排队报到的人，和里面排队拿饭的人，互相都像看猴一样。&emsp;&emsp;想补一个题，拖拖拉拉地还是没补完。&emsp;&emsp;得益于50G/月的流量套餐，成为全队外出流量担当，并得知酒店的网十分炸裂。 7.19&emsp;&emsp;早餐有面和豆腐花，还有一大堆凉菜，没有 coffee。总体来说质量可能跟去年华为晚宴是一样的，但早餐跟正餐评价体系不一样，所以感受是略有进步。然而豆腐花竟然是酸的，感到十分震惊。&emsp;&emsp;午餐的菜品十分少，廉价感十足，这就又回到了华为晚宴的质量了。联想到比赛场地叫“御宴宫”，突然绷不住了，当即创作了一个“御宴丁真，鉴定为油饼”。不过好像大家不混贴吧，不太玩丁真梗。。。 &emsp;&emsp;下午宣(chou)讲(jiang)。先去了元戎启行打算抽机键，结果发现要提问回答才能拿奖，于是把 6 张虾皮券集中到欧主力手上，派他去看看 switch，我们留守元戎。结果得知要扫二维码签到且没有 switch，我就扫了二维码，元戎结束后去虾皮第二场看看情况，然而签到码只能扫一次，于是第二场没有资格抽奖，空手而归。&emsp;&emsp;后来才知道我第一场中了蓝牙音箱，但是人不在场，被 skip 了。。。 &emsp;&emsp;热身赛，观察环境，斜对角是胖头鱼头胖，斜前方是小万邦和冰泮北徂。&emsp;&emsp;登录进去发现有二次元（&emsp;&emsp;开场写个 A 题，然后队友直接跟我说，C 题你这样处理一下字符串，然后跑个 Manacher 就行了，我题都没读，直接开冲，过了才大概知道题意（&emsp;&emsp;面基胖头鱼头胖，结果没认出 Howard Li（ &emsp;&emsp;晚餐依旧是菜品非常少，廉价感十足。发现他们对蒸鱼非常自信，总要在没菜的时候端一锅这样的鱼出来。身为天天吃鱼的广东人，只能说精神可嘉。&emsp;&emsp;晚上参加华为宣讲错过水生放的两首新歌试听。发现前面一群纪中人聚会。。。pku、tju、hkust、scut、hdu，加上我 sysu，10 个人左右了，太辉煌了。&emsp;&emsp;学弟们以及其他熟人见到我，第一句话都是：“你不是已经毕业了吗？” 7.20&emsp;&emsp;吃一大碗酸豆腐，带两瓶咖啡，开场。&emsp;&emsp;签个 I 题，讨论一下，但是去重写错了，获得首红。&emsp;&emsp;很快 A, L 也签完了。&emsp;&emsp;读完 G, H，zayin 表示都有印象，甚至是出过的。判断是 G 简单些，于是想了个构造：先用 bfs 把确定的填完，然后第一行第一列放 $B$，其余依次填。我觉得这个构造有点假，因为黄大爷曾经出过类似的题是要用行和列来构造的，但 zayin 还是先去写了一发，WA 掉。&emsp;&emsp;然后邓老板会了 J，zayin 会了 B，我们讨论出 C 的一个容斥+dp 的做法。B 过得顺利，J WA 后觉得变量定义有点乱，队友们一直在讨论。期间我写 C 发现假了，想写些“迟早要写”的东西发现也很麻烦，遂去读 E。&emsp;&emsp;J 查错无果，遂弃，邓老板完善 D 的想法，我和 zayin 讨论 E。E 非常多 corner case，讨论出大致框架就开冲了，一路 WA 一路修，幸运的是最终集齐了所有 corner case 过了。期间 J 修了两个 bug 过了，D 也讨论清楚开始写了。&emsp;&emsp;后来就是 D 一路写到封榜后，补上一个漏了的 corner case 后过掉。期间 C 一直假，最后扫了一眼 G 和 H，zayin 突然会了 H 的建图，最后 13min rush，赛后一分钟过样例。 &emsp;&emsp;刚出考场感到非常遗憾，因为算了算 8 题出线概率比较大，7 题就基本没戏了，所以如果 H 真的赛后 1min，那就痛失出线了，zayin 哀嚎。我也有一种非常可惜的感觉，但并不深刻，本身就没奔着出线来的，能在强队如云的 EC 不怎么训练还混到金就不错了，没想到好像还混得挺前，真要是过了 H 出了线，谁研二还要打 final 啊~&emsp;&emsp;但其实我们队本质上都是乐子人心态了，这样的遗憾如果放在大三及以前，我们估计会以头抢地，但这次，其实也就是哀嚎两声，平静得很快，以至于后来有民间榜说我们也出线了，心态也都没啥波动了。 &emsp;&emsp;滚榜发现一众强队出线队都寄了，排在我们前面的都是清北浙南+一两支突出的队伍。大家都跟我们一样是爆发户？还是战线太长大家都不想训练了？现在就是清北浙南这些学校集中排在各大赛站前排，使得榜上 10 多名的队伍还能有不错的校排成绩。&emsp;&emsp;然后关于题目，分类讨论的浓度实在太高了。从 I 签到就开始讨论，E 超级大讨论，D 也要讨论，好像就是大半场都在听队友讨论，帮队友梳理讨论。其他题 debug 时想 corner case 也会加重这一感受。&emsp;&emsp;知乎上好像都是关于环境酒店的吐槽，没有对题目的评价。&emsp;&emsp;对于我来说，又是一次被队友带飞的比赛。全程就是开场签了个到，然后胡说八道四小时躺了个金。E 主要还是在听和 check，D 姑且算是提供了一个 corner case。&emsp;&emsp;后来发现我们 rush 的 H 的做法还是有问题的，建出二分图是对的，但后面应该求最大独立集而不是黑白染色。这题在赛场上估计还要半小时，WA 一次，才能意识到这个问题。所以我们的整体节奏还是慢了许多，并不是少了一两分钟的遗憾。我们花在 C 上的时间非常多，并且大部分时间是判断 G 比 H 简单，导致花在 H 的时间是不够的。 &emsp;&emsp;虾皮最后黑幕钦定 switch。&emsp;&emsp;浅体验了下新的华为晚宴，之前华为 hr 说敲打了酒店必须做出重大改进，最后质量是合格了，但要说一桌 1000，那不如去抢。&emsp;&emsp;晚上快乐逛市区。大雁塔南侧建了条商业街叫大唐不夜城，十分奇怪，根据初中历史，大唐的长安是宵禁的而且严格管控商业，在大唐搞不夜城你是想被杀头吗？&emsp;&emsp;登上城墙，但无法眺望长安城。只走了 1/4 段，要是有充足时间走完它就好了。感觉西安这个城很厉害，用古代城墙包住现代市区，高楼大厦、旧市区建筑、古风建筑、洋式建筑就这么交在一起。 End&emsp;&emsp;体会最深刻的还是心态变化了。最早大一大二是激情洋溢地打比赛，大三崩溃过所以是半热情半烦躁地过着，大三后期以及大四，因为没有压力了，就是以一种业余爱好的心态在参与。所以乐呵呵地来，乐呵呵地走。&emsp;&emsp;可能这次最受伤的是亮亮了。最后的午餐这年非常努力，有在认真训练，但最终都没能有出线的机会。前几场区域赛还有些策略问题，比如有人一个题自闭一整场没人救，但最后昆明区域赛，没有太多策略问题了，是凭实力自闭了。欧主力和梁主力如果想打还有两年，并且下一届还能招到 NOI 银水平的一众新大一，但是亮亮的竞赛就结束了，他做了很多事情来提升水平，包括用一年时间与水平一般的队友组队练 carry 能力，最后赌上大四，输了。&emsp;&emsp;其实以我校的训练强度和水平，冲出线并不稳定，还得有一定的运气因素，得恰好选到一个没什么人的赛区，恰好没有重大失误。大四这一年，各赛区都有稳定强队和暴发户强队，没有上一年的济南昆明这种赛区了。 &emsp;&emsp;再说些杂的。引用我校教练的观点，疫情的 xcpc，特点就是战线拉得特别长，到了后期，大家都累。有的队伍仍然坚持一周四训甚至一周六训，但应该更多的学校，氛围会逐渐变差。战时氛围跟备战下一赛季的氛围是不一样的，前者紧张得多，消耗的精力也会大。而且占用太多课余时间，没时间去体验科研等其他事情，这也不好。 &emsp;&emsp;后面还有 ccpc final 和 world final，打完，就可以写退役记了，这就是真退役了。希望孟加拉还是能去线下。","categories":[{"name":"总结与游记","slug":"总结与游记","permalink":"http://kqp.world/categories/%E6%80%BB%E7%BB%93%E4%B8%8E%E6%B8%B8%E8%AE%B0/"},{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[]},{"title":"【AtCoder Grand 029F】Construction of a tree 题解","slug":"【AtCoder Grand 029F】Construction of a tree 题解","date":"2022-06-17T06:58:32.000Z","updated":"2024-04-24T03:59:22.824Z","comments":true,"path":"【AtCoder Grand 029F】Construction of a tree 题解/","link":"","permalink":"http://kqp.world/%E3%80%90AtCoder%20Grand%20029F%E3%80%91Construction%20of%20a%20tree%20%E9%A2%98%E8%A7%A3/","excerpt":"题目大意&emsp;&emsp;设全集为 $\\{1,2,\\cdots,n\\}$，给出 $n-1$ 个子集 $E_1,\\cdots,E_{n-1}$，$|E_i| \\ge 2$，请从每个子集中选出两个元素，视为给两个节点连一条边，使得最后构成一棵树。&emsp;&emsp;输出一种方案或是“-1”表示无解。 &emsp;&emsp;$n \\leq 10^5,\\ \\ \\sum |E_i| \\le 2 \\times 10^5$&emsp;&emsp;4s","text":"题目大意&emsp;&emsp;设全集为 $\\{1,2,\\cdots,n\\}$，给出 $n-1$ 个子集 $E_1,\\cdots,E_{n-1}$，$|E_i| \\ge 2$，请从每个子集中选出两个元素，视为给两个节点连一条边，使得最后构成一棵树。&emsp;&emsp;输出一种方案或是“-1”表示无解。 &emsp;&emsp;$n \\leq 10^5,\\ \\ \\sum |E_i| \\le 2 \\times 10^5$&emsp;&emsp;4s \\\\ \\\\ \\\\题解&emsp;&emsp;这种觉得好像是流但看上去不是很能流最后又确实是流的题真的一流。。。 &emsp;&emsp;考虑必要条件，一棵树去掉根以后，边和点可以一一对应（每个点跟它连向父亲的边对应），因此建一个二分图，左边是 $1,\\cdots,n$ 表示节点，右边是 $E_1,\\cdots,E_{n-1}$ 表示边，那么左边去掉根节点之后应当有完美匹配。并且这是一棵无根树，所以左边去掉任意点以后都应当有完美匹配。&emsp;&emsp;然后看看这个条件充不充分。有完美匹配以后我们还需要的是整个图连通，也就是根节点可以到达其他所有点，也就是从左边的根节点开始，沿着“非匹配边-匹配边-非匹配边-……”的交错路能遍历所有的点。题解证明了这是成立的：因为“左边去掉任意点以后都有完美匹配”，所以任取非根节点 $x$，把去掉它的完美匹配与去掉根的完美匹配并起来，这样除了根和 $x$ 外所有点的度数都是 $2$（因为每个点都连了两条匹配边，只有根和 $x$ 连了一条匹配边）。现在全图只有根和 $x$ 度数为 $1$，那它们必然在同一个连通块里，因为连通块的总度数一定是偶数。所以根和 $x$ 是连通的。&emsp;&emsp;因此，“有解” $\\to$ “左边去掉任意点都有完美匹配” $\\to$ “任意求一个完美匹配，从左边的根节点开始，沿‘非匹配边-匹配边-非匹配边-……’做 BFS，可以遍历所有的点”，并且这样也就构造出一组解了。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include&lt;bits/stdc++.h&gt;#define fo(i,a,b) for(int i=a;i&lt;=b;i++)using namespace std;const int maxn=1e5+5, maxsum=2e5+5, maxe=4e5+5;int n,m;vector&lt;int&gt; S[maxn];vector&lt;int&gt; e[maxn];int dis[2*maxn],pt[2*maxn],maxdis;bool Hopcroft_bfs() &#123; memset(dis,255,sizeof(dis)); maxdis=-1; queue&lt;int&gt; Q; fo(i,1,n) if (!pt[i]) &#123; Q.push(i); dis[i]=0; &#125; while (!Q.empty()) &#123; int cur=Q.front(); Q.pop(); for(int go:e[cur]) if (dis[go]==-1) &#123; dis[go]=dis[cur]+1; if (!pt[go]) &#123; maxdis=dis[go]; continue; &#125; else &#123; dis[pt[go]]=dis[go]+1; Q.push(pt[go]); &#125; &#125; &#125; return maxdis&gt;-1;&#125;bool Hopcroft_dfs(int k) &#123; for(int go:e[k]) if (dis[k]+1==dis[go]) &#123; dis[go]=-1; if (!pt[go] || Hopcroft_dfs(pt[go])) &#123; pt[k]=go, pt[go]=k; return 1; &#125; &#125; return 0;&#125;int Hopcroft() &#123; int re=0; while (Hopcroft_bfs()) fo(i,1,n) if (!pt[i]) re+=Hopcroft_dfs(i); return re;&#125;bool vis[maxn];pair&lt;int,int&gt; ans[maxn];int main() &#123; scanf(&quot;%d&quot;,&amp;n); fo(i,1,n-1) &#123; int sz,x; scanf(&quot;%d&quot;,&amp;sz); fo(j,1,sz) &#123; scanf(&quot;%d&quot;,&amp;x); e[x].push_back(n+i); S[x].push_back(i); &#125; &#125; if (Hopcroft()!=n-1) &#123;puts(&quot;-1&quot;); return 0;&#125; int root; fo(i,1,n) if (!pt[i]) &#123;root=i; break;&#125; queue&lt;pair&lt;int,int&gt;&gt; Q; for(int x:S[root]) &#123; vis[x]=1; Q.push(make_pair(root,x)); &#125; while (!Q.empty()) &#123; auto cur=Q.front(); Q.pop(); int son=pt[n+cur.second]; ans[cur.second]=make_pair(cur.first,son); for(int x:S[son]) if (!vis[x]) &#123; vis[x]=1; Q.push(make_pair(son,x)); &#125; &#125; fo(i,1,n-1) if (!vis[i]) &#123;puts(&quot;-1&quot;); return 0;&#125; fo(i,1,n-1) printf(&quot;%d %d\\n&quot;,ans[i].first,ans[i].second);&#125;","categories":[{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[{"name":"算法_网络流/匹配","slug":"算法-网络流-匹配","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E7%BD%91%E7%BB%9C%E6%B5%81-%E5%8C%B9%E9%85%8D/"}]},{"title":"【AtCoder Regular 141D】Non-divisible Set 题解","slug":"【AtCoder Regular 141D】Non-divisible Set 题解","date":"2022-05-31T08:45:50.000Z","updated":"2024-04-24T03:59:22.829Z","comments":true,"path":"【AtCoder Regular 141D】Non-divisible Set 题解/","link":"","permalink":"http://kqp.world/%E3%80%90AtCoder%20Regular%20141D%E3%80%91Non-divisible%20Set%20%E9%A2%98%E8%A7%A3/","excerpt":"题目大意&emsp;&emsp;给定长度为 $n$ 的序列 $a_1,\\cdots,a_n$ 和一个参数 $m$，对于每个 $i$，问是否能从序列中选出满足如下条件的子集： 集合包含 $a_i$； 集合大小为 $m$； 集合内不存在一个数是另一个数的倍数。 &emsp;&emsp;$m \\le 3 \\cdot 10^5,\\ m \\le n \\le 2m$&emsp;&emsp;$1 \\le a_1 &lt; a_2 &lt; \\cdots &lt; a_n \\le 2m$&emsp;&emsp;2s","text":"题目大意&emsp;&emsp;给定长度为 $n$ 的序列 $a_1,\\cdots,a_n$ 和一个参数 $m$，对于每个 $i$，问是否能从序列中选出满足如下条件的子集： 集合包含 $a_i$； 集合大小为 $m$； 集合内不存在一个数是另一个数的倍数。 &emsp;&emsp;$m \\le 3 \\cdot 10^5,\\ m \\le n \\le 2m$&emsp;&emsp;$1 \\le a_1 &lt; a_2 &lt; \\cdots &lt; a_n \\le 2m$&emsp;&emsp;2s \\\\ \\\\ \\\\题解&emsp;&emsp;如果建出一个“倍数关系图”，那么每次询问就是去掉一个点之后求最大独立集，这就很不可做，所以这个倍数关系一定是要利用的。&emsp;&emsp;子集大小为 $m$ 而每个数最多只有 $2m$，看着就有玄机，只是没想到竟然是这样用的。。。 &emsp;&emsp;每个 $a_i$ 可以表示成 $2^c \\cdot d$，其中 $d$ 为奇数。按照 $d=1,3,\\cdots,2m-1$ 把所有的 $a_i$ 分门别类放好，这样总共有 $m$ 个类，且每个类最多只能选 1 个数，又因为最后要选 $m$ 个数，因此每个类恰好选一个数。&emsp;&emsp;考虑如果选了 $2^{c_1}d_1$ 和 $2^{c_2}d_2$，如果 $d_1 | d_2$，那么必须有 $c_1 &gt; c_2$。因此直观来看，$d$ 较小的类 $c$ 应该较大，$d$ 较大的类 $c$ 应该较小。因此可以用 $O(m \\log m)$ 的时间从左到右、从右到左分别求出每个类的 $c$ 的上限和下限，那么只要夹在上限和下限之间的数都一定是可行的（比它小的类全部选上限、比它大的类全部选下限即可）。 &emsp;&emsp;虽然它真的很巧妙，不过似乎只能用于判断 $m$ 为“$d$ 的种类数”是否可行。能用于判断比这更小的 $m$ 是否可行吗？ 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;bits/stdc++.h&gt;#define fo(i,a,b) for(int i=a;i&lt;=b;i++)using namespace std;const int maxn=6e5+5, maxm=6e5+5;int n,m;vector&lt;pair&lt;int,int&gt;&gt; V[maxm];void Invalid() &#123; fo(i,1,n) puts(&quot;No&quot;); exit(0);&#125;int L[maxm],R[maxm],lim[maxm];bool ans[maxn];int main() &#123; scanf(&quot;%d %d&quot;,&amp;n,&amp;m); fo(i,1,n) &#123; int a; scanf(&quot;%d&quot;,&amp;a); int er=0; while (!(a&amp;1)) a&gt;&gt;=1, er++; V[a].push_back(make_pair(er,i)); &#125; for(int i=1; i&lt;2*m; i+=2) if (V[i].empty()) Invalid(); memset(lim,127,sizeof(lim)); for(int i=1; i&lt;2*m; i+=2) &#123; if (lim[i]&lt;=(V[i].begin())-&gt;first) Invalid(); R[i]=(lower_bound(V[i].begin(),V[i].end(),make_pair(lim[i],0))-1)-&gt;first; for(int j=i*3; j&lt;2*m; j+=i+i) lim[j]=min(lim[j],R[i]); &#125; for(int i=2*m-1; i&gt;0; i-=2) &#123; int lim=-1; for(int j=i*3; j&lt;2*m; j+=i+i) lim=max(lim,L[j]); if (lim&gt;=(V[i].rbegin())-&gt;first) Invalid(); L[i]=upper_bound(V[i].begin(),V[i].end(),make_pair(lim,n+1))-&gt;first; &#125; for(int i=1; i&lt;2*m; i+=2) for(auto p:V[i]) ans[p.second]=(L[i]&lt;=p.first &amp;&amp; p.first&lt;=R[i]); fo(i,1,n) puts(ans[i] ?&quot;Yes&quot; :&quot;No&quot;);&#125;","categories":[{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[{"name":"算法_神奇的脑洞","slug":"算法-神奇的脑洞","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E7%A5%9E%E5%A5%87%E7%9A%84%E8%84%91%E6%B4%9E/"}]},{"title":"【AtCoder Grand 037D】Sorting a Grid 题解","slug":"【AtCoder Grand 037D】Sorting a Grid 题解","date":"2022-05-07T07:43:17.000Z","updated":"2024-04-24T03:59:22.827Z","comments":true,"path":"【AtCoder Grand 037D】Sorting a Grid 题解/","link":"","permalink":"http://kqp.world/%E3%80%90AtCoder%20Grand%20037D%E3%80%91Sorting%20a%20Grid%20%E9%A2%98%E8%A7%A3/","excerpt":"题目大意&emsp;&emsp;给定一个 $n$ 行 $m$ 列的矩阵，里面的元素是 $1,\\cdots,nm$ 每个恰好出现一次。依次执行以下操作： 对每一行任意重排； 对每一列任意重排； 对每一行任意重排， 使得最后矩阵第 $i$ 行第 $j$ 列恰好是 $i(m-1)+j$。输出一种方案（第 1 步和第 2 步后的结果）。可证明一定有解。 &emsp;&emsp;$n, m \\le 100$&emsp;&emsp;2s","text":"题目大意&emsp;&emsp;给定一个 $n$ 行 $m$ 列的矩阵，里面的元素是 $1,\\cdots,nm$ 每个恰好出现一次。依次执行以下操作： 对每一行任意重排； 对每一列任意重排； 对每一行任意重排， 使得最后矩阵第 $i$ 行第 $j$ 列恰好是 $i(m-1)+j$。输出一种方案（第 1 步和第 2 步后的结果）。可证明一定有解。 &emsp;&emsp;$n, m \\le 100$&emsp;&emsp;2s \\\\ \\\\ \\\\题解&emsp;&emsp;一些简单的推导：把一个元素属于第几行（即除以 $m$ 上取整）叫做它的颜色。第 3 步对每一行重排，因此第 2 步结束后肯定是每个元素都去到了它所在的行，这时候每一列包含每种颜色恰好一个，这也是第 1 步要达成的效果。因此问题变成：每行重排，使得每列包含每种颜色恰好一个。&emsp;&emsp;这时候就能嗅到匹配的味道了，但具体怎么匹配还是有点技巧。&emsp;&emsp;题解给的做法是一列一列确定。建一个二分图，左边 $n$ 个点表示行，右边 $n$ 个点表示颜色，连边表示这一行有这种颜色。这个二分图是有完美匹配的（证明：Hall 定理，任取左边若干个点，它连向右边的点表示选取的行总共包含了多少种颜色，这不可能比行数少，不然就有颜色超过 $m$ 个了），把这个完美匹配拉出来作为第 1 列，剩下的变成 $(n,m-1)$ 的子问题了，因此总共做 $m$ 次二分图匹配就好了。 &emsp;&emsp;官方题解给的有完美匹配的证明似乎有点问题，它说二分图每个点的度数都是 $m$ 因此符合 Hall 定理，但这“度数为 $m$”是有重边的，不能直接应用 Hall 定理。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;bits/stdc++.h&gt;#define fo(i,a,b) for(int i=a;i&lt;=b;i++)using namespace std;const int maxn=105;int n,m,a[maxn][maxn],b[maxn][maxn],br[maxn][maxn],c[maxn];vector&lt;int&gt; e[maxn];inline int getr(const int &amp;x) &#123;return (x+m-1)/m;&#125;int f[maxn],bz[maxn];bool Hung(int k,int tim) &#123; if (bz[k]==tim) return 0; bz[k]=tim; for(int go:e[k]) if (!f[go] || Hung(f[go],tim)) &#123; f[go]=k; return 1; &#125; return 0;&#125;int main() &#123; scanf(&quot;%d %d&quot;,&amp;n,&amp;m); fo(i,1,n) &#123; fo(j,1,m) scanf(&quot;%d&quot;,&amp;a[i][j]); sort(a[i]+1,a[i]+1+m); &#125; int tm=0; fo(j,1,m) &#123; fo(i,1,n) e[i].clear(); fo(i,1,n) fo(k,j,m) if (k==j || getr(a[i][k])!=getr(a[i][k-1])) &#123; int r=getr(a[i][k]); e[i].push_back(r); br[i][r]=k; &#125; memset(f,0,sizeof(f)); fo(i,1,n) Hung(i,++tm); fo(i,1,n) &#123; int ii=f[i]; b[ii][j]=a[ii][br[ii][i]]; a[ii][br[ii][i]]=-1; sort(a[ii]+1,a[ii]+1+m); &#125; &#125; fo(i,1,n) &#123; fo(j,1,m) printf(&quot;%d &quot;,b[i][j]); putchar(&#x27;\\n&#x27;); &#125; fo(j,1,m) &#123; fo(i,1,n) c[i]=b[i][j]; sort(c+1,c+1+n); fo(i,1,n) b[i][j]=c[i]; &#125; fo(i,1,n) &#123; fo(j,1,m) printf(&quot;%d &quot;,b[i][j]); putchar(&#x27;\\n&#x27;); &#125;&#125;","categories":[{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[{"name":"算法_网络流/匹配","slug":"算法-网络流-匹配","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E7%BD%91%E7%BB%9C%E6%B5%81-%E5%8C%B9%E9%85%8D/"}]},{"title":"【CF1580E】Railway Construction 题解","slug":"【CF1580E】Railway-Construction-题解","date":"2022-04-25T07:20:49.000Z","updated":"2024-04-24T03:59:22.836Z","comments":true,"path":"【CF1580E】Railway-Construction-题解/","link":"","permalink":"http://kqp.world/%E3%80%90CF1580E%E3%80%91Railway-Construction-%E9%A2%98%E8%A7%A3/","excerpt":"题目大意&emsp;&emsp;给定一幅 $n$ 个点 $m$ 条边的带权无向图（权值表示距离），现在想要加一些单向边，权值自定（需是正整数），使得： 从 $1$ 号点到每个点的最短路长度不变； 从 $1$ 号点到每个点都有至少两条点不相交的最短路径。 &emsp;&emsp;新建一条从 $u$ 号点出发的单向边代价为 $w_u$。求最小代价。&emsp;&emsp;以及有 $q$ 次修改操作，每次选择一个点 $k$ 把 $w_k$ 增加 $x$。 &emsp;&emsp;$n \\le 2 \\times 10^5,\\ m \\le 3 \\times 10^5,\\ q \\le 2 \\times 10^5$&emsp;&emsp;$1 \\le w_i \\le 10^9$，初始边权 $d$ 满足 $1 \\le d \\le 10^9$，每次操作增加的代价 $x_i$ 满足 $1 \\le x_i \\le 4 \\times 10^8$。&emsp;&emsp;2.5s","text":"题目大意&emsp;&emsp;给定一幅 $n$ 个点 $m$ 条边的带权无向图（权值表示距离），现在想要加一些单向边，权值自定（需是正整数），使得： 从 $1$ 号点到每个点的最短路长度不变； 从 $1$ 号点到每个点都有至少两条点不相交的最短路径。 &emsp;&emsp;新建一条从 $u$ 号点出发的单向边代价为 $w_u$。求最小代价。&emsp;&emsp;以及有 $q$ 次修改操作，每次选择一个点 $k$ 把 $w_k$ 增加 $x$。 &emsp;&emsp;$n \\le 2 \\times 10^5,\\ m \\le 3 \\times 10^5,\\ q \\le 2 \\times 10^5$&emsp;&emsp;$1 \\le w_i \\le 10^9$，初始边权 $d$ 满足 $1 \\le d \\le 10^9$，每次操作增加的代价 $x_i$ 满足 $1 \\le x_i \\le 4 \\times 10^8$。&emsp;&emsp;2.5s \\\\ \\\\ \\\\题解&emsp;&emsp;中国特色数据结构题 &emsp;&emsp;首先考虑无修改怎么做。这种情况的推导是自然流畅的：&emsp;&emsp;原始图做了最短路之后可以得到一幅最短路图（只保留最短路边的 DAG），后面就都在这个最短路图上讨论了。稍加观察可以发现，如果一个点的入度至少为 $2$，那么当它的前驱满足了“至少有两条点不相交的最短路径”之后，它也会自然满足这个条件。简单证明：如下图，对于点 $x$，假设它有前驱 $y$ 和 $z$，其中 $y$ 不是 $z$ 的必经点（否则交换 $y$ 和 $z$），$y$ 有两条点不相交的最短路径 $p_1,p_2$。任取一条从 $1$ 到 $z$ 不经过 $y$ 的路径，假设最后与 $p_1,p_2$ 交在点 $v$，那么 $1 \\to p_1 \\to y \\to x$ 和 $1 \\to p_2 \\to v \\to z \\to x$ 就是 $x$ 的两条点不相交的最短路。&emsp;&emsp;这样一来，就只有最短路图上入度为 $1$ 的点是需要关注的关键点了。对于每个关键点，当然是在最短路长度 $dis$ 比它小的点里找 $w$ 最小的连过来了（这样就能使它入度 $&gt;1$ 了），但如果这个点是它的直接父亲且不为 $1$，那就要找 $w$ 次小的了。&emsp;&emsp;所以无修改的版本就是把点按 $dis$ 排序，每个点在前面找 $w$ 的最小和次小。 &emsp;&emsp;带修改就有点米奇妙妙屋了。&emsp;&emsp;首先倒序处理操作，把增加代价变成减少代价，要好做些，因为增加代价是把最小值和次小值分散出去，而减少代价是把最小值和次小值聚集过来。&emsp;&emsp;这里的分段现象比较明显（连续一段数最(次)小值值相同），考虑用 set 维护这些段，用 $S_1$ 维护最小值相同的连续段及段内需要使用最小值的关键点数量，用 $S_2$ 维护次小值相同的连续段及段内需要使用次小值的关键点数量。当减小点 $k$ 的代价 $w_k$ 时，从第一个 $&gt;dis_k$ 的点开始，先修改 $S_1$，即把最小值 $&gt;w_k$ 的段合并起来并且把这个原最小值变为次小值丢到 $S_2$ 里；再修改 $S_2$，即把次小值 $&gt;w_k$ 的段合并起来。维护关键点数量需要 lower_bound 之类的求一个节点在一个区间内的儿子数量，用关键点数量就可以维护答案了。&emsp;&emsp;分析一下时间复杂度。初始每个 set 最多有 $n$ 个段，每次修改操作，可能要在初始位置把一个段给断开（即新增一个段）。对于 $S_1$，剩下的就都是合并操作了，所以总段数是 $O(n+q)$ 的，复杂度 $O((n+q) \\log (n+q))$。对于 $S_2$，还会在更新最小值的时候产生次小值的新段，但每个最小值段最多只会贡献一个次小值段（贡献完它就被合并了），所以总段数仍然是 $O(n+q)$ 的，复杂度 $O((n+q) \\log (n+q))$。 &emsp;&emsp;注意，有一种写法是按“最小值与次小值都相同”对序列分段，只用一个 set。这个复杂度是不对的，如果有很多很多段，这些段的最小值相同，次小值不同，而每次操作都把这个最小值再减小，那就每次操作都要把这些段都遍历一遍了。 &emsp;&emsp;注意一些细节，比如如果最小值次小值记录的是节点标号而不是具体的值，就要注意最小值来源不变但值减少了的情况；比如答案会爆 long long，要 unsigned long long。 扯淡&emsp;&emsp;可能可以把一些 set 操作换成线段树？就像题解写的那样。 &emsp;&emsp;比较搞笑的是，在我本地拍的时候，上面说的“只用一个 set 维护最小值和次小值都相同的段”的写法跑得比分开两个 set 的写法还要快。。。不过前者交上去就 T 了。&emsp;&emsp;（并且在拍的过程中还卡 T 了一个跑得飞快的老哥。。。可惜现在不能 hack 了 QAQ 代码// 实现细节比较多，修修补补会变得特别丑，建议少看（x 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184#include&lt;bits/stdc++.h&gt;#define fo(i,a,b) for(int i=a;i&lt;=b;i++)#define fd(i,a,b) for(int i=a;i&gt;=b;i--)using namespace std;typedef long long LL;typedef unsigned long long ULL;const int maxn=2e5+5, maxq=2e5+5;struct SEG &#123; int l,r,minw,num; SEG(int l0,int r0,int minw0,int num0) &#123;l=l0, r=r0, minw=minw0, num=num0;&#125;&#125;;bool operator &lt; (const SEG &amp;a,const SEG &amp;b) &#123;return a.r&lt;b.r;&#125;int n,m,q,qk[maxq],qx[maxq];vector&lt;pair&lt;int,int&gt;&gt; e[maxn];ULL w[maxn];LL dis[maxn];int d[maxn],d0;void dijkstra() &#123; memset(dis,127,sizeof(dis)); dis[1]=0; priority_queue&lt;pair&lt;LL,int&gt;&gt; Q; Q.push(make_pair(0ll,1)); while (!Q.empty()) &#123; auto tp=Q.top(); Q.pop(); int cur=tp.second; if (-tp.first!=dis[cur]) continue; d[++d0]=cur; for(auto go:e[cur]) if (dis[go.first]&gt;dis[cur]+go.second) &#123; dis[go.first]=dis[cur]+go.second; Q.push(make_pair(-dis[go.first],go.first)); &#125; &#125;&#125;vector&lt;int&gt; son[maxn];set&lt;SEG&gt; S1,S2;int indg[maxn],fa[maxn],st[maxn],keynum[maxn];ULL ans;void init() &#123; fo(i,1,n) for(auto go:e[i]) if (dis[i]+go.second==dis[go.first]) &#123; indg[go.first]++; fa[go.first]=i; &#125; SEG min1(1,1,1,0), min2(1,1,1,0); int j=1; memset(st,127,sizeof(st)); fo(i,2,n) &#123; int cur=d[i]; int minw1=min1.minw, minw2=min2.minw; for(; j&lt;=n &amp;&amp; dis[d[j]]&lt;dis[cur]; j++) &#123; st[d[j]]=i; if (w[d[j]]&lt;w[minw1]) minw2=minw1, minw1=d[j]; else if (w[d[j]]&lt;w[minw2]) minw2=d[j]; &#125; if (minw1!=min1.minw || minw2!=min2.minw) &#123; if (min2.l&lt;=min2.r) S2.insert(min2); min2=SEG(min2.r+1,i,minw2,0); &#125; if (minw1!=min1.minw) &#123; if (min1.l&lt;=min1.r) S1.insert(min1); min1=SEG(min1.r+1,i,minw1,0); &#125; keynum[i]=keynum[i-1]+(indg[cur]==1); if (indg[cur]==1) &#123; son[fa[cur]].push_back(i); if (fa[cur]!=1 &amp;&amp; fa[cur]==minw1) &#123; min2.num++; ans+=w[minw2]; &#125; else &#123; min1.num++; ans+=w[minw1]; &#125; &#125; min1.r=min2.r=i; &#125; S1.insert(min1); S2.insert(min2);&#125;int get_num(int l,int r,int minw) &#123; return (minw==1) ?0 :upper_bound(son[minw].begin(),son[minw].end(),r)-upper_bound(son[minw].begin(),son[minw].end(),l-1);&#125;void cut_cur(set&lt;SEG&gt; &amp;S,int pos,int ty) &#123; set&lt;SEG&gt;::iterator it=S.lower_bound(SEG(0,pos,0,0)); if (it==S.end() || it-&gt;l==pos) return; SEG t=*it; S.erase(it); if (ty==1) &#123; S.insert(SEG(t.l, pos-1, t.minw, keynum[pos-1]-keynum[t.l-1]-get_num(t.l,pos-1,t.minw))); S.insert(SEG(pos, t.r, t.minw, keynum[t.r]-keynum[pos-1]-get_num(pos,t.r,t.minw))); &#125; else &#123; S.insert(SEG(t.l, pos-1, t.minw, get_num(t.l,pos-1,(S1.lower_bound(SEG(0,t.l,0,0)))-&gt;minw))); S.insert(SEG(pos, t.r, t.minw, get_num(pos,t.r,(S1.lower_bound(SEG(0,pos,0,0)))-&gt;minw))); &#125;&#125;ULL Ans[maxn],w_old[maxn];int main() &#123; scanf(&quot;%d %d %d&quot;,&amp;n,&amp;m,&amp;q); fo(i,1,n) &#123; LL x; scanf(&quot;%lld&quot;,&amp;x); w[i]=x; &#125; fo(i,1,m) &#123; int u,v,d; scanf(&quot;%d %d %d&quot;,&amp;u,&amp;v,&amp;d); e[u].push_back(make_pair(v,d)), e[v].push_back(make_pair(u,d)); &#125; fo(i,1,q) &#123; scanf(&quot;%d %d&quot;,&amp;qk[i],&amp;qx[i]); w[qk[i]]+=qx[i]; &#125; dijkstra(); init(); memcpy(w_old,w,sizeof(w)); fd(i,q,1) &#123; Ans[i]=ans; int cur=qk[i]; w[cur]-=qx[i]; cut_cur(S1,st[cur],1); cut_cur(S2,st[cur],2); // minw1 int tl=st[cur], tr=tl-1, tnum=0; set&lt;SEG&gt;::iterator it=S1.lower_bound(SEG(0,tl,0,0)); while (it!=S1.end() &amp;&amp; w[cur]&lt;w_old[it-&gt;minw]) &#123; SEG t=*it; if (t.minw==cur) &#123; ans-=(ULL)t.num*qx[i]; it++; tl=t.r+1, tr=t.r; continue; &#125; ans-=t.num*w_old[t.minw]; S1.erase(it++); set&lt;SEG&gt;::iterator it2=S2.lower_bound(SEG(0,t.l,0,0)); while (it2!=S2.end() &amp;&amp; it2-&gt;l&lt;=t.r) &#123; ans-=w_old[it2-&gt;minw]*it2-&gt;num; S2.erase(it2++); &#125; int num=get_num(t.l,t.r,cur); ans+=w[t.minw]*num; S2.insert(SEG(t.l,t.r,t.minw,num)); tnum+=keynum[t.r]-keynum[t.l-1]-num; tr=t.r; &#125; if (tl&lt;=tr) &#123; ans+=tnum*w[cur]; S1.insert(SEG(tl,tr,cur,tnum)); &#125; // minw2 tl=tr+1; tnum=0; it=S2.lower_bound(SEG(0,tl,0,0)); while (it!=S2.end() &amp;&amp; w[cur]&lt;w_old[it-&gt;minw]) &#123; tr=it-&gt;r; tnum+=it-&gt;num; ans-=it-&gt;num*w_old[it-&gt;minw]; S2.erase(it++); &#125; if (tl&lt;=tr) &#123; ans+=tnum*w[cur]; S2.insert(SEG(tl,tr,cur,tnum)); &#125; w_old[cur]-=qx[i]; &#125; Ans[0]=ans; fo(i,0,q) printf(&quot;%llu\\n&quot;,Ans[i]);&#125;","categories":[{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[{"name":"算法_图论","slug":"算法-图论","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E5%9B%BE%E8%AE%BA/"},{"name":"算法_平衡树/set","slug":"算法-平衡树-set","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E5%B9%B3%E8%A1%A1%E6%A0%91-set/"}]},{"title":"偶像作品衍生的美学文学哲学 open problems","slug":"偶像作品衍生的美学哲学 open problems","date":"2022-04-10T08:33:05.000Z","updated":"2024-04-24T03:59:22.882Z","comments":true,"path":"偶像作品衍生的美学哲学 open problems/","link":"","permalink":"http://kqp.world/%E5%81%B6%E5%83%8F%E4%BD%9C%E5%93%81%E8%A1%8D%E7%94%9F%E7%9A%84%E7%BE%8E%E5%AD%A6%E5%93%B2%E5%AD%A6%20open%20problems/","excerpt":"&emsp;&emsp;其实偶像作品中也有很多很有趣的美学、哲学、艺术问题可以思考。我逐渐觉得我应该再修一个艺术理论的学位，去读一些书。&emsp;&emsp;博客逐渐变成了奇怪的形状","text":"&emsp;&emsp;其实偶像作品中也有很多很有趣的美学、哲学、艺术问题可以思考。我逐渐觉得我应该再修一个艺术理论的学位，去读一些书。&emsp;&emsp;博客逐渐变成了奇怪的形状 &emsp;&emsp;现在还只是一个理工科学生道听途说了一些美学、哲学概念，然后胡乱做一些思考罢了，书和 paper 也没读过多少。毕竟不是专业，不知道能消耗多少时间在这上面，只能是说读了更多的书和 paper 以后慢慢修正。 美的创作过程的分离与异化一个较长的 intro&emsp;&emsp;3 月 3 号 liella 的生放谈了一专里每一个人的 solo，香音那首比较独特，主要是歌词，初读可以说怪得很，不知道什么原因就对着一个人说大嫌い，一整首歌都在讨厌你讨厌你，却又在结尾的时候突然变成大好き了，很难懂的感情。这场生放里小百合似乎是给出了解释，不过我没有听懂生肉，结合弹幕的同传师爷和其他人的表现，看上去是小百合给出了深层次的解读，并不是浮于歌词表面的样子。&emsp;&emsp;所以今天就想要补这场熟肉，想要更好地理解这首歌。然而，却发现小百合并不是在解释歌词内涵，她讲了一堆与此不太相关的东西。她首先提到这个“君”可能不是人类，可以理解成一个香音最喜欢的人，但也说“一千个观众有一千个‘君’”，具体她的理解没有明说。她说以前读了歌词然后按自己的理解唱，但这次行不通，这跟香音的风格差了太多，需要主动走进香音。她说巡演期间录的歌，正好对唱歌思考了很多。她说不是单纯地歌唱低落，不是悲しみ，不是切ない。总之说了一通，大概就是两个重点，一我确乎没有明白这个“君”到底是谁，香音为什么对他大嫌い，又为什么突然转成了大好き；二是小百合明白了吗，不知道，她只是给出了自己的解答。&emsp;&emsp;所以这个出新歌的过程是这样的，作曲人、作词人把作品交给小百合，小百合开始做阅读理解，然后交上一份答卷。答得对不对呢？小百合自己也说，以前就不太管，香音不这么理解但是小百合这么理解的。所以我们说我们在欣赏一首歌的时候，我们到底在欣赏什么呢？欣赏歌曲的旋律，这是对作曲人的；欣赏歌词的文学艺术，这是对作词人的。那么小百合是什么呢？一个发声工具，和一个做阅读理解的考生。那么到底谁才是涉谷香音呢？不是小百合了。&emsp;&emsp;LoveLive 毕竟是偶像企划，绝大多数歌曲其实表意很清晰，没什么能过多分析的。比如“僕らの勢いは四方八方九方”，这种歌词也没法存在第二种解读，结合水水的经历，声优们就能跟作词达成共识，很容易就能把这个内涵表达出来了。这个时候，Aqours 和声优 Aqours 是站在一起的。但是像这次，或者以后作词人还想在歌词中表达些什么更深刻的，更隐晦一点的，那么歌曲、声优、角色就全都分离开了。&emsp;&emsp;记得去年读了一本讲美学和美育的哲学书，里面就提到了美的创作的异化。以前是由创作主体完成整个美的创作过程，因此在过程中主体完成了审美，而现在这个创作过程是分离的，造成审美也是破碎的。一首现代歌曲的作曲、作词、演唱的分离恰恰是此书里的例子，歌手很难把自己的感情、经历等审美要素代入这首歌，因为这首歌压根就不是他参与创作的。&emsp;&emsp;所以尽管小百合很用力去研究香音唱这首歌的心境，总是听着少了真情实感。以前咻卡也这样，夜空知晓一切的现场版也这样，只是在用一些歌唱技巧去制造低落、伤感的情绪，很容易用力过猛，然后变得假起来。在这个过程中她们本应是讲故事的人，但现在只是转述故事的人，这个故事就不是她们的故事。&emsp;&emsp;难免还是要对如今的商业模式做出思考。当然，作词作曲演唱这三者的分离是不可避免的，不这么分化大家都得饿死。但是，如果一味迁就，那就会让偶像的意义越发模糊。要我提出观点的话，我认为偶像本身应该参与创作，至少，作词和偶像应当有一个合作与交流，让歌词成为共同完成的作品，从而得到文学、角色人设、演出者生活经历三者的结合。&emsp;&emsp;回到这首歌本身，最好的解读还是来信里提到的，开始是对歌唱的讨厌，歌唱带给了她不好的经历，但触及心底，发现对于歌唱还是要说热爱。我们所希望的是，这是香音的想法，香音怀着这份心情唱了出来，而不是香音看了别人寄给她的稿子想到了这些然后唱了出来。 创作与观众的关系&emsp;&emsp;虹第二季第二话 Q4 劝岚珠的场景，体现了两种不同的表演理念的冲突。发现这也是我思考的一个问题：表演者应该为自己而创作，还是为粉丝而创作？&emsp;&emsp;这是两种不同的追求。一种是追求艺术本身的，我是为了歌唱，舞蹈，我的艺术理念，展现自我的风格，所以来表演，我不是为了在观众这里获得人气和支持。而一种是我希望带给粉丝一些东西，比如欢乐，感动，坚定的信念，传递各种気持ち，我希望能与观众产生共鸣。&emsp;&emsp;Lovelive 的定位是后者，是偶像和粉丝一起完成的企划，粉丝投票选出了 c 位，选出了歌词中的关键词，选衣服，选一堆东西，所以歌曲也和粉丝结合得很紧密，总是要君と一緒に这样的。所以如果在这些特定的企划里寻找答案，那几乎是唯一的。但相比起来，也正如岚珠所说，前者是更加随心所欲的，它可以在创作上更纯粹，因为审美主体很大程度被创作者选择了，就是自己这一类的主体。&emsp;&emsp;当然岚珠很可能会走到一个矛盾里，她固然是需要受众的，而且是广泛的受众，因为她的目标学园偶像，到底有没有纯粹的表现自我的学园偶像呢？可能这就不是学园偶像的定义了。&emsp;&emsp;但是抛开学园偶像这个追求和身份，这就是艺术和观众的联系问题了。尽管在一定的哲学体系下，这已经是一个相当成熟的问题了。","categories":[{"name":"杂写","slug":"杂写","permalink":"http://kqp.world/categories/%E6%9D%82%E5%86%99/"}],"tags":[]},{"title":"Aqours 6th 巨蛋收集计划","slug":"Aqours-6th-dome-collection","date":"2022-02-14T02:25:56.000Z","updated":"2024-04-24T03:59:22.774Z","comments":true,"path":"Aqours-6th-dome-collection/","link":"","permalink":"http://kqp.world/Aqours-6th-dome-collection/","excerpt":"&emsp;&emsp;继“Aqours 东蛋之路”后，现在差不多可以开始起草“Aqours 蛋巡之路”了。。。","text":"&emsp;&emsp;继“Aqours 东蛋之路”后，现在差不多可以开始起草“Aqours 蛋巡之路”了。。。 &emsp;&emsp;2020初宣布五蛋巡，本以为一路顺利在人气巅峰创下声优偶像最高成就，却因为疫情，一度将近两年开不了9人 live。起起落落，开开停停，一路上不断有 live 开催又延期又终止。最终勉强把两次小组 live 组织起来（说勉强是因为缺了老王），在声优的请求下开了 dreamy concert，逢田姐甚至直言：“两年不开 live，粉丝都掉了一大半。”五蛋巡被迫向疫情屈服，只剩下两个蛋（UPD：三个了），千言万语汇成一句话：蛋巡尚未成功，同志仍需努力。 Ocean Stage&emsp;&emsp;Ocean Stage Day1 在开学前，学校吃土群组织不起来，只能是去广州转播场。这次是跟漫展认识的雪雪人以及贴吧网友萤火虫 staff 一起。对于广州大场的印象就是虎上加虎，果不其然，这次又见到了经典熟悉的“南方灯光展”“南方动物园”，仿佛回到了两年前的南方剧院里的 5th。 &emsp;&emsp;而这场 6th，也无处不渗透着 5th 的气息。&emsp;&emsp;不会想到在开场听到 hop stop nonstop，气氛一下就回到了 5th 的剧场版主题了。接连几首动画曲也在告诉大家，动画曲和剧场版曲不是某些数字 live 独有的，以后总会源源不断地听到。姐姐那句俏皮可爱的“デキナカッタコトガデキタリ”仍然使得全场爆发。&emsp;&emsp;天花板上 kurukuru 的那条龙，像个吊死鬼一样飘着。&emsp;&emsp;一二年级分别唱完以后，仍在猜测三年级会唱哪一首，是特典还是剧场版，然而音乐一响，居然是鞠南的泪水化为雪花。明显感受到整个观众席都虎躯一震。这是冬 2223 的第一次现场表演，鞠南的 CD 唱功（sww是没开麦呢还是神速进步了呢？）、高虐拥抱；曜梨的贵妇服装、专业舞蹈、白学对视、奇卡背景；花露的活泼欢快、sif 音效；宫林波的手捧白碟、认真过节、情人节礼物，实在是尽显特色。&emsp;&emsp;两个幕间都是没内容的金曲 medley，十分敷衍。&emsp;&emsp;接下来小姐姐们穿着私服出场了，几位时尚达人（喵香王）的衣服很漂亮，杏似乎是比较保守的。私服打了海盗、白日梦、君瞳三首热气氛的歌，效果非常好，甚至有韩舞的感觉，咻卡抡大旗的动作似乎改了，改得更魅惑了。然而往下的几首动画曲，穿着私服跳，味道却是不对的，水族馆的ゆらゆら的动作非得穿二单服才有鱼的感觉，水蓝没有了脱衣服也丢掉了朝向新世界的寓意。后来换回了 op1 的衣服是挺好的（据说还改新了，增加了亮片），咻卡的样貌回到了 18 年，想起了鲤鱼锐评 op1 袜子。&emsp;&emsp;live 前流传出了彩虹光路企划，果然，安可一开始，彩虹就形成了。这就像是对逢田姐的回应，时隔两年，彩虹仍在，粉丝一个没跑。广播曲一出场，爱爱直接泪目，显然也是被 surprise 了。彩虹让人感受到 LoveLive 的确是一个双向企划，台上的人能让台下的人哭，台下的人也能让台上的人哭。&emsp;&emsp;广州场的观众席也形成了短暂的彩虹，只可惜拍完照就散了。 &emsp;&emsp;回想自己，头一次对 live 产生向往，也是在贴吧云 5th 的时候，看到了彩虹，从而十分强烈地想要成为彩虹一员。两年后，正好是下一场数字 live，在 live viewing 里短暂地成为了彩虹，我们的心意，一定要届过去啊。&emsp;&emsp;水水经历了十分艰难的两年，我们都能感受到。运营其实不容易，谁不想等疫情稳一点憋一个大招呢？毕竟是要冲蛋巡的呀。小场也不能开太多，因为 live 的安排还要匀给正在冉冉上升的虹和星，要租场地，要考虑粉丝们的钱包。这场 6th 显然也是硬开的，东京疫情爆炸了，整个霓虹声优界一个一个开盲盒似的感染，台下观众席也不知道藏有什么狼虫虎豹。疫情之下没有完美的决策，只有胆战心惊的博弈。&emsp;&emsp;只不过逢田姐不用再担心粉丝跑掉了，彩虹就是最好的证明。 Sunny Stage&emsp;&emsp;有空补。 &emsp;&emsp;曲目编排结构跟 Ocean Stage 基本一致，就是把 2223 换成了生日专 1，因此亮点大概就是 AAO 和大新闻重回东蛋了。&emsp;&emsp;然后你水现在似乎是超级求稳策略，动不动就关麦放 CD。。。好听是好听了，车祸是少了，不是 live 了。 Windy Stage&emsp;&emsp;宣布重回东蛋以来，其实很快讨论度就没了，因为虹Ⅱ高质量播出，星团低质量加人，焦点都在后辈。重新让大家动员起来，应该是将近 5 月底，全国民间观影组织再次联动，大约 10 多个城市有组织观影，还制作联动谷子。吃土群水厨日渐稀少，加之 live 日期在考试周前，组织不起来，最终与萤火虫 staff 桑与雪雪单推哥一起去 day1 大场，家里蹲白嫖 day2。&emsp;&emsp;本来还是比较担心的，毕竟加藤达也带着交响乐团来了，很高雅的，如果叠上“南方灯光展”“南方动物园”的 buff 那可就全毁了。但出乎意料地，这次灯光和 mix 氛围比军 call 还好，待会要好好夸夸他们。 &emsp;&emsp;作为 6th 的句号，两天下来，算是对得起东蛋了，亮点很多，当然槽点也有，据贴吧大佬分析上座率还挺高，动员人数挺多。最重要的，它的意义太多了，它是疫情以来的一个总结，加上 day2 大新闻，它又铺开了水水乃至企划的新的未来。 &emsp;&emsp;先从 live 本身讲起。这次的曲目编排没有那么模块化了，所以很难记流水了，就发散一点讲吧。&emsp;&emsp;加藤达也手一挥，水水战歌起，两个篇章向角色打完招呼，小姐姐已经站上台，这样的开场，最令人激动。&emsp;&emsp;开场的服装很华丽，是根据主视图来做的，整体造型非常优雅，布料看上去很好。虽然颜色是偏离了主视图的（主视图的衣服略带黄色，看上去有 ns 的感觉），实际选择了纯白色，不过这样也能给人以纯洁之感。&emsp;&emsp;MC 的欢迎辞，就是通常会喊的「皆さん、こんばんは」，这次改成了「皆さん、ただいまー」。都是张开双臂大声喊出来的，喜悦溢于言表。我们在下面喊「お帰り」也是一样的，这心情，真的何异于老友重逢呢？&emsp;&emsp;新歌很多，特别多，两天加起来大概把后疫情时代正经的都翻出来唱了。跟 Ocean 和 Sunny 差别很大，Windy 两天的差别也很大。之前贴吧有大佬做表统计已发售但未在 live 演唱的歌曲，现在应该是把这个表清空了，就连 a to z、ing i try 这样的都吐出来了（anju 自己都吐槽这歌埋了 3 年。。。）。当然还有一个表，是未上过数字 live 的歌，这个还没清空，但也有在清了，像 4 单，fes 首秀之后等上 Aqours 专场等到今天，喷蝴蝶好评。然后动画曲，6th 加上前面几次 live，也差不多把动画（TV+剧场）中的关键曲目都再滚了一遍了，剧场版曲甚是。&emsp;&emsp;加藤达也带着乐团来，当然也是亮点了。这次乐团相比 4th 可是辛苦了不少，参与的曲目多得多。从转播的体验来说，乐团伴奏跟播放伴奏效果是差不多的，但是乐团对幕间体验的提升那就太大了，尤其是在 Ocean 和 Sunny 幕间还特别敷衍的衬托下。乐队投票曲是心羽君飞和奇迹闪耀不错，真的是奇迹再现了。加藤真的活泼，也扮小恶魔，也用手指指人。&emsp;&emsp;唱了生日专 2，各自有特色。anju 的鞋全场最高，这么细高的高跟鞋蹦蹦跳跳真的吓人，原以为水的鞋子是打算一直保守下去的（水一直都是运动鞋底，虹有小皮鞋，青山姐直接上芭蕾舞鞋），看来水的鞋子也要突破了；逢田姐的舞蹈加了色气的动作，尽显工口梨本色；姐姐的歌旋律很像《一百万个可能》，然后发力比较柔弱，是大和抚子、绝世美人；sww。。。你开心就好，唱到高音还唱断了只剩垫音；王弹吉他；咻卡活力；kyan 偷跑新歌，背景翅膀超帅。&emsp;&emsp;唱功整体有进步，体力和音准比以往的观感好多了，sww在团歌中不再那么突出了。因为设备不好，判断不了这次哪些有垫音哪些是假唱，反正水水一如既往采用稳如老狗策略，真实不真实不知道，总之观感好。&emsp;&emsp;我一定要夸夸这次广州场的 call 啊！！我坐在右后角落，看下去上举、快挥、特殊动作都是非常整齐的，厄的时候连风火轮都非常整齐！屏幕前几个大闪风火轮领头，前半场和两边的蓝色白色风火轮，后排零星几个风火轮，转起来的时候整齐划一，而且因为是官棒官色没有光污染，比军 call 壮观得多。所以说这东西，不整齐是厄介是光害，整齐了、颜色亮度正常了就是光路企划了。可惜没有拍照。不过高速拍掌一定是一个坏文明。ns 因为不在最后，不需要那么感动，所以拉 mix 反而很合适（？&emsp;&emsp;day 2 最后来了时隔近 4 年的二次返场。不过感情基调不一样了，4th 是感谢与不舍，这次是激动与对未来的憧憬。 &emsp;&emsp;最大的问题应该在于选曲。一是关联性，虽然新歌和金曲很多，但是拼凑感较强，如贴吧评论“网易云心动模式都比这个好”，而且这是个老问题，4th 也被吐槽了。这种 live 没有动画做主题，因此要把握整体感和关联性是比较难的，何况还有投票曲等不可控因素，但实际上歌曲各自有感情，幕间加一点引导，从感情上把歌曲都串起来，应是可以做到的。二是非团曲曲目选择，Ocean 是 2223，Sunny 是 solo，那么顺理成章这次就是小组了，结果又是 solo。在生日专质量普遍偏低的情况下，小组有高质量曲不上，又要藏到不知什么时候。很期待 AAA 三人的凤凰舞。三是顺序，这也是感情关联性把握不好的一个原因。最突出的就是 ns 了，ns 的位置很突兀，本身情感是偏向高毒的，适合后置，而甚至动作都没改，唱到半场挥手了（这本来是 5th 结尾时向大家挥手的），唱到最后都跑了（就一种要安可的味道）。只能以后面接 ing i try 稍作解释，从“一二年级 -&gt; 三年级”到“三年级 -&gt; 一二年级”，就是 Aqours 特别是三年级又回来了的感觉。&emsp;&emsp;第二大问题在于导播。一是个人特写占比太高，全团镜头和全场镜头又少又糟糕。东蛋的宏大没有拍出来，团曲 9 人整齐的动作和团体舞蹈效果没有拍出来，舞台走位没有拍出来，观众应援没有拍出来。day2 开头至少把长长的屏幕拍进来了（我才知道原来舞台布局都换了），结果这个优秀导播马上就离开了。二是个人特写切换也不及时，day1 狂拍不唱歌不说话的成员，互动也漏掉很多。&emsp;&emsp;然后是舞台利用度低了很多。东蛋这么大，舞台也不止一个，但是表演场地太局限了，大部分主舞台，少量中心舞台，几趟花车，移动不丰富，很是浪费。参考 4th 和缪的 FL，移动量都很大，4th 的圣诞歌是在主舞台向中心舞台的走道上进行的舞蹈动作，这利用率一下子就上去了。&emsp;&emsp;剩下就是一些小问题了，“僕らの勢いは四方八方九方”这最有气势的词，应该更用力些，把气势更加发挥出来。くるるん始终像个被小孩不小心放飞的氢气球。 &emsp;&emsp;总的来说，从曲目选择上，从歌单清理上，整一个 6th 巡演就像是对 5th 以后疫情以来的一个大总结。这一段空窗期熬过去了，这段时间的努力和精彩也都展现出来了。&emsp;&emsp;因此也就来到了本场 live 最万众瞩目的一环：象征未来的大新闻。&emsp;&emsp;你的水第三季，又何必是水第三季！&emsp;&emsp;水的动画活过来了，这真的很难想到，当大家都在为学园偶像题材寻找出路，讨论将来还有多少新团，虹和星谁先出第三季的时候，一直被认为转向三次元发展的水水竟然率先给出一个回答。&emsp;&emsp;这是一个十分有创意又十分大胆冒险的尝试。出异世界番（暂且不知是 20min 的正常季度番还是小泡面），换一个题材重生，这样就续下去了，给企划也添上更多的 tag。只不过，如果完全脱离学园偶像，完全转型，就不是企划大方向了，这是另起炉灶，推倒重建，就算冲第三次东蛋、蛋巡乃至新国立，也不是以学园偶像的身份了。如何在转型时规避风险，应当是企划要慎重考虑的。&emsp;&emsp;可以看得出这个破企划一直在做新的尝试，有些尝试很令人苦恼，比如星团硬塞式的加人；有些尝试则大放异彩，比如虹团的模式，虹的动画制作（以二次元去贴合三次元）。这次的尝试会如何？会吸引动画党入坑？会被人骂改朝换代？会讲出一个好故事还是摆烂乱写？&emsp;&emsp;但是在粉丝看来，这代表着 Aqours 能再战很长时间，而且还有机会冲三次东蛋或者更大的场，这就是最好的消息了。这是强大的定心针，我们不必再担心水水江河日下，惨淡退出，live 开一场少一场，靠着越来越难以鉴赏的流水线产歌苦度余生。借助新的主题，水水可以产出具有新的内涵的歌，有更多不同的经历，也可以把经历填进词里，让词具有更丰富的感情（虽然现在问题最严重的应该是作曲 qaq）。有歌和动画，就有资本继续往上冲，路一下子宽了。&emsp;&emsp;拨云见日，前途大好，未来光明。 End&emsp;&emsp;还记得 20 年生放，做出一个“Aqours 结成 5 周年”的动作。5 周年以前，时间过得还算慢，动画、live 一步步来，不会感受到时间过得快。但是 5 周年以后，疫情空窗，一下子就到 7 周年了，虹也 5 周年了，突然间都开始纪年了。&emsp;&emsp;蛋巡，起起落落，从线上振替，到成熟的线上 live，到小组现场试水，然后更多的现场水 live，最后是 6th 登蛋，点出水水甚至是企划的新未来。&emsp;&emsp;疫情改变了很多很多。在等待水水的过程中，我也在经历这些大事，竞赛，升学，找研究方向，确定未来的路子。我也迷茫，未来怎么走，就像水水和运营一开始也不知所措，一步一步在试。试错很多，我错过了润北美的机会，水水以及整个企划的活动安排也不见得合理。最终到这里，我毕业了，马上要开启新的旅程，水水和企划也是。&emsp;&emsp;好像在和什么人一同战斗一样。&emsp;&emsp;我不要让我的人生变成“为水水和 LoveLive 而奋斗”，但是和她们在两条战线上，一同都在奋斗，能永远相互支持，这就最高了。","categories":[{"name":"玩","slug":"玩","permalink":"http://kqp.world/categories/%E7%8E%A9/"}],"tags":[]},{"title":"【ICPC Camp PTZ-Shanghai 2022 Day2 G】Gross LCS 题解","slug":"【ICPC-Camp-PTZ-Shanghai-2022-Day2-G】Gross-LCS-题解","date":"2022-02-11T09:33:59.000Z","updated":"2024-04-24T03:59:22.847Z","comments":true,"path":"【ICPC-Camp-PTZ-Shanghai-2022-Day2-G】Gross-LCS-题解/","link":"","permalink":"http://kqp.world/%E3%80%90ICPC-Camp-PTZ-Shanghai-2022-Day2-G%E3%80%91Gross-LCS-%E9%A2%98%E8%A7%A3/","excerpt":"题目大意&emsp;&emsp;给定两个数组 $A=\\langle a_1,\\cdots,a_n \\rangle$ 和 $B=\\langle b_1,\\cdots,b_m \\rangle$，定义 $A+x$ 表示 $\\langle a_1+x,\\cdots,a_n+x \\rangle$，求 $\\sum_{x=-10^{100}}^{10^{100}} LCS(A+x,B)$。 &emsp;&emsp;$n,m \\le 4000,\\ \\ |a_i|,|b_i| \\le 10^8$&emsp;&emsp;10s，16MB","text":"题目大意&emsp;&emsp;给定两个数组 $A=\\langle a_1,\\cdots,a_n \\rangle$ 和 $B=\\langle b_1,\\cdots,b_m \\rangle$，定义 $A+x$ 表示 $\\langle a_1+x,\\cdots,a_n+x \\rangle$，求 $\\sum_{x=-10^{100}}^{10^{100}} LCS(A+x,B)$。 &emsp;&emsp;$n,m \\le 4000,\\ \\ |a_i|,|b_i| \\le 10^8$&emsp;&emsp;10s，16MB \\\\ \\\\ \\\\题解&emsp;&emsp;首先，这么大的 $x$ 范围里，必定有很多是无贡献的。有贡献的 $x$ 的数量不超过 $nm$ 个，因为 $a_i+x=b_j$ 这样的等式只有 $nm$ 个。&emsp;&emsp;这相当于说，对于一个固定的 $x$，在一个 $n$ 行 $m$ 列的矩阵上，把符合 $a_i+x=b_j$ 的格子 $(i,j)$ 做标记，在每一个标记点可以走到其右下方的任意标记点，问从左上走到右下的最长距离。&emsp;&emsp;再往下想，每一对 $(i,j)$ 对应的 $x$ 是唯一的，也就是每种 $x$ 产生的标记总数也只有 $nm$。那么只要想办法把每种 $x$ 产生的标记弄出来，就可以 dp 了。 &emsp;&emsp;如果没有空间限制，那么就 $O(nm)$ 枚举所有的数对即可。这个 dp 是个简单的 LIS。&emsp;&emsp;现在有空间限制，那么就需要用一些方法按顺序生成 $(x,i,j)$ 三元组。可以把 $b$ 数组从小到大排序（记为 $b’_1,\\cdots,b’_m$），初始在堆里加入所有 $(b’_1-a_i,i,1)$，然后每从堆里取出一个元素，就把 $b’$ 向前推进一位，这样就能顺序生成所有 $(x,i,j)$ 三元组了。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include&lt;bits/stdc++.h&gt;#define fo(i,a,b) for(int i=a;i&lt;=b;i++)using namespace std;typedef pair&lt;int,int&gt; pr;const int maxn=4005;const int inf=2e9;struct B &#123; int val,i;&#125;;bool cmpB(const B &amp;a,const B &amp;b) &#123;return a.val&lt;b.val || a.val==b.val &amp;&amp; a.i&gt;b.i;&#125;struct QST &#123; int x,i,j;&#125;;bool operator &lt; (const QST &amp;a,const QST &amp;b) &#123; return a.x&gt;b.x || a.x==b.x &amp;&amp; a.i&gt;b.i || a.x==b.x &amp;&amp; a.i==b.i &amp;&amp; a.j&lt;b.j;&#125;int n,m,a[maxn],p[maxn];B b[maxn];int c[maxn];unordered_set&lt;int&gt; RC;int lowbit(const int &amp;x) &#123;return x&amp;(-x);&#125;int get(int x) &#123; int re=0; for(; x; x-=lowbit(x)) re=max(re,c[x]); return re;&#125;void xg(int x,int z) &#123; RC.insert(x); for(; x&lt;=m; x+=lowbit(x)) c[x]=max(c[x],z);&#125;void c_clear() &#123; for(int x:RC) for(; x&lt;=m; x+=lowbit(x)) c[x]=0; RC.clear();&#125;int main() &#123; scanf(&quot;%d %d&quot;,&amp;n,&amp;m); fo(i,1,n) scanf(&quot;%d&quot;,&amp;a[i]); fo(i,1,m) scanf(&quot;%d&quot;,&amp;b[i].val), b[i].i=i; sort(b+1,b+1+m,cmpB); fo(i,1,m) p[b[i].i]=i; priority_queue&lt;QST&gt; Q; fo(i,1,n) Q.push((QST)&#123;b[1].val-a[i],i,b[1].i&#125;); int lastx=inf, ans=0, curans=0; while (!Q.empty()) &#123; QST cur=Q.top(); Q.pop(); if (lastx!=cur.x &amp;&amp; lastx!=inf) &#123; ans+=curans; curans=0; c_clear(); &#125; int dp=get(cur.j-1)+1; curans=max(curans,dp); xg(cur.j,dp); lastx=cur.x; if (p[cur.j]&lt;m) &#123; int newj=p[cur.j]+1; Q.push((QST)&#123;b[newj].val-a[cur.i],cur.i,b[newj].i&#125;); &#125; &#125; ans+=curans; printf(&quot;%d\\n&quot;,ans);&#125;","categories":[{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[{"name":"算法_DP","slug":"算法-DP","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-DP/"}]},{"title":"LoveLive 三团跨年 live + 72红白","slug":"countdownlovelive_72kouhaku","date":"2022-01-01T06:00:00.000Z","updated":"2024-04-24T03:59:22.775Z","comments":true,"path":"countdownlovelive_72kouhaku/","link":"","permalink":"http://kqp.world/countdownlovelive_72kouhaku/","excerpt":"12.31 已经成为每年最期待的日子了 qaq","text":"12.31 已经成为每年最期待的日子了 qaq LoveLive Countdown&emsp;&emsp;老实说我不希望 LL 自己办跨年，我希望有朝一日能在红白看见 LL series special，或者像さだまさし那样的在自己的 live 上连线红白。&emsp;&emsp;今年这种线上线下并行的 live 已经成熟了，各种 live 依次宣布，加上也有过 fes 先例了，所以听见三团跨年其实也没多大惊奇。惊奇的是今年的民间组织竟然这么给力，全国上下二三十个城市几乎都有正规的民间组织观影，还做宣传视频，仿佛 live 开到家门口一样。总策划真的辛苦了。&emsp;&emsp;一开始还纠结是去广州的大场还是吃土群自己的小场，后来因为带上了 sif 网友和贴吧网友（叫我传销头子），网友喜欢小场，又看到广州场标题叫 live with a tiger 感觉很可怕，就选择了一带三去吃土群小场。遗憾的是某位帅气小哥哥受伤没来。&emsp;&emsp;这场 live 最担心的是 liella 特别是小百合，18场高强度巡演已经让她们嗓子很辛苦了，这个1st巡演过后，要么报废，要么成神。 &emsp;&emsp;看了红白的歌单，五木大叔不上了，松田圣子亡女不上了，岚停止活动了，有些许失望。あいみょん常驻了，几位老叔叔老阿姨还在，杰尼斯搬出了今年的雪皇桶三巨头（去年的 imitation rain 真的好听），yoasobi 两年都是现象级的歌，所以也十分期待。但是预计着只能够在 LL 开场前那一小会儿看一看，比如看到了雪人杂技团（ &emsp;&emsp;开场先放日天歌，一波烟雾弹。&emsp;&emsp;星一单虹一专开场，水一转攻势来了个 dreamy color。这里最令人激动的当然是看到菜宝的大红旗袍和过膝靴。&emsp;&emsp;然后来到星专场，像是简化的 1st 巡演，有给 pay 子发挥的nonfiction，有给小百合展现的symphony，拍手歌一如既往跳协调操，星光序曲将成为新的光路企划。mc可以看鲤鱼乱摸小百合。&emsp;&emsp;接下来是虹专场，上来12个solo短版，似乎是各自选曲。我虽然虹听得少，但还是识得一些亮点，哀温之诗三专封神，岚珠米娅首秀，萌p绝育之光，兔兔可爱充满活力的开花宣言。最后11人版LLL，我喜欢这个摆字造型。&emsp;&emsp;然后出现了146与167并肩的名场面。&emsp;&emsp;时间来到水专场，开场竟然是水蓝，现在水live已经能源源不断地重新看到动画歌曲了非常感动。后面几首则是近期live比较常规的曲子，亮点反而偏少（也可能是我看得多），情怀多，比如水蓝的衣服。&emsp;&emsp;三个专场之后是听广播坐牢，跟相似度调查一样感觉都是在硬凑时间，所以这一段跑去看红白了，看到红组ゲスト吃零蛋竟然还能优胜，实属宅男人气优势。中途LL有三首广播曲，这是live的焦点之一，水水轻快海边曲，虹虹炫酷rap，星星用网友的话叫“意外地成熟”。大家的衣服都改得很漂亮，尤其是某十四岁少女米娅，太成熟了。&emsp;&emsp;最后的跨年倒数，最精彩的部分，网卡了直接错过，新年第一寄，成为本场最大遗憾。&emsp;&emsp;倒数完后只有主题曲了，三团leader向系列致敬。没有021这样的新寓意。有点戛然而止的感觉。 &emsp;&emsp;于是又一年过去了。这年也发生了很多事，最大的感想就是，看着小姐姐们年龄渐长，真的很希望在水水退役前来一次现地。不会想到LL有如今这般发展，后辈实力越来越猛，而且都是逐梦成功的远古拉拉人。如果再展望，我希望的是一路平稳，不需要搞大事，只求长久，一代又一代的传承，把羽毛接好。如果还有祝愿，那就是星星能实现她们动画里的目标——新国立。 &emsp;&emsp;live还有很多，所以并没有太强烈的“结束了”的感觉。fes，以后还会有。 &emsp;&emsp;写这篇东西写着写着看到里p结婚了。只能说，恭喜，你怎么会有女朋友嘛.jpg伤害提升十倍。 72届红白&emsp;&emsp;终于在过年期间有时间补了红白，甚至还是熟肉。 &emsp;&emsp;还是那句话：“不得不说跟红白一对比都要感慨你拉是怎么活到现在的”。偶像live看多了，还是要看点红白修正一下品味，至少不能认为天天翻车是正常的。 &emsp;&emsp;郷ひろみ 67 了你敢信，气息真的厚足，身体健壮，活力四射。&emsp;&emsp;dish 出场前有 あいみょん 跟主持人的互动，あいみょん 竟然还能这么娇小活泼可爱，全靠大泉洋衬托。&emsp;&emsp;特别影片提到了 アイゴ 褐蓝子鱼，以为是什么高档鱼类，一百度竟然是泥猛，好家伙还隔这吹生态破坏呢，台山人来了全吃了。煲汤不知多鲜！&emsp;&emsp;小孩子的歌很可爱啊啊啊，小小的人总是有大大的和平梦想，但是这个作曲就一股夜に駆ける味，果然还是你 yoasobi。&emsp;&emsp;纯烈清洁工上线。&emsp;&emsp;来到了筒就顺带把雪皇筒都说一说。筒翻车率较高，没有去年 imitation rain 那番冷艳；king 中规中矩的偶像男团表现；雪人杂技团，秀多过唱了。&emsp;&emsp;天童奶奶经典花道，不过乐队动作有点骚。&emsp;&emsp;上白石萌音长得好可爱啊~&emsp;&emsp;まふまふ这首是惊艳，首先布景把人带入一个很梦幻虚无的境界，然后高音特别猛，比上一个 milet 还猛，麦克风还用绷带跟手绑起来。歌词初读觉得很没头绪，怎么描述了一通生命的无意义，嘲讽了劝活的人，最后自己还拼命喊生きて呢？倒回去再读了两三遍，大约理解了，在生不如死的情感面前，歌词反对的是那些轻浮说教的劝活，转而以撕心裂肺的呐喊表达出内心对生命的尊重。&emsp;&emsp;水森かおり的歌配上旅行画面，真的让人感到很舒服。&emsp;&emsp;マツケンサンバ，日式桑巴，从报幕到结尾都是整活的气息。&emsp;&emsp;没有指挥的交响乐团，对这位游戏音乐人的纪念。&emsp;&emsp;年年晨间剧主题歌都吸引我，但是年年都不知道去哪里找晨间剧看。&emsp;&emsp;这个bish是怎么被选上红白的。。。全场唯一一首听到头皮发麻的，质量似乎比水水live还差（&emsp;&emsp;剑玉队打破规律魔咒，二连胜了，可喜可贺。以后选首长点的歌唱吧，队伍越来越长了。&emsp;&emsp;决明子的 rap 很棒，节奏适中，歌词很鼓舞人，很温柔又很能届到明天的勇气。&emsp;&emsp;perfume打造的元宇宙很有现代感，有迷失在科技空间的感觉。美中不足是只有三个女生唱歌气息很弱，bgm太强，整首歌就会感觉很虚。&emsp;&emsp;宫本浩次，这唱得面目狰狞的，一副“我特么跟你安利我家乡你敢不去？”的样子，感觉这首歌温柔一点会更贴合。&emsp;&emsp;紫团这次是生田绘梨花的毕业live，温暖的毕业歌总是很触动人。不仅联想到kon，还联想到逢田姐（x&emsp;&emsp;細川たかし这个演歌够味，小街欢腾感，不过津轻都这么冷感伤感的吗？以及大泉洋水平高啊。&emsp;&emsp;坂本阿姨今年借助樱吹雪的背景也特别美，给这首歌换上了不同的风格。&emsp;&emsp;拖鞋睡衣战神藤井风，整首歌曲也是充满了随性的气息，包括旋律变化、唱法、眼神。&emsp;&emsp;yoasobi 又一现象级歌曲，最初是在鬼畜区认识这首歌的。歌难度很高但是唱得很稳，不过感觉现场不如 CD 有气势？&emsp;&emsp;铃木大叔这首摇滚又有点爵士风的小曲，配上几个老爷子扭来扭去的动作，真的太有大叔味了！去年初识铃木大叔，被特有的大叔磁性声音吸引，这次由深情思念变为活泼欢快，充满中年男人的魅力。&emsp;&emsp;ゆず护花使者一般，歌曲轻快像rap，和声很棒！&emsp;&emsp;gen桑同样是一首很安静舒服的歌曲。&emsp;&emsp;あいみょん这首把乐队live的feel发挥到极致了，自由的衣服，标准的乐队站位和灯光，あいみょん特有的低沉和像甩出去一样的滑音。&emsp;&emsp;出现了！さだまさし这个形式，在自己的live中途接入红白，一石二鸟，是我最希望出现在LL跨年live上的形式！自己跨年跟上红白两不误！歌曲的话，跟まふまふ的劝活又是两种风格，这种是很慈祥的老爷爷用毕生的阅历鼓励你笑って。&emsp;&emsp;苹果姐姐拿个喇叭唱歌是要做什么？这歌词倒也确实适合播广播（&emsp;&emsp;石川小百合的摇滚rap，香香辣辣你见过没！！还是要靠津轻拉回风格qaq。&emsp;&emsp;福山大叔的歌是想把人间看透，并赞美生命的延续。&emsp;&emsp;奥运会片段体现出的是互相尊重的价值观，展现了很多比赛之上的爱。稍有别于国内价值观，例如因心理原因退赛的体操选手，这样的事迹至少不会在国内被公开宣传，我们宣传的是拼尽全力为国争光，而他们如他们所说：“他选择的不是运动员的立场，而是人类的立场。”&emsp;&emsp;高音战神misia，第一首破音和粗嗓比较严重，第二首跟拖鞋战神合作的歌就挺好，充分发挥了高音战神的魅力。&emsp;&emsp;最后红组在审查员评分吃零蛋的情况下奇迹般赢了。要分析起来的话可能需要考虑如下因素：红组会不会因为 bish 而一票否决；杰尼斯和坂道系在宅女宅男中的人气对比；现象级歌曲的人气因素；审查员似乎都偏年轻因此老歌的地位会不会下降。 &emsp;&emsp;今年没有像前几年一样发现特别令我眼前一亮的歌曲，有点可惜。不过，也是各位霓虹音乐人一年又一年努力呈现的舞台。抱以欣赏和学习的态度去观看，身心愉悦。","categories":[{"name":"玩","slug":"玩","permalink":"http://kqp.world/categories/%E7%8E%A9/"}],"tags":[]},{"title":"2021ICPC南京站大杂记","slug":"2021_ICPC_nanjing","date":"2021-12-04T15:24:08.000Z","updated":"2024-04-24T03:59:22.772Z","comments":true,"path":"2021_ICPC_nanjing/","link":"","permalink":"http://kqp.world/2021_ICPC_nanjing/","excerpt":"&emsp;&emsp;发现自己真的好久没写游记了啊。。。倒是各式各样的其他小作文写了不少。。。","text":"&emsp;&emsp;发现自己真的好久没写游记了啊。。。倒是各式各样的其他小作文写了不少。。。 前言&emsp;&emsp;真没想到吧，大四了还没退役。以前中学说“五年 OI 一场空”，或者“十年 OI 一场空”，今年，都第 11 个年头了。。。&emsp;&emsp;大一打完了没想过会有大二，结果被郭老拉去毛营；大二打完了没想过会有大三，结果被 zayin 哥哥盛情邀请；大三打完了线也出了杯也捧了更不会想到有大四，结果暑假校队选拔的时候被拉进小黑屋谈话，说今年金牌数量危，出线名额危，让我们来救救场，甚至还要拆了我们队变成两个抢出线的队来着。。。最后大概就是以“final 还没来”为理由又续了一年。 &emsp;&emsp;算法竞赛这个东西，说真的，我现在大概不是很有资格说我很热爱它，无论从想法上还是行动上。放到大二及以前我认为我是有资格的。转折是大三以来，出现了更多的兴趣爱好，有了想投入精力的课程，有了对科研生活、TCS research 的向往 ，有了想要追的女生。补题时间骤减，训练补题时的厌烦情绪骤升，想不出题目被人智商碾压时的痛苦骤升。逐渐发现，比赛打久了，真的会累。 &emsp;&emsp;这一年波波折折也算是把学校定了，预计着大四就混在实验室，读 paper，想问题，喝茶（x）暑假去校选帮忙，去小黑屋谈话，给学弟队伍凑个人头好训练，回过神来才发现又被忽悠上了赛道。 开学&emsp;&emsp;当然这个赛季无人之境有多拉大家也都看到了。最好的可能就是第一场 CCPC 网络赛，凭运气挤进了 hdu 土豆服务器抢了个第 9。后面的三场网络赛每场都是两个人打、另一人实习，全部都 rk70+。&emsp;&emsp;打校赛拿了个第一，尚能饭。仔细分析了与最后的午餐的差距，他们做后期题比我们更有潜力，但是前中期我们更稳，所以在日常难度较大的训练里他们总要超我们一两个题，但也通常要到 3h-4h 以后才翻上去，校赛这种 90% 简单题的场我们自然也更有优势。&emsp;&emsp;这样一分析，其实我们就像是当年的穷游中国，靠前中期优势取胜。 &emsp;&emsp;排赛站的时候，我们想着把小赛区留给冲出线的队，我们去大赛区旅游，结果几个来回全线上了，旅游泡汤。&emsp;&emsp;队友实习结束后大概一周能有 4 场训练。没怎么补题倒是真的。 &emsp;&emsp;很快 11 月就到了。&emsp;&emsp;CCPC 广州，完全是老年人随心所欲流派打法，zayin 卡 C 题，邓老板写几何题，两人直接从 1h 卡到 5h，期间不换题也不看榜，F 板刷了什么的根本不知道。我最后把数论题搞出来了没机时，赛后 10min 才卡完常。颁奖的时候十分希望直接打铁，这样我们名字就不会被念到，结果很不幸铜了。&emsp;&emsp;ICPC 上海，体面了一点，至少会开题、会跟榜了。遗憾的是我开场摸的全是中后期题，一个签到都没抢到，最后全程躺，一题都没写，就看着队友输出，给他们小黄鸭。&emsp;&emsp;可见这两场其实没什么游记可写。。。&emsp;&emsp;CCPC 威海，出题历程大概有 3 个月，几经风雨，呕心沥血，在挖精妙的 idea、不停地叉做法改进做法、控难度等方面下了很大功夫。最后功亏一篑，H 题 generator 写错导致数据弱了，被很弱智的水法冲了过去，荣登 XCPC 比烂表。关于出题我也有很多想说的，等后面的 OI 出题任务过了以后再开篇。 &emsp;&emsp;好几场打崩的场恰好都有锅，然后就可以在一些群里看到：“无人之境都打成这样，总不能是无人之境有问题吧”“不会以为无人之境不训练了就很弱吧”……赫然发现我们的表现竟然成了判断一场比赛区分度好坏的标准之一了。感谢你们对我们过往成绩的认可，不过我们也十分惭愧，我们打崩了基本上都是自身原因，我们尚不足以用于评判区分度的好坏。 &emsp;&emsp;然后就到南京了。 南京&emsp;&emsp;星期三得知正赛竟然是周六，又赶上周六大一的同学有军理考试，于是含有大一的队伍突然间全寄了，紧急换人。对着校赛榜抓壮丁，抓了个打得很好的研究生队（两个我校退役选手，一个来自 csu 进过小米邀请赛的大神），再抓了校队里还没打满 2 场里的唯一不含大一的一支队伍。 &emsp;&emsp;周五热身前看到 cjb 哥哥发了个死亡笔记，不幸榜上有名。热身完了以后回去看到某 C 开头的学会以“代码含有暴戾语言”为由禁赛了 5 个人，血压拉满。 &emsp;&emsp;周六早上，第一趟出门，到机房发现忘带电脑；回宿舍拿电脑第二趟出门，到机房发现忘带板子，回宿舍拿板子第三趟出门，到机房离开始只有 10 min 了。阿尔茨海默症晚期选手。还没开场先跑个 2km 感觉很淦。 &emsp;&emsp;开场，邓老板抢了个 G 一血。我玩 M 题猜了个错结论，也没判 $n=1$，WA 了两发，罚时大概从一开始就没有了。&emsp;&emsp;然后读过几个题之后我就开始想 J，队友陆续过掉 CD，zayin 开始快乐线段树历史和。我的 J 转化了模型却一直没进展。邓老板被迫开计数题。&emsp;&emsp;2.5h 后 E 过了。zayin 一边救 J 一边听计数题，机位空了一万年。&emsp;&emsp;最后我突然发现每一步操作结果一定是一段连续的区间，zayin 听了马上补充说不是连续区间而是恰好只有两个相邻的数，于是 dp 做法就出来了。最终 4h18min 过了 J。&emsp;&emsp;我写 J 的时候他们 IG 都会了，但是一开始以为 I 要 cdq 所以决定先写 G。最后两题都没写完。 &emsp;&emsp;苟在金区。想比上海更体面一点，想能够给这篇游记起个标题叫“体面记”，但结果不算很体面。就这样吧。&emsp;&emsp;这场主要问题就是我的 J 卡了半个场，节奏全部拖慢了。这个 J 的套路应该是老套路了，所幸最后能想起来。I 比较歪。 &emsp;&emsp;发现我校稳定每场一个金，这样下去金牌数和出线还真的很危。求求下一任中大之光赶紧出线呀。。。 结束了&emsp;&emsp;现在是处于一种退役了但又没完全退役的状态。&emsp;&emsp;已有的比赛确实打完了，两场 ICPC，一场 CCPC。神不知鬼不觉被拉上的大四赛道，也算是走完了。大四打完，这下是真不会有下一年了。&emsp;&emsp;但是很大概率将来还要被拉去打 EC，下周还有个毛营想要试着去旅游去抢钱，一年后还有一个状态未知的 WF2021。 &emsp;&emsp;竞赛就是这样子，前面无论多累多不想做，恨不得没有比赛天天过科研生活，可是真的比赛完了，真的到退役的时候了，就总会觉得还远远不够，还应该再做几个题，再打上几年。&emsp;&emsp;没有完全把实力发挥出来，当然会意犹未尽。不过，我相信不只是因为赛场的遗憾，这么多年的投入，不可能不在说再见的时候牵动心弦。&emsp;&emsp;所幸这次又又又只是暂别。atcoder，codeforces，太多没补完的东西，暂时要放一放，去读 paper 做毕设了。总会在 EC、WF 之前，又捡起来再打。不过可以肯定的是，一大段时间内，不会再有一周四训这样热火朝天的行为了。 &emsp;&emsp;EC 确定日期之前大概也不会康复了。现在可以开始你想要的生活了，它还是你期待的样子吗？&emsp;&emsp;希望是的。 &emsp;&emsp;更多的话，等下一篇年终总结来说吧。","categories":[{"name":"总结与游记","slug":"总结与游记","permalink":"http://kqp.world/categories/%E6%80%BB%E7%BB%93%E4%B8%8E%E6%B8%B8%E8%AE%B0/"},{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[]},{"title":"【AtCoder Grand 030E】Less than 3 题解","slug":"【AtCoder Grand 030E】Less than 3 题解","date":"2021-11-25T11:45:14.000Z","updated":"2024-04-24T03:59:22.824Z","comments":true,"path":"【AtCoder Grand 030E】Less than 3 题解/","link":"","permalink":"http://kqp.world/%E3%80%90AtCoder%20Grand%20030E%E3%80%91Less%20than%203%20%E9%A2%98%E8%A7%A3/","excerpt":"题目大意&emsp;&emsp;给定两个长度为 $n$ 的 01 串 $s,t$，每个串都不会有连续三个相同的字符。现在每次操作可以将 $s$ 的一位反转，但反转之后也要保证没有连续三个相同的字符，求最少的步数使得 $s$ 变成 $t$。 &emsp;&emsp;$n \\le 5000$&emsp;&emsp;2s","text":"题目大意&emsp;&emsp;给定两个长度为 $n$ 的 01 串 $s,t$，每个串都不会有连续三个相同的字符。现在每次操作可以将 $s$ 的一位反转，但反转之后也要保证没有连续三个相同的字符，求最少的步数使得 $s$ 变成 $t$。 &emsp;&emsp;$n \\le 5000$&emsp;&emsp;2s \\\\ \\\\ \\\\题解&emsp;&emsp;题解这个模型转化非常 nice。 &emsp;&emsp;给 $0$ 和 $1$ 之间画一条红线，给 $1$ 和 $0$ 之间画一条蓝线，这样这个 01 串就变成了： 有很多红蓝相间的线；（开头和结尾可以补充无限条红蓝相间的线） 相邻的线间隔为 1 或 2； 每次操作可以将一条线往左或者往右移 1 位，不能与别的线重合，线的间隔仍然要为 1 或 2。 &emsp;&emsp;可以发现这样就变成了线的匹配问题。$O(n)$ 枚举 $s$ 串开头的线匹配 $t$ 的哪一条线，然后再 $O(n)$ 算出匹配代价即可，总共 $O(n^2)$。整个过程用些数据结构或者 trick 可以优化成 $O(n)$，不过意义不大。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;bits/stdc++.h&gt;#define fo(i,a,b) for(int i=a;i&lt;=b;i++)using namespace std;typedef pair&lt;int,int&gt; pr;const int maxn=5005;int n,ps0,ps1,pt0,pt1,ps2,pt2;pr ps[4*maxn],pt[4*maxn];char s[maxn],t[maxn];void pre(char *t,pr *p,int &amp;p0,int &amp;p1,int &amp;p2) &#123; fo(i,0,n+5) p[++p0]=make_pair(0,i&amp;1); if (p[p0].second!=(t[0]&gt;t[1])) p[++p0]=make_pair(0,(t[0]&gt;t[1])); p1=p0+1; fo(i,1,n-1) if (t[i]!=t[i+1]) p[++p0]=make_pair(i,(t[i]&gt;t[i+1])); p2=p0; int cur=(t[n]==&#x27;1&#x27;); fo(i,0,n+5) p[++p0]=make_pair(n,cur), cur^=1;&#125;int main() &#123; scanf(&quot;%d&quot;,&amp;n); scanf(&quot;%s&quot;,s+1); scanf(&quot;%s&quot;,t+1); if (n&lt;=2) &#123; int ans=0; fo(i,1,n) ans+=(s[i]!=t[i]); printf(&quot;%d\\n&quot;,ans); return 0; &#125; s[0]=(s[1]==&#x27;1&#x27; ?&#x27;0&#x27; :&#x27;1&#x27; ); t[0]=(t[1]==&#x27;1&#x27; ?&#x27;0&#x27; :&#x27;1&#x27; ); pre(s,ps,ps0,ps1,ps2); pre(t,pt,pt0,pt1,pt2); int ans=n*n*10; fo(i,1,pt2) if (ps[ps1].second==pt[i].second) &#123; int bs=ps1-max(0,i-pt1), be=ps2+max(0,pt2-(i+ps2-ps1)), bt=i-(ps1-bs), len=be-bs+1; int ans1=0; fo(j,1,len) ans1+=abs(ps[bs+j-1].first-pt[bt+j-1].first); ans=min(ans,ans1); &#125; printf(&quot;%d\\n&quot;,ans);&#125;","categories":[{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[{"name":"算法_神奇的脑洞","slug":"算法-神奇的脑洞","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E7%A5%9E%E5%A5%87%E7%9A%84%E8%84%91%E6%B4%9E/"}]},{"title":"【2021 ICPC Gran Premio de Mexico 2da Fecha F】Flipped Factorization 题解","slug":"【2021 ICPC Gran Premio de Mexico 2da Fecha F】Flipped Factorization 题解","date":"2021-11-09T04:11:15.000Z","updated":"2024-04-24T03:59:22.817Z","comments":true,"path":"【2021 ICPC Gran Premio de Mexico 2da Fecha F】Flipped Factorization 题解/","link":"","permalink":"http://kqp.world/%E3%80%902021%20ICPC%20Gran%20Premio%20de%20Mexico%202da%20Fecha%20F%E3%80%91Flipped%20Factorization%20%E9%A2%98%E8%A7%A3/","excerpt":"题目大意&emsp;&emsp;设 $x$ 的质因数分解为 $p_1^{c_1}p_2^{c_2}\\cdots p_m^{c_m}$，记 $f(x) = c_1^{p_1}c_2^{p_2}\\cdots c_m^{p_m}$，给定 $n$，求 $\\sum_{i=1}^n f(n) \\bmod 10^9+7$。 &emsp;&emsp;$n \\le 10^{14}$&emsp;&emsp;10s","text":"题目大意&emsp;&emsp;设 $x$ 的质因数分解为 $p_1^{c_1}p_2^{c_2}\\cdots p_m^{c_m}$，记 $f(x) = c_1^{p_1}c_2^{p_2}\\cdots c_m^{p_m}$，给定 $n$，求 $\\sum_{i=1}^n f(n) \\bmod 10^9+7$。 &emsp;&emsp;$n \\le 10^{14}$&emsp;&emsp;10s \\\\ \\\\ \\\\题解&emsp;&emsp;$n$ 的这个范围没法筛，但却很根号。&emsp;&emsp;因此用 powerful number 求积性函数和。 &emsp;&emsp;观察到对质数来说 $f(p)=1$，能对上这个形式的，马上想到全 1 函数 $1(n)=1$。然后观察 $h = \\frac{f}{1} = f \\ast \\mu$，得到 h(p^c)=\\begin{cases} c^p-(c-1)^p, &c>1 \\\\ 0, &c=1 \\end{cases}&emsp;&emsp;然后推式子 \\begin{aligned} & f = h \\ast 1 \\\\ \\Rightarrow & \\sum_{i=1}^n f(i) = \\sum_{i=1}^n \\sum_{j=1}^{\\lfloor \\frac ni \\rfloor} h(i)1(j) = \\sum_{i=1}^n h(i) \\lfloor \\frac ni \\rfloor \\\\ \\end{aligned}&emsp;&emsp;又由于 $h$ 只在 powerful number 处有值，因此用 dfs 把 $O(\\sqrt n)$ 个 powerful number 都找出来算答案就行了。dfs 的过程中要维护 $h$ 的值，$c^p$ 可以用快速幂算。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;bits/stdc++.h&gt;#define fo(i,a,b) for(int i=a;i&lt;=b;i++)using namespace std;typedef long long LL;const int maxp0=1e7+5;const LL mo=1e9+7;LL n;int p[maxp0],p0;bool bz[maxp0];void Prime(int n) &#123; fo(i,2,n) &#123; if (!bz[i]) p[++p0]=i; fo(j,1,p0) &#123; if (i*p[j]&gt;n) break; bz[i*p[j]]=1; if (i%p[j]==0) break; &#125; &#125;&#125;LL Pow(LL x,LL y) &#123; LL re=1; for(; y; y&gt;&gt;=1, x=x*x%mo) if (y&amp;1) re=re*x%mo; return re;&#125;LL ans;void dfs(int k,LL h,LL i) &#123; if (k&gt;p0) return; if (n/i&lt;(LL)p[k]*p[k]) return; dfs(k+1,h,i); LL last=1; i*=p[k]; for(int c=2; ; c++) &#123; LL cur=Pow(c,p[k]); LL newh=h*(cur-last+mo)%mo; i*=p[k]; (ans+=(n/i)%mo*newh)%=mo; dfs(k+1,newh,i); if (n/i&lt;p[k]) break; last=cur; &#125;&#125;int main() &#123; Prime(1e7); scanf(&quot;%lld&quot;,&amp;n); ans=n%mo; dfs(1,1,1); printf(&quot;%lld\\n&quot;,ans);&#125;","categories":[{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[{"name":"算法_数论","slug":"算法-数论","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E6%95%B0%E8%AE%BA/"}]},{"title":"TCS papers 阅读记录","slug":"TCS_papers_reading","date":"2021-10-27T14:04:08.000Z","updated":"2024-04-24T03:59:22.796Z","comments":true,"path":"TCS_papers_reading/","link":"","permalink":"http://kqp.world/TCS_papers_reading/","excerpt":"大概就随便记一记读过的有亮点的东西，觉得很牛逼的东西就分享一下，随缘更新。 当然也不是教程或者阅读笔记。 TCS 是指 Theoretical Computer Science。","text":"大概就随便记一记读过的有亮点的东西，觉得很牛逼的东西就分享一下，随缘更新。 当然也不是教程或者阅读笔记。 TCS 是指 Theoretical Computer Science。 Fine-Grained Complexity and Cryptography这是 MIT 的 Fine-Grained Complexity 课，可以用它的 lecture note 简单学一学。以及它的大作业的 paper list 作为起点我认为是不错的。 Marshall Ball, Alon Rosen, Manuel Sabin, and Prashant Nalini Vasudevan. Average-Case Fine-Grained Hardness. In STOC 2017.&emsp;&emsp;以下称为 [avg-fg]&emsp;&emsp;声称是第一篇将 fine-grained complexity 与 cryptography 结合起来的工作。&emsp;&emsp;先推导一个重要的 Lemma 1，就是将传统的 random self-reducibility 改造了一下，原本的归约只要多项式复杂度就好了，现在要求复杂度更精细，因此要用比较牛逼的点值和插值。&emsp;&emsp;然后基于这个做出了几个基本问题的 average-case hardness。&emsp;&emsp;然后针对 OV 问题，给出了只用 $\\tilde O(n)$ 的验证方法（灵活运用多点求值和快速插值），这样就给出了一个 MA 协议和 Proof of Work。虽然是老竞赛选手了，但还是被秀得头皮发麻&emsp;&emsp;然后它说用 OV 构造的 instance-solution pair 作为 OWF 会证伪 NSETH，因此 OV 的这个 hardness 不太能用来做 OWF。 Marco L. Carmosino, Jiawei Gao, Russell Impagliazzo, Ivan Mihajlin, Ramamohan Paturi, and Stefan Schneider. Nondeterministic extensions of the strong exponential time hypothesis and consequences for non-reducibility. In TCS 2016.&emsp;&emsp;以下称为 [NSETH]&emsp;&emsp;[avg-fg] 在构建 one-way function 的时候说，如果他设计的 one-way function 存在，就会证伪 NSETH 猜想。这篇就是讲 NSETH 猜想。&emsp;&emsp;简单来说，SETH 是说 k-SAT 需要指数时间，而 NSETH 是说 k-UNSAT 在非确定图灵机上也要指数时间。&emsp;&emsp;然后他说证伪 NSETH 会得到一些 circuit lower bound，所以很难证伪。由于不懂电路就先跳过了。&emsp;&emsp;fine-grained reduction 可以在非确定性图灵机上进行，这样就可以使用 NSETH 这个 hardness 了。NSETH 推导出来最有趣的结果应当是，SETH-hard 不能说明 3-SUM-hard 和 APSP-hard。 Rio LaVigne, Andrea Lincoln, and Virginia VassilevskaWilliams. Public-Key Cryptography in the Fine-Grained Setting. In CRYPTO 2019.&emsp;&emsp;以下称为 [pubkey]&emsp;&emsp;老板：“如果 public key 做出来了，那数字签名之类的全套都有了，你代码实现一下，假装数字签名那些是很难很创新的东西，不就把毕设水出来了吗？反正你校的老师都水平低看不懂。”&emsp;&emsp;这篇想要基于 [avg-fg] 继续深入，搞 public key 和 key exchange，顺便深入研究 one-way function。&emsp;&emsp;开局 27 个 definition 让人为之震撼，这套东西居然要基于这么强的限制，花拳绣腿。&emsp;&emsp;而后面基于 Merkle Puzzle 设计具体协议的那部分，特别是证明，还没读懂。要么是我水平低领悟不了她们的奥妙，要么是她们喝了假酒在那乱写。&emsp;&emsp;然后老板的想法大概也是要 fail 的，像“均匀采样一个 3-SUM 问题无解的例子”这样的东西就很不可实现。 Marshall Ball, Alon Rosen, Manuel Sabin, and Prashant Nalini Vasudevan. Proofs of Work From Worst-Case Assumptions. In CRYPTO 2018.&emsp;&emsp;以下称为 [PoW]&emsp;&emsp;原班人马对 [avg-fg] 的延续。&emsp;&emsp;前半部分是把 OV 问题换成了 kOV 问题重新推了一遍 Proof of Work，但是复杂度算得很假，包括但不限于多点求值和快速插值的复杂度竟然离谱地达到了 $O(n \\log^3 n \\log p)$、一些步骤细节写得不清不楚。&emsp;&emsp;后面比较有趣的是搞了一个 Zero Knowledge Proof of Work，美中不足的是它根据 ElGamal 来改的，因此用了 Decisional Diffie-Hellman 假设，违背了 Fine-Grained Cryptography 的初衷（使用 Fine-Grained Complexity 中的 hardness）。 Shyan Akmal, Lijie Chen, Ce Jin, Malvika Raj, and Ryan Williams. Improved Merlin-Arthur Protocols for Central Problems in Fine-Grained Complexit. In ITCS 2022.&emsp;&emsp;以下称为 [improved-ma]&emsp;&emsp;为 $k$-SUM、#Zero-Weight $k$-Clique、$k$-CNF Unsat 设计了高效的 MA 协议。都是多项式/生成函数加上一些神奇的多项式技巧。怎么感觉一直都是同一班人在给 OI/XCPC/学术带来多项式的血雨腥风&emsp;&emsp;这里会发现，$k$-SUM 和 $k$-CNF 都是做经典问题的补问题。因为 MA 协议还是比较爽的，以 $\\exists$ 开头的问题（如问是否有解）直接让 prover 把解扔给 verifier 就行了，所以反过来以 $\\forall$ 开头的问题（如问是否无解）才是有挑战性的。&emsp;&emsp;但如果尝试给 MA 套上 zero-knowledge，难度就另说了。。。 Amir Abboud, Virginia Vassilevska Williams, and Huacheng Yu. Matching Triangles and Basing Hardness on an Extremely Popular Conjecture.&emsp;&emsp;以下称为 [matching-triangles]&emsp;&emsp;这篇文章大概干了两件事：一是把很多问题归约到了 $\\Delta$-Matching-Triangle 问题上，第二是给出了 $\\Delta$-Matching-Triangle 问题的一个优秀的做法。做法是，枚举三种颜色的 size，然后取两种子做法复杂度较小者（算是一种复杂度平衡），第一个子做法是 size 比较小的时候直接枚举 $\\Delta-1$ 个三角形，然后用矩阵乘法判断是否存在最后一个三角形；第二个子做法是 size 比较大的时候先鸽笼一波排除掉一定有解的情况，然后把三角形 list 出来。 Interactive ProtocalsDOES co-NP HAVE SHORT INTERACTIVE PROOFS?Zero Knowledge Proof看这里 (Weighted) First Order Logic Model Counting and SamplingPaul Beame, Guy Van den Broeck, Eric Gribkoff, and Dan Suciu. Symmetric Weighted First-Order Model Counting. In PODS 2015.&emsp;&emsp;证明了 FO3（最多 3 个变量的一阶逻辑式子）的 WFOMC 是困难的。方法是把 $#P_1$ 问题的非确定性图灵机通过拉皮变成线性时间，然后像 Cook-Levin 定理一样归约到 FO3。&emsp;&emsp;附录的一些小技巧很有用：对于 Weighted Model Counting 来说，$\\exists$ 是可以去掉的（相当于只需考虑 Universal FO3），$\\lnot$ 是可以去掉的，等号也是可以去掉的。这三个技巧是巧妙地使用了 weight，甚至会把代入不同的 weight 当成是多项式插值，所以 weight 版本真的不仅仅是简单加强，而是引入了更多好玩的特性。&emsp;&emsp;这篇也顺带简述了 FO2 的 counting，所以是一篇很全的 WFOMC 入坑文。 Yuanhong Wang, Juhua Pu, Yuyi Wang, and Ondrej Kuzelka. On Exact Sampling in the Two-Variable Fragment of First-Order Logic. In LICS 2022.&emsp;&emsp;给出了 FO2 的 WFOMS 的多项式算法。&emsp;&emsp;其实 WFOMS 跟 WFOMC 的思路差不多的，因为本质上都是“用 counting 算概率来 sampling”。因此都是先处理一元谓词（1-type），再处理二元谓词（2-type）。实际上一元谓词的 1-type 可以看作是点染色，二元谓词的 2-type 可以看作是边染色。&emsp;&emsp;如果是 Universal 的 WFOMS，那点染完色之后各边就独立了，那就非常简单。但现在不是 Universal，而是 Scott Normal Form，就会复杂些。但同样是把 Scott Normal Form 抽象成图论问题，变成采样一个连通图。这个图论思路非常精彩。&emsp;&emsp;由于“能 counting 就能 sampling”，所以带 cardinality 限制的谓词、特殊限制谓词（比如要求一个二元谓词是一棵树）都是可以 sampling 的了。 Timothy van Bremen, and Ondrej Kuzelka. Lifted Inference with Tree Axioms. In AI 2023.&emsp;&emsp;给出了特殊谓词限制（比如 tree axiom，要求谓词是一棵树）的 counting。&emsp;&emsp;同样是先处理一元谓词（枚举 1-type，相当于点染色），再处理二元谓词（2-type，相当于边染色）。但是在边染色的时候，你就可以套矩阵树定理了！&emsp;&emsp;头一次见到矩阵树定理在科研中的应用&emsp;&emsp;这给人以一种强烈的感觉，像是我会了什么图上或树上的计数技巧（比如矩阵树定理），我就套进来，宣称我有了一种特殊谓词限制的算法。所以矩阵树定理绝不是唯一能套的，应当可以整理一个框架，讨论什么样的图上或树上计数技巧可以套进来当特殊谓词限制。 杂项Moein Falahatgar, Ashkan Jafarpour, Alon Orlitsky, Venkatadheeraj Pichapati, and Ananda Theertha Suresh. Estimating the Number of Defectives with Group Testing. In ISIT 2016.&emsp;&emsp;这里做的是 Group Testing 问题的其中一个版本：approximate the size of defective group，但不必求出来这个 group 具体有哪些人。&emsp;&emsp;这篇文章把上界和下界都做到了 $\\log \\log d$，其中 $d$ 就是要预测的 size。也就是说这俩界都是紧的，这个问题算是做完了。&emsp;&emsp;上界的算法就是通过不断平方、二分等方法调整预估 d 值的大小，使得 random test 结果为 1 的概率接近常数，然后用 chernoff bound 一波带走。&emsp;&emsp;下界是比较 trivial 的信息论证明，究其本质就是，最终 multiplicative error approximation 其实最多只有 $\\log n$ 种答案，而每次 test 只能返回 0 或 1，所以需要 $\\log \\log n$ 次 test 才能确定。 Nathan Linial, and Noam Nisan. Approximate Inclusion-Exclusion. In STOC 1990.&emsp;&emsp;求集合并（的大小或者概率，下省略）通常用容斥转化成求集合交，如果只知道一部分集合交（具体来说，有一个参数 $k$，我们只能知道任意不超过 $k$ 个集合的交），就可以通过这个方法来近似求出集合并。&emsp;&emsp;文章首先证明了任意两个集合序列，如果它们的“任意不超过 $k$ 个集合的交”都相同，这两个集合并就不会差太多。证明方法比较复杂，将“最大化集合并的差”表示成一个线性规划问题，然后对偶，变成一个求多项式的问题，再代入切比雪夫多项式。&emsp;&emsp;基于这个思路也就能在线性规划那一步改一改得到一个近似算法了。 Andrew Chi-Chih Yao. Probabilistic Computations: Toward A Unified Measure of Complexity. In SFCS 1977.&emsp;&emsp;著名的 Yao’s Minimax Principle。它说人话的表达就是：任意随机算法的 worst case complexity，大于等于（论文给的等于，但是 wiki 更简单的证明是大于等于）任给一个输入分布，最好的确定性算法在这上面的 complexity。&emsp;&emsp;它给出了一种将随机算法 lower bound 转化成确定性算法 lower bound 的思路，就是找一个分布，使得确定性算法不能做到这个 lower bound。","categories":[{"name":"TCS","slug":"TCS","permalink":"http://kqp.world/categories/TCS/"}],"tags":[{"name":"complexity","slug":"complexity","permalink":"http://kqp.world/tags/complexity/"},{"name":"ZKP","slug":"ZKP","permalink":"http://kqp.world/tags/ZKP/"}]},{"title":"【2018 NWERC D】Date Pickup 题解","slug":"【2018 NWERC D】Date Pickup 题解","date":"2021-10-09T05:59:34.000Z","updated":"2024-04-24T03:59:22.804Z","comments":true,"path":"【2018 NWERC D】Date Pickup 题解/","link":"","permalink":"http://kqp.world/%E3%80%902018%20NWERC%20D%E3%80%91Date%20Pickup%20%E9%A2%98%E8%A7%A3/","excerpt":"题目大意&emsp;&emsp;有一幅 $n$ 个点 $m$ 条边的有向图，边有边权（代表通过所需时间），你在 $1$ 号点，女朋友在 $n$ 号点。&emsp;&emsp;你可以选择在 $1$ 号点延迟任意时间之后，选定一条路线开始游走，一旦开始游走就不能停下来。你的女朋友会在时间区间 $[a,b]$ 中的任意一个实数时间点 call 你，你一旦被 call 就要马上过去 $n$ 号点，女朋友的等待时间就是她 call 了之后到你到达所用的时间。&emsp;&emsp;求女朋友的最坏等待时间最小。 &emsp;&emsp;$n,m \\le 10^5,\\ \\ 0 \\le a \\le b \\le 10^{12}$，边权 $\\le 10^6$&emsp;&emsp;保证每个点至少有一条出边，即总是可以无限游走的。 &emsp;&emsp;6s","text":"题目大意&emsp;&emsp;有一幅 $n$ 个点 $m$ 条边的有向图，边有边权（代表通过所需时间），你在 $1$ 号点，女朋友在 $n$ 号点。&emsp;&emsp;你可以选择在 $1$ 号点延迟任意时间之后，选定一条路线开始游走，一旦开始游走就不能停下来。你的女朋友会在时间区间 $[a,b]$ 中的任意一个实数时间点 call 你，你一旦被 call 就要马上过去 $n$ 号点，女朋友的等待时间就是她 call 了之后到你到达所用的时间。&emsp;&emsp;求女朋友的最坏等待时间最小。 &emsp;&emsp;$n,m \\le 10^5,\\ \\ 0 \\le a \\le b \\le 10^{12}$，边权 $\\le 10^6$&emsp;&emsp;保证每个点至少有一条出边，即总是可以无限游走的。 &emsp;&emsp;6s \\\\ \\\\ \\\\题解&emsp;&emsp;官方题解有很多细节不是很懂，不过对我考场上的想法有很大的启发，于是完成了我考场上的想法。 &emsp;&emsp;二分答案 $mid$。&emsp;&emsp;首先，如果到了 $[a,b]$ 这个时间段，我们必须随叫随到，因此我们可以知道这时候哪些点哪些边是能走的：对于点 $u$ 需满足 $dis(u,n) \\le mid$，对于边 $(u,v,w)$ 需满足 $w+dis(v,n) \\le mid$。这个时间段内我们只能在这个子图上走，除了开始的一点点（$a$ 时刻我们可能还在去这个子图的路上）。&emsp;&emsp;如果我们能从 $1$ 号点去到这个子图，那么接下来要做的事情就是：如果这个子图有环，我们就一直沿着环走，就合法了；如果这个子图没有环，它就是个 DAG，就可以在上面 dp 出一个最久逗留时间，让它 $\\ge b$ 就好了。&emsp;&emsp;所以现在就是要判断从 $1$ 号点能不能到达这个子图，即会不会在 $a$ 时刻还没走到子图但是被 call 了然后去不了 $n$ 号点。&emsp;&emsp;假设在 $[a,b]$ 时间段我们最先到达的节点是 $x$，它的充要条件就是：1、$x$ 是子图上的点；2、$dis(1,x) \\le a+mid-dis(x,n)$（即 $a$ 时刻 call 合法）。这样就相当于筛选出了子图的合法起点，可以做一个 bfs 筛去子图里起点不能到的点，然后做上面的拓扑找环和 dp。 &emsp;&emsp;关于 DAG 上的 dp，初值是对于子图起点 $x$，$dp_x=a+mid-dis(x,n)$（即越晚出发越好，但要满足 $a$ 时刻 call 合法），然后按拓扑序求最长路径。 &emsp;&emsp;注意一些特殊情况，比如 $1$ 号点本身是子图里的点的时候，只需判断 $dis(1,n) \\le mid$。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include&lt;bits/stdc++.h&gt;#define fo(i,a,b) for(int i=a;i&lt;=b;i++)using namespace std;typedef long long LL;typedef pair&lt;int,int&gt; pr;const int maxn=1e5+5;int n,m;LL a,b;vector&lt;pr&gt; e[maxn],ef[maxn];LL dis1[maxn],disn[maxn];bool vis[maxn];void dijkstra(int st,vector&lt;pr&gt; *e,LL *dis) &#123; memset(dis,127,sizeof(LL)*(n+2)); dis[st]=0; memset(vis,0,sizeof(vis)); priority_queue&lt;pair&lt;LL,int&gt;&gt; Q; Q.push(make_pair(0,st)); fo(i,1,n) &#123; while (!Q.empty() &amp;&amp; vis[Q.top().second]) Q.pop(); if (Q.empty()) break; auto tp=Q.top(); Q.pop(); vis[tp.second]=1; for(pr go:e[tp.second]) if (!vis[go.first] &amp;&amp; dis[go.first]&gt;-tp.first+go.second) &#123; dis[go.first]=-tp.first+go.second; Q.push(make_pair(-dis[go.first],go.first)); &#125; &#125;&#125;bool valid[maxn],arrived[maxn];vector&lt;pr&gt; et[maxn];LL dp[maxn];int dg[maxn];void bfs(LL mid) &#123; memset(dg,0,sizeof(dg)); memset(arrived,0,sizeof(arrived)); queue&lt;int&gt; Q; fo(i,1,n) &#123; et[i].clear(); if (valid[i] &amp;&amp; dis1[i]&lt;=a+mid-disn[i]) &#123; Q.push(i); arrived[i]=1; &#125; &#125; while (!Q.empty()) &#123; int cur=Q.front(); Q.pop(); for(auto go:e[cur]) if (go.second+disn[go.first]&lt;=mid) &#123; if (!arrived[go.first]) Q.push(go.first), arrived[go.first]=1; et[cur].push_back(go); dg[go.first]++; &#125; &#125;&#125;bool topo(LL mid) &#123; memset(dp,0xbf,sizeof(dp)); queue&lt;int&gt; Q; fo(i,1,n) if (arrived[i] &amp;&amp; !dg[i]) Q.push(i); while (!Q.empty()) &#123; int cur=Q.front(); Q.pop(); if (dis1[cur]&lt;=a+mid-disn[cur]) dp[cur]=max(dp[cur],a+mid-disn[cur]); if (dp[cur]&gt;=b) return 1; for(auto go:et[cur]) &#123; dp[go.first]=max(dp[go.first],dp[cur]+go.second); if (--dg[go.first]==0) Q.push(go.first); &#125; &#125; fo(i,1,n) if (arrived[i] &amp;&amp; dg[i]) return 1; return 0;&#125;bool check(LL mid) &#123; fo(i,1,n) valid[i]=(disn[i]&lt;=mid); if (valid[1]) return 1; bfs(mid); return topo(mid);&#125;int main() &#123; scanf(&quot;%lld %lld&quot;,&amp;a,&amp;b); scanf(&quot;%d %d&quot;,&amp;n,&amp;m); fo(i,1,m) &#123; int x,y,z; scanf(&quot;%d %d %d&quot;,&amp;x,&amp;y,&amp;z); e[x].push_back(make_pair(y,z)); ef[y].push_back(make_pair(x,z)); &#125; dijkstra(1,e,dis1); dijkstra(n,ef,disn); LL l=0, r=dis1[n]; while (l&lt;=r) &#123; LL mid=(l+r)&gt;&gt;1; if (check(mid)) r=mid-1; else l=mid+1; &#125; printf(&quot;%lld\\n&quot;,r+1);&#125;","categories":[{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[{"name":"算法_DP","slug":"算法-DP","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-DP/"},{"name":"算法_最短路模型","slug":"算法-最短路模型","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E6%9C%80%E7%9F%AD%E8%B7%AF%E6%A8%A1%E5%9E%8B/"}]},{"title":"【2021 Multi-University 4 E】Didn‘t I Say to Make My Abilities Average in the Next Life?! 题解","slug":"【2021 Multi-University 4 E】Didn‘t I Say to Make My Abilities Average in the Next Life! 题解","date":"2021-08-14T06:11:29.000Z","updated":"2024-04-24T03:59:22.818Z","comments":true,"path":"【2021 Multi-University 4 E】Didn‘t I Say to Make My Abilities Average in the Next Life! 题解/","link":"","permalink":"http://kqp.world/%E3%80%902021%20Multi-University%204%20E%E3%80%91Didn%E2%80%98t%20I%20Say%20to%20Make%20My%20Abilities%20Average%20in%20the%20Next%20Life!%20%E9%A2%98%E8%A7%A3/","excerpt":"题目大意&emsp;&emsp;定义一个序列的 average 为 $\\frac{最大值+最小值}{2}$。&emsp;&emsp;给定一个序列 $a_1,\\cdots,a_n$，有 $m$ 次询问，每次问这个区间的所有子区间的 average 期望。 &emsp;&emsp;$n,m \\le 2 \\times 10^5,\\ 1 \\le a_i \\le 10^9$&emsp;&emsp;多测，$\\sum n,\\sum m \\le 3 \\times 10^5$&emsp;&emsp;8s","text":"题目大意&emsp;&emsp;定义一个序列的 average 为 $\\frac{最大值+最小值}{2}$。&emsp;&emsp;给定一个序列 $a_1,\\cdots,a_n$，有 $m$ 次询问，每次问这个区间的所有子区间的 average 期望。 &emsp;&emsp;$n,m \\le 2 \\times 10^5,\\ 1 \\le a_i \\le 10^9$&emsp;&emsp;多测，$\\sum n,\\sum m \\le 3 \\times 10^5$&emsp;&emsp;8s \\\\ \\\\ \\\\扯淡&emsp;&emsp;考场上脑补了个 $O(m \\sqrt n)$ 的只增莫队巨难写，写到最后又 WA 又 T。&emsp;&emsp;第二天牛爷爷说这是个原题，上网搜了一下大家说这个题是【HNOI2016 序列】，于是就去学习了一下，老年选手被这个神奇的技巧秀得头皮发麻。。。 题解&emsp;&emsp;首先 $\\mathbb E[\\frac{\\max+\\min}{2}]=\\frac{\\mathbb E[\\max]+\\mathbb E[\\min]}{2}$，所以问题变成每次求一个区间所有子区间的 $\\max$ 和以及 $\\min$ 和。这就是【HNOI2016 序列】了。 &emsp;&emsp;做法多种多样，莫队和在线 $O(n \\log n+m)$ 的都有，但其实本质相同的，莫队到在线也就多一步小转化而已。下面就讲在线的。&emsp;&emsp;考虑这样一个数组：$f_i$ 表示右端点为 $i$、左端点 $\\in [1,i]$ 的所有区间的 $\\max$ 和。它的转移很简单，就是找到 $i$ 上一个比它大的数 $L_i$，那么左端点 $\\le L_i$ 的区间的 $\\max$ 都保持不变，左端点 $\\in (L_i,i]$ 的区间的 $\\max$ 等于 $a_i$，因此 f_i=f_{L_i}+a_i(i-L_i)&emsp;&emsp;这东西怎么用呢？变形得到 $f_i-f_{L_i}=a_i(i-L_i)$，也就是说，知道了 $i$ 的转移点 $L_i$，那么就知道了左端点 $\\in(L_i,i]$、右端点为 $i$ 的所有区间的 $\\max$ 和。&emsp;&emsp;更进一步，$i$ 从 $L_i$ 转移来，$L_i$ 从 $L_{L_i}$ 转移来……这样形成一个转移路径（实际上就是以 $i$ 结尾的单调栈），在这条路径上的任何一个 $j$，都满足 $f_i-f_j$ 等于左端点 $\\in(j,i]$、右端点为 $i$ 的所有区间的 $\\max$ 和。 &emsp;&emsp;接下来就可以做这题了。&emsp;&emsp;询问一个区间 $[l,r]$ 的所有子区间的 $\\max$ 和，先找到这个区间的最大值所在位置 $mx$，那么凡是左端点 $\\in [l,mx]$、右端点 $\\in (mx,r]$ 的子区间，最大值都是 $a_{mx}$。因此问题转化成 $[l,mx)$、$(mx,r]$ 的子问题。&emsp;&emsp;考虑 $(mx,r]$，重要的性质是，$mx$ 一定在 $r$ 的转移路径上，因此 $f_r-f_{mx}$ 就是左端点 $\\in (mx,r]$、右端点为 $r$ 的子区间的 $\\max$ 和；同理，$mx$ 一定也在 $r-1$ 的转移路径上，所以 $f_{r-1}-f_{mx}$ 就是左端点 $\\in (mx,r-1]$、右端点为 $r-1$ 的子区间的 $\\max$ 和……&emsp;&emsp;因此 $(mx,r]$ 的贡献就是 (f_r-f_{mx})+(f_{r-1}-f_{mx})+\\cdots+(f_{mx+1}-f_{mx})=\\left(\\sum_{i=mx+1}^rf_i\\right)-f_{mx}(r-mx)&emsp;&emsp;所以求个 $f$ 的前缀和就做好了。&emsp;&emsp;同理可求 $[l,mx)$ 的贡献，以及 $\\min$ 和。 &emsp;&emsp;时间复杂度，预处理 rmq 需要 $O(n \\log n)$，预处理 $f$ 需要 $O(n)$，每个询问是 $O(1)$ 的，因此是 $O(n \\log n + m)$。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106#include&lt;bits/stdc++.h&gt;#define fo(i,a,b) for(int i=a;i&lt;=b;i++)#define fd(i,a,b) for(int i=a;i&gt;=b;i--)using namespace std;typedef long long LL;const int maxn=2e5+5, MX=17;const LL mo=1e9+7, inv2=(mo+1)&gt;&gt;1;int n,m,a[maxn];int st_mx[MX+2][maxn],st_mn[MX+2][maxn],Log[maxn];void rmq_pre() &#123; fo(i,1,n) st_mx[0][i]=st_mn[0][i]=i; fo(i,2,n) Log[i]=Log[i&gt;&gt;1]+1; fo(j,1,MX) fo(i,1,n) &#123; st_mx[j][i]=st_mx[j-1][i]; st_mn[j][i]=st_mn[j-1][i]; int t=i+(1&lt;&lt;(j-1)); if (t&lt;=n) &#123; if (a[st_mx[j][i]]&lt;a[st_mx[j-1][t]]) st_mx[j][i]=st_mx[j-1][t]; if (a[st_mn[j][i]]&gt;=a[st_mn[j-1][t]]) st_mn[j][i]=st_mn[j-1][t]; &#125; &#125;&#125;pair&lt;int,int&gt; rmq(int l,int r) &#123; int t=Log[r-l+1]; int mx=(a[st_mx[t][l]]&gt;=a[st_mx[t][r-(1&lt;&lt;t)+1]]) ?st_mx[t][l] :st_mx[t][r-(1&lt;&lt;t)+1]; int mn=(a[st_mn[t][l]]&lt;a[st_mn[t][r-(1&lt;&lt;t)+1]]) ?st_mn[t][l] :st_mn[t][r-(1&lt;&lt;t)+1]; return make_pair(mx,mn);&#125;LL f_l_mx[maxn],f_l_mn[maxn],f_r_mx[maxn],f_r_mn[maxn];LL s_l_mx[maxn],s_l_mn[maxn],s_r_mx[maxn],s_r_mn[maxn];int z0,z[maxn];void f_pre() &#123; z0=0; fo(i,1,n) &#123; while (z0 &amp;&amp; a[z[z0]]&lt;a[i]) z0--; f_l_mx[i]=(f_l_mx[z[z0]]+(LL)a[i]*(i-z[z0]))%mo; s_l_mx[i]=(s_l_mx[i-1]+f_l_mx[i])%mo; z[++z0]=i; &#125; z0=0; fo(i,1,n) &#123; while (z0 &amp;&amp; a[z[z0]]&gt;=a[i]) z0--; f_l_mn[i]=(f_l_mn[z[z0]]+(LL)a[i]*(i-z[z0]))%mo; s_l_mn[i]=(s_l_mn[i-1]+f_l_mn[i])%mo; z[++z0]=i; &#125; z0=0; s_r_mx[n+1]=0; fd(i,n,1) &#123; while (z0 &amp;&amp; a[z[z0]]&lt;=a[i]) z0--; f_r_mx[i]=(f_r_mx[z[z0]]+(LL)a[i]*(z[z0]-i))%mo; s_r_mx[i]=(s_r_mx[i+1]+f_r_mx[i])%mo; z[++z0]=i; &#125; z0=0; s_r_mn[n+1]=0; fd(i,n,1) &#123; while (z0 &amp;&amp; a[z[z0]]&gt;a[i]) z0--; f_r_mn[i]=(f_r_mn[z[z0]]+(LL)a[i]*(z[z0]-i))%mo; s_r_mn[i]=(s_r_mn[i+1]+f_r_mn[i])%mo; z[++z0]=i; &#125;&#125;LL Pow(LL x,LL y) &#123; LL re=1; for(; y; y&gt;&gt;=1, x=x*x%mo) if (y&amp;1) re=re*x%mo; return re;&#125;LL sum(LL x) &#123;return x*(x+1)%mo*inv2%mo;&#125;int main() &#123; int T; scanf(&quot;%d&quot;,&amp;T); while (T--) &#123; scanf(&quot;%d %d&quot;,&amp;n,&amp;m); fo(i,1,n) scanf(&quot;%d&quot;,&amp;a[i]); rmq_pre(); f_pre(); while (m--) &#123; int l,r; scanf(&quot;%d %d&quot;,&amp;l,&amp;r); pair&lt;int,int&gt; p=rmq(l,r); int mx=p.first, mn=p.second; LL ans_mx=a[mx]*(LL)(mx-l+1)%mo*(r-mx+1)%mo; (ans_mx+=s_l_mx[r]-s_l_mx[mx]+mo-f_l_mx[mx]*(r-mx)%mo+mo)%=mo; (ans_mx+=s_r_mx[l]-s_r_mx[mx]+mo-f_r_mx[mx]*(mx-l)%mo+mo)%=mo; LL ans_mn=a[mn]*(LL)(mn-l+1)%mo*(r-mn+1)%mo; (ans_mn+=s_l_mn[r]-s_l_mn[mn]+mo-f_l_mn[mn]*(r-mn)%mo+mo)%=mo; (ans_mn+=s_r_mn[l]-s_r_mn[mn]+mo-f_r_mn[mn]*(mn-l)%mo+mo)%=mo; LL ans=(ans_mx+ans_mn)%mo*inv2%mo*Pow(sum(r-l+1),mo-2)%mo; printf(&quot;%lld\\n&quot;,ans); &#125; &#125;&#125;","categories":[{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[{"name":"算法_神奇的脑洞","slug":"算法-神奇的脑洞","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E7%A5%9E%E5%A5%87%E7%9A%84%E8%84%91%E6%B4%9E/"},{"name":"算法_莫队/分块","slug":"算法-莫队-分块","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E8%8E%AB%E9%98%9F-%E5%88%86%E5%9D%97/"}]},{"title":"【2021 Multi-University 4 G】Increasing Subsequence 题解","slug":"【2021 Multi-University 4 G】Increasing Subsequence 题解","date":"2021-08-13T02:54:40.000Z","updated":"2024-04-24T03:59:22.818Z","comments":true,"path":"【2021 Multi-University 4 G】Increasing Subsequence 题解/","link":"","permalink":"http://kqp.world/%E3%80%902021%20Multi-University%204%20G%E3%80%91Increasing%20Subsequence%20%E9%A2%98%E8%A7%A3/","excerpt":"题目大意&emsp;&emsp;给定一个排列 $a_1,\\cdots,a_n$，求极长上升子序列的数量。 &emsp;&emsp;$n \\le 10^5$","text":"题目大意&emsp;&emsp;给定一个排列 $a_1,\\cdots,a_n$，求极长上升子序列的数量。 &emsp;&emsp;$n \\le 10^5$ \\\\ \\\\ \\\\题解&emsp;&emsp;设 $dp_i$ 表示以 $i$ 结尾的极长上升子序列数量，那么关键就是找到 $dp_i$ 能从哪些 $dp_j$ 转移过来，需要满足 $a_i&gt;a_j$ 且 $j$ 到 $i$ 之间没有 $\\in [a_j,a_i]$ 的数了。&emsp;&emsp;这种前面的数贡献到后面的数的模型，还要想到 cdq 这种！&emsp;&emsp;假设当前分治区间 $[l,r]$，中间是 $mid$。把 $a_l,\\cdots,a_r$ 从小到大排序，然后左半边维护一个位置单调递减的栈，右半边维护一个位置单调递增的栈，大概长这样： 7\\ 6\\ 3\\ 1\\ |\\ 2\\ 4\\ 5\\ 8&emsp;&emsp;（中线代表 $mid$，两边分别是向左向右增长的栈，数字是 $a$ 值，保持了原序列的相对位置关系）&emsp;&emsp;左边的单调栈的含义是，如果有一个很大的数放在了很右的位置，显然它左边的小的数都不再能转移出去了；右边的单调栈的含义是，因为右边是代表询问的，因此如果有一个很大的数放在了很左的位置，那么它会对以后的询问构成更紧的限制，它右边的小的数就没用了。&emsp;&emsp;那么比如 $8$ 插入到右边的栈，它的栈里下一个元素是 $5$，意思就是左边 $5$ 及以下的数都不能转移到 $8$，因此能转移到 $8$ 的只有 $6,7$。那么这就是个在左边栈里二分的过程。&emsp;&emsp;复杂度 $O(n \\log ^2 n)$ 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include&lt;bits/stdc++.h&gt;#define fo(i,a,b) for(int i=a;i&lt;=b;i++)#define fd(i,a,b) for(int i=a;i&gt;=b;i--)using namespace std;typedef long long LL;const int maxn=1e5+5;const LL mo=998244353;int n,a[maxn];bool canBeInit[maxn];LL dp[maxn],Sl[maxn];int b0,zl0,zl[maxn],zr0,zr[maxn];pair&lt;int,int&gt; b[maxn];int find(int x) &#123; int l=1, r=zl0; while (l&lt;=r) &#123; int mid=(l+r)&gt;&gt;1; if (a[zl[mid]]&lt;x) l=mid+1; else r=mid-1; &#125; return l-1;&#125;void cdq(int l,int r) &#123; if (l==r) &#123; (dp[l]+=canBeInit[l])%=mo; return; &#125; int mid=(l+r)&gt;&gt;1; cdq(l,mid); b0=0; fo(i,l,r) b[++b0]=make_pair(a[i],i); sort(b+1,b+1+b0); zl0=zr0=0; fo(i,1,b0) if (b[i].second&lt;=mid) &#123; while (zl0 &amp;&amp; zl[zl0]&lt;b[i].second) zl0--; zl[++zl0]=b[i].second; Sl[zl0]=(Sl[zl0-1]+dp[b[i].second])%mo; &#125; else &#123; while (zr0 &amp;&amp; zr[zr0]&gt;b[i].second) zr0--; int t=find(a[zr[zr0]]); (dp[b[i].second]+=Sl[zl0]-Sl[t]+mo)%=mo; zr[++zr0]=b[i].second; &#125; cdq(mid+1,r);&#125;int main() &#123; int T; scanf(&quot;%d&quot;,&amp;T); while (T--) &#123; scanf(&quot;%d&quot;,&amp;n); fo(i,1,n) scanf(&quot;%d&quot;,&amp;a[i]); int last=n+1; fo(i,1,n) if (a[i]&lt;last) &#123; canBeInit[i]=1; last=a[i]; &#125; else canBeInit[i]=0; memset(dp,0,sizeof(LL)*(n+2)); cdq(1,n); last=0; LL ans=0; fd(i,n,1) if (a[i]&gt;last) &#123; last=a[i]; (ans+=dp[i])%=mo; &#125; printf(&quot;%lld\\n&quot;,ans); &#125;&#125;","categories":[{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[{"name":"算法_分治","slug":"算法-分治","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E5%88%86%E6%B2%BB/"}]},{"title":"【SEERC 2020 H】AND = OR 题解","slug":"【SEERC 2020 H】AND = OR 题解","date":"2021-08-12T08:10:36.000Z","updated":"2024-04-24T03:59:22.866Z","comments":true,"path":"【SEERC 2020 H】AND = OR 题解/","link":"","permalink":"http://kqp.world/%E3%80%90SEERC%202020%20H%E3%80%91AND%20=%20OR%20%E9%A2%98%E8%A7%A3/","excerpt":"题目大意&emsp;&emsp;定义一个序列是好的，当且仅当能把这个序列里的数划分成两个非空集合，使得一个集合的 and 等于另一个集合的 or。&emsp;&emsp;给定 $a_1,\\cdots,a_n$，有 $q$ 个询问，每次询问 $a_l,\\cdots,a_r$ 是否是好的。 &emsp;&emsp;$n,q \\le 10^5,\\ 0 \\le a_i &lt; 2^{30}$&emsp;&emsp;3s","text":"题目大意&emsp;&emsp;定义一个序列是好的，当且仅当能把这个序列里的数划分成两个非空集合，使得一个集合的 and 等于另一个集合的 or。&emsp;&emsp;给定 $a_1,\\cdots,a_n$，有 $q$ 个询问，每次询问 $a_l,\\cdots,a_r$ 是否是好的。 &emsp;&emsp;$n,q \\le 10^5,\\ 0 \\le a_i &lt; 2^{30}$&emsp;&emsp;3s \\\\ \\\\ \\\\题解&emsp;&emsp;and 会把数字越 and 越小，or 会把数字越 or 越大，所以应该让“大”的数去 and，“小”的数去 or。&emsp;&emsp;怎么定义“大”和“小”呢？如果就按数值来分，是可以的，可以证明如果询问一个区间 $[l,r]$，一定是把这个区间从小到大排序后从某个位置切开，小的部分 or，大的部分 and，但似乎不太能做这题。。。&emsp;&emsp;另一种“大”和“小”的定义是二进制下 1 的个数。对于每个询问，假设最终答案有 $x$ 个 1，那么比 $x$ 多的 $a_i$ 就应当 and，比 $x$ 小的 $a_i$ 就应当 or。而恰好有 $x$ 个 1 的 $a_i$，要么全都扔向同一边，要么它们全都相等（都等于答案）然后分到两边。&emsp;&emsp;所以对于每个询问，用主席树求出这个区间以 1 的数量为下标的前缀 or 以及后缀 and，然后枚举 $x$ 判断即可。注意如果要把恰好有 $x$ 个 1 的 $a_i$ 扔到两边的话，那么这样的 $a_i$ 的数量要 $\\ge 2$。因此主席树要记录区间 or、区间 and、区间元素数量。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#include&lt;bits/stdc++.h&gt;#define fo(i,a,b) for(int i=a;i&lt;=b;i++)#define fd(i,a,b) for(int i=a;i&gt;=b;i--)using namespace std;const int maxn=1e5+5, MX=30, maxtot=2e6+5;struct AST&#123; int val,num,i;&#125;;bool cmpA(const AST &amp;a,const AST &amp;b) &#123;return a.num&lt;b.num;&#125;int n,q;AST a[maxn];int totOr,totAnd,tr_or[maxtot],tr_and[maxtot],tr_cnt[maxtot],son_or[maxtot][2],son_and[maxtot][2];int rootOr[MX+2],rootAnd[MX+2],resOr,resAnd,resCnt;void tr_xg_or(int k,int last,int l,int r,int x,int z) &#123; while (l&lt;r) &#123; tr_or[k]=tr_or[last]|z; tr_cnt[k]=tr_cnt[last]+1; int mid=(l+r)&gt;&gt;1; if (x&lt;=mid) &#123; son_or[k][1]=son_or[last][1]; son_or[k][0]=++totOr; k=totOr, last=son_or[last][0], r=mid; &#125; else &#123; son_or[k][0]=son_or[last][0]; son_or[k][1]=++totOr; k=totOr, last=son_or[last][1], l=mid+1; &#125; &#125; tr_or[k]=tr_or[last]|z; tr_cnt[k]=tr_cnt[last]+1;&#125;void tr_xg_and(int k,int last,int l,int r,int x,int z) &#123; while (l&lt;r) &#123; tr_and[k]=tr_and[last]&amp;z; int mid=(l+r)&gt;&gt;1; if (x&lt;=mid) &#123; son_and[k][1]=son_and[last][1]; son_and[k][0]=++totAnd; k=totAnd, last=son_and[last][0], r=mid; &#125; else &#123; son_and[k][0]=son_and[last][0]; son_and[k][1]=++totAnd; k=totAnd, last=son_and[last][1], l=mid+1; &#125; &#125; tr_and[k]=tr_and[last]&amp;z;&#125;void tr_cx(int kOr,int lastOr,int kAnd,int l,int r,int x,int y) &#123; if (x&lt;=l &amp;&amp; r&lt;=y) &#123; resOr|=tr_or[kOr]; resAnd&amp;=tr_and[kAnd]; resCnt+=tr_cnt[kOr]-tr_cnt[lastOr]; return; &#125; int mid=(l+r)&gt;&gt;1; if (x&lt;=mid) tr_cx(son_or[kOr][0],son_or[lastOr][0],son_and[kAnd][0],l,mid,x,y); if (mid&lt;y) tr_cx(son_or[kOr][1],son_or[lastOr][1],son_and[kAnd][1],mid+1,r,x,y);&#125;int sumOr[MX+5],sumAnd[MX+5],cnt[MX+5];int main() &#123; scanf(&quot;%d %d&quot;,&amp;n,&amp;q); fo(i,1,n) &#123; scanf(&quot;%d&quot;,&amp;a[i].val); a[i].num=__builtin_popcount(a[i].val); a[i].i=i; &#125; sort(a+1,a+1+n,cmpA); int i=1; fo(w,0,MX) &#123; if (w) rootOr[w]=rootOr[w-1]; for(; i&lt;=n &amp;&amp; a[i].num==w; i++) &#123; int last=rootOr[w]; tr_xg_or(rootOr[w]=++totOr,last,1,n,a[i].i,a[i].val); &#125; &#125; tr_and[0]=(1&lt;&lt;30)-1; i=n; fd(w,MX,0) &#123; rootAnd[w]=rootAnd[w+1]; for(; i &amp;&amp; a[i].num==w; i--) &#123; int last=rootAnd[w]; tr_xg_and(rootAnd[w]=++totAnd,last,1,n,a[i].i,a[i].val); &#125; &#125; while (q--) &#123; int l,r; scanf(&quot;%d %d&quot;,&amp;l,&amp;r); int sumCnt=0; fo(w,0,MX) &#123; resOr=0, resAnd=(1&lt;&lt;30)-1, resCnt=0; tr_cx(rootOr[w],(w==0 ?0 :rootOr[w-1]),rootAnd[w],1,n,l,r); sumOr[w]=resOr; sumAnd[w]=resAnd; cnt[w]=resCnt; sumCnt+=resCnt; &#125; bool ans=0; int numLess=0; fo(w,0,MX) &#123; if (numLess &amp;&amp; numLess&lt;sumCnt &amp;&amp; sumOr[w-1]==sumAnd[w]) &#123;ans=1; break;&#125; if (sumOr[w]==sumAnd[w] &amp;&amp; cnt[w]&gt;=2) &#123;ans=1; break;&#125; numLess+=cnt[w]; &#125; puts(ans ?&quot;YES&quot; :&quot;NO&quot;); &#125;&#125;","categories":[{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[{"name":"算法_位运算","slug":"算法-位运算","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/"}]},{"title":"【编译原理大作业】Tiny+的三地址码","slug":"Tiny+3addrcode","date":"2021-08-11T08:32:19.000Z","updated":"2024-04-24T03:59:22.798Z","comments":true,"path":"Tiny+3addrcode/","link":"","permalink":"http://kqp.world/Tiny+3addrcode/","excerpt":"&emsp;&emsp;咕得有点久了&emsp;&emsp;这是编译原理大作业的第二步：进行语义分析，生成三地址码。","text":"&emsp;&emsp;咕得有点久了&emsp;&emsp;这是编译原理大作业的第二步：进行语义分析，生成三地址码。&emsp;&emsp;三地址码是一种平台无关的中间代码（类似汇编，但没到 x86、MIPS 那么具体），特点是：1、变量和 label 无需换成具体的地址，能区分清楚就行（例如嵌套作用域的同名变量要区分开）；2、寄存器无限量，不需要考虑有限的寄存器池；3、没有关于 CPU、操作系统的对接细节。这还是一个比较中间层次的东西，要生成具体的可执行代码时，不同平台可以直接拿三地址码来翻译。&emsp;&emsp;有了上一步的语法树之后，这一部分就不需要额外的工具了，就在语法树上完成需要的操作。尽管语义分析可以在语法分析的过程中完成，但是建出树以后再操作会好写一点，反正时间复杂度是不变的。&emsp;&emsp;参考书用龙书即可（Compilers Principles, Techniques, Tools. second version），龙书已经把框架给得很清楚了，虽然略去了一堆坑 b 的细节。。。&emsp;&emsp;三地址码的格式也用龙书的。 &emsp;&emsp;项目地址 语义分析&emsp;&emsp;语义分析是比较大的概念，对于不同的程序有不同的语义分析内容，例如，基于我的语言定义，可以进行包括但不限于如下的语义分析： 检查整个程序是否有且仅有一个 MAIN 标识的函数； 检查变量、函数引用前是否声明； 检查变量、函数是否重定义； 类型检查与类型强制转换。目前 Tiny+ 程序可用的类型只有 BOOL,CHAR,INT,REAL，它们之间都可以强制转换，且已按优先级从低到高排好。因此可以不用进行类型检查，只需在类型不匹配时强制类型转换（低优先级转换到高优先级）； 调用函数时检查参数及类型是否匹配； 检查函数是否以 RETURN 结尾，若不是，需提出 warning。 &emsp;&emsp;我们可以在生成三地址码的过程中顺便做这些事情。 符号表&emsp;&emsp;符号表是一个栈结构，用于记录生成代码中遇到的各种符号，以便在真正的编译中替换成地址。本次的符号表需记录以下内容： 定义的变量； 定义的函数； 控制流跳转用的 label &emsp;&emsp;具体实现，在基类 node 中定义符号表：(26 行)12345678910111213141516171819202122232425262728enum Symbol_t&#123; SB_VAR, SB_FUNC, SB_LABEL, SB_NOTFOUND&#125;;class node;struct Symbol &#123; Symbol_t type; string label; Var_t varType; node *ref; // reference to that symbol Symbol(Symbol_t ty,string lb=&quot;&quot;,Var_t vt=V_BOOL,node *rf=nullptr) &#123; type=ty, varType=vt, label=lb, ref=rf; &#125; Symbol() &#123;&#125;&#125;;typedef unordered_map&lt;string,Symbol&gt; SymbolTabType;class node&#123; public: ... static vector&lt;SymbolTabType&gt; symbolTab; // symbol table. It is a stack static int EOCFCnt, elseCnt, loopCnt, varCnt; // label count&#125;; &emsp;&emsp;用 std::vector 来模拟符号表的栈（为了可以遍历栈元素而不用 std::stack）；栈的每一项是一个 unordered_map&lt;string,Symbol&gt;，用于映射符号到其信息；信息用 struct Symbol 来记录，内容包括符号类型、符号的 label、符号的运算类型（BOOL,INT 等）、代表该符号的语法树节点。&emsp;&emsp;在实际编译中，只有跨文件的符号需要记录 label 以用于链接，其余符号可直接记录其内存地址，因为符号最终就是要替换成地址的。&emsp;&emsp;另使用 EOCFCnt, elseCnt, loopCnt, varCnt 四个计数器来生成控制流跳转 label 标号、else 跳转 label 标号、循环跳转 label 标号、变量及寄存器唯一标号。使用计数器的目的就是使得 label、变量和寄存器标号变得唯一。 从符号表中查找符号&emsp;&emsp;从符号表中查找一个符号，就从栈顶往栈底依次查找，找到了返回相应的 Symbol 信息，找不到就返回 NOTFOUND。12345Symbol find_symbol(string s) &#123; for(int i=node::symbolTab.size()-1; i&gt;=0; i--) if (node::symbolTab[i].count(s)) return node::symbolTab[i][s]; return Symbol(SB_NOTFOUND);&#125; 控制流结束跳转 label&emsp;&emsp;If、For 等控制流需要一个继承属性 label 表示该控制流结束之后跳转到何处。这个继承属性在符号表中实现，用 %EOCF 符号（End Of Control Flow）来表示该语句结束后应跳转到的 label。这样 If、For 等节点具体生成代码的时候，只要从符号表中查找最近的 %EOCF，就知道如何跳转了。 三地址码&emsp;&emsp;在基类 node 中定义虚函数 generate_3addr_code()，即每个节点类实现自己的三地址码生成过程。12345678typedef vector&lt;pair&lt;string,string&gt;&gt; Codes; // format: pair&lt;label,instruction&gt;class node&#123; public: ... Codes codes; virtual bool generate_3addr_code() &#123;&#125; // return 0 if compiled successfully&#125;;&emsp;&emsp;三地址码形如 vector&lt;pair&lt;string,string&gt;&gt;，每条指令代码用两个 string 表示，前一个 string 表示 label，后一个 string 表示指令。&emsp;&emsp;本次实验中，label 和指令是多对一的关系，即相同名称的 label 一定指向同一条指令，但一条指令可以对应多个 label。这在实际编译中也是可行的，因为 label 的本质是内存地址，如果用内存地址代替 label 的记录，那么 label 和指令就是一一对应的了。&emsp;&emsp;接下来分不同的节点类来说明 generate_3addr_code() 的实现，以及相应的语法检查。 Program&emsp;&emsp;Program 是整个语法树的根，它新建一层符号表用于标记全局 label，调用它的子节点（MethodDecls）生成代码，并在整份代码开头补充一句 goto mainFuncLabel 使得程序跳到 MAIN 函数入口。12345678bool node_Program::generate_3addr_code() &#123; symbolTab.push_back(SymbolTabType()); // global label bool err=son[0]-&gt;generate_3addr_code(); codes.push_back(make_pair(&quot;&quot;,&quot;goto &quot;+mainFuncLabel)); // goto main function add_codes(codes,son[0]-&gt;codes); symbolTab.pop_back(); return err;&#125;&emsp;&emsp;add_codes(a,b) 是把 b 的代码加到 a 的末尾。12345void add_codes(Codes &amp;a,Codes &amp;b) &#123; if (a.empty()) a=b; else for(auto code:b) a.push_back(code); b.clear();&#125; MethodDecls&emsp;&emsp;该节点可以得到整个程序的函数列表。因此先把函数标识符添加到符号表中，生成它们的跳转 label（”__” 加函数名），这样就可以做到函数的调用与声明顺序无关。&emsp;&emsp;此处顺便找出 MAIN 标识的函数，并检查是否唯一。123456789101112131415161718192021222324string node::mainFuncLabel=&quot;NO&quot;;bool node_MethodDecls::generate_3addr_code() &#123; bool err=0; // add function names to symbol table, and find &#x27;main&#x27; for(auto xp:son) &#123; node_MethodDecl *x=(node_MethodDecl*)xp; string &amp;funcName=((node_Id*)(x-&gt;son[1]))-&gt;name; symbolTab.back()[funcName]=Symbol(SB_FUNC,&quot;__&quot;+funcName,((node_Type*)(x-&gt;son[0]))-&gt;varType,xp); if (x-&gt;isMain) &#123; if (mainFuncLabel!=&quot;NO&quot;) semantic_error(&quot;more than one main function&quot;) else mainFuncLabel=&quot;__&quot;+funcName; &#125; &#125; if (mainFuncLabel==&quot;NO&quot;) semantic_error(&quot;no main function&quot;); for(auto xp:son) &#123; // enumerate each method // each method generates its codes and add to this-&gt;codes node_MethodDecl *x=(node_MethodDecl*)xp; err|=x-&gt;generate_3addr_code(); add_codes(codes,x-&gt;codes); &#125; return err;&#125;这里用到了语义报错操作。简单地在节点类里记录一下当前节点对应的代码的行号（新建节点时保存 flex 的 yylineno 即可），就可以报错时输出行号了。1234567#define semantic_error(message) &#123;\\ cout &lt;&lt; lineno &lt;&lt; &quot;: semantic error: &quot; &lt;&lt; message &lt;&lt; endl;\\ err=1;\\&#125;#define semantic_warning(message) &#123;\\ cout &lt;&lt; lineno &lt;&lt; &quot;: warning: &quot; &lt;&lt; message &lt;&lt; endl;\\&#125; MethodDecl&emsp;&emsp;该节点是具体的一个函数。首先新建一层符号表，表示新一层的局部变量，以及在表里记录当前所在的函数信息（return 要用）；然后处理形参表，将形参加入局部变量；接着生成函数内的 statements 的具体代码；最后检查代码的最后一条指令是否是 return。&emsp;&emsp;这里需要新建一个 %EOCF 符号，指向最后的 return，即如果该函数最后一条语句是 If 等控制流，那么这个 If 语句就知道它要跳转到最后的 return 了。（如果代码自己生成了 return，那么这个符号也是用不上的。）123456789101112131415161718192021bool node_MethodDecl::generate_3addr_code() &#123; bool err=0; symbolTab.push_back(SymbolTabType()); // local label symbolTab.back()[&quot;%EOCF&quot;]=Symbol(SB_LABEL,&quot;EOCF_&quot;+to_string(EOCFCnt++)); // &#x27;End Of Control Flow&#x27; label // mark which function we are in symbolTab.back()[&quot;%FUNC&quot;]=Symbol(SB_LABEL,&quot;&quot;,((node_Type*)son[0])-&gt;varType,(node*)this); err|=((node_FormalParams*)son[2])-&gt;add_formal_params(); // formal parameters if (son.size()&gt;=4) &#123; err|=son[3]-&gt;generate_3addr_code(); // statements add_codes(codes,son[3]-&gt;codes); &#125; // check if the last instruction is return if (codes.empty() || codes.back().second!=&quot;return&quot;) &#123; semantic_warning(&quot;lack of return at the end of function&quot;); codes.push_back(make_pair(&quot;&quot;,&quot;return&quot;)); &#125; codes.back().first.insert(0,symbolTab.back()[&quot;%EOCF&quot;].label+&quot;: &quot;); codes[0].first.insert(0,&quot;__&quot;+((node_Id*)son[1])-&gt;name+&quot;: &quot;); // mark the entrance of function symbolTab.pop_back(); return err;&#125; Statements&emsp;&emsp;该节点表示语句的集合，同时也表示被 BEGIN, END 包起来的一个区块。所以逻辑就是先新建一层符号表表示局部变量，然后每条语句依次生成。&emsp;&emsp;但是遇到控制流语句的时候，要判断该语句是否是最后一句，如果是，那么 %EOCF 沿用祖先的（即控制流结束后跳转到祖先指定的地方），否则新建一个 %EOCF 指向下一条语句，并在下一条语句的第一个指令加上这个 label。 &emsp;&emsp;听起来很简单 &emsp;&emsp;但实际上。。。细思极恐，所谓“%EOCF指向下一条语句，并在下一条语句的第一个指令加上这个 label”，它可能需要处理这样的代码：123456789101112131415161718192021IF (z==1) BEGIN IF (i==1) BEGIN IF (y==2) BEGIN END BEGIN END BEGIN BEGIN END END END BEGIN BEGIN END END BEGIN ENDENDBEGIN INT a;END &emsp;&emsp;这里的三个 if 全部都有“下一条语句”，但由于“下一条语句”为空，因此它们最终全都要使用祖先的 %EOCF，而不能新建 label 然后加到“下一条语句”。&emsp;&emsp;有同学说，既然这是空语句产生的 bug，那在生成语法树时就把这些空语句规避掉，不建立节点，不就好了？其一，空语句结构可能很复杂（比如这样嵌套的），从语法上处理它是比较麻烦的；其二，空语句不一定是形式上的空语句，还可以是实质空语句（就是写了非平凡的代码但生成的是空语句，例如因代码优化导致的空语句，例如局部变量定义也是不产生代码的），这导致一个不可规避的问题。 &emsp;&emsp;解决方法是，遇到控制流，就把这一段连续的控制流语句抠出来，然后倒着做，相当于先要找到真正的非空的“下一条语句”在哪，然后倒序依次在这条语句的开头新建 %EOCF（或是决定用祖先的）给上一条语句用。123456789101112131415161718192021222324252627282930313233343536373839404142434445bool isControlFlow(node *x) &#123; return (!x-&gt;son.empty() &amp;&amp; (x-&gt;son[0]-&gt;nodeType==IFSTMT || x-&gt;son[0]-&gt;nodeType==FORSTMT));&#125;bool node_Statements::generate_3addr_code() &#123; bool err=0; symbolTab.push_back(SymbolTabType()); // local label for(int i=0; i&lt;son.size(); i++) &#123; node_Statement *x=(node_Statement*)son[i]; if (isControlFlow(x)) &#123; // for continuous control flows, generate codes in reverse order, // to avoid bugs of EOCF label with empty statement vector&lt;node*&gt; CFlist; int j=i; // i: the first CF; j: after the last CF for(; ; j++) &#123; for(; j&lt;son.size() &amp;&amp; isControlFlow(son[j]); j++) CFlist.push_back(son[j]); if (j&gt;=son.size()) break; err|=son[j]-&gt;generate_3addr_code(); if (!son[j]-&gt;codes.empty()) break; &#125; if (j&lt;son.size()) &#123; string eocf=&quot;EOCF_&quot;+to_string(EOCFCnt++); symbolTab.back()[&quot;%EOCF&quot;]=Symbol(SB_LABEL,eocf); son[j]-&gt;codes[0].first.insert(0,eocf+&quot;: &quot;); &#125; for(int k=CFlist.size()-1; k&gt;=0; k--) &#123; err|=CFlist[k]-&gt;generate_3addr_code(); if (k&gt;i) &#123; string eocf=&quot;EOCF_&quot;+to_string(EOCFCnt++); symbolTab.back()[&quot;%EOCF&quot;]=Symbol(SB_LABEL,eocf); CFlist[k]-&gt;codes[0].first.insert(0,eocf+&quot;: &quot;); &#125; &#125; symbolTab.back().erase(&quot;%EOCF&quot;); for(; i&lt;=j; i++) if (i&lt;son.size()) add_codes(codes,son[i]-&gt;codes); i--; &#125; else &#123; err|=x-&gt;generate_3addr_code(); // each statement add_codes(codes,x-&gt;codes); &#125; &#125; symbolTab.pop_back(); return err;&#125; 简单语句&emsp;&emsp;LocalVarDecl, AssignStmt, ReturnStmt, ReadStmt, WriteStmt 都是单条简单语句，它们生成的代码都较为简单，代码不赘述。&emsp;&emsp;ReturnStmt 需要注意若返回表达式的类型与函数类型不匹配，则要强制类型转换。&emsp;&emsp;ReadStmt, WriteStmt 当作函数调用处理。 &emsp;&emsp;以 AssignStmt 为例：1234567891011bool node_AssignStmt::generate_3addr_code() &#123; bool err=0; string &amp;leftName=((node_Id*)son[0])-&gt;name; Symbol left=find_symbol(leftName); if (left.type==SB_NOTFOUND) semantic_error(&quot;undeclared identifier &#x27;&quot;+leftName+&quot;&#x27;&quot;) else if (left.type!=SB_VAR) semantic_error(&quot;identifier &#x27;&quot;+leftName+&quot;&#x27; is not a variable&quot;); err|=son[1]-&gt;generate_3addr_code(); add_codes(codes,son[1]-&gt;codes); codes.push_back(make_pair(&quot;&quot;,left.label+&quot; = &quot;+((node_Expression*)son[1])-&gt;resultLabel)); return err;&#125; IfStmt&emsp;&emsp;If 是一个控制流，有 else 和没 else 的生成规则分别为：1234&lt;codes of expression of condition&gt;ifFalse &lt;condition&gt; goto %EOCF&lt;codes of ifTrue&gt;%EOCF: ...&emsp;&emsp;和123456&lt;codes of expression of condition&gt;ifFalse &lt;condition&gt; goto else&lt;codes of ifTrue&gt;goto %EOCFelse: &lt;codes of else&gt;%EOCF: ...&emsp;&emsp;注意 ifTrue 和 else 的语句都要新建一层符号表。这里的 else label 要用 elseCnt 计数器来生成唯一标号。具体代码翻译该逻辑即可，不赘述。 ForStmt&emsp;&emsp;For 语句共 4 个部分：初始化语句 init、循环条件 condition、每次循环结束后执行的操作 afterLoop、循环体 loop。生成规则为：1234567&lt;codes of init&gt;&lt;codes of condition&gt;loop: ifFalse &lt;condition&gt; goto %EOCF&lt;codes of loop&gt;&lt;codes of afterLoop&gt;goto loop%EOCF: ... Expression&emsp;&emsp;每个 Expression 类要得到它的代码、返回类型、存放结果的 label。 若为二元算术运算，则先生成左右两个子 Expression 的代码，然后两个返回值取类型优先级较高的作为最终结果类型，接着对两边进行强制类型转换，最后进行左右两个返回值的运算； 若为二元逻辑运算，则同上，但最后结果类型是 BOOL 若为一元运算，则先生成子 Expression 的代码，然后进行运算； 若为立即数，则结果直接赋为该立即数； 若为变量，则从符号表中寻找该变量的 label 作为结果 label； 若为函数调用，则先生成实参的 Expression 的代码（并检查是否与形参匹配），接着用 param 语句传递参数，然后调用函数，最后取出返回值放到一个寄存器。 &emsp;&emsp;这里是把布尔表达式和算数表达式等同对待了，但实际编译器是区别对待的，比如 or 运算，前件成立了是不判断后件的。本来这只是个代码优化，但它已经形成一种编程规范了，如果前件成立仍然判断后件会导致很多程序出错的。 &emsp;&emsp;至此，三地址码的生成就基本说完了。 后续内容&emsp;&emsp;做一做前端交互，用 -o 选项把代码输出到指定文件啥的，改一下上次的代码不要因为存在语法错误就把整棵树析构了，使其能够同时检查语法错误和语义错误，最好再按行号排个序输出。&emsp;&emsp;我现在的语言定义里还有很多东西没做，例如数组、指针、break、continue 之类的，因此这个语言还不是很完备。&emsp;&emsp;再后续，就是代码优化了，平台无关代码优化的部分龙书讲了很多，都挺有趣的。&emsp;&emsp;但是学期结束了哈哈哈哈哈哈哈哈哈哈","categories":[{"name":"project","slug":"project","permalink":"http://kqp.world/categories/project/"}],"tags":[{"name":"编译器","slug":"编译器","permalink":"http://kqp.world/tags/%E7%BC%96%E8%AF%91%E5%99%A8/"}]},{"title":"【2021 Multi-University 2 J】I love permutation 题解","slug":"【2021 Multi-University 2 J】I love permutation 题解","date":"2021-07-25T02:32:45.000Z","updated":"2024-04-24T03:59:22.817Z","comments":true,"path":"【2021 Multi-University 2 J】I love permutation 题解/","link":"","permalink":"http://kqp.world/%E3%80%902021%20Multi-University%202%20J%E3%80%91I%20love%20permutation%20%E9%A2%98%E8%A7%A3/","excerpt":"题目大意&emsp;&emsp;给定一个 $a$ 和一个奇质数 $p$（$1 \\le a&lt;p$），令 $b_x=ax\\bmod p,\\ x=1,2,\\cdots,p-1$，则 $b$ 序列形成一个 $1$ 到 $p-1$ 的排列，求这个排列的逆序对数量 $\\bmod 2$。 &emsp;&emsp;$p \\le 10^{18}$&emsp;&emsp;多测，$T \\le 10^5$&emsp;&emsp;1s","text":"题目大意&emsp;&emsp;给定一个 $a$ 和一个奇质数 $p$（$1 \\le a&lt;p$），令 $b_x=ax\\bmod p,\\ x=1,2,\\cdots,p-1$，则 $b$ 序列形成一个 $1$ 到 $p-1$ 的排列，求这个排列的逆序对数量 $\\bmod 2$。 &emsp;&emsp;$p \\le 10^{18}$&emsp;&emsp;多测，$T \\le 10^5$&emsp;&emsp;1s \\\\ \\\\ \\\\题解&emsp;&emsp;排列 $b_1,\\cdots,b_n$ 的逆序对数量的奇偶性用这个式子表示，奇数就得到 $-1$，偶数就得到 $1$： sign=\\frac{\\prod_{1 \\le j < i \\le n}b_i-b_j}{\\prod_{1\\le j < i \\le n}i-j}&emsp;&emsp;这是因为，分子的 $(b_j,b_i)$ 如果是正序对，那么会跟分母的 $b_i-b_j$ 约掉；如果是逆序对，那么跟分母约掉之后还会多出一个 $-1$。 &emsp;&emsp;式子代入这题： sign = \\frac{\\prod_{1 \\le j < i","categories":[{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[{"name":"算法_数学","slug":"算法-数学","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E6%95%B0%E5%AD%A6/"}]},{"title":"【长更】杂写","slug":"something","date":"2021-07-21T14:10:05.000Z","updated":"2024-11-18T04:02:48.026Z","comments":true,"path":"something/","link":"","permalink":"http://kqp.world/something/","excerpt":"$\\ \\ $","text":"$\\ \\ $ 2021.7.18只要每天跑五公里我就可以健步如飞穿过农讲所 省实 南越王宫 骑楼还有步行街半路碰见唐可可她也在跑步她累趴下了香音在支持她 虽然不知道步行街里还有佛寺不过阿梓喵还在动星我仍然想去上野公园uchi，emi，还有大佛其实大家都在燃火人没有完全燃尽而是保护了大家只是我一个人在吃萨莉亚 2021.7.19追寻梦想的人一批一批地来了风作勇气 湛蓝的勇气我也借一点罢让歌声简单些仿佛看到每日开动的细胞之城抱起血小板生命初生之时 一定无比欣喜 满怀笑意 雪菜偷偷笑着焦急挖星石的小朋友爱丽丝拉着小忍奔向田野麦秸帽盖着金盏花孩子们在树林里追跑硕大的鲸鱼明年就要游回来了在一天的阳光完全收敛以后我像佛陀一样死去 2021.7.19楼宇繁灯间自有摇滚却也是山河中生 山河而归也许我想去的只是无名小溪谁不想得到那纯洁无瑕的弯弯的月牙呢谁又能得到呢 2021.8.1过去 我欣赏雨日的朦胧而今 压抑的黑云却要按住我的呼吸惨白的风雨要抹去矗立的高楼是谁 把这厌雨喜晴传染给了我 过去 我搏击沉重的任务而今 微小的压力就要打碎我的身体望不尽的辛劳要盖过苦中作乐是谁 教我贪上了只需玩耍的假期 过去 我享受一人的孤独而今 空荡的周围似要吞掉我的灵魂满街满天的欢声笑语也不告诉我我是过客是谁 让已经成长的我重新变回小孩 原来 我也会在雨天悲伤原来 我也倾向躲避压力原来 我也喜欢跟人说话纵使生活会让我重新投入它也不免在回头时发现我变成了你你变成了我想象中的你 2021.10.1&emsp;&emsp;这两天所思有点多，意识流一下。&emsp;&emsp;昨晚给gyg发了一个恭喜役满解放，然后就聊开了，很大一部分是她在讲她如何地焦虑，又如何在焦虑中找到一个好的心态。她节奏太紧了，以至于我好几次想插话都插不上。&emsp;&emsp;不得不说跟gyg聊天真的有一个神奇的功效，就是会让我变得想要沉下心学习，我羡慕她一直保持着高中时的那种学习状态，所以聊完之后也会让我感染一点这种状态，就会变得想要学习。&emsp;&emsp;但这一天晚上还有新的收获。她说她成绩不太能保研，师妹离开也令她消沉，最后一个人去了教室看书。我想起这个情景对我很熟悉，好像我高中的时候也很喜欢到一个人的地方去学习，这时忽然就闪过一个词：“一无所有”。我好像忽然又找到了曾经努力的动机——正是因为一无所有，所以才得以什么也不用顾虑地努力。高中时，没有协议，竞赛最终也没有带来成果，文化课成绩掉得厉害，没有十分亲密的朋友，没有发生爱情，对 LL 的认识非常浅并没有深度厨的概念也没有条件深度厨。正如同之前安慰学弟，他问怎样摆脱省选考差了的郁闷，我说回去考个文化课期中考，发现更差，你的郁闷就转移了(x)。所以，只有失败了，失去了，想要努力改变的心情才会变得无比坚定。高中不停地失败，真正地一无所有，所以不但沉着地学习，而且沉着得可怕，沉着得跟现在不是同一个人。&emsp;&emsp;“正是因为一无所有，所以才得以不用顾虑地努力。”这句话很熟悉，LL 里这句话再多不过了，再看来，其实 LL 也一直是在讲这样的故事，缪自然不用说，水第一次参加东京的比赛不也是零蛋，虹的开局完全就是缪的开局。有趣的是，改变了一无所有的局面之后呢，也就是这句话的反面，却都是轻描淡写的，不是功成名就解散引退，就是废校了。&emsp;&emsp;突然发现她就很像是高中的我。唯一不同的可能就是，她等的人，还有三年就可以等到了，而我等的人，等了五年，最终无果。&emsp;&emsp;本来计划好的 10 月 1 号这天随大流放假，先找一个野生 lovelive fes 资源补掉，然后补掉感谢祭表演赛、liella op 发售 live 等“稍后再看”，最后剩余的时间补 clannad。但是因为临时受到感染，想要找回一点感觉。看一下现在的我，其实也还是一无所有——竞赛题不会做，实验室师兄的任务搞不出来，想做 complexity 但自己还是 newbie，看上了美帝的老师也没去套瓷。于是又有了一无所有的感觉，可以开始竞争了。&emsp;&emsp;只不过到了下午还是重新审视了一下计划，毕竟国庆假是仅有的全天有空的机会了，过了之后下一个假期就是元旦了，像 live 这种东西要补就得挑全天有空的机会补。思想斗争了很久最后决定还是执行娱乐版计划。&emsp;&emsp;然后把 fes 和积攒的“稍后再看”补了，主要是 fes。感动自然不用说，因为学会了一点日语，歌词也能听懂七七八八了，于是现在对于歌词本身有了更多的感触。LL 的歌曲除去情歌，大抵就是这么些主题：突然找到梦想了我悸动了、不要害怕不要犹豫干就完了、好想去到你的身边、给自己好吃好喝的好快乐。最对我有感触的大概就是“干就完了”这一类的主题，印象最深的是花丸两首 solo，都是对明天充满了期待，不要犹豫直接尝试，我被这两首歌激励了无数次。&emsp;&emsp;然而悸动多了之后，心态似乎又变了。说不上来的感觉就是，它跟“一无所有”的心态总是有区别，或许是后者天生带有一丝消极，而前者一定是积极的。我尝试思考，但并不能找到这两种心态的融合点。这令我在 live 被某几句歌词触发思考之后，回过神来发现歌都唱完了。&emsp;&emsp;所以到头来依然是一个矛盾。不知“一无所有”的心态能保持多久，只能尝试在接下来的工作日里，翻看与 gyg 的聊天记录，重新感受。也不知道该怎么把这两年所思的心态融合起来，我并不希望每隔一段时间就提出一个哲学概念。&emsp;&emsp;矛盾的也不仅是心态，还有规划，明天究竟要抓住一无所有的心态竞争，还是抓住全天有空的机会补番，还是抓住全天有空的机会来一次追寻内心的散步。 2022.3.14&emsp;&emsp;未来也变得十分奇怪。&emsp;&emsp;complexity 这条路是我自己选的。选的理由其中一条，我想要证明，sysu 也是有人能做看上去高深的理论研究的。&emsp;&emsp;我觉得我以前不是那种会对未来产生恐惧的人，不考虑会不会失败，也是干就完了的。第一次产生了对未来、对失败的恐惧，大概是做申请美国学校的计划的时候，让我对我曾经的决心、以及我到底喜欢怎样的生活，感到很迷惑，我看到了与以往所有坚定信念都不同的想法，倒不如说，让我分不清到底哪个才是心底的想法。&emsp;&emsp;做 complexity 也是，一次次看见自己的对手都是些什么人，是学军那帮 ioi 冠军，是一帮 noi 知名人物，姚班图班 ACM 班求班大佬，也会很破防。这时候，也大抵是偶尔的跟人聊天恢复信心，以及听一些歌曲，从歌词中突然振奋。例如花丸的 solo，Aqours 许多歌，群青，这一类。 好きなものを好きだと言う怖くて仕方ないけど本当の自分出会えた気がしたんだ——《群青》 ランラランわかったランラランわかったまずはやっちゃうね勢いってきっと大事だって思うからときめいた気持ちが消えないうちに——《あこがれランララン》 &emsp;&emsp;于是我的未来好像就是，选了个大目标，然后靠听歌走了下去。回过头来的时候，就会觉得很不靠谱。 2022.4.9&emsp;&emsp;看了小百合对「青空をまってる」歌词的解释，本来想写一小篇感想，结果越写越多，涌现出很多题材，决定开个合集。 2022.4.28&emsp;&emsp;惊闻 Liella 加了 4 个人。&emsp;&emsp;然后也跟朋友们聊了很久，围观了贴吧、b 站的各路吐槽。&emsp;&emsp;其实加人不会影响羁绊的发展，旧的羁绊也不会消失，按动画剧情，缪最初还是果海鸟三人呢，水最初还是千曜梨三人呢，还不是加成 9 人的，虹这 12 人也说明了旧的记忆和新的路程可以共存。只是官方的“9人の少女達の物語”“初5人の物語”这样的宣传和建设是越来越没有公信力了，这也是粉丝们对 LL 这个企划的信仰的瓦解的一小步，以后会有更多精神内核崩塌吗？不知道，但危机感有了。&emsp;&emsp;我也比较庆幸，经过大三大四这么多事情的冲击，我逐渐懂得“人不能把全部信仰建立在一个商业构建的故事上”这个道理了，把 LL 作为人生最多一半的信仰即可，这样既可以把 LL 有益的精神内核结合进来，也可以避免在企划发生骚操作时崩溃。 &emsp;&emsp;但是无论如何，这毕竟是我最喜欢的企划，我有认真参与的企划。我真正感到害怕的是，看着 LL 从“大家一起实现梦想”变成“梦想的流水线工厂”，看着它变成 LL48，快速更替，缺乏沉淀；看着它毫无初始过程地加塞，直接就上 fmt，撞水东蛋，心浮气躁；看着它打人海战术，现在四代六团 43 人了，秋天还要加皮套人，“台下早已座无虚席，台上比台下还挤。”&emsp;&emsp;很难说这样还能用心经营好每一个人。live 档期混乱甚至撞车，有人被埋没了近两年，有人歌唱还没练好赶鸭子上架开巡演出专辑，动画也急着做，剧情也急。 &emsp;&emsp;从前的日子过得很慢，车马邮件都慢，一年看一两场live，一个月看一场生放。偶尔来个“九周年放送黄金周”，也不过是一周有三天生放而已。现在是连 live 都能每周两演了，人对这些的态度能不轻浮吗？原来正是因为每一次节目都来之不易，我们才能赋予每一次节目重要的意义，每一次都抱以绝佳的投入，事后慢慢回味，充分挖掘各种细节，而不是快餐似的娱乐享受，搞完今天还有明天，看完这周还有下周。人也被娱乐事业绑架，work-life-balance 被打破，那就真应了那个表情包了。 2022.5.28&emsp;&emsp;“现在加入，还来得及吗？”&emsp;&emsp;“来得及哦！欢迎加入学园偶像同好会！” &emsp;&emsp;也好想有一个声音对我说：“现在加入，还来得及哦！离你希望的开学前交出一份像样的研究，还有三个月。现在上车古典研究方向，来得及哦！”&emsp;&emsp;大概就是有点焦虑，虽然今天又看到一个音乐学院的 up 主的视频，反驳“好的旋律已经被开发完了”。 &emsp;&emsp;现在是一看外国学校就会严重焦虑和后悔，一看娱乐作品就会疯狂思考哲学，一碰学术就不专心（x&emsp;&emsp;虽然很感谢充裕的时间让我可以对一些新奇的概念胡思乱想，但是就是写完毕设到现在两个月颓得很进步微乎其微。昨天参与保研宣讲浏览了下 IIIS 的主页看到一堆 STOC 收录，就很“无边落木萧萧下，不尽长江滚滚来”。庆幸的是现在看 abstract 能看懂他们在干什么了。&emsp;&emsp;希望我配得上端午的旅游吧。。。 2022.6.25-27&emsp;&emsp;这周末算是 LL 快乐日了，大概就是这幅图： &emsp;&emsp;现在真的做得像个祭り一样，到处都有摆摊，到处都有活动，你爱逛哪边就逛哪边。线上很快乐，线下大概要痛苦得想杀人。&emsp;&emsp;关于水 6th 就写在这里了。虹最终话也很好，相比起来就是星的 fmt 最没意思了。。。&emsp;&emsp;水 6 大新闻让我相信企划还是在健康发展的。 &emsp;&emsp;然后实际上除了 LL 现实的事情也非常多，超多竞赛工作，超多行政工作，还要收拾行李退宿回家。LL 快乐日就尽情嗨一下，嗨完了继续回来工作。。。 2022.7.11&emsp;&emsp;趁着最后一个在广州 free 的日子，clear 了一个梦想了很久的 todo：从东校骑行至白云机场。全程 52km，路程大致为大学城-小洲-石榴岗-广州大道-同泰路-空港大道-鹤龙路，从梅花园开始与 3 号线重叠，后面大致都为 3 号线地上路段。&emsp;&emsp;大概也摸清了自己的极限，全程抽筋两次，预抽筋三次。全都发生在后半段，过白云山前状态良好，之后顶多腿根累些，大概从空港大道后半段开始感觉肌肉在无规律收缩了，过了龙归在鹤龙路段发生第一次抽筋（左大腿），此时离终点不过 14km，不甘放弃，休息 1h 后继续；在迎宾大道处发生第二次抽筋（右小腿），此时离终点不过 4km，甚至跑道就在前面了，遂坚持，直到进了空港南街道，双腿稳定在抽筋临界状态，颤抖不可直，确信已经无法继续骑车了，且单车超出范围被收走，才不得已最后步行 3km 进入机场。&emsp;&emsp;中途路程还是十分精彩的。珠江以南的市郊、市区、大桥就不多说了，骑过无数次了。这次是第一次过广州大道天河立交以北，第一次从中间穿过白云山（虽然两边什么也没得看，树都高过山，全挡住了），看到了白云山周边的小镇，之前去从化穿过的流溪河竟然也在人和镇穿过了。最后过了迎宾大道进入小村庄，转头看到左边就是机场跑道，飞机从前面冲过来飞起，颤颤巍巍的双腿终于获得了慰藉。&emsp;&emsp;晒了一天进机场被风干以后，从照烧人肉变成盐焗人肉（x 第一次全身都是盐 &emsp;&emsp;晚上无法入睡，每一公里的路都清晰地浮现在眼前。 2022.8.1&emsp;&emsp;最近在看星Ⅱ，随时发表一下感受。 2022.8.8&emsp;&emsp;出题是一件很快乐的事，除非教练是个商人。 &emsp;&emsp;想象中的毕业暑假应该是，可以悠闲地读论文读书，累了看看杂志和番剧，出门逛逛。不知道为什么，就出了三个月的题。。。&emsp;&emsp;反而开学会成为一种解放？？ 2022.8.25&emsp;&emsp;被少歌震惊了。&emsp;&emsp;目前看了两话，让我感觉遇到了一部写作手法极为丰富的作品。在目前大家都从主旨大意、思想感情等方面下功夫的大环境中，竟然有选择极致地突出艺术表现方式的一员猛将，独具匠心啊！&emsp;&emsp;也怪我读意识流的水平欠缺，久久没有从这个方向来理解。而且我觉得它不只有意识流。我可能得再看多一点来赏析。 &emsp;&emsp;相比之下现在星Ⅱ的讲故事方式确实有点平淡了。其实可以像水水一样，主线剧情不用搞得太复杂，这样就可以推剧情不推那么快，就有充分的时间来做各种描写，比如心理现实主义的描写，适当引入一些意识流，之类的。整部番的艺术体验会很不一样。 2022.8.29&emsp;&emsp;这两天到 HK 来，差不多是 settle down 了。逛了很多，买了很多，接触了很多，有很多如“HKU、坚尼地城一带全是上下坡山路”“萨莉亚比茶餐厅便宜”“超市买日用品纯纯大怨种”“住宅区的巷子竟然能开一家景品店”“老板非要等我做完核酸才肯见我”等令人“笑死”的故事。不过都没有强烈到想要写博客写下来，倒是晚上看了个生放评论气得火上心头。以后逐渐克制吧，不要被这些评论带得只会喷人了，不要让博客完全变成番剧的形状了。 &emsp;&emsp;现在总归也是走着 register 的流程了，去逐渐感受 HKU 的宏大。不再去主动酸那些润北美的人了。可能说麻木也行，有得争取的时候可以去酸，这样更有动力，现在一切尘埃落定，酸就浪费时间了。PhD 最终还是要回归本质吧，最重要的还是找到好课题，然后做出好贡献，其次才是我在哪个学校毕业，跟了哪个大牛。 2022.9.11&emsp;&emsp;参观完 CUHK，也带人参观完 HKU 了。&emsp;&emsp;我相对于这几个去了 CU 的同学，就好像我在北校，他们在东校一样。他们在郊区宽敞的大山里，宿舍如同小区一样精致，两站地铁去到大商场，自给自足。我在城市边上一个狭小的学校，依着半山腰而建，没有运动场，要穿梭一段山地居民区才能到宿舍。&emsp;&emsp;学校里有几栋楼围起来装修，我带他们参观学校的时候，脱口而出第一句话也是：“带你们看看这破破烂烂的hku。”（这句话来自 gyg 带我参观北校时说的：“带你看看这破破烂烂的北校。”） 2022.9.16&emsp;&emsp;总结一下这个实验室几个怪地方： 工位并没有像传说中的那样“小到连两个屏幕都放不下”，反而我们这里宽敞得很，可能是老板比较牛逼，能搞到好的 office。一个遗憾是没有窗，得走出去走廊才能看海景 丰富的桌游，甚至有我喜欢的骆驼大赛 隔音好到能唱 K，而且真的有音响设备 office 里有 4 个二次元，占比 50% 老板每天下午来查房，逮着谁就跟谁 talk，完全不需要组会 实验室里的学长眼中，老板是一个性格、人品、学术志向、学术眼光全方位都很有问题的人，跟我事先了解的完全相反 zhiyi 是全民男神 &emsp;&emsp;分享一句我觉得老板很调皮的话：“我跟你是同时开始学这个东西的，但是我读论文的速度比你快，每次 talk 的时候我都能领先你一点点，所以我能一直 advise 你。” 2022.9.24&emsp;&emsp;参加宿舍 City Hunt 活动，本来是想来认识一点妹子的，结果妹子没搭话多少，却因为 Whatsapp 头像是高咲侑，钓上来一个蒙古二次元，还约我一起去女仆咖啡厅（x 2022.10.9&emsp;&emsp;跟 office 的石仔说了摇曳露营剧场版上映，石仔立即表示要拉上我和一个学长一起去看。&emsp;&emsp;但是我本篇都没看过……出发前补了第一季的前五话，就直接去看了。其实没啥关系，剧场版可以不需要本篇基础。倒是让我把这部番从 todo list 里提前了（ &emsp;&emsp;这个番也是典型的芳文风格，讲五位女孩子露营和户外运动的故事。它的节奏感比较悠闲，女生之间的感情比较细腻，自然风光很多，配乐极好（应该是用了和式民乐的，我认为配乐是这部番的亮点），适合在心境悠闲放松的状态下看，绝对不能急，不要在生活节奏很快的时候来看它。&emsp;&emsp;然后剧场版给我带来了全新的认识——关于这类女高中生番毕业了以后怎么写。大多数番毕业就结束了，有些把毕业的故事拉长成剧场版。而摇曳露营，则是直面毕业后的大人生活，直接写五位女生工作后仍然一起活动的故事，从以前单纯地出来玩，变成大家合伙创业，开发一个露营营地，历经社会、工作和创业的艰难险阻，突出了“变成大人以后有愿望也有能力去把自己的喜好分享出来，去创造和改变世界”的主旨。这种写法令人眼前一亮，也让绝大多数已经工作了的年轻观众有很强的代入感，有更多的身份认同和思考。 &emsp;&emsp;最大的问题在于石仔没有抢到带特典的票。 &emsp;&emsp;最后就是今天晚上的星Ⅱ最终话和生放了。星Ⅱ不算好不算坏，普普通通但是商业气味很浓的故事，算是结束了，三个月每周忍受不堪入目的评论也终于过去了。评价仍然写在这里。&emsp;&emsp;生放新闻先是 TV 第三季，可喜可贺，系列首次，期待她们更好的故事。&emsp;&emsp;然而接下来弹出一个“三期生，一般公募 1 人”差点没让我喷出来。有三期，有没有四期？虽然不绝对（如果是招满一二三年级就结束，那就只有三期），但概率比较大了。也就是说，大概率走 Liella48 路线了。那么评价跟上面 2022.4.28 的一样，这里面最本质的问题是把 Lovelive 变成“梦想的流水线工厂”，而不是打算精益求精地把每个人打造好，这很没意思。&emsp;&emsp;不过换个角度想，这算不算是另一种版本的“大家一起实现的故事”？有越来越多原本是粉丝的人走上了台，她们也在创造着故事。到目前为止，也并没有新人是打算借这个平台来混的，目前的新人都是浓度极高的老粉，看得出她们都在努力维护 lovelive 的精神核心。但将来有没有混子？平台开放出来了，这可不好说了。 2022.10.25&emsp;&emsp;突如其来的、持续将近两周的日本出行规划，随着今天正式咕了签证预约而结束了。&emsp;&emsp;详细梳理一下这事是这样的。日本 10 月初开放了个人入境，于是大伙就开始计划去玩了。鉴于圣诞机票太贵，就初定于 12 月中去。隔壁泉哥连机票都买好了，我一看日历，有 Liella 3rd 爱知，遂匆忙计划买碟抽选。&emsp;&emsp;虽然再看一眼日历，发现 cover 了期末考试，要监考要改卷，这个请假大概率是不批的。但去到卖碟的店里，还是没忍住冲动，买了 5 张碟，给你星爹狠狠地爆了一波金币。以后谁还敢说我是无效粉丝，就把碟砸他头上。&emsp;&emsp;后来请假果然不批，五张抽选烂在手里了。泉哥也惨，要退票。&emsp;&emsp;最后想想还是把计划推到明年三月，冲一波水 extra live。经过几番利弊权衡和思想斗争，最后还是买了一盒水费，申请了一个抽选。 &emsp;&emsp;几个来回，给 LL 送了一大笔钱，并且最后都是无效花费。其实是比较心痛的。无论是爱知还是水 extra，都是小规模 live，并不那么值得花大代价去搞抽选。每日一问：发明抽选制度的人死了没&emsp;&emsp;某场比赛的出题费给高了很多，这也稍让我安心一些，钱包还是有容错空间的。&emsp;&emsp;好的一方面是，联系上了在日留学的 zzb 先辈，也熟悉了抽选流程，下一次大 live，就可以认真准备了。 2022.11.1&emsp;&emsp;无法想象LL会有换声优的一天。&emsp;&emsp;我们愿意抱以最大的善意，相信大人们做出的决策是全心全意为了灯的健康着想。如今只能祝愿灯身体健康，工作顺利，迎接新的优木雪菜。 有时候人真的是有各种各样的原因，但是我们能做到又有什么了，只能是把自己的做好，其他的就顺其自然了。——gyg &emsp;&emsp;然后，大概也开始了 azuna 1st live 的抽选计划。老雪菜的毕业 live，冲一冲试试吧。 2022.11.4&emsp;&emsp;review Financial Crypto 的感想：不会写论文可以不写。真的不用特地找个 C 会来恶心 reviewer。 2022.11.11&emsp;&emsp;昨晚专心与小姐姐拼乐高，错过了 ICPCWF 滚榜。&emsp;&emsp;非常厉害，四个金牌都是亚洲队员，冠亚军也几乎都是从 OI 开始就闻名的中国选手。IOI 赛场已经证明了“CNOI, Best OI”了，ICPC 会不会有这一天呢？尽管 OI 和 XCPC 在不少老前辈眼里，都已烂到天际，但成绩摆在眼前，到底怎样的模式是最好的？可能不由老前辈说了算。&emsp;&emsp;进的第一次 final 就以观看者的身份过去了。豪哥组织校选、准备 wf 出行计划的时候，老板也无数次问我：“你怎么不去达卡？”“今年你要不要再打一年？”尽管嘴上说着累了累了不玩了，到昨天还是跟人一起打了同步赛。在老板眼里，ICPC 是一场娱乐，玩得开心就好，他并不会很容易明白，有一个可靠的队伍，付出时间训练，这又是另一层的快乐。&emsp;&emsp;要问为什么不去单挑，当然是因为不想太菜被人发现给学校丢脸啊毕竟是大家一起打下来的 final，如果不是无人之境三个人一起去，多少少点意思。 &emsp;&emsp;等明年吧。如果真的能去埃及，看看会不会出现“hku 教练代表 sysu 参赛”的怪事hhh。不会真的有人博二还在打比赛吧 2022.11.19听着《皇后大道东》从皇后大道西，走到皇后大道东以为这就是这条街的味道了直到切了歌原来街道长什么样，取决于耳机里放什么歌 当耳机里是可爱的歌，高楼繁宇也顿时变得可爱起来可以在任何一处路口遇见幸福快乐当换到《皇后大道东》，街上日本面孔就变成了香港面孔只能看到人来人往，车来车往，没有表情，没有方向又换到流行情歌，路上行人都不见了抬头看到大厦，天空，夕阳，过去，未来 我何尝不想让街道变得可爱已经播放了这么多可爱的歌为什么仍会想要修正意境也许，风格意境确实不搭也许，还在想着以前的歌配以前的街道也许，行路本就不应听歌 其实也有另一种可能歌曲只是带来了一片虚幻城市与街道骨子里就只有市井的味道如果中途碰到一条上山的路径我只能加快脚步，不停地往前走直到把自己累抽筋为止 2023.3.20朦胧，是迷离，是羽化，是泥香；朦胧，将要笼罩，将要压迫，将要吞噬；朦胧，因而神秘，因而可怕，因而向往。 ——夜行起雾的太平山 UPD：一周后更离谱，直接变成能见度 5m 的丛林探险。 2023.3.27&emsp;&emsp;抬头寻找属于我的白鸽。&emsp;&emsp;什么时候我也能看到白鸽朝不同的方向飞呢？ 2023.5.4&emsp;&emsp;起因是我读了一篇批判“特种兵旅行”的公众号推文，思考了几天，决定反驳一下，说说我的体会。&emsp;&emsp;我认识“特种兵旅行”这个词不过是半个月前的事，当时从香港到广州一日游，给小学妹过生日，她说我是“特种兵”，我才知道原来还有这种说法。随后半个月这个词在网上越来越火，百度热搜能看见，群友吹水会提到，专家也来发表意见，直到五一大规模出行，这个词的使用频率达到小高峰，也就有了那篇批判文。&emsp;&emsp;对照一下“特种兵”的定义，看看我的旅行和出差，我也经常在极短的时间内急行军至百里千里之外，经常要快速辗转多个任务点，偶尔也会夜晚行军。我曾经两度一个月连去两次北京(from 广州)，可以一周末往返中国南北、一天闪现珠三角各地，无缝衔接工作与赴日旅游，在日本各两天逛完原宿、台场、沼津。这样看来，俨然我已经是一名从中学就开始服役的老特种兵了。&emsp;&emsp;所以我这十年间的出行突然被否定，我还是要斟酌一下的。&emsp;&emsp;不过这一届新兴起的特种兵似乎还只是新兵，他们的任务就只是打个卡，拍个照尝个吃的就可以溜了。他们也会在各社交媒体留下痕迹，其实照片还挺美的，就是文字可能空了些。这也是那篇文章所批判的，打卡式的旅行，没有思考，没有感悟，没有学习，为了来而来，却累得要死。&emsp;&emsp;这样看来我侥幸逃过一劫，不在他的批判对象里。我到达目的地之后都要感受一番的，可能还要吟两句诗，哪怕是最像打卡式旅行的圣地巡礼，也要在造访圣地后重入一遍动画，体验在这发生的故事和人物心理感情，就像去到诗词名篇描写的景胜时，要体会古仁人的心境。&emsp;&emsp;但问题是，旅行的意义只存在于目的地么？&emsp;&emsp;旅行是过程还是结果？这么问大家肯定回答是过程，但过程是什么？更具体地说，如果只是批判打卡式旅行，那是不是忽略了什么过程？&emsp;&emsp;这个过程就是“在旅途中”。至少对于我来说，旅行最有魅力的，最令灵魂得到休息的，是“处于‘在旅途中’这一状态”。它由很多部分组成，出行、在车上、在飞机上，到达另一座城市后奔赴目的地。它让你感知状态的切换，让你感受到移动，让你知道你不是办公室的一潭死水。如果不懂，不妨下次旅行买一张B737或A320的机票，由机长播歌的那种，插上耳机，切到轻爵士的频道，捧起前面的南航月刊读一读。你会仿佛身处西班牙的海边小酒吧，吃着火腿听着浪涛；你会仿佛进入台湾的闹市小巷，看着繁灯听着喧嚣；你会来到国际创意发明展，欣赏各种奇妙的红点奖创造；你会去到北欧的酒窖，听听酒艺大师品鉴各种红酒……&emsp;&emsp;我对“在旅途中”的一种实例化，叫做“寻找”。寻找什么？寻找景点在哪儿，寻找隐藏的名物，寻找动画场景的角度，寻找除此之外我还能找到些什么。我在乎我寻找的是什么吗？它不重要，我要的是我正在寻找，要的是路上的憧憬。因为人生就是这样的啊，永不停止地探索、寻找、追逐，一件又一件，你对未来有所期待，是因为你有路可探、有物可寻、有梦可追。&emsp;&emsp;这也是为什么我通常会把圣地巡礼玩成定向越野。在网上我只能获得一些残缺的信息（比如没标地点的视频），我要自己整合所有信息，推理出圣地的位置，然后跋涉到那儿，再校对动画角度。很累很辛苦，但很快乐，绝不只是因为我喜欢定向越野这项运动，一定还因为它带来的寻找感、收集感、旅途感。以后还会这样，我跟朋友约好，如果下次还去沼津，就会用《Find Our 沼津》来跑定向越野。&emsp;&emsp;清晰这一追求之后，你会发现奔向远方并不是旅行的必要条件，旅行可以发生在任何地方，家门口也符合要求。你真正了解你所在的城市吗？你门前的每座山每条路每条街都走过了吗？你能很好地描述你那的地理环境和风土人情了吗？没有，那家门口就值得旅行。那为什么我们还想要奔向远方呢？交通发达罢了，便利的交通让各地平权。&emsp;&emsp;注重“旅途中”与那篇文章所述的精神之旅行并不矛盾，因为它们是两个阶段的东西，追求旅途与寻找并不妨碍到达目的地后进行有智慧的审美。实际上我还想把它们结合起来，把旅途也作为一个目的地，把目的地也拉长成一段旅途，这两阶段的界线本应模糊。旅途中也应当能使精神随之前进，因为处于“在旅途中”的状态时，思维本应是自由的，它飞驰于世界中，四处碰撞，然后触发各种各样的思考，如他所说，独特而深入。&emsp;&emsp;即便是打卡式旅行，也要看你怎么打卡，完全可以把卡打得高级。比如你在小学课文里学到了铜锣湾人头攒动川流不息，你不要只来铜锣湾拍个人挤人就走，你要站在路中间，头朝向天，感受人来人往，想象一条大江穿过，这样你才真正感受到川流不息。要是有这样的意识，何尝担心别人提起特种兵是在贬低你？&emsp;&emsp;3202 年的今天，发达的交通、有限的假日和财力，促成了“特种兵”的概念进入旅行。但归根结底，也是新瓶装旧酒。早已有特种兵（我就是），并不是特种兵不好，而是大家没有找到当兵的意义，所以在当假兵。 2023.7.8&emsp;&emsp;千里寻迹凤凰台，石碎泥烂路不开。&emsp;&emsp;空楼卫厨宴商贾，寂湖草树埋太白。&emsp;&emsp;日下流江与江逝，鸟飞掠云共云徘。&emsp;&emsp;收耳不笑鸟浮语，潜心可待凤飞来。 2023.9.11&emsp;&emsp;现在终于可以说出这句话了。 &emsp;&emsp;有题想，有山爬，有番看，有 Abby 陪，人生如此大概已经 maximal 了。&emsp;&emsp;（以上四项不分先后） 2024.2.12&emsp;&emsp;人生的意义。&emsp;&emsp;初中政治肯定背过的，“人生的价值在于创造和奉献”，人生的意义就是对社会的贡献。有了这层意义，自然就会思考，究竟目标是要对社会做到多大的贡献？于是梦想就有了，就是建设富强美好的社会主义国家。这样一来，个人梦和中国梦就统一了。&emsp;&emsp;可以说迷茫具体的方向，可以说痛苦具体的实现，这我也迷茫，我也痛苦。但要说人为什么活着，不妨再温习一下初中政治。 2024.6.30&emsp;&emsp;两年前还在忙着巨蛋巡演，最后上到东京巨蛋，宣布幻日夜羽动画化，百废俱兴，欣欣向荣，蒸蒸日上。&emsp;&emsp;哪知然后就跟被拔了网线一样。 &emsp;&emsp;听到每一首水水的歌，想起的都是一段特定的时光。它已经跟我的回忆绑在一起了。水水的故事和一些歌词，总是带来希望，让我对前方更加坚定。真的真的是一位陪跑的老朋友。&emsp;&emsp;5th 的安可观众席组成彩虹光路，让我第一次有看现场 live 的想法。后面也成功去了沼津，去了小组甲子园。&emsp;&emsp;LoveLive 如果能长久发展，我真的期待有一天，大家聚在一起，唱一次 sunny day song。","categories":[{"name":"杂写","slug":"杂写","permalink":"http://kqp.world/categories/%E6%9D%82%E5%86%99/"}],"tags":[]},{"title":"【AtCoder Regular 119D】Grid Repainting 3 题解","slug":"【AtCoder Regular 119D】Grid Repainting 3 题解","date":"2021-05-27T09:40:04.000Z","updated":"2024-04-24T03:59:22.828Z","comments":true,"path":"【AtCoder Regular 119D】Grid Repainting 3 题解/","link":"","permalink":"http://kqp.world/%E3%80%90AtCoder%20Regular%20119D%E3%80%91Grid%20Repainting%203%20%E9%A2%98%E8%A7%A3/","excerpt":"题目大意&emsp;&emsp;给定一个 $H\\times W$ 的矩阵，每个格子要么是红色要么是蓝色。每次可以选择一个红色格子，然后把这一列或者这一行染白。问最多能染白多少格子，并输出一种方案。 &emsp;&emsp;$H,W \\le 2500$&emsp;&emsp;2s","text":"题目大意&emsp;&emsp;给定一个 $H\\times W$ 的矩阵，每个格子要么是红色要么是蓝色。每次可以选择一个红色格子，然后把这一列或者这一行染白。问最多能染白多少格子，并输出一种方案。 &emsp;&emsp;$H,W \\le 2500$&emsp;&emsp;2s \\\\ \\\\ \\\\题解&emsp;&emsp;其实思路十分自然 但你就是想不出来哈哈哈哈 &emsp;&emsp;可以想到经典的二分图模型，左边一排点表示行，右边一排点表示列。每次操作选择一个度数大于 $1$ 的点，然后把这个点的连边全部删掉。假设删了 $x$ 个左边点和 $y$ 个右边点，那么最终收益是 $xW+yH-xy$。&emsp;&emsp;显然删的点越多越好。 &emsp;&emsp;考虑二分图连成一棵树。这棵树不可能全部删完，但是也最多只会留下一个点（以它为根，每次删一个叶子）。所以要么留一个左边点，要么留一个右边点。 &emsp;&emsp;考虑森林（假设不包含单点的树），设有 $k$ 棵树，$z$ 棵树选择留左边点，那么最终收益是 (X-z)W+(Y-(k-z))H-(X-z)(Y-(k-z))&emsp;&emsp;其中 $X=\\sum_{i=1}^k x_i,\\ Y=\\sum_{i=1}^k y_i$。&emsp;&emsp;发现这是关于 $z$ 的开口向上的二次函数，因此最优值只在两端取，即要么都保留左边点，要么都保留右边点。 &emsp;&emsp;最后考虑图。发现图等价于它的生成树。（因为图也不可能完全删完，但也最多只会留下一个点）&emsp;&emsp;于是这题最后就是个并查集+生成树。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include&lt;bits/stdc++.h&gt;#define fo(i,a,b) for(int i=a;i&lt;=b;i++)using namespace std;typedef pair&lt;int,int&gt; pr;const int maxn=5005;int n,m;vector&lt;int&gt; e[maxn];pr operator + (const pr &amp;a,const pr &amp;b) &#123;return make_pair(a.first+b.first,a.second+b.second);&#125;void ReadChar(char &amp;ch) &#123; ch=getchar(); while (ch!=&#x27;R&#x27; &amp;&amp; ch!=&#x27;B&#x27;) ch=getchar();&#125;int ga[maxn];pr num[maxn];int get(int x) &#123;return ga[x]==x ?x :ga[x]=get(ga[x]) ;&#125;void merge(int x,int y) &#123; e[x].push_back(y), e[y].push_back(x); x=get(x), y=get(y); ga[x]=y; if (x!=y) num[y]=num[x]+num[y];&#125;inline int calc(int x,int y) &#123;return x*m+y*n-x*y;&#125;vector&lt;pair&lt;pr,int&gt;&gt; ans;bool vis[maxn];void dfs(int k,int c) &#123; vis[k]=1; for(int go:e[k]) if (!vis[go]) &#123; if (c==0) ans.push_back(make_pair(make_pair(k,go-n),1)); else ans.push_back(make_pair(make_pair(go,k-n),0)); dfs(go,c^1); &#125;&#125;int main() &#123; scanf(&quot;%d %d&quot;,&amp;n,&amp;m); fo(i,1,n) ga[i]=i, num[i]=make_pair(1,0); fo(j,1,m) ga[n+j]=n+j, num[n+j]=make_pair(0,1); fo(i,1,n) fo(j,1,m) &#123; char ch; ReadChar(ch); if (ch==&#x27;R&#x27;) merge(i,n+j); &#125; int compNum=0; pr compRB; fo(i,1,n+m) if (get(i)==i &amp;&amp; num[i].first+num[i].second&gt;1) &#123; compNum++; compRB=compRB+num[i]; &#125; if (calc(compRB.first-compNum,compRB.second)&gt;calc(compRB.first,compRB.second-compNum)) &#123; fo(i,1,n) if (!vis[i]) dfs(i,0); &#125; else &#123; fo(j,1,m) if (!vis[n+j]) dfs(n+j,1); &#125; printf(&quot;%d\\n&quot;,ans.size()); reverse(ans.begin(),ans.end()); for(auto p:ans) printf(&quot;%c %d %d\\n&quot;,(p.second ?&#x27;Y&#x27; :&#x27;X&#x27; ),p.first.first,p.first.second);&#125;","categories":[{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[{"name":"算法_并查集","slug":"算法-并查集","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E5%B9%B6%E6%9F%A5%E9%9B%86/"}]},{"title":"【AtCoder Regular 119E】Pancakes 题解","slug":"【AtCoder Regular 119E】Pancakes 题解","date":"2021-05-19T12:44:21.000Z","updated":"2024-04-24T03:59:22.828Z","comments":true,"path":"【AtCoder Regular 119E】Pancakes 题解/","link":"","permalink":"http://kqp.world/%E3%80%90AtCoder%20Regular%20119E%E3%80%91Pancakes%20%E9%A2%98%E8%A7%A3/","excerpt":"题目大意&emsp;&emsp;给出一个序列 $a_1,\\cdots,a_n$，你可以选择一段区间 $[l,r]$ 然后翻转 $a_l,\\cdots,a_r$，使得 $\\sum_{i=1}^{n-1} |a_i-a_{i+1}|$ 最小。 &emsp;&emsp;$n \\le 3\\times 10^5,\\ 1 \\le a_i \\le 10^9$&emsp;&emsp;2s","text":"题目大意&emsp;&emsp;给出一个序列 $a_1,\\cdots,a_n$，你可以选择一段区间 $[l,r]$ 然后翻转 $a_l,\\cdots,a_r$，使得 $\\sum_{i=1}^{n-1} |a_i-a_{i+1}|$ 最小。 &emsp;&emsp;$n \\le 3\\times 10^5,\\ 1 \\le a_i \\le 10^9$&emsp;&emsp;2s \\\\ \\\\ \\\\题解&emsp;&emsp;首先翻转一段区间只有端点处会产生影响，影响是 $-|a_{l-1}-a_l|-|a_r-a_{r+1}|+|a_{l-1}-a_r|+|a_l-a_{r+1}|$。 &emsp;&emsp;于是反手就是一个拆开绝对值+四个区域二维偏序。&emsp;&emsp;光荣 TLE \\\\&emsp;&emsp;于是需要观察出一些额外的性质。&emsp;&emsp;就是如果 $a_{l-1} \\le a_l$ 且 $a_r \\ge a_{r+1}$，那么翻转 $[l,r]$ 必不会使答案更优。对称地，若 $a_{l-1} \\ge a_l$ 且 $a_r \\le a_{r+1}$，也不行。&emsp;&emsp;通过讨论可证。&emsp;&emsp;然后如果 $a_{l-1} \\le a_l$ 且 $a_r \\le a_{r+1}$，那么可以视为两个值域区间 $[a_{l-1},a_l],[a_r,a_{r+1}]$，于是翻转 $[l,r]$ 的收益就是这两个区间的交的长度的两倍。&emsp;&emsp;$a_{l-1} \\ge a_l$ 且 $a_r \\ge a_{r+1}$ 同理。 &emsp;&emsp;所以现在问题转化成，给定若干个值域区间，求任意两个区间的交的最大长度。&emsp;&emsp;简单的 $O(n \\log n)$ 数据结构即可。&emsp;&emsp;正着做一次再把序列反过来做一次。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;bits/stdc++.h&gt;#define fo(i,a,b) for(int i=a;i&lt;=b;i++)#define fd(i,a,b) for(int i=a;i&gt;=b;i--)using namespace std;typedef long long LL;typedef pair&lt;int,int&gt; pr;const int maxn=3e5+5;const int inf=2139062143;int n,a[maxn];int b[maxn],b0;void discretize() &#123; memcpy(b,a,sizeof(a)); sort(b+1,b+1+n); b0=unique(b+1,b+1+n)-b-1; fo(i,1,n) a[i]=lower_bound(b+1,b+1+b0,a[i])-b;&#125;int tr[4*maxn];void tr_xg(int k,int l,int r,int x,int z) &#123; if (l==r) &#123; tr[k]=z; return; &#125; int t=k&lt;&lt;1, mid=(l+r)&gt;&gt;1; if (x&lt;=mid) tr_xg(t,l,mid,x,z); else tr_xg(t+1,mid+1,r,x,z); tr[k]=min(tr[t],tr[t+1]);&#125;LL ans,organs;vector&lt;int&gt; Q[maxn];int cnt[maxn];void solve() &#123; fo(i,1,b0) Q[i].clear(); fo(i,2,n) if (a[i-1]&lt;a[i]) &#123; cnt[a[i-1]]++; Q[a[i]].push_back(a[i-1]); &#125; memset(tr,127,sizeof(tr)); fo(i,1,b0) &#123; if (cnt[i]) tr_xg(1,1,b0,i,i); for(int x:Q[i]) &#123; if (--cnt[x]==0) tr_xg(1,1,b0,x,inf); int lp=max(tr[1],x); if (lp&lt;=i) ans=min(ans,organs-2ll*(b[i]-b[lp])); &#125; &#125;&#125;int main()&#123; scanf(&quot;%d&quot;,&amp;n); fo(i,1,n) scanf(&quot;%d&quot;,&amp;a[i]); fo(i,2,n) ans+=abs(a[i]-a[i-1]); organs=ans; fo(i,2,n-1) ans=min(ans,organs-abs(a[i]-a[i+1])+abs(a[1]-a[i+1])); fo(i,2,n-1) ans=min(ans,organs-abs(a[i]-a[i-1])+abs(a[n]-a[i-1])); discretize(); solve(); reverse(a+1,a+1+n); solve(); printf(&quot;%lld\\n&quot;,ans);&#125;","categories":[{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[{"name":"算法_偏序关系","slug":"算法-偏序关系","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E5%81%8F%E5%BA%8F%E5%85%B3%E7%B3%BB/"}]},{"title":"2020 EC Final 诸事不顺记","slug":"2020_EC_Final","date":"2021-04-22T13:56:33.000Z","updated":"2024-04-24T03:59:22.771Z","comments":true,"path":"2020_EC_Final/","link":"","permalink":"http://kqp.world/2020_EC_Final/","excerpt":"&emsp;&emsp;好像又快过了一星期了。。。简要记一下好了。","text":"&emsp;&emsp;好像又快过了一星期了。。。简要记一下好了。 day -14&emsp;&emsp;昆明之后的两个星期，第一个星期在搞 GDOI 各项准备工作，第二个星期在肝编译原理大作业、编译原理理论作业、通信原理作业。&emsp;&emsp;就这样过了毫无训练的两周，出发了。。。&emsp;&emsp;也不能说毫不接触竞赛，毕竟还是有在搞 GDOI 的。&emsp;&emsp;实验室那边才真的是被我咕爆了。。。 day -1&emsp;&emsp;10:20 起飞的航班，7:30 地铁口集合。&emsp;&emsp;ddl 推荐地铁是绕远路的 4-7-3，我们走了 4-8-3，如他所料，在 3 号线撞上了早高峰。&emsp;&emsp;客村挤不上地铁，遂决定沿 3 号线往回倒一站。&emsp;&emsp;之后 zayin 和 ctlchild 通过暴力手段挤上去了，我们几个上不去，还有一个学弟挤上去被弹了出来（&emsp;&emsp;遂决定继续往回倒。&emsp;&emsp;倒到厦滘，我看着我前面 5 个人每次只能上 1 个人，心态崩了，遂决定上楼打车。&emsp;&emsp;出了地铁口看到限流排队，我知道我做的一切操作都不可逆。&emsp;&emsp;此时离起飞还剩 2h。&emsp;&emsp;缺德地图说华南快线很堵，叫我们走市区，我们切换了市区路线以后，zzb 说他们打车上高速了一点也不堵。&emsp;&emsp;在车上做好了各种心理准备，已经计划好要买第二天的高铁了。队友帮我们值了机。&emsp;&emsp;最终在司机的带领下，起飞前 40 min 到达了机场，可喜可贺。我们三人跳过托运直接冲安检快速通道，正常登机。 &emsp;&emsp;然后两位学弟的行李太大被拦了，登机口小姐姐帮忙拿去托运。到了西安得知，被托运到了下一班机。要等 2h。 &emsp;&emsp;从韦曲南出地铁以后，恰好开走了一辆接驳车，要等 2h。 &emsp;&emsp;【诸事不顺】*100。 &emsp;&emsp;路程上补完了 Liella 游乐园视频，准备晚上看 AS 国服特别生放，结果发现是录播，兴致少了一半。 &emsp;&emsp;晚上吃饭的时候发现 我 ddl ctlchild 竟然都带了 19 bytedance camp 的黑色外套，突然回归了 SYSU_FateBlueBird。至此，19 年 sysu 集训队前四队全部进入 EC（ day 0&emsp;&emsp;早上报到，拍了 SYSU_FateBlueBird 的照片，zayin 做 student coach。 &emsp;&emsp;中午看到超市草莓特价 6 块一斤，冲进去买了一盒结果发现 15 块一斤，问老板，说我选的是一级草莓，特价的是三级草莓。同样十来块，我这一盒，别人一筐（&emsp;&emsp;【诸事不顺】*101。 &emsp;&emsp;下午试机，我们左边 pku，左前 thu，前边 uestc，右边后边 fdu，呈包围之势。&emsp;&emsp;我做 B 题，小清新计数题，上来先列一波生成函数。良久，发现是个第二类斯特林数模板题。虽然后面很顺利过了，但我意识到这个生疏感不是好事。&emsp;&emsp;出去以后牛爷爷说 C 可以下降幂多项式。已经不懂后现代 oier 的力量了。。。 &emsp;&emsp;晚上走路回酒店，路上看 Aqours 生放一直断网，将近酒店了才通畅，幸好只是错过了读信环节。【诸事不顺】*102 &emsp;&emsp;晚上大伙去泡温泉，我蹲生放所以没去。想上 cf 看一道心心念念的题的题解，结果 cf 上不去。【诸事不顺】*103 day 1&emsp;&emsp;早餐有点赶，没喝上 coffee。【诸事不顺】*104 &emsp;&emsp;洛谷抽签，我是大吉，zayin 是”不宜调 WA 了的题“。 &emsp;&emsp;上来 zayin 把 F 过了。我读了 L 认为是简单题，不过感觉有点困，思维比较乱，决定丢给 zayin，zayin 很快想到了每个质因子单独考虑，然后讨论一下过了。 &emsp;&emsp;发现有个打牌题竟然长达 6 页。 &emsp;&emsp;看了 G 觉得是个小清新数据结构题，于是脑补了一会儿认为会做了，开始码。&emsp;&emsp;期间队友读了 ABD，说 A 会做了。&emsp;&emsp;我下机，他们码 A 和 D。D WA 了。A 改了几个 bug 之后 T 了，基本确定是常数问题要卡常。&emsp;&emsp;我上去写 G，测样例发现做法假了。&emsp;&emsp;虽然浪费了时间，但是我清醒了。 &emsp;&emsp;然后这个 A 死也卡不过去，拼命压缩 $O(62n)$ 的数组，一直 T。D 的 bug 改完之后也 T 了。然后 B 榜上过一片了但我们还不会做，我和 zayin 都想着容斥，整个矩形减去关键点左边再减去关键点右边这样。感觉过了一万年。&emsp;&emsp;我在 ABD 反复横跳思维非常不集中。&emsp;&emsp;A 最后强力压缩到只有一次 $O(62n)$ 的数组访问，本地大数据仍然要 3s，放弃了，觉得评测机应该比本地快，于是交上去，过了。zayin 几乎是哭着过的。 &emsp;&emsp;zayin 意识到 B 不用容斥，而是从关键点往左往右分别是后缀前缀，于是 B 可做了。然后他也会了 G。&emsp;&emsp;我的 B WA 了，他开始写 G，封榜了，我们 3 题，大概在铜区或铁区。 &emsp;&emsp;【诸事不顺】*1e9 &emsp;&emsp;我和 ddl 小黄鸭了一万年没有找到 B 的错，遂决定拍。大概 4h35min 的时候过了。&emsp;&emsp;然后调 G 题，大概 4h45min 的时候改了个小错误，然后过了。&emsp;&emsp;ddl 开始打牌，我抱着下班的心态回头看看 D 题能不能救。忽然发现公共路径只与长度有关，说出来之后 zayin 和 ddl 一起改了改，4h55min 的时候过了。&emsp;&emsp;ddl 说打牌打不完了，那就下班了。&emsp;&emsp;天亮了。 &emsp;&emsp;头一次见到封榜后过三题，还都是最后半小时过的，从铜铁区突然滚到金区。&emsp;&emsp;封榜后的心态变化大概就是 &emsp;&emsp;当然还是被各路高校吊着打了。&emsp;&emsp;出题人说 A 题本来是要卡 $O(n\\Sigma^2)$ 的，卡着卡着把 $O(n\\Sigma)$ 也给卡了，大家都被卡常了，差评。&emsp;&emsp;打牌题据说只用写 5min，如果再快一点的话我们是有希望封榜后过 4 题的（&emsp;&emsp;意识到 G 题其实也是去年 csp 的弱化版，在考场上竟然毫无感觉。 &emsp;&emsp;第一次线下见到冒冒，确实如同 gyg 说的一样可爱（ &emsp;&emsp;晚上一路奔波到饭店已经 7 点半了，华为这个晚宴质量不太行。。。&emsp;&emsp;看到一半决定翘，临走前牛爷爷中了个平板。 &emsp;&emsp;住到了市区，楼下是一条运煤铁轨。 day 2&emsp;&emsp;早上集合，有人迟到了，等了十几分钟眼看要极限操作了决定不等了往地铁走，迟到的人自行打车。&emsp;&emsp;结果地铁大团队几乎极限赶到机场，打车小队不仅早就到了，还悠闲地吃了午饭，打车费还比地铁便宜。&emsp;&emsp;【诸事不顺】*(1e9+7) &emsp;&emsp;回到广州，行程单打不出来，说早上打过了。。。？？？&emsp;&emsp;早上刚踏出酒店的门，这时打印了行程单？？？&emsp;&emsp;啥灵异事件？被盗号了？&emsp;&emsp;海航你明天股价必暴跌&emsp;&emsp;【诸事不顺】*(1e9+9) day 3&emsp;&emsp;跟人吹水，我这次拿了 3k 奖金，我要买充电宝，我要买华硕灵珑3，我要成为高端商务本用户。&emsp;&emsp;手一挥，架子上的台灯掉下来。&emsp;&emsp;砸了个戴尔 2k 屏，两千块。 &emsp;&emsp;【诸事不顺】*(1e18) 后记&emsp;&emsp;已经几乎是个旅游队了。。。 &emsp;&emsp;但是现阶段的重点确实不太能是训练，还是得做升学的事情。。。&emsp;&emsp;各种夏令营提前批也要开始了，以及还得找国外的学校，我校的推荐信真不知道能有几斤几两，望洋兴叹。 &emsp;&emsp;算上夏令营、ccpc final、bytedance camp，估计还得去北京至少 3 次。。。","categories":[{"name":"总结与游记","slug":"总结与游记","permalink":"http://kqp.world/categories/%E6%80%BB%E7%BB%93%E4%B8%8E%E6%B8%B8%E8%AE%B0/"},{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[]},{"title":"【编译原理大作业】Tiny+的语法树","slug":"Tiny+syntaxtree","date":"2021-04-17T14:17:24.000Z","updated":"2024-04-24T03:59:22.798Z","comments":true,"path":"Tiny+syntaxtree/","link":"","permalink":"http://kqp.world/Tiny+syntaxtree/","excerpt":"&emsp;&emsp;这是编译原理大作业的第一步：词法分析与语法分析，最终效果是构建出语法树。","text":"&emsp;&emsp;这是编译原理大作业的第一步：词法分析与语法分析，最终效果是构建出语法树。&emsp;&emsp;学过编译原理都知道，词法分析要用自动机，语法分析要用 CFG。善良的老师说，我们可以不用手写自动机和 CFG，可以用工具。然后又看到实验室里做逻辑公式求解器的代码也用的是 flex 和 bison，于是我就需要学习 flex+bison 这一套现代工具链。&emsp;&emsp;过程中我发誓我一定要写一篇 flex 和 bison 踩坑记 &emsp;&emsp;推荐资料：《flex&amp;bison》（中文版叫《flex与bison(中文版)》）、bison官方文档，做的过程中遇到问题在谷歌里搜索，StackOverflow 的解答还是相当不错的，也有些国内的博客回答问题也很 nice，这是少有的。&emsp;&emsp;环境：Ubuntu18，flex 2.6.4，bison 3.0.4。强烈推荐 Windows 用户使用 WSL，右键即可打开当前目录下的 Linux 环境，妈妈再也不用担心我没有 Linux。 &emsp;&emsp;项目地址。 Task&emsp;&emsp;有一个语言叫 Tiny，具体规则在这里。 将 Tiny 扩展成 Tiny+，用 EBNF 描述 Tiny＋ 的语法； 将 Tiny＋ 源程序翻译成对应的 token 序列，并能检查一定的词法错误； 将 token 序列转换成语法分析树，并能检查一定的语法错误。 &emsp;&emsp;（听说有标准的 Tiny+ 语言，但是我没找到，老师的要求是自行扩展，那么我就自行扩展了，主要让它尽量完备。放在这里） flex 与 bison 的组合&emsp;&emsp;flex 是用来做词法分析的，bison 是用来做语法分析的。&emsp;&emsp;最早的组合版本叫 lex+yacc，然后 lex 升级成了 flex，yacc 升级成了 bison，于是现代工具链就变成了 flex+bison。&emsp;&emsp;flex 需要编写一个 .l 文件，然后用 flex 根据它生成一个 lex.yy.c 文件，用 C 编译器编译就可以了。这个文件读入字符串，通过调用 int yylex() 每次返回一个 token。&emsp;&emsp;bison 需要编写一个 .y 文件，然后用 bison 根据它生成一个 .tab.h 和 .tab.c 文件。后者实现了一个过程 yyparse()，每次读入一个 token，根据 CFG 规则进行归约；前者则给出了相关接口（如 token 的定义）。&emsp;&emsp;组合使用的方法为：lex.yy.c 里面 #include&quot;xxx.tab.h&quot;；在 xxx.tab.c 里实现 main 函数或者单开一个文件实现 main 函数并 #include&quot;xxx.tab.h&quot;（推荐后者），然后使用 C/C++ 编译器联合编译。&emsp;&emsp;所以编译的时候最好写个 Makefile。 bison&emsp;&emsp;bison 的基本格式是1234567%&#123;/* part 1 */%&#125;%%/* part 2 */%%/* part 3 */&emsp;&emsp;part 1 将原封不动抄到生成代码的开头，part 3 将原封不动抄到生成代码的结尾，part 2 是 CFG 规则描述区，其余部分可以用来设置一些有用的开关和定义。/* 和 */ 是注释。 bison - part 1&emsp;&emsp;part 1 一般用来声明头文件和接口，例如123456789%&#123;#include&lt;bits/stdc++.h&gt;#include&quot;syntax_tree.h&quot;using namespace std;extern int yylex();void yyerror(const char* s);node *root;%&#125;&emsp;&emsp;前面说过 int yylex() 是每次调用返回一个 token，这是与 flex 的接口之一。&emsp;&emsp;这里有个坑，yyerror 过程是它生成的代码里会用到的，但是它自己没有声明！！还得我们用户来声明！！&emsp;&emsp;root 则是我们要构建的语法树的根。语法树的结点基类是 node，而语法规则里的每一个非终结符对应一个自己特有的派生类。这些定义放在 syntax_tree.h 里。&emsp;&emsp;这个写法比较工程，每个非终结符对应自己特有的派生类，就既可以在基类定义公有方法，也可以定义自己特有的变量和方法。比如“表达式 Expression”需要记录该表达式的类型，或者值，但是“区块 Block”就不用这些东西。同时，还可以用虚函数等多态特性，避免臃肿的 switch。 bison - part 1.5&emsp;&emsp;在 part 2 之前，我们需要先定义 token 和所有标识符。123456789101112131415161718/* part 1 */%&#125;%define api.value.type union%token&lt;int&gt; Number_Integer%token&lt;double&gt; Number_Float%token&lt;char*&gt; IdString QString%token IF ELSE FOR WRITE READ RETURN tkBEGIN END MAIN INT REAL CHAR Assign &quot;:=&quot; Equal &quot;==&quot; NEqual &quot;!=&quot; LE &quot;&lt;=&quot;%type&lt;node_Program*&gt; Program%type&lt;node_MethodDecls*&gt; MethodDecls MethodDeclsWithMain%type&lt;node_MethodDecl*&gt; MethodDecl MethodDeclMain%type&lt;node_FormalParams*&gt; FormalParams...%%/* part 2 */&emsp;&emsp;这里用 token 来定义终止标识符，用 type 来定义非终止标识符，后面尖括号是它的类型，无类型则不用加括号。&quot;:=&quot; 这样的用引号括起来的表示别名。&emsp;&emsp;类型是这么回事：CFG 的每条产生式在进行归约的时候，可以让你返回一个值，比如返回语法树结点的指针。从词法分析器来的 token，也可以带有值，比如常数值。&emsp;&emsp;在 bison 3.0 以上的版本，可以用 %define api.value.type union 开关然后在下面尖括号里面直接写变量类型。否则，需要手动写一个 union 来把这些类型合并起来。注意这里需要使用能被 union 起来的类型，像 std::string 这类变长的就不行。&emsp;&emsp;（更高级的版本特性支持 std::string，详见官方文档。）&emsp;&emsp;有些 token 如果只是单个字符，则可以不用专门起名字，不用在这里声明。例如加号“+”，要用的时候用单引号引起来即可。 bison - part 2&emsp;&emsp;part 2 用来写 CFG 规则，形式如123%%&lt;标识符&gt;: &lt;产生式1&gt; &#123;产生式1要做的事&#125; | &lt;产生式2&gt; &#123;产生式2要做的事&#125; ;%%&emsp;&emsp;例如12345678910%%Program: MethodDeclsWithMain &#123;$$ = new node_Program(1,$1); root=$$;&#125; ;MethodDecls: MethodDecl &#123;$$ = new node_MethodDecls(1,$1);&#125; | MethodDecl MethodDecls &#123;$$ = new node_MethodDecls(2,$1,$2);&#125; ;...%%&emsp;&emsp;\\$\\$ 表示当前标识符的返回值，$1,$2... 分别表示当前产生式的各标识符的返回值（无论是终止标识符还是非终止标识符都是有返回值的）。&emsp;&emsp;把程序语言的规则逐条抄下来，这就可以把整个语法树构建起来了。&emsp;&emsp;由于每个结点的子结点数量不相同，为方便维护，推荐使用可变参列表来传递子结点信息。可以在基类写一个统一的构造函数，子类的构造函数就把可变参列表传递给基类。 bison - part 3&emsp;&emsp;part 3 没啥要写的，调试的时候可以在这里写个 main 函数，但最终还是分离出去好些。&emsp;&emsp;这里要实现的是 void yyerror(const char *s) 函数，这玩意在 part 1 被声明，在它生成的代码里被调用，那么就在 part 3 这里实现。这个是语法分析出错时向用户输出报错信息的，把 s 输出就可以了。12345/* part 2 */%%void yyerror(const char *msg) &#123; printf(&quot;%s\\n&quot;,msg);&#125; bison 编译&emsp;&emsp;编译命令是 bison -d xxx.y，要加上 -d 才能生成 xxx.tab.h 头文件。 flex&emsp;&emsp;flex 的基本格式与 bison 相同：1234567%&#123;/* part 1 */%&#125;%%/* part 2 */%%/* part 3 */&emsp;&emsp;part 1 将原封不动抄到生成代码的开头，part 3 将原封不动抄到生成代码的结尾，part 2 是 token 的规则描述区，其余部分可以用来设置一些有用的开关和定义。/* 和 */ 是注释。 flex - part 1&emsp;&emsp;part 1 一般用来声明头文件，比如123456%&#123;#include&lt;bits/stdc++.h&gt;#include&quot;syntax_tree.h&quot;#include&quot;tiny.tab.h&quot;using namespace std;%&#125;&emsp;&emsp;这里要引用 bison 生成的头文件 xxx.tab.h，里面用 enum 定义了 token。因为 part 2 是要完善 int yylex()，这个的返回值就是 token 的 enum。 flex - part 1.5&emsp;&emsp;这里可以用正则表达式定义一些记号，避免后面过于繁琐，比如1Integer ([1-9][0-9]*|[0]) flex - part 2&emsp;&emsp;part 2 写 token 规则。基本格式是1&lt;正则表达式&gt; &#123;要做的事&#125;&emsp;&emsp;例如123456789101112131415161718192021222324%%&quot;IF&quot; &#123;return IF;&#125;&quot;ELSE&quot; &#123;return ELSE;&#125;&quot;FOR&quot; &#123;return FOR;&#125;...&quot;+&quot; |&quot;-&quot; |&quot;;&quot; &#123;return yytext[0];&#125;&quot;:=&quot; &#123;return Assign;&#125;...&#123;Integer&#125; &#123;yylval.Number_Integer=atoi(yytext); return Number_Integer;&#125;&#123;Integer&#125;&quot;.&quot;[0-9]+ &#123;yylval.Number_Float=atof(yytext); return Number_Float;&#125;[a-zA-Z_][a-zA-Z_0-9]* &#123;yylval.IdString=yytext; return IdString;&#125;\\&quot;..*\\&quot; &#123;yylval.QString=yytext; return QString;&#125;[ \\t\\n\\r]+&quot;/**&quot;.*&quot;**/&quot;. &#123;printf(&quot;%d: Undefined token\\n&quot;,yylineno);&#125;%%&emsp;&emsp;return 的值是该 token 的 enum 值；变量 yylval 用来记录这个 token 的值，在 bison 里的 $1,$2... 被用到；变量 yytext 记录了当前匹配到的输入字符串。&emsp;&emsp;第一部分用引号引起来的是关键字，直接返回相应的无类型 token。&emsp;&emsp;第二部分是字符 token，如果是单个字符，在 bison 里没有声明，就直接返回字符本身即可（也就是 yytext[0]）。&emsp;&emsp;注意有个坑，每个正则表达式都要放在行首，不能因为 | 符号就接在别人后面，一定要另起一行。&emsp;&emsp;第三部分是复杂一点的 token：整数、浮点数、变量名函数名、双引号非空字符串。这里不仅要返回 token 的 enum，还要记录 token 的值，token 的值的类型就是 bison part 1.5 里的大 union，如果用了 %define api.value.type union 开关的话，标识符的名称就是值的类型的名称。&emsp;&emsp;第四部分是空白字符和注释，它们不做任何操作。&emsp;&emsp;第五部分是一个简单的词法分析报错，如果匹配不上以上规则，就输出非法字符。 flex - part 3&emsp;&emsp;没啥做的。调试的话可以在这里写 main 函数。 flex 编译&emsp;&emsp;flex xxx.l 余下的事情&emsp;&emsp;经过上面两步，已经生成好词法分析和语法分析的 C 代码了，接下来只要把 syntax_tree.h 和 main.c/cpp 完成，就可以编译了。&emsp;&emsp;main 里要做的，就是调用 int yyparse() 函数，进行语法分析。该函数正常结束时返回 0。当然，还有必要的用户交互要在这里写。&emsp;&emsp;如果要画出语法树，那么就在基类里写一个 dfs 就好了，每个子类实现一个虚函数 get_type 返回它的类型和相关信息即可。&emsp;&emsp;简单的 Makefile 如下：123456tiny: tiny.tab.c lex.yy.c main.cpp syntax_tree.h syntax_tree.cpp g++ main.cpp syntax_tree.cpp tiny.tab.c lex.yy.c -o tiny -gtiny.tab.c: tiny.y bison -d tiny.ylex.yy.c: tiny.l flex tiny.l 高级特性使用 g++ 编译&emsp;&emsp;flex 里使用开关 %option noyywrap。写在 part 1.5 的地方。&emsp;&emsp;因为 flex 生成的代码用到了 yywrap 这个东西，这个东西在动态链接库 -lfl 中，而这个库会导致不能用 g++。&emsp;&emsp;因此直接把 yywrap 禁了就好了。这个东西是历史遗留功能，用不上的。 flex 文件读入&emsp;&emsp;flex 生成的代码里有个 FILE *yyin 变量，默认是指向 stdin。在 main.cpp 里 extern 出来，然后指向一个文件，就可以文件读入了。&emsp;&emsp;通常应该像命令行操作的编译器一样，由运行参数指定文件名。 语法分析器的 debug&emsp;&emsp;观察 bison 生成的 .tab.c 文件，发现它 printf 了很多调试信息，怎么把它们用起来呢？&emsp;&emsp;在 bison 里打开两个开关，一个是 %define parse.trace，写在 part 1.5 的地方；另一个是将 yydebug 这个变量赋一个非零值（这个变量在 .tab.h 里声明了，因此随时随地可以直接赋值）。&emsp;&emsp;这个 debug 信息非常详细，bison 是用 LALR 的，它把它每一步进入了什么状态、栈里有什么、移进归约选择全部列出来了，十分好用，就是有点长。 查看 LALR 状态以及哪个规则发生冲突&emsp;&emsp;有时候 bison 编译 warning 说有移进归约冲突 / 归约归约冲突，所以想看看是哪条规则搞的。&emsp;&emsp;bison 编译的时候加个 -v，即可生成一个 .output 文件，里面列出了 LALR 的详细信息，包括状态、移进归约指示。被方括号括起来的规则，就是因冲突而弃用的规则。 优先级&emsp;&emsp;这是个比较大的话题。&emsp;&emsp;flex 的默认冲突处理是：匹配尽量长的输入字符串，等长时匹配写在最前面的规则。&emsp;&emsp;bison 的默认冲突处理是：移进归约冲突优先移进。&emsp;&emsp;一般来说，出现二义性，多数情况下是语法本身有问题，应当优先修改语法。&emsp;&emsp;但是也有例外，例如运算表达式，虽然可以修改语法使得加减乘除之间不具有二义性，但是运算符变多了以后这个方法就很蠢了。例如 if-else，可以用龙书的 matched_stmt 和 open_stmt 来使得它没有歧义，但是相关的 stmt 的定义会变得很丑。 &emsp;&emsp;运算表达式的解决方法：优先级符号，在 bison part 1.5 的部分定义优先级1234%nonassoc &quot;==&quot; &quot;!=&quot; &#x27;&lt;&#x27; &quot;&lt;=&quot;%left &#x27;+&#x27; &#x27;-&#x27;%left &#x27;*&#x27; &#x27;/&#x27;%nonassoc UMINUS&emsp;&emsp;优先级从上往下依次递增，同一行优先级相同。left 表示该符号左结合，right 表示该符号右结合，nonassoc 表示不具有结合性。&emsp;&emsp;一个规则的优先级取决于该规则最右边的 token 的优先级。于是就可以直接像下面这么写了：12345678910Expression: | Expression &#x27;+&#x27; Expression &#123;$$ = new node_Expression(OP_PLUS,2,$1,$3);&#125; | Expression &#x27;-&#x27; Expression &#123;$$ = new node_Expression(OP_MINUS,2,$1,$3);&#125; | Expression &#x27;*&#x27; Expression &#123;$$ = new node_Expression(OP_MUL,2,$1,$3);&#125; | Expression &#x27;/&#x27; Expression &#123;$$ = new node_Expression(OP_DIV,2,$1,$3);&#125; | Expression Equal Expression &#123;$$ = new node_Expression(OP_EQUAL,2,$1,$3);&#125; | Expression LE Expression &#123;$$ = new node_Expression(OP_LE,2,$1,$3);&#125; | &#x27;-&#x27; Expression %prec UMINUS &#123;$$ = new node_Expression(OP_UMINUS,1,$2);&#125; ... ;&emsp;&emsp;这里还定义了负数。&#39;-&#39; Expression 这里用了 %prec，这表示规定这条规则的优先级是后面那个符号，而不是减号的优先级。 &emsp;&emsp;if-else 的解决方法：一般来说不用解决，因为有默认规则“移进归约冲突优先移进”。如果看 warning 不顺眼非要消除，可以用优先级符号把 else 的优先级抬高。 报错输出行号&emsp;&emsp;可以在 flex 里使用开关 %option yylineno，这样你就拥有了一个变量 yylineno 记录当前的行号。&emsp;&emsp;在 void yyerror(const char *s) 过程里，就可以输出行号了：123void yyerror(const char *msg) &#123; printf(&quot;%d: %s\\n&quot;,yylineno,msg);&#125;&emsp;&emsp;但是要在 bison 的 part 1 的部分 extern int yylineno;。 输出更多报错信息&emsp;&emsp;传给 yyerror 的报错信息默认只有 “syntax error”。但是观察 .tab.c，发现它还有诸如这样的代码：1234567switch (yycount) &#123; YYCASE_(0, YY_(&quot;syntax error&quot;)); YYCASE_(1, YY_(&quot;syntax error, unexpected %s&quot;)); YYCASE_(2, YY_(&quot;syntax error, unexpected %s, expecting %s&quot;)); YYCASE_(3, YY_(&quot;syntax error, unexpected %s, expecting %s or %s&quot;)); ...&emsp;&emsp;于是我们知道又有开关没用起来。&emsp;&emsp;这个只需要在 bison 使用 %error-verbose（写在 part 1.5）即可。这样，我们的报错信息就又稍微丰富了些。 error 标识符&emsp;&emsp;但是这个报错信息还是简陋了些，怎样才能像 g++ 那样有丰富的报错信息呢？&emsp;&emsp;在 bison 中可以使用 error 标识符，它不用提前声明，作用有点类似万能匹配符。在语法分析出现错误的时候，它就开始退栈，直到能匹配带有 error 标识符的规则。&emsp;&emsp;因此可以针对性地输出错误信息了：1234AssignStatement: ... | Id error Expression &#x27;;&#x27; &#123;yyerror(“expect \\&quot;:=\\&quot; before Expression.&quot;); $$ = nullptr;&#125; | Id &#x27;:=&#x27; Expression &#123;yyerror(&quot;expect \\&quot;;\\&quot; at the end of the statement.&quot;); $$ = nullptr;&#125;&emsp;&emsp;可以自行搞一些交互变量来阻止默认的 yyerror 调用以避免重复报错。详见《flex&amp;bison》得到更加丰富的报错信息，例如加上当前所在文件、错误发生的列号等。 destructor&emsp;&emsp;上面还存在一个问题：语法分析出错要退栈的时候，树结点是要析构的！&emsp;&emsp;因此在 bison part 1.5 要写有 %destructor&#123;要做的事&#125; 标识符或&lt;类型&gt;，例如12%destructor&#123;&#125; &lt;int&gt; &lt;double&gt; &lt;char*&gt;%destructor&#123; clear($$); &#125; &lt;*&gt;&emsp;&emsp;&lt;*&gt; 表示匹配任意类型，因为每个标识符有自己的子类所以类型挺多的。然后普通的类型不用析构，所以把普通类型又单列了出来。clear(node*) 是自己写的递归析构。 yynerrs&emsp;&emsp;直接上面这样写是有问题的。凡是非归约退栈都会调用 destructor，这不仅包括遇到错误退栈，还包括整个语法分析完成后的根节点退栈。于是你发现，根节点被析构了。。。&emsp;&emsp;因此要加一点判断，只有遇到错误时才进行析构。.tab.c 里有一个 yynerrs 变量记录了当前总共发生了多少次错误，把它 extern 出来，将它作为析构条件。1%destructor&#123; if (yynerrs) clear($$); &#125; &lt;*&gt;","categories":[{"name":"project","slug":"project","permalink":"http://kqp.world/categories/project/"}],"tags":[{"name":"编译器","slug":"编译器","permalink":"http://kqp.world/tags/%E7%BC%96%E8%AF%91%E5%99%A8/"}]},{"title":"【Ozon Tech Challenge 2020 F】Kuroni and the Punishment 题解","slug":"【Ozon Tech Challenge 2020 F】Kuroni and the Punishment 题解","date":"2021-04-15T07:54:22.000Z","updated":"2024-04-24T03:59:22.862Z","comments":true,"path":"【Ozon Tech Challenge 2020 F】Kuroni and the Punishment 题解/","link":"","permalink":"http://kqp.world/%E3%80%90Ozon%20Tech%20Challenge%202020%20F%E3%80%91Kuroni%20and%20the%20Punishment%20%E9%A2%98%E8%A7%A3/","excerpt":"题目大意&emsp;&emsp;有一个正整数序列 $a_1,\\cdots,a_n$，每次操作可以把一个数 $+1$ 或 $-1$，但要使其仍为正数。问至少多少次操作，使得整个序列的 $\\gcd$ 不为 $1$。&emsp;&emsp;$n \\le 2 \\times 10^5$&emsp;&emsp;2.5s","text":"题目大意&emsp;&emsp;有一个正整数序列 $a_1,\\cdots,a_n$，每次操作可以把一个数 $+1$ 或 $-1$，但要使其仍为正数。问至少多少次操作，使得整个序列的 $\\gcd$ 不为 $1$。&emsp;&emsp;$n \\le 2 \\times 10^5$&emsp;&emsp;2.5s \\\\ \\\\ \\\\题解&emsp;&emsp;首先有些很明显的观察，比如，可以枚举一个 $a_i$ 的质因数 $p$ 作为 $\\gcd$，然后每个数变成 $\\min(a_i \\bmod p,p-a_i \\bmod p)$，这样判一次是 $O(n)$ 的。&emsp;&emsp;再比如，答案不会超过序列中奇数的数量，因为每个奇数 $+1$ 就会使得 $2|\\gcd$。&emsp;&emsp;然后。。。&emsp;&emsp;就没有然后了。。。 &emsp;&emsp;然后题解说，虽然判一个质因子要 $O(n)$，但是只用判很少的质因子。&emsp;&emsp;由观察 2，答案不超过 $n$，因此最终改动在 $1$ 以内的位置至少有 $\\frac n2$ 个。也就是说，任选一个位置，至少有 $\\frac n2$ 的概率，最终的 $\\gcd$ 被它的质因子整除。&emsp;&emsp;因此就随机选序列的 20 个数，判断 $a_i,a_i+1,a_i-1$ 的所有质因子，就行了~ 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;bits/stdc++.h&gt;#define fo(i,a,b) for(int i=a;i&lt;=b;i++)using namespace std;typedef long long LL;const int maxn=2e5+5;int n;LL a[maxn];LL _check(LL p)&#123; LL ans=0; fo(i,1,n) ans+=(a[i]&lt;p) ?p-a[i] :min(a[i]%p,p-a[i]%p); return ans;&#125;LL check(LL x)&#123; LL ans=n+500; int sqrtx=sqrt(x); for(int i=2; i&lt;=sqrtx; i++) if (x%i==0) &#123; ans=min(ans,_check(i)); while (x%i==0) x/=i; &#125; if (x&gt;1) ans=min(ans,_check(x)); return ans;&#125;int main()&#123; scanf(&quot;%d&quot;,&amp;n); fo(i,1,n) scanf(&quot;%lld&quot;,&amp;a[i]); LL ans=0; fo(i,1,n) ans+=(a[i]&amp;1); random_shuffle(a+1,a+1+n); random_shuffle(a+1,a+1+n); random_shuffle(a+1,a+1+n); fo(i,1,min(n,20)) &#123; ans=min(ans,check(a[i]-1)); ans=min(ans,check(a[i])); ans=min(ans,check(a[i]+1)); &#125; printf(&quot;%lld\\n&quot;,ans);&#125;","categories":[{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[{"name":"算法_神奇的脑洞","slug":"算法-神奇的脑洞","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E7%A5%9E%E5%A5%87%E7%9A%84%E8%84%91%E6%B4%9E/"},{"name":"算法_随机大法","slug":"算法-随机大法","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E9%9A%8F%E6%9C%BA%E5%A4%A7%E6%B3%95/"}]},{"title":"【300iq Contest 1 H】Hall‘s Theorem 题解","slug":"【300iq Contest 1 H】Hall‘s Theorem 题解","date":"2021-02-26T09:36:47.000Z","updated":"2024-04-24T03:59:22.820Z","comments":true,"path":"【300iq Contest 1 H】Hall‘s Theorem 题解/","link":"","permalink":"http://kqp.world/%E3%80%90300iq%20Contest%201%20H%E3%80%91Hall%E2%80%98s%20Theorem%20%E9%A2%98%E8%A7%A3/","excerpt":"题目大意&emsp;&emsp;一个二分图，设左边的一个点集为 $S$，记它在右边的邻集为 $N(S)$，如果 $|S|&gt;|N(S)|$，则称 $S$ 是 critical 的。&emsp;&emsp;给定 $n,k$，构造一幅左右各 $n$ 个点的二分图，使得 critical 的点集数量恰好为 $k$。 &emsp;&emsp;$n &lt; 20,\\ 0 \\le k &lt; 2^n$&emsp;&emsp;1s","text":"题目大意&emsp;&emsp;一个二分图，设左边的一个点集为 $S$，记它在右边的邻集为 $N(S)$，如果 $|S|&gt;|N(S)|$，则称 $S$ 是 critical 的。&emsp;&emsp;给定 $n,k$，构造一幅左右各 $n$ 个点的二分图，使得 critical 的点集数量恰好为 $k$。 &emsp;&emsp;$n &lt; 20,\\ 0 \\le k &lt; 2^n$&emsp;&emsp;1s \\\\ \\\\ \\\\题解&emsp;&emsp;（虽然题解提到杨表但是并不能理解如何用杨表解释这个题 qaq&emsp;&emsp;不过杨表的结构却是很有启示性。 &emsp;&emsp;先把 $k$ 换成非空非 critical 点集数 $2^n-1-k$。假设左边每个点 $i$ 都连向右边的一个前缀 $1,\\cdots,a_i$，那么左边的每一个点集只取决于其 $a_i$ 最大的点。把左边的点按 $a_i$ 从小到大排序，那么一个点 $i$ 的贡献就是 $\\sum_{j=0}^{a_i-1} \\binom{i-1}{j-1}$。&emsp;&emsp;那么可以看成有一个 $n^2$ 的网格图，元素 $(i,j)$ 的价值是 $\\binom{i-1}{j-1}$。现在每一行选一个前缀，每一行的长度要大于等于上一行，问是否存在一种方案使得价值和为 $k$。 &emsp;&emsp;题解给的标准做法是 $O(\\frac{n^32^n}{64})$ dp，设 $dp_{i,j}$ 表示目前到第 $i$ 行，这行选的前缀长度为 $j$，所能取到的价值和的 bitset。&emsp;&emsp;但是观察一波发现可以从下往上贪心。从最后一行开始，每行从左到右，能选则选，不能选则往上一行。&emsp;&emsp;不会证明，只能马后炮地归纳证明一下。归纳证明左上角为 $(1,1)$ 右下角为 $(n,m)$ 的子矩阵可以取到所有不超过矩阵元素和的价值和。$n=1$ 时显然满足。$n&gt;1$ 时，要么最后一行取满了，那么剩余价值和一定不超过去掉最后一行的子矩阵的元素和；要么最后一行没取满，只取到 $(n,j)$，则剩余价值和不超过 $value_{n,j+1}=\\binom{n-1}{j}$，而 $\\sum_{i=0}^{n-2} \\binom{i}{j-1}=\\binom{n-1}{j}$，所以剩余价值和也不超过去掉最后一行的子矩阵的元素和。 代码123456789101112131415161718192021222324252627282930313233343536373839#include&lt;bits/stdc++.h&gt;#define fo(i,a,b) for(int i=a;i&lt;=b;i++)#define fd(i,a,b) for(int i=a;i&gt;=b;i--)using namespace std;const int maxn=25;int n,k;vector&lt;pair&lt;int,int&gt;&gt; e;int C[maxn][maxn];void C_Pre(int n)&#123; fo(i,0,n) &#123; C[i][0]=1; fo(j,1,i) C[i][j]=C[i-1][j-1]+C[i-1][j]; &#125;&#125;int main()&#123; scanf(&quot;%d %d&quot;,&amp;n,&amp;k); k=(1&lt;&lt;n)-k-1; C_Pre(n); int cur=0; fd(i,n,1) fo(j,1,n) if (cur+C[i-1][j-1]&gt;k) break; else &#123; cur+=C[i-1][j-1]; e.push_back(make_pair(i,j)); &#125; printf(&quot;%d\\n&quot;,e.size()); for(auto p:e) printf(&quot;%d %d\\n&quot;,p.first,p.second);&#125;","categories":[{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[{"name":"算法_DP","slug":"算法-DP","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-DP/"},{"name":"算法_构造题","slug":"算法-构造题","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E6%9E%84%E9%80%A0%E9%A2%98/"},{"name":"算法_贪心","slug":"算法-贪心","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E8%B4%AA%E5%BF%83/"}]},{"title":"始まりは君の空","slug":"sum2020","date":"2021-02-21T16:55:53.000Z","updated":"2024-04-24T03:59:22.795Z","comments":true,"path":"sum2020/","link":"","permalink":"http://kqp.world/sum2020/","excerpt":"&emsp;&emsp;就感觉年终了又新年了想要说些什么话，补一补漏的这么多游记（x","text":"&emsp;&emsp;就感觉年终了又新年了想要说些什么话，补一补漏的这么多游记（x &emsp;&emsp;以前比赛回来就会写游记，去年区域赛却一篇都没有。可能因为是家里蹲的线上赛，“游记”的“游”的部分没有了，所以可写的也少了。但其实比赛的过程也挺刺激的，像济南这样冲得这么前，很难说没什么感想总结，但那个时候正值年底 ddl，比赛结束当晚就要交数据库作业还要陪妹子吃饭，然后四天之内还有几科大作业，于是游记就咕了~ &emsp;&emsp;上一篇压抑的东西发出来以后收到很多鼓励与慰问，再次谢谢各位。“厌恶”现在来看可能还是用词过重了，后面临近比赛的时候，间歇性的热情也会变成持续性的，可能也是课程作业做烦了就想改改题。&emsp;&emsp;疫情真的把什么都变了。icpc 时间表被打乱，你鸭从寒假最短变成寒假最长，本来能体会的高四一般的大二下也变水了，实验室的课题被搁置，做事的心态波动变得剧烈，会因为一些不应有的想法而敌视好朋友，变得在意别人的想法，喜欢的事情的信仰受到冲击，LLfes 上映见面会取消，AZALEA 公演中止，Aqours 蛋巡中止……&emsp;&emsp;倒是催生的新的机会也不少。学校迟迟不开网课使我们迎来自己的“3月狂训”（是 3 个月不是三月），干掉了大半的 opentrain，低成本参加 prefinal，实现了每天坐在家里看着太阳从头顶落下感受时间流逝，有时间逛遍大半个市区好好感受城市，学会了做菜，LLfes 上映见面会取消使日语学习计划从临时补习变成全面学习，线上 live 让所有观众都是 live viewing 平起平坐，还认识了学校吃土群里一起看 live 的大佬们…… &emsp;&emsp;这么一写，好的方面还是比坏的方面要长。。。 &emsp;&emsp;最大的收获还是进一步学会了做自己想做的事吧。&emsp;&emsp;是从去年暑假开始的，总是想提高居家工作效率，于是发明了很多方法，每天主要时间用于补题，但是每天花3h做想做的事，想做的事以七天为一个周期循环滚动，第一天第四天上日语课，第二天第五天补 LL 未补完的生放、杂志之类的，第三天第六天补 LL 以外未补完的例如番和音乐节目，第四天学一本实验室相关的书例如《计算理论导引》《近世代数》。&emsp;&emsp;虽然很难限制自己严格执行，比如有时候就想点开 B 站，然后刚好就看到有鬼畜区 up 主更新了。但是真的做到了保证大体执行。大概是近两年最快乐的暑假。&emsp;&emsp;后来 9 月开学了，我的时间又要交给学校来规划了。学着为了凑学分而强选的不感兴趣却又很硬的课，复习正香时被安排校队选拔，后来又有无数次做作业做累了想补题、打竞赛打累了想做作业，逐渐明白了至少现阶段的自己真正想做的事。 &emsp;&emsp;所以什么才是真正想做的事情呢？比较重要的几点，一它不一定要是终身的，它可以持续一段时间然后被遗忘；二它不一定只有一项；三它不一定时时都带来快乐，但大部分时候是快乐的，是那种来自脑子里叫你坚持下去的。&emsp;&emsp;以前觉得做算法题学东西就是天下第一的趣味了，西瓜大爷退役之后发了一条说说大概是“除了 OI，还有很多有趣的东西，世界还是很宽广的”，当时并不认同。直到现在，我理解了这句话。 &emsp;&emsp;算法竞赛是值得坚持的，学一门外语是值得坚持的，追偶像也是值得坚持的，读书，学数学，看番，听音乐，练字，学习厨艺，运动健身，徒步走一条开车需要半小时以上的路，像宿管阿姨一样在草坪上晒太阳，不要因为优先级低就永久挂起饿死。 &emsp;&emsp;当想要做的事不止一项时，不要两三天埋头做一件事，也不要一小时做一件事，果然还是需要一个恰当大小的时间片轮转。一天分为早上、下午、晚上三个时段大约是合适的。 &emsp;&emsp;现在想来，即便是在高二、高三这样紧张的日子，也会有“周日下午”这样的休息时间吧。&emsp;&emsp;倒是我自己，高二高三那过年的时候，还在群里口胡刷题，看高考复习资料。要是经历多几次今年这样的，才刚入中年就贲门癌离世的伯伯（新生的儿子才一岁），103 岁的仙人一般的长寿伯公突然变得吃不了饭，年三十逝世，恐怕永远不敢认为过年没有做题重要了。好好跟能见到的亲戚说几句话，真的说不准哪年就见不到了，毕竟我自己也是可能猝死的。 &emsp;&emsp;跟 gyg 聊天时聊到过，她那边的学习氛围非常压抑，总是被压力裹得近乎麻木，想要逃离。我觉得我不比她轻松太多，作业没停过还要挤时间训练，但是我说，再苦再累，想到再努力几个月，就能看红白了，于是就又有精神了。&emsp;&emsp;红白并不是最精彩的节目，但它在年末，有一定的象征解放的意义，加上它本身也是我认识霓虹音乐界的重要渠道，我总是对它抱有期待。&emsp;&emsp;所以，我还是认同塞缪尔对青春的理解，“心灵的天线轰然倒塌”是青春与年老的分界线。对明天抱有期待，仍然在等待某一件事情的到来，或是在为之努力，这是年轻；不再对未来有所期待，所有快乐的事情都已经结束了，没有在等待什么日子，苟一天是一天，那就是年老。 &emsp;&emsp;所以今后呢？ &emsp;&emsp;在这天杀的 final 到来之前，都会保持训练的。10 年 OI，离开时说厌恶，也不是自己想要的结果吧，而且现在压力小些，能够以更轻松的心态去做题了，感受到做题的快乐，自然就有执行计划的动力了。这是一件等待的事情。&emsp;&emsp;下学期要着手准备研究生的事了吧，万法师说要带我冲几篇文章，同时我还得寻找并联系外校的导师了。这估计会是接下来的主要任务。这是一件等待的事情。&emsp;&emsp;Aqours 蛋巡，总得去一趟现地 live 的，趁着小姐姐们还年轻时。这是一件等待的事情。&emsp;&emsp;学分快修完了，绩点也基本定型了，不必再拼死拼活去卷些有的没的了。&emsp;&emsp;这两年记录下的各种 TCS 相关的学习资料，这学期就要 ddl 了，没法在这学期坚定方向的话，就真的要滚回 AI 大潮流了。&emsp;&emsp;日语，发自内心想学一门外语的感受是如此美妙，与被逼迫学英语的感受非常不同，来试试今年考 N2 吧。 &emsp;&emsp;有时会想到逢田姐在 3rd 提到的粉丝发言：“虽然工作很累，但是一想到明天就能来看 Aqours 的演出了，还是会变得有干劲。”那天正好很颓，听到这句话忽然觉得芒刺在背。&emsp;&emsp;也要好好工作过，累过，才对得起这句话吧。时而累，时而潇洒，才是人生的平衡。 &emsp;&emsp;一同在这新的一年起步的，还有 Liella 呢。","categories":[{"name":"总结与游记","slug":"总结与游记","permalink":"http://kqp.world/categories/%E6%80%BB%E7%BB%93%E4%B8%8E%E6%B8%B8%E8%AE%B0/"}],"tags":[]},{"title":"【300iq Contest 1 K】Knowledge 题解","slug":"【300iq Contest 1 K】Knowledge 题解","date":"2021-02-08T15:25:50.000Z","updated":"2024-04-24T03:59:22.820Z","comments":true,"path":"【300iq Contest 1 K】Knowledge 题解/","link":"","permalink":"http://kqp.world/%E3%80%90300iq%20Contest%201%20K%E3%80%91Knowledge%20%E9%A2%98%E8%A7%A3/","excerpt":"题目大意&emsp;&emsp;给定一个长度为 $n$ 的、仅含 a,b 的字符串 $s$，每次可以对 $s$ 做下列操作： 在任意位置添加或删除 aa； 在任意位置添加或删除 bbb； 在任意位置添加或删除 ababab。 &emsp;&emsp;问 $s$ 能变成多少种长度为 $x$ 的字符串，答案模 $998244353$。 &emsp;&emsp;$n \\le 3 \\times 10^5,\\ x \\le 10^9$","text":"题目大意&emsp;&emsp;给定一个长度为 $n$ 的、仅含 a,b 的字符串 $s$，每次可以对 $s$ 做下列操作： 在任意位置添加或删除 aa； 在任意位置添加或删除 bbb； 在任意位置添加或删除 ababab。 &emsp;&emsp;问 $s$ 能变成多少种长度为 $x$ 的字符串，答案模 $998244353$。 &emsp;&emsp;$n \\le 3 \\times 10^5,\\ x \\le 10^9$ \\\\ \\\\ \\\\题解&emsp;&emsp;官方题解直接抛出了个 Tetrahedral symmetry。。。这玩意到底是怎么跟四面体旋转扯上关系的啊 &emsp;&emsp;以下是比较算法竞赛的思路。 &emsp;&emsp;就是每个字符串的最小表示竟然是唯一的。具体来说，给定一个字符串，它能唯一转化成一个长度在 4 以内的串。&emsp;&emsp;而这种基础串只有 12 种。 &emsp;&emsp;证明的话因为题解啥也没写，不知道这鬼东西是不是有什么绝妙的证明，所以我只能脑补一个马后炮的归纳证法。首先手撸长度为 5 以内的所有串，发现它们确实能且仅能转化成 12 种基本串，然后归纳法，假设串长为 $n$ 时结论成立，串长为 $n+1$ 时可以先对前 $n$ 位做操作使其转化成 4 以内的基本串，然后再加上第 $n+1$ 位的字符形成一个长度为 5 的串，由手撸结果，它能转化为基本串。 &emsp;&emsp;这个归纳证明也给出了求一个串转化成基本串（即最小表示）的方法：从左往右一位一位地添加字符，若当前字符串能转化成基本串，则转化。只需一开始把手撸的长度在 5 以内的转化规则全部记在 map 里即可。 &emsp;&emsp;最后只需一个矩阵快速幂求出各种基本串在长度为 $x$ 时有多少对应的字符串即可。具体来说，做一个转移矩阵 $C$，$C_{ij}$ 表示基本串 $i$ 在末尾添加一个字符（a 或 b）转化成基本串 $j$ 的方案数。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include&lt;bits/stdc++.h&gt;#define fo(i,a,b) for(int i=a;i&lt;=b;i++)using namespace std;typedef long long LL;const int maxtot=13;const LL mo=998244353;int n,x;string s;unordered_map&lt;string,int&gt; M;unordered_map&lt;string,string&gt; trans;int tot;void add(string s) &#123;M[s]=++tot;&#125;int getMinStr(string s)&#123; string t; for(auto c:s) &#123; t+=c; if (trans.count(t)) t=trans[t]; &#125; return M[t];&#125;struct ARR&#123; LL n[maxtot][maxtot];&#125; re;ARR operator * (const ARR &amp;a,const ARR &amp;b)&#123; fo(i,1,tot) fo(j,1,tot) &#123; re.n[i][j]=0; fo(k,1,tot) (re.n[i][j]+=a.n[i][k]*b.n[k][j])%=mo; &#125; return re;&#125;ARR C,Ans;void Pow(ARR x,int y)&#123; for(; y; y&gt;&gt;=1, x=x*x) if (y&amp;1) Ans=Ans*x;&#125;void Pre()&#123; add(&quot;&quot;); add(&quot;a&quot;); add(&quot;ab&quot;); add(&quot;aba&quot;); add(&quot;abb&quot;); add(&quot;b&quot;); add(&quot;ba&quot;); add(&quot;bab&quot;); add(&quot;babb&quot;); add(&quot;bb&quot;); add(&quot;bba&quot;); add(&quot;bbab&quot;); trans[&quot;aa&quot;]=trans[&quot;bbb&quot;]=&quot;&quot;; trans[&quot;abaa&quot;]=&quot;ab&quot;; trans[&quot;abab&quot;]=&quot;bba&quot;; trans[&quot;abba&quot;]=&quot;bab&quot;; trans[&quot;abbb&quot;]=&quot;a&quot;; trans[&quot;baa&quot;]=&quot;b&quot;; trans[&quot;baba&quot;]=&quot;abb&quot;; trans[&quot;babba&quot;]=&quot;bbab&quot;; trans[&quot;babbb&quot;]=&quot;ba&quot;; trans[&quot;bbaa&quot;]=&quot;bb&quot;; trans[&quot;bbaba&quot;]=&quot;babb&quot;; trans[&quot;bbabb&quot;]=&quot;aba&quot;; for(auto p:M) &#123; C.n[p.second][getMinStr(p.first+&#x27;a&#x27;)]++; C.n[p.second][getMinStr(p.first+&#x27;b&#x27;)]++; &#125;&#125;int main()&#123; Pre(); cin &gt;&gt; n &gt;&gt; s &gt;&gt; x; Ans.n[1][1]=1; Pow(C,x); printf(&quot;%lld\\n&quot;,Ans.n[1][getMinStr(s)]);&#125;","categories":[{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[{"name":"算法_神奇的脑洞","slug":"算法-神奇的脑洞","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E7%A5%9E%E5%A5%87%E7%9A%84%E8%84%91%E6%B4%9E/"},{"name":"算法_字符串","slug":"算法-字符串","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"算法_矩阵乘法","slug":"算法-矩阵乘法","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95/"}]},{"title":"【Samara Farewell Contest 2020 C】Cyclically Shifted Maze 题解","slug":"【Samara Farewell Contest 2020 C】Cyclically Shifted Maze 题解","date":"2021-02-08T14:42:52.000Z","updated":"2024-04-24T03:59:22.864Z","comments":true,"path":"【Samara Farewell Contest 2020 C】Cyclically Shifted Maze 题解/","link":"","permalink":"http://kqp.world/%E3%80%90Samara%20Farewell%20Contest%202020%20C%E3%80%91Cyclically%20Shifted%20Maze%20%E9%A2%98%E8%A7%A3/","excerpt":"题目大意&emsp;&emsp;给定一幅 $n \\times m$ 的地图，地图由“.”和“#”构成，“.”表示空地，“#”表示障碍。&emsp;&emsp;求这个地图沿垂直和水平方向分别 shift 多少，能使空地形成一个连通块。求出所有可能的 shift 方案。 &emsp;&emsp;$n,m \\le 200$&emsp;&emsp;2s","text":"题目大意&emsp;&emsp;给定一幅 $n \\times m$ 的地图，地图由“.”和“#”构成，“.”表示空地，“#”表示障碍。&emsp;&emsp;求这个地图沿垂直和水平方向分别 shift 多少，能使空地形成一个连通块。求出所有可能的 shift 方案。 &emsp;&emsp;$n,m \\le 200$&emsp;&emsp;2s \\\\ \\\\ \\\\题解&emsp;&emsp;一开始想的是，把地图复制 4 份，然后在上面框出一个 $n \\times m$ 的子矩阵使得空地是一个连通块。&emsp;&emsp;后来发现不用复制 4 份，可以看成是这个地图找一个垂直方向的分割线和一个水平方向的分割线，移动分割线时维护并查集。&emsp;&emsp;但无论如何总会遇到一个问题：要动态加边删边就很麻烦。 &emsp;&emsp;于是题解给出了不用删边的办法。 &emsp;&emsp;枚举上下方向的 shift，接着对于左右方向，对于每一个前缀都把它的并查集记录下来，每一个后缀也把它的并查集记录下来，这样使得后面可以枚举左右方向的分割线，然后合并前缀后缀并查集。&emsp;&emsp;记录并查集不需要把 $nm$ 个点都记下来，因为合并前缀后缀并查集只是在合并第一列和最后一列，因此前缀并查集只需把第一列的连通性记下来，后缀并查集只需把最后一列的连通性记下来。&emsp;&emsp;枚举上下方向的 shift 是 $O(n)$ 的，接着求前缀后缀并查集、枚举合并并查集都是 $O(n^2)$ 的，总的是 $O(n^3)$ 的。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include&lt;bits/stdc++.h&gt;#define fo(i,a,b) for(int i=a;i&lt;=b;i++)#define fd(i,a,b) for(int i=a;i&gt;=b;i--)using namespace std;typedef long long LL;const int maxn=205;int n,m;char s[maxn][maxn];int ga[maxn*maxn],num;int get(int x) &#123;return ga[x]==x ?x :ga[x]=get(ga[x]) ;&#125;void merge(int x,int y)&#123; x=get(x), y=get(y); if (x!=y) ga[x]=y, num--;&#125;void clear_ga()&#123; for(int x=0; x&lt;n*m; x++) ga[x]=x; num=0;&#125;inline int id(int x,int y) &#123;return x*m+y;&#125;int prega[maxn][maxn],sufga[maxn][maxn],prenum[maxn],sufnum[maxn];vector&lt;pair&lt;int,int&gt;&gt; ans;int main()&#123; scanf(&quot;%d %d&quot;,&amp;n,&amp;m); fo(i,0,n-1) scanf(&quot;%s&quot;,s[i]); for(int i=0; i&lt;n; i++) &#123; clear_ga(); for(int j=0; j&lt;m; j++) &#123; for(int x=0; x&lt;n; x++) num+=(s[(i+x)%n][j]==&#x27;.&#x27;); for(int x=0; x&lt;n; x++) &#123; int curi=(i+x)%n; if (j &amp;&amp; s[curi][j-1]==&#x27;.&#x27; &amp;&amp; s[curi][j]==&#x27;.&#x27;) merge(id(curi,j-1),id(curi,j)); if (x&lt;n-1 &amp;&amp; s[curi][j]==&#x27;.&#x27; &amp;&amp; s[(curi+1)%n][j]==&#x27;.&#x27;) merge(id(curi,j),id((curi+1)%n,j)); &#125; for(int x=0; x&lt;n; x++) prega[j][(i+x)%n]=get(id((i+x)%n,0)); prenum[j]=num; &#125; clear_ga(); for(int j=m-1; j&gt;=0; j--) &#123; for(int x=0; x&lt;n; x++) num+=(s[(i+x)%n][j]==&#x27;.&#x27;); for(int x=0; x&lt;n; x++) &#123; int curi=(i+x)%n; if (j&lt;m-1 &amp;&amp; s[curi][j+1]==&#x27;.&#x27; &amp;&amp; s[curi][j]==&#x27;.&#x27;) merge(id(curi,j+1),id(curi,j)); if (x&lt;n-1 &amp;&amp; s[curi][j]==&#x27;.&#x27; &amp;&amp; s[(curi+1)%n][j]==&#x27;.&#x27;) merge(id(curi,j),id((curi+1)%n,j)); &#125; for(int x=0; x&lt;n; x++) sufga[j][(i+x)%n]=get(id((i+x)%n,m-1)); sufnum[j]=num; &#125; for(int j=0; j&lt;m; j++) &#123; if (j==0) &#123; num=sufnum[j]; &#125; else &#123; num=prenum[j-1]+sufnum[j]; for(int x=0; x&lt;n; x++) &#123; int t=ga[id((i+x)%n,0)]=prega[j-1][(i+x)%n]; ga[t]=t; t=ga[id((i+x)%n,m-1)]=sufga[j][(i+x)%n]; ga[t]=t; &#125; for(int x=0; x&lt;n; x++) if (s[(i+x)%n][0]==&#x27;.&#x27; &amp;&amp; s[(i+x)%n][m-1]==&#x27;.&#x27;) merge(id((i+x)%n,0),id((i+x)%n,m-1)); &#125; if (num==1) ans.push_back(make_pair(i,j)); &#125; &#125; printf(&quot;%d\\n&quot;,ans.size()); for(auto p:ans) printf(&quot;%d %d\\n&quot;,p.first,p.second);&#125;","categories":[{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[{"name":"算法_并查集","slug":"算法-并查集","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E5%B9%B6%E6%9F%A5%E9%9B%86/"}]},{"title":"【Samara Farewell Contest 2020 H】Video Reviews - 2 题解","slug":"【Samara Farewell Contest 2020 H】Video Reviews - 2 题解","date":"2021-02-02T15:19:31.000Z","updated":"2024-04-24T03:59:22.865Z","comments":true,"path":"【Samara Farewell Contest 2020 H】Video Reviews - 2 题解/","link":"","permalink":"http://kqp.world/%E3%80%90Samara%20Farewell%20Contest%202020%20H%E3%80%91Video%20Reviews%20-%202%20%E9%A2%98%E8%A7%A3/","excerpt":"题目大意&emsp;&emsp;有 $n$ 个人排队准备录视频，轮到第 $i$ 个人的时候，如果他被商家钦定，或者排他前面的至少有 $a_i$ 个人录视频，他就会录视频。问商家至少钦定多少人，使得最终录视频的人数 $\\ge m$。&emsp;&emsp;$m \\le n \\le 5 \\times 10^7$，由于输入过大，仅输入 $a_1$，接下来给出 $k$ 段生成器，每段生成 $c_i$ 个 $a$（保证 $\\sum_{i=1}^k c_i=n-1$），每个生成器形如 $a_i=(x a_{i-1}+y) \\bmod z$，$z$ 为质数。&emsp;&emsp;$k \\le 10^5$&emsp;&emsp;4s, 64MB","text":"题目大意&emsp;&emsp;有 $n$ 个人排队准备录视频，轮到第 $i$ 个人的时候，如果他被商家钦定，或者排他前面的至少有 $a_i$ 个人录视频，他就会录视频。问商家至少钦定多少人，使得最终录视频的人数 $\\ge m$。&emsp;&emsp;$m \\le n \\le 5 \\times 10^7$，由于输入过大，仅输入 $a_1$，接下来给出 $k$ 段生成器，每段生成 $c_i$ 个 $a$（保证 $\\sum_{i=1}^k c_i=n-1$），每个生成器形如 $a_i=(x a_{i-1}+y) \\bmod z$，$z$ 为质数。&emsp;&emsp;$k \\le 10^5$&emsp;&emsp;4s, 64MB \\\\ \\\\ \\\\题解&emsp;&emsp;思考许久，转头发现，这个空间，甚至连 $n$ 的数组都存不下。。。 &emsp;&emsp;感觉题解给得很妙啊。 &emsp;&emsp;考虑最后一个人，如果 $a_n &lt; m$，他是一定会录视频的，因此转化为子任务 $(n-1,m-1)$；&emsp;&emsp;否则，如果 $a_n \\ge m$ 且 $n=m$，这个人必须被钦定，不然不合法，因此也转化为子任务 $(n-1,m-1)$；&emsp;&emsp;否则，$a_n \\ge m$ 且 $n &gt; m$，此时要么前 $n-1$ 个人已经选出了 $m$ 个，那么第 $n$ 人直接扔了就好；要么前 $n-1$ 个人只选了 $m-1$ 个，想要钦定第 $n$ 个人，但是钦定前面的人只会使答案更优，所以不会有该情况。也就是说，$a_n \\ge m$ 且 $n &gt; m$ 时，直接忽略最后一个人，转化为子任务 $(n-1,m)$。 &emsp;&emsp;于是这样倒着做一遍就做好了。 &emsp;&emsp;由于空间不允许存下整个数组，可以先求出 $a_n$，因为 $z$ 都是质数，因此可以倒推出所有 $a_i$。$z$ 不同的生成器之间不能倒推，但是可以开一个 $O(k)$ 的数组记录每个生成器最后生成的 $a$ 是多少。&emsp;&emsp;妙啊 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;bits/stdc++.h&gt;#define fo(i,a,b) for(int i=a;i&lt;=b;i++)#define fd(i,a,b) for(int i=a;i&gt;=b;i--)using namespace std;typedef long long LL;const int maxk=1e5+5;int n,m,k,c[maxk],x[maxk],y[maxk],z[maxk],invx[maxk];LL a,fn[maxk];LL Pow(LL x,LL y,LL mo)&#123; LL re=1; for(; y; y&gt;&gt;=1, x=x*x%mo) if (y&amp;1) re=re*x%mo; return re;&#125;int main()&#123; scanf(&quot;%d %d&quot;,&amp;n,&amp;m); scanf(&quot;%lld %d&quot;,&amp;a,&amp;k); fn[0]=a; fo(i,1,k) &#123; scanf(&quot;%d %d %d %d&quot;,&amp;c[i],&amp;x[i],&amp;y[i],&amp;z[i]); invx[i]=Pow(x[i],z[i]-2,z[i]); fo(j,1,c[i]) a=(x[i]*a+y[i])%z[i]; fn[i]=a; &#125; int ans=0; fd(i,k,1) &#123; a=fn[i]; fo(j,1,c[i]) &#123; if (m==0) break; if (a&lt;m) m--, n--; else if (n==m) ans++, n--, m--; else n--; a=(a-y[i]+z[i])*invx[i]%z[i]; &#125; &#125; a=fn[0]; if (a&lt;m) m--, n--; else if (n==m) ans++, n--, m--; else n--; printf(&quot;%d\\n&quot;,ans);&#125;","categories":[{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[{"name":"算法_神奇的脑洞","slug":"算法-神奇的脑洞","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E7%A5%9E%E5%A5%87%E7%9A%84%E8%84%91%E6%B4%9E/"}]},{"title":"【XVIII Open Cup E.V. Pankratiev. Grand Prix of Gomel E】Exit Song 题解","slug":"【XVIII Open Cup E.V. Pankratiev. Grand Prix of Gomel E】Exit Song 题解","date":"2020-12-14T12:32:00.000Z","updated":"2024-04-24T03:59:22.872Z","comments":true,"path":"【XVIII Open Cup E.V. Pankratiev. Grand Prix of Gomel E】Exit Song 题解/","link":"","permalink":"http://kqp.world/%E3%80%90XVIII%20Open%20Cup%20E.V.%20Pankratiev.%20Grand%20Prix%20of%20Gomel%20E%E3%80%91Exit%20Song%20%E9%A2%98%E8%A7%A3/","excerpt":"题目大意&emsp;&emsp;电影院观众席为 $n \\times m$ 的方阵，其中 $k$ 个座位 $(r_1,s_1),\\cdots,(r_k,s_k)$ 已经被占。问从剩下的座位中，选择某一行的一个连续段（长度至少为 $1$）的方案数。 &emsp;&emsp;$n,m \\leq 10^5,\\ \\ 1 \\le k \\le nm$，给定 $r_1,s_1,a_r,b_r,a_s,b_s$，按如下方式生成剩余数据： r_i = (r_{i-1} \\cdot a_r + b_r) \\bmod n \\\\ s_i = (s_{i-1} \\cdot a_s + b_s) \\bmod m&emsp;&emsp;2s","text":"题目大意&emsp;&emsp;电影院观众席为 $n \\times m$ 的方阵，其中 $k$ 个座位 $(r_1,s_1),\\cdots,(r_k,s_k)$ 已经被占。问从剩下的座位中，选择某一行的一个连续段（长度至少为 $1$）的方案数。 &emsp;&emsp;$n,m \\leq 10^5,\\ \\ 1 \\le k \\le nm$，给定 $r_1,s_1,a_r,b_r,a_s,b_s$，按如下方式生成剩余数据： r_i = (r_{i-1} \\cdot a_r + b_r) \\bmod n \\\\ s_i = (s_{i-1} \\cdot a_s + b_s) \\bmod m&emsp;&emsp;2s \\\\ \\\\ \\\\题解&emsp;&emsp;它说它是数据随机生成，它可不是随机生成的啊，一次函数，模 $n$，后来它说 $k$ 是 $O(nm)$ 的，看来是 有 循 环 节 &emsp;&emsp;这个 $r$ 和 $s$ 显然是有循环节的。为了方便处理，先把还没进入循环节的坐标（$(r_i,s_i)$ 横纵坐标任意一个没有进入循环节就算这个坐标没有进入循环节）特殊标记出来（怎么用后面再说）。假设去掉这些坐标以后，起始坐标为 $(r_0,s_0)$，$r$ 序列的循环节长度为 $pr$，循环节为 $r_0,\\cdots,r_{pr-1}$；$s$ 序列的循环节长度为 $ps$，循环节为 $s_0,\\cdots,s_{ps-1}$。&emsp;&emsp;这里会有 $pr \\le n,\\ ps \\le m$。 &emsp;&emsp;对于 $r_0$，暴力把这一行的所有纵坐标求出来（即 $s_0,s_{pr \\bmod ps},s_{2pr \\bmod ps},\\cdots$，直到超出 $k$ 的限制），这个时间是 $O(\\frac{ps}{\\gcd(pr,ps)})$ 的。求出来之后丢进一个 set 里，就可以维护出这一行的答案了（记得考虑没进循环节的特殊点）。&emsp;&emsp;接下来最最重要的就是，发现有些行跟它是相似的！&emsp;&emsp;考虑第 $r_{ps \\bmod pr}$ 行，发现它的纵坐标序列跟 $r_0$ 的纵坐标序列大体相同，只有头尾有些不同。（因为纵坐标的循环节就是 $ps$，所以中间大部分纵坐标循环了一圈没有变化，不同的在于，$r0$ 的最后几个纵坐标放到 $r_{ps \\bmod pr}$ 里去可能超出了 $k$ 的限制，$r_{ps\\bmod pr}$ 可能在开头会比 $r_0$ 多几个。）&emsp;&emsp;而头尾这些不同的元素数量是 $O(\\lceil \\frac{ps}{pr} \\rceil)$ 的，可以用 $O(\\lceil \\frac{ps}{pr} \\rceil)$ 的时间把 set 调整过来。&emsp;&emsp;同理，第 $r_{2ps \\bmod pr}$ 行跟第 $r_{ps \\bmod pr}$ 行也是这样相似的，第 $r_{3ps \\bmod pr}$ 跟第 $r_{2ps \\bmod pr}$ 行也是这样相似的……&emsp;&emsp;因此 $r_0,\\cdots,r_{pr-1}$ 共分成了 $\\gcd(ps,pr)$ 个相似类，每个相似类的大小为 $\\frac{pr}{\\gcd(ps,pr)}$。每个相似类首先暴力求出初始一行的纵坐标序列，丢进 set 里，然后遍历这个相似类，调整 set 算答案。&emsp;&emsp;暴力求初始纵坐标的时间复杂度为 $O(\\gcd(ps,pr) \\cdot \\frac{ps}{\\gcd(ps,pr)}) = O(ps)$，set 调整的次数为 $O(pr \\cdot \\lceil \\frac{ps}{pr} \\rceil) = O(ps)$，再加上 set 那么这题的复杂度就是 $O(m \\log m)$。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125#include&lt;bits/stdc++.h&gt;#define fo(i,a,b) for(int i=a;i&lt;=b;i++)using namespace std;typedef long long LL;const int maxn=1e5+5;int n,m,r0,s0,ar,br,as,bs;LL k;int visr[maxn],viss[maxn],r[maxn],s[maxn],pr,ps;vector&lt;int&gt; spc[maxn];void make_period()&#123; while (k &amp;&amp; (!visr[r0] || !viss[s0])) &#123; spc[r0].push_back(s0); visr[r0]=1, viss[s0]=1; r0=(r0*(LL)ar+br)%n; s0=(s0*(LL)as+bs)%m; k--; &#125; memset(visr,0,sizeof(visr)); for(; !visr[r0]; r0=(r0*(LL)ar+br)%n) visr[r0]=1, r[pr++]=r0; memset(viss,0,sizeof(viss)); for(; !viss[s0]; s0=(s0*(LL)as+bs)%m) viss[s0]=1, s[ps++]=s0;&#125;inline LL sum1(LL x) &#123;return (x*(x+1))&gt;&gt;1;&#125;LL ans1,ans;set&lt;int&gt; S;void add(int x)&#123; int l,r; set&lt;int&gt;::iterator it=S.upper_bound(x); r=*it; it--; l=*it; ans1+=sum1(x-l-1)+sum1(r-x-1)-sum1(r-l-1); S.insert(x);&#125;void del(int x)&#123; int l,r; set&lt;int&gt;::iterator it=S.lower_bound(x); it--; l=*it; it++;it++; r=*it; it--; ans1+=sum1(r-l-1)-sum1(x-l-1)-sum1(r-x-1); S.erase(it);&#125;void calc_ans(int i)&#123; for(int x:spc[i]) add(x); ans+=ans1; for(int x:spc[i]) del(x);&#125;int main()&#123; scanf(&quot;%d %d %lld&quot;,&amp;n,&amp;m,&amp;k); scanf(&quot;%d %d %d&quot;,&amp;r0,&amp;ar,&amp;br); scanf(&quot;%d %d %d&quot;,&amp;s0,&amp;as,&amp;bs); make_period(); memset(visr,0,sizeof(visr)); memset(viss,0,sizeof(viss)); int timeStamp=0; fo(i,0,pr-1) if (!visr[r[i]]) &#123; timeStamp++; ans1=sum1(m); S.clear(); S.insert(-1), S.insert(m); deque&lt;int&gt; Q; LL curTime=i+1; for(int j=i%ps; curTime&lt;=k; (j+=pr)%=ps, curTime+=pr) &#123; if (viss[j]==timeStamp) break; Q.push_back(j); viss[j]=timeStamp; add(s[j]); &#125; for(int ii=i; !visr[r[ii]]; (ii+=ps)%=pr) &#123; visr[r[ii]]=1; if (Q.empty()) &#123; curTime=ii+1; for(int j=ii%ps; curTime&lt;=k; (j+=pr)%=ps, curTime+=pr) &#123; Q.push_back(j); add(s[j]); &#125; &#125; else &#123; while (Q.front()!=ii%ps) &#123; int j=((Q.front()-pr)%ps+ps)%ps; add(s[j]); Q.push_front(j); &#125; &#125; while (!Q.empty() &amp;&amp; ii+1+(Q.size()-1)*(LL)pr&gt;k) &#123; del(s[Q.back()]); Q.pop_back(); &#125; calc_ans(r[ii]); &#125; &#125; ans1=sum1(m); S.clear(); S.insert(-1), S.insert(m); fo(i,0,n-1) if (!visr[i]) calc_ans(i); printf(&quot;%lld\\n&quot;,ans);&#125;","categories":[{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[{"name":"算法_神奇的脑洞","slug":"算法-神奇的脑洞","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E7%A5%9E%E5%A5%87%E7%9A%84%E8%84%91%E6%B4%9E/"}]},{"title":"【2020 黑龙江省赛 E】Everybody Lost Somebody 题解","slug":"【2020 黑龙江省赛 E】Everybody Lost Somebody 题解","date":"2020-12-03T12:17:36.000Z","updated":"2024-04-24T03:59:22.813Z","comments":true,"path":"【2020 黑龙江省赛 E】Everybody Lost Somebody 题解/","link":"","permalink":"http://kqp.world/%E3%80%902020%20%E9%BB%91%E9%BE%99%E6%B1%9F%E7%9C%81%E8%B5%9B%20E%E3%80%91Everybody%20Lost%20Somebody%20%E9%A2%98%E8%A7%A3/","excerpt":"题目大意&emsp;&emsp;给定一个 $SA$ 数组和一个 $height$ 数组，其中 $height$ 数组的一些位置被抹掉了（用 $-1$ 表示），要求还原一个字典序最小的字符串，保证一定有解。 &emsp;&emsp;$n \\leq 5000$","text":"题目大意&emsp;&emsp;给定一个 $SA$ 数组和一个 $height$ 数组，其中 $height$ 数组的一些位置被抹掉了（用 $-1$ 表示），要求还原一个字典序最小的字符串，保证一定有解。 &emsp;&emsp;$n \\leq 5000$ \\\\ \\\\ \\\\题解&emsp;&emsp;先观察一下，给定 $SA$ 数组和 $height$ 数组，我们能够判断一些位置的大小关系。具体来说： 对于 $2 \\le i \\le n$，有 $s[SA_{i-1}] \\le s[SA_i]$，更进一步，若 $rank_{SA_{i-1}+1}&gt;rank_{SA_i+1}$，则必须有 $s[SA_{i-1}] &lt; s[SA_i]$； 对于 $2 \\le i \\le n$，对于 $0 \\le j &lt; height_i$，有 $s[SA_{i-1}+j] = s[SA_i+j]$，且若 $SA_{i-1}+height_i \\le n$ 的话还会有 $s[SA_{i-1}+height_i] &lt; s[SA_i+height_i]$。 &emsp;&emsp;因此想法就是搞出一个大小关系拓扑图，按拓扑序确定每个字母。&emsp;&emsp;然后又发现，$SA_1,\\cdots,SA_n$ 就是一个天然的拓扑序，直接以这个顺序一个一个确定就行了。显然，按这个顺序贪心放并满足所有限制的话，得到的字符串就是字典序最小的。 &emsp;&emsp;首先，根据上面的两条规则，先把确切的小于关系和等于关系记下来，小于关系连一条边，等于关系用并查集合并。&emsp;&emsp;$s[SA_1]$ 直接赋值为 $a$ 没问题，然后 $s[SA_2],\\cdots,s[SA_n]$ 依次确定，目标是每次处理完 $s[SA_i]$ 之后，只与 $s[SA_1],\\cdots,s[SA_i]$ 有关的限制被全部满足。对于 $s[SA_i]$，它就等于 $\\max(s[SA_{i-1}],s[小于关系里连向 i 的]+1)$，然后再去更新 $s[SA_1],\\cdots,s[SA_{i-1}]$ 中跟它有等于关系的位置（这只会把字符往大的改，因此 $s[SA_1],\\cdots,s[SA_{i-1}]$ 的限制仍然满足）。就做完了。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;bits/stdc++.h&gt;#define fo(i,a,b) for(int i=a;i&lt;=b;i++)using namespace std;const int maxn=5005;int n;int SA[maxn],Rank[maxn],height[maxn];int eql[maxn];vector&lt;int&gt; larger[maxn];int geteql(int x) &#123;return eql[x]==x ?x :eql[x]=geteql(eql[x]) ;&#125;int T;char ans[maxn];int main()&#123; scanf(&quot;%d&quot;,&amp;n); fo(i,1,n) scanf(&quot;%d&quot;,&amp;SA[i]), Rank[SA[i]]=i; fo(i,2,n) scanf(&quot;%d&quot;,&amp;height[i]); Rank[0]=Rank[n+1]=0; fo(i,1,n) eql[i]=i; fo(i,2,n) if (height[i]&gt;-1) &#123; int x=SA[i-1], y=SA[i]; fo(j,1,height[i]) eql[geteql(x+j-1)]=geteql(y+j-1); if (x+height[i]&lt;=n) larger[y+height[i]].push_back(x+height[i]); &#125; else &#123; int x=SA[i-1]+1, y=SA[i]+1; if (Rank[x]&gt;Rank[y]) larger[SA[i]].push_back(SA[i-1]); &#125; ans[SA[1]]=&#x27;a&#x27;; fo(i,2,n) &#123; ans[SA[i]]=ans[SA[i-1]]; for(int x:larger[SA[i]]) if (ans[x]+1&gt;ans[SA[i]]) ans[SA[i]]=ans[x]+1; fo(j,1,n-1) if (geteql(SA[j])==geteql(SA[i])) ans[SA[j]]=ans[SA[i]]; &#125; fo(i,1,n) putchar(ans[i]); puts(&quot;&quot;);&#125;","categories":[{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[{"name":"算法_字符串","slug":"算法-字符串","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"【若干大作业】RNN三连","slug":"【若干大作业】RNN三连","date":"2020-12-02T05:11:04.000Z","updated":"2024-04-24T03:59:22.879Z","comments":true,"path":"【若干大作业】RNN三连/","link":"","permalink":"http://kqp.world/%E3%80%90%E8%8B%A5%E5%B9%B2%E5%A4%A7%E4%BD%9C%E4%B8%9A%E3%80%91RNN%E4%B8%89%E8%BF%9E/","excerpt":"&emsp;&emsp;这学期一口气选了三门 AI 课（AI、模式识别、NLP），初衷就是想深入了解以后能更有底气地说“我不喜欢AI”（x&emsp;&emsp;然后三门课内容高度重复，每个知识点平均听三遍。。。其中最近发生的重合是，人工智能实验先要写一个 RNN 做关键词提取，然后 NLP 课要用 BiLSTM+CRF 做中文分词，完了之后还要用 LSTM 做语言模型。。。&emsp;&emsp;于是这位可怜的老 C++ 选手在用 C++ 写完了 KNN、决策树、PLA、逻辑回归、BPNN 之后，不得不在一个月内从 python 语法入门摸爬打滚到机器学习带师（x &emsp;&emsp;这篇博客大概只是分享和记录，不是教程。我认为学 AI 最好的方式是在学校里上课（有老师带，有同学一起讨论），或者买本书来学。在网上找博客自学是很不靠谱的。","text":"&emsp;&emsp;这学期一口气选了三门 AI 课（AI、模式识别、NLP），初衷就是想深入了解以后能更有底气地说“我不喜欢AI”（x&emsp;&emsp;然后三门课内容高度重复，每个知识点平均听三遍。。。其中最近发生的重合是，人工智能实验先要写一个 RNN 做关键词提取，然后 NLP 课要用 BiLSTM+CRF 做中文分词，完了之后还要用 LSTM 做语言模型。。。&emsp;&emsp;于是这位可怜的老 C++ 选手在用 C++ 写完了 KNN、决策树、PLA、逻辑回归、BPNN 之后，不得不在一个月内从 python 语法入门摸爬打滚到机器学习带师（x &emsp;&emsp;这篇博客大概只是分享和记录，不是教程。我认为学 AI 最好的方式是在学校里上课（有老师带，有同学一起讨论），或者买本书来学。在网上找博客自学是很不靠谱的。 前置&emsp;&emsp;做这些事的前置技能大概就是：学会 python、学会神经网络的理论框架。 &emsp;&emsp;一开始作为 C++ 选手也本能地纠结了一下既然 pytorch 也有 C++ API，为啥还要转 python 呢？大概考虑三个因素： 从速度来说：大家心中都有一个观念是“C++跑得快”，但是写起神经网络来，基本上都是在调库，时间瓶颈在于训练和反向传播的那些矩阵运算，线程优化和 GPU 算力才是硬道理。pytorch 底层也是 C/C++ 实现的，所以通篇都在调库的情况下，没有多大时间差。 从操作方便性来说：编程简便性是 python 优胜毫无疑问了，python 对于数据处理有更灵活的语法，还有巨多方便的库，例如一行 one-hot，例如许多课程可能要求先手写 BPNN，在 numpy 的支撑下 python 会从时间和简便性两方面吊打 C++。python 有包管理器这一点也很资瓷。 从环境来说：你周围的同学应该 98% 都会跟风用 python，这意味着如果你执意用别的语言，你将基本单打独斗，你们的讨论将变得困难，你代码出了 bug 不会有人来帮你调。这点对于学生可能才是最应该考虑的，为了获得学习环境的兼容，一起跟风吧~ &emsp;&emsp;然后神经网络的数学基础，大概就是《最优化方法》一类的课程，最好手写一遍 BPNN，该造的轮子必须得造。 RNN 关键词提取Task&emsp;&emsp;数据集是 http://alt.qcri.org/semeval2014/task4/ 的 SemEval-2014,Laptop，里面有 3000 余条英文句子，给出了每个句子的关键词（或词组）。每个句子可能有多个关键词（或词组）。&emsp;&emsp;以此训练一个模型，输入一个英文句子，可以找出句子的关键词。 模型准备&emsp;&emsp;首先要将这个任务表示为具体的数学模型。 &emsp;&emsp;第一步是词嵌入。采用 100 维的 Glove 词向量（https://nlp.stanford.edu/projects/glove/），将每个单词及标点都换成相应的词向量，那么一个句子就是若干个 100 维向量组成的序列。 &emsp;&emsp;第二步是序列标注。怎样使得模型的输出能够表征句子的关键词？序列标注是一种方法。参考中文分词的序列标注法，给每个字标上 B,M,E,S 中的一个标记，B 表示分词开始，M 表示词语中间字，E 表示分词结束，S 表示单字词语。这个序列唯一对应了一种分词结果。&emsp;&emsp;同理应用到关键词提取任务中，可以想到一种标注方法：N 表示非关键词，B 表示关键词开始，M 表示关键词中间词，E 表示关键词结束，S 表示单个关键词。这样就使得关键词提取变成了分类任务，输入一个句子，为每一个单词做分类。 &emsp;&emsp;以“NBMES”来标注虽然十分准确，但是标注较为复杂，数据集较小时训练效果不好。&emsp;&emsp;一种改进是改为“NBM”标注，N 表示非关键词，B 表示关键词开始，M 表示关键词非开始位置。这与“NBMES”标注是等价的（二者是唯一对应的），但是化简了标注。&emsp;&emsp;另一种改进是改为“IO”标注，I 表示是关键词，O 表示不是关键词。这种标注法比上述方法更简便，且变成了二分类问题，可以使用更多评测指标（例如 F1 分数）。但缺点是无法区分关键词组与连续单个关键词。&emsp;&emsp;本次任务采用“IO”标注。检视本次数据集发现所有关键词（组）均不相邻，因此上述缺点在训练中不存在。在实际应用中，也并非一定要区分关键词组与连续单个关键词。 网络&emsp;&emsp;句子的长度是变化的，不适合使用固定大小的全连接层。循环神经网络（RNN）可以有效应对这类数据。&emsp;&emsp;（此处略去若干 RNN 原理。。。） &emsp;&emsp;RNN 可以做许多扩展，例如： 多个 RNN 垂直叠加，成为多层 RNN； 再增加一层从右影响到左的隐状态，成为双向 RNN； &emsp;&emsp;RNN 虽然理论上实现了当前状态与过往状态的联系，但对于时间相隔较长的过往状态保留的信息很少。同时,RNN 展开较深的时序时，存在梯度消失和梯度爆炸的问题。&emsp;&emsp;LSTM 是一种改进的 RNN，在其结构中加入了许多控制门：&emsp;&emsp;LSTM 新增了一层隐状态 $\\mathbf C_t$。传统 RNN 通过 $\\mathbf x_t$ 与 $\\mathbf h_{t-1}$ 直接得到 $\\mathbf h_t$；但在 LSTM 中，先通过 $\\mathbf x_t$ 与 $\\mathbf h_{t-1}$ 使用不同的权重和偏置分别算出遗忘门 $\\mathbf f_t$、输入门 $\\mathbf i_t$、输出门 $\\mathbf o_t$，再使用遗忘门和输入门对 $\\mathbf C_t$ 进行更新，最后用 $\\mathbf C_t$ 和输出门得到 $\\mathbf h_t$。&emsp;&emsp;三个控制门矩阵都经过了 sigmoid 函数，因此元素都 $\\in (0,1)$，用这些矩阵对别的矩阵做对应位置相乘求和，相当于控制别的矩阵的每个元素的保留程度。因此 $\\mathbf C_t = \\mathbf f_t \\odot \\mathbf C_{t-1} + \\mathbf i_t \\odot \\mathbf g_t$ 这一项，就相当于控制 $\\mathbf C_{t-1}$ 遗忘了多少、当前 $\\mathbf g_t$ 记住了多少，是一种平滑移动。 代码实现&emsp;&emsp;整份代码实现起来难度不大，主要难度在于学习如何使用 pytorch。就只放网络结构了，其实也都是调包侠。。。1234567891011121314151617181920import torchimport torch.nn as nnimport torch.nn.utils.rnn as tRnnclass LSTM(nn.Module): def __init__(self, vec_dim, hidden_dim, out_dim): super(LSTM, self).__init__() self.lstm = nn.LSTM(vec_dim, hidden_dim, batch_first = True, dropout = 0.2, bidirectional = False) self.fc1 = nn.Linear( hidden_dim, 64) self.fc2 = nn.Linear(64, out_dim) self.dropout10 = nn.Dropout(0.1) def forward(self, x): x, _ = self.lstm(x) x, _ = tRnn.pad_packed_sequence(x, batch_first=True) x = self.fc1(F.relu(x)) x = self.fc2(F.relu(x)) return x&emsp;&emsp;还有数据的预处理也是比较繁琐的，但是也只是编程实现上的难度，不是算法设计的难度。 效果&emsp;&emsp;因为序列标注用了二分类，因此结果的评价就用 $F1$ 分数了 F1 = \\frac{2 \\cdot \\text{precision rate} \\cdot \\text{recall rate}}{\\text{precision rate} + \\text{recall rate}} BiLSTM+CRF 中文分词Task&emsp;&emsp;使用 BiLSTM+CRF 分词模型，在 SIGHAN Microsoft Research 数据集上进行中文分词的训练和测试。&emsp;&emsp;已标注数据集的每一条数据是一个中文句子，词之间用两个空格隔开。 整体设计&emsp;&emsp;依然是采用序列标注的方法来做分词，为每个字标上 B,M,E,S 中的一个标记，B 表示分词开始，M 表示词语中间字，E 表示分词结束，S 表示单字词语。这个序列唯一对应了一种分词结果。 &emsp;&emsp;模型的整体框架为：对于一个句子，设长度为 $l$（以 UTF8 字符数量计），依次通过以下步骤： 将每个 UTF8 字符替换成字向量，得到长度为 $l$ 的字向量序列； 通过 BiLSTM 得到长度为 $l$ 的分数向量序列（分数向量是一个 4 维向量，分别代表该字表为 B(begin),M,E,S 的分数）； 通过 CRF 得到长度为 $l$ 的序列标注； 基于序列标注得到分词结果。 &emsp;&emsp;采用 300 维的预训练字向量 sgns.context.word-character.char1-1.dynwin5.thr10.neg5.dim300.iter5，该向量集含有单字、词语、标点符号、英语缩写、希腊字母等诸多元素，但只取单字和标点符号用于本次任务。&emsp;&emsp;本次任务中，若句子含有未被字向量覆盖的字符，则该数据作废。经验证，训练集有 1 条数据被作废，测试集数据全部有效。 BiLSTM+CRF&emsp;&emsp;LSTM 上面已经写过了，BiLSTM 就是双向的 LSTM。&emsp;&emsp;LSTM 的输出是 4 维分数向量的序列，进行归一化可以直接得到每个字的标签预测概率分布。但是结合传统概率模型可以使上下文关联效果更好，因此 LSTM 之后采用 CRF。&emsp;&emsp;CRF 有两个任务：训练的时候求出给定序列标注的后验概率，并以其负对数作为损失函数进行梯度下降；测试的时候通过输入的分数向量序列求出概率最大的序列标注。&emsp;&emsp;但实际上许多现有的 CRF 实现方法做的并不是真正的概率模型，而是用一种标注方案的分数除以所有标注方案分数和作为该方案的“概率”。以下先按概率模型作分析，再说明现有 CRF 实现方法的分数模型。 概率模型&emsp;&emsp;训练时，设给定序列标注为 $y_1,\\cdots,y_l$，CRF 的输入序列为 $\\mathbf x_1,\\cdots,\\mathbf x_l$，则后验概率为 P(y_1,\\cdots,y_l\\ |\\ \\mathbf x_1,\\cdots,\\mathbf x_l) = \\left(\\prod_{i=1}^l P(y_i|\\mathbf x_i)\\right)\\left(\\prod_{i=2}^{l}P(y_i|y_{i-1})\\right)&emsp;&emsp;求解该式只需将 $i$ 从 $1$ 到 $l$ 遍历一遍，把所有用到的概率乘起来即可。其中 $P(y_i|\\mathbf x_i)$ 为发射概率，可以将向量 $\\mathbf x_i$ 归一化之后取 $y_i$ 那一项；$P(y_i|y_{i-1})$ 为转移概率，可以用矩阵 $\\mathbf A$ 来求，$A_{ij}$ 表示由标签 $i$ 转移到标签 $j$ 的概率，该矩阵与其他网络参数一起参与训练。&emsp;&emsp;测试时，已有输入序列 $\\mathbf x_1,\\cdots,\\mathbf x_l$ 和标签转移矩阵 $\\mathbf A$，则通过动态规划找到最大概率的标注方案。设 $dp_{i,j}$ 表示已经考虑了序列的前 $i$ 项，第 $i$ 项选择标签 $j$，的最大概率，则 dp_{i,j} = P(j|\\mathbf x_i) \\cdot \\max_{k=1}^4 (dp_{i-1,k} \\cdot A_{kj})&emsp;&emsp;记录 DP 的转移路径，最后选最大的 $dp_{l,j}(j=1,2,3,4)$ 根据转移路径倒推即得到标注结果。&emsp;&emsp;实现的时候应当对概率取对数，将乘法变为加法运算，避免精度问题。 分数模型&emsp;&emsp;以 torchcrf 的实现为例：所有的概率都被换成分数，后验概率改为后验分数；发射概率 $P(y_i|\\mathbf x_i)$ 替换为发射分数，直接取向量 $\\mathbf x_i$ 中 $y_i$ 那一维的值；转移概率矩阵 $\\mathbf A$ 替换为转移分数矩阵，$A_{ij}$ 表示由标签 $i$ 转移到标签 $j$ 可以获得的分数。上面两式的概率乘法改为分数相加。 \\begin{aligned} & F(y_1,\\cdots,y_l\\ |\\ \\mathbf x_1,\\cdots,\\mathbf x_l) = \\left(\\sum_{i=1}^l F(y_i|\\mathbf x_i)\\right)+\\left(\\sum_{i=2}^{l}F(y_i|y_{i-1})\\right) \\\\ & dp_{i,j} = F(j|\\mathbf x_i) + \\max_{k=1}^4 (dp_{i-1,k} + A_{kj}) \\end{aligned}&emsp;&emsp;训练时还需计算一个“所有标注方案的分数和”，可以用类似递推算出。&emsp;&emsp;计算损失函数的时候，定义给定标注序列 $y_1,\\cdots,y_l$ 的“概率”为 \\frac{exp(\\text{序列} y_1,\\cdots,y_l \\text{的分数})}{exp(\\text{所有标注方案的分数和})}&emsp;&emsp;取对数则为 (\\text{序列} y_1,\\cdots,y_l \\text{的分数}) - (\\text{所有标注方案的分数和})代码实现&emsp;&emsp;依然是大调包，只放网络结构了。&emsp;&emsp;网络里的结构依次为：BiLSTM，全连接层，CRF。在训练的前向过程中，CRF 层是计算“概率”的对数，得到结果取反为损失函数；而测试的前向过程，则是动态规划解码，直接返回标注序列。123456789101112131415161718192021222324252627import torchimport torch.nn as nnimport torch.nn.utils.rnn as tRnnfrom torchcrf import CRFclass BiLSTM_CRF(nn.Module): def __init__(self, vec_dim, hidden_dim, out_dim): super(BiLSTM_CRF, self).__init__() self.lstm = nn.LSTM(vec_dim, hidden_dim//2, batch_first = True, dropout = 0.2, bidirectional = True) self.hidden2tag = nn.Linear(hidden_dim, out_dim) self.dropout10 = nn.Dropout(0.1) self.crf = CRF(out_dim, batch_first = True) def forward_train(self, x, label, mask): x, _ = self.lstm(x) x, _ = tRnn.pad_packed_sequence(x, batch_first=True) # x = self.dropout10(x) x = self.hidden2tag(x) x = -self.crf(x, label, mask) return x def forward_test(self, x, mask): x, _ = self.lstm(x) x, _ = tRnn.pad_packed_sequence(x, batch_first=True) x = self.hidden2tag(x) x = self.crf.decode(x, mask) return x 结果&emsp;&emsp;评估指标为 F1： \\begin{aligned} F1 &= \\frac{2 \\times precision \\times recall}{precision + recall} \\\\ precision &= \\text{分对词数}/\\text{预测分词结果的总词数} \\\\ recall &= \\text{分对词数}/\\text{标准分词结果的总词数} \\end{aligned} LSTM 语言模型Task&emsp;&emsp;语言模型是机器对于语言本身的掌握程度，形式化地定义就是，给定一个句子，计算这个句子的概率。&emsp;&emsp;这东西的应用，比如，翻译标准“信达雅”中的“达”，即目标语言的通顺流畅，就是语言模型；比如，输入法或者百度搜索框里面输入了一个词，系统就会联想下一个词，或者联想了一个句子，这个是文本生成。&emsp;&emsp;本次任务就是文本生成。给定初始词，用这个词生成下一个词，再用新生成的词生成下一个词，再用新生成的词生成下一个词……直至生成\\表示句子的结束。用 LSTM 实现。训练集仍是 SIGHAN Microsoft Research。 原理与步骤&emsp;&emsp;模型核心为一个单向 LSTM，输入是一个句子转化成的词向量序列，训练时通过 LSTM 得到相同长度的预测概率分布序列（序列的每一个元素是词表大小的向量，表示预测为词表某个词的概率分布），以与正确文本的逐词交叉熵作为损失函数进行反向传播；测试时给定初始词，不断用上一个词通过 LSTM 生成下一个词，直至生成 \\ 句末标志。 词表&emsp;&emsp;词表构建有两种方法，一是沿用上一个 Task 的 300 维预训练字词向量 sgns.context.word-character.char1-1.dynwin5.thr10.neg5.dim300.iter5，它包含了绝大部分常用词语。但该方法有很多缺点： 词表有 63 万个词，搭建网络对显存需求很大； 训练集被词表完全覆盖的句子只有 39231 条，意味着超过一半的句子存在“未知词”； 观察词表发现 150000 以后的词并不常用（如各种网络用语），几乎不会出现在训练集里，造成浪费。 &emsp;&emsp;第二种方法是仅给训练集里出现的词语进行编号，用 pytorch 的 embedding 层得到词向量，随其他网络参数一同训练。训练集的词语约 88000 条，相比上一个方法能有效减小网络大小，且完全覆盖训练集。 &emsp;&emsp;本次两种方法都尝试了一遍，一是截取预训练词表前 150000 个词，且训练集只保留被词向量完全覆盖的句子（否则预测出来的句子也会大量出现“未知词”）；二是给训练集的词编号并使用 embedding 层，词向量跟随网络一起训练。 实现网络结构&emsp;&emsp;网络里的结构依次为：(embedding)，LSTM，全连接层。词表大小为 vocab\\_size，embedding 层维度为 vocab\\_size$$\\to$$embedding\\_dim，LSTM 层维度为 embedding\\_dim$$\\to$$hidden\\_dim，全连接层维度 hidden\\_dim$$\\to$$vocab\\_size。&emsp;&emsp;若采用预训练词向量则没有 embedding 层。&emsp;&emsp;由于显存的限制，hidden\\_dim 只能开到 350，造成该网络是比较畸形的网络。（后面全连接层输出至少是 8 万维） 123456789101112131415161718192021222324252627import torch.nn.utils.rnn as tRnnclass LSTM(nn.Module): def __init__(self, vocab_size, embedding_dim, hidden_dim, out_dim): super(LSTM, self).__init__() self.embedding = nn.Embedding(vocab_size, embedding_dim) self.lstm = nn.LSTM(embedding_dim, hidden_dim, batch_first = True, dropout = 0.2) self.hidden2tag = nn.Linear(hidden_dim, out_dim) self.dropout10 = nn.Dropout(0.1) def forward_train(self, x, data_length): x = self.embedding(x) x = tRnn.pack_padded_sequence(x, data_length, batch_first=True) x, _ = self.lstm(x) x, _ = tRnn.pad_packed_sequence(x, batch_first=True) x = self.dropout10(x) x = self.hidden2tag(x) return x def forward_test(self, x, data_length): x = self.embedding(x) x = tRnn.pack_padded_sequence(x, data_length, batch_first=True) x, _ = self.lstm(x) x, _ = tRnn.pad_packed_sequence(x, batch_first=True) x = self.hidden2tag(x) _, x = torch.max(x,2) return x 测试&emsp;&emsp;由于 pytorch 比较难实现直接通过上一个词得出下一个词，故用以下方式实现：&emsp;&emsp;设当前句子为 $sentence$（是一个词序列），初始时 $sentence$ 为输入的初始词。每次将 $sentence$ 输入网络，得到相同长度的输出 $predict$，取 $predict$ 的最后一个词添加到 $sentence$ 的末尾，若该词不为 \\ 则重复该过程。12345678910111213141516def test(initWord, myNetwork) : if not(initWord in wordVec) : print(&#x27;This word is not in training set!&#x27;) return sentence = [wordVec[initWord]] myNetwork.eval() while True: data = torch.tensor([sentence]) predict = myNetwork.forward_test(data,[len(sentence)])[0] lastWord = predict[-1] sentence.append(lastWord) if (lastWord==0) : break for i in sentence : print(vecWord[i],end=&#x27;&#x27;) print() 结果&emsp;&emsp;迭代 30 次，取每次 epoch 的所有句子的平均交叉熵，对比如下： &emsp;&emsp;可以看到，使用训练集作为词表的效果会略微好些，差距大约在 15 次 epoch 时被拉开。 &emsp;&emsp;生成句子的测试效果如下：&emsp;&emsp;4 个图分别称作图 1 ~ 图 4，分别为预训练词向量测试效果1、预训练词向量测试效果2、训练集embedding 测试效果1、训练集embedding 测试效果2。&emsp;&emsp;整体来看，二者都能正常执行生成句子的过程，生成的句子大致通顺，但存在大量语法问题，句子成分缺失明显，句意基本都不通顺。&emsp;&emsp;相比来看，在测试集 1 上训练集 embedding 的效果（图 3）要好于预训练词向量的效果（图 1），后者出现了大量的重复词语和句子，且句子通顺程度弱于前者；测试集 2 虽然整体来看是训练集 embedding 更通顺（图 4），但预训练词向量的结果（图 2）中有“给北京军区某给水工程团记一等功。”这样完全符合语法、句意完全通顺的句子。&emsp;&emsp;以图 3 为代表，可以发现生成的句子具有如下特点： 有关党和政治的语句特别多，与党和政治相关的开头（如图 3 的前三句）效果要好于其他句子，甚至用“诗”作开头都能扯到党的建设。这是明显的训练集特征，训练集大部分句子是与党和政治相关的。 部分句子会使用训练集原文。如图3 的“美国”开头的句子，这条新闻可以在百度搜到原文。 稍有典雅性。如图 3 的后三句——“墨色生几分侵蚀”“诗才敏捷，音韵铿锵”等，尽管这完全不足以进行文学分析。","categories":[{"name":"project","slug":"project","permalink":"http://kqp.world/categories/project/"}],"tags":[{"name":"RNN","slug":"RNN","permalink":"http://kqp.world/tags/RNN/"}]},{"title":"【2020 Multi-University 4 I】Imperative Meeting 题解","slug":"【2020 Multi-University 4 I】Imperative Meeting 题解","date":"2020-11-02T09:03:04.000Z","updated":"2024-04-24T03:59:22.813Z","comments":true,"path":"【2020 Multi-University 4 I】Imperative Meeting 题解/","link":"","permalink":"http://kqp.world/%E3%80%902020%20Multi-University%204%20I%E3%80%91Imperative%20Meeting%20%E9%A2%98%E8%A7%A3/","excerpt":"题目大意&emsp;&emsp;有一棵 $n$ 个结点的树，现有 $m$ 个人位于不同的结点，那么要让他们在同一结点相遇的话会有一个最小总路程。而“$m$个人位于不同结点”共有 $\\binom nm$ 种情况，求这 $\\binom{n}{m}$ 种情况的最小总路程之和，模 $10^9+7$。 &emsp;&emsp;$m \\le n \\le 10^6$&emsp;&emsp;多测，$T \\le 1000$，$\\sum n \\le 2\\times 10^6$&emsp;&emsp;2s","text":"题目大意&emsp;&emsp;有一棵 $n$ 个结点的树，现有 $m$ 个人位于不同的结点，那么要让他们在同一结点相遇的话会有一个最小总路程。而“$m$个人位于不同结点”共有 $\\binom nm$ 种情况，求这 $\\binom{n}{m}$ 种情况的最小总路程之和，模 $10^9+7$。 &emsp;&emsp;$m \\le n \\le 10^6$&emsp;&emsp;多测，$T \\le 1000$，$\\sum n \\le 2\\times 10^6$&emsp;&emsp;2s \\\\ \\\\ \\\\题解&emsp;&emsp;考虑每条边的贡献，一条边有贡献当且仅当这条边两侧都有人，且贡献等于两侧人数的较小值。形式化地说，假设一条边连接了 $x$ 子树和 $y$ 子树，那么这条边的贡献为： \\sum_{i=1}^{m-1} \\binom{size_x}{i} \\binom{size_y}{m-i} \\min(i,m-i)&emsp;&emsp;把 $\\min$ 拆掉变成 \\sum_{i=1}^{\\lfloor \\frac{m-1}{2} \\rfloor} i\\binom{size_x}{i} \\binom{size_y}{m-i} + \\sum_{i=1}^{\\lfloor \\frac{m-1}{2} \\rfloor}i\\binom{size_y}{i} \\binom{size_x}{m-i} + [m为偶数]\\frac m2 \\binom{size_x}{\\frac m2} \\binom{size_y}{\\frac m2}&emsp;&emsp;这式子共 3 项，最后一项对于每条边单独算一下就行了，所以要算前两项，以第一项为例做一个变形把乘 $i$ 去掉： \\begin{aligned} &\\sum_{i=1}^{\\lfloor \\frac{m-1}{2} \\rfloor} i\\binom{size_x}{i} \\binom{size_y}{m-i} \\\\ =& \\sum_{i=1}^{\\lfloor \\frac{m-1}{2} \\rfloor} i\\cdot\\frac{size_x!}{i!\\cdot(size_x-i)!}\\binom{size_y}{m-i} \\\\ =& \\sum_{i=1}^{\\lfloor \\frac{m-1}{2} \\rfloor} \\frac{size_x \\cdot (size_x-1)!}{(i-1)!\\cdot(size_x-i)!}\\binom{size_y}{m-i} \\\\ =& size_x\\sum_{i=1}^{\\lfloor \\frac{m-1}{2} \\rfloor} \\binom{size_x-1}{i-1} \\binom{size_y}{m-i} \\end{aligned}&emsp;&emsp;注意到 $size_x+size_y=n$，记 $h_s=\\sum_{i=1}^{\\lfloor \\frac{m-1}{2} \\rfloor} \\binom{s-1}{i-1} \\binom{n-s}{m-i}$，结果发现这玩意是能递推的！&emsp;&emsp;有两种方法能够得到递推结果。&emsp;&emsp;一种是考虑 $h_s$ 的组合意义：把 $m-1$ 个球放到 $n-1$ 个盒子里，每个盒子最多放 $1$ 个球，且要求前 $s-1$ 个盒子最多只能有 $\\lfloor \\frac{m-1}{2} \\rfloor-1$ 个球，问方案数。&emsp;&emsp;$m-1$ 个球放入 $n-1$ 个盒子共 $\\binom{n-1}{m-1}$ 种方案，这也是 $h_1$ 的值。随着 $s$ 的增大，只会有越来越多的方案变得非法。从 $h_{s-1}$ 到 $h_s$ 变得非法的方案，即为前 $s-2$ 个盒子已经放够了 $\\lfloor \\frac{m-1}{2} \\rfloor -1$ 个球，而第 $s-1$ 个盒子又放了一个球，其余球放在后面的盒子里，方案数为 $\\binom{s-2}{\\lfloor \\frac{m-1}{2} \\rfloor -1}\\binom{n-s}{m-1-\\lfloor \\frac{m-1}{2} \\rfloor}$。&emsp;&emsp;另一种方法是硬推： h_{s+1}-h_s = \\sum_{i=1}^{\\lfloor \\frac{m-1}{2} \\rfloor} \\binom{s}{i-1}\\binom{n-s-1}{m-i}-\\binom{s-1}{i-1}\\binom{n-s}{m-i}&emsp;&emsp;把 $i=1$ 单独拉出来，其余的把 $\\binom{s}{i-1}$ 拆成 $\\binom{s-1}{i-1}+\\binom{s-1}{i-2}$、把 $\\binom{n-s}{m-i}$ 拆成 $\\binom{n-s-1}{m-i}+\\binom{n-s-1}{m-i-1}$，然后基本上所有的项都被消去了，能得到同样的结果。式子太长就不写了。 &emsp;&emsp;于是，$O(n)$ 递推出 $h$，然后每条边单独算贡献，就得到答案了。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include&lt;bits/stdc++.h&gt;#define fo(i,a,b) for(int i=a;i&lt;=b;i++)#define fd(i,a,b) for(int i=a;i&gt;=b;i--)using namespace std;typedef long long LL;const int maxn=1e6+5;const LL mo=1e9+7;int n,m,mh;vector&lt;int&gt; e[maxn];LL Pow(LL x,LL y)&#123; LL re=1; for(; y; y&gt;&gt;=1, x=x*x%mo) if (y&amp;1) re=re*x%mo; return re;&#125;LL fac[maxn],inv[maxn];void C_Pre(int n)&#123; fac[0]=1; fo(i,1,n) fac[i]=fac[i-1]*i%mo; inv[n]=Pow(fac[n],mo-2); fd(i,n-1,0) inv[i]=inv[i+1]*(i+1)%mo;&#125;LL C(int n,int m) &#123;return (n&gt;=m &amp;&amp; m&gt;=0) ?fac[n]*inv[m]%mo*inv[n-m]%mo :0 ;&#125;void ReadInt(int &amp;data)&#123; data=0; char ch=getchar(); while (ch&lt;&#x27;0&#x27; || ch&gt;&#x27;9&#x27;) ch=getchar(); do&#123; data=(data&lt;&lt;3)+(data&lt;&lt;1)+ch-&#x27;0&#x27;; ch=getchar(); &#125; while (ch&gt;=&#x27;0&#x27; &amp;&amp; ch&lt;=&#x27;9&#x27;);&#125;LL h[maxn];void Pre()&#123; int mhv=(m-1)&gt;&gt;1; if (mhv==0) &#123; fo(i,1,n-1) h[i]=0; return; &#125; h[1]=C(n-1,m-1); fo(i,2,n-1) h[i]=(h[i-1]-C(i-2,mhv-1)*C(n-i,m-1-mhv)%mo+mo)%mo; fo(i,1,n-1) (h[i]*=i)%=mo;&#125;int size[maxn];void dfs_size(int k,int last)&#123; size[k]=1; for(int son:e[k]) if (son!=last) &#123; dfs_size(son,k); size[k]+=size[son]; &#125;&#125;LL ans;void dfs_ans(int k,int last)&#123; for(int son:e[k]) if (son!=last) &#123; (ans+=h[size[son]]+h[n-size[son]]+((m&amp;1) ?0 :C(size[son],mh)*C(n-size[son],mh)%mo*mh ))%=mo; dfs_ans(son,k); &#125;&#125;int T;int main()&#123; C_Pre(1e6); scanf(&quot;%d&quot;,&amp;T); while (T--) &#123; ReadInt(n), ReadInt(m); mh=m&gt;&gt;1; fo(i,1,n) e[i].clear(); fo(i,2,n) &#123; int x; ReadInt(x); e[x].push_back(i); &#125; Pre(); dfs_size(1,0); ans=0; dfs_ans(1,0); printf(&quot;%lld\\n&quot;,ans); &#125;&#125;","categories":[{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[{"name":"算法_计数","slug":"算法-计数","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E8%AE%A1%E6%95%B0/"}]},{"title":"RSA 破解同一模数的其他私钥","slug":"RSA_private_key","date":"2020-10-07T03:19:39.000Z","updated":"2024-04-24T03:59:22.790Z","comments":true,"path":"RSA_private_key/","link":"","permalink":"http://kqp.world/RSA_private_key/","excerpt":"&emsp;&emsp;把那些别人认为显然的而我死也想不出来的东西，都记下来 Task&emsp;&emsp;做作业的时候遇到了这么个题： Alice and Bob love each other, so they decide to use a single RSA modulus $N$ for their key pairs. Of course each of them does not know the private key of the other. Mathematically, Alice and Bob have their own key pairs $(e_A,d_A)$ and $(e_B,d_B)$ sharing the same $N$. Demonstrate how Bob can derive the private key of Alice. &emsp;&emsp;大意是说，Alice 和 Bob 用传统的 RSA 进行交流，但用的是同一个模数 $N$。问 Bob 如何利用这一点来破解 Alice 的私钥。","text":"&emsp;&emsp;把那些别人认为显然的而我死也想不出来的东西，都记下来 Task&emsp;&emsp;做作业的时候遇到了这么个题： Alice and Bob love each other, so they decide to use a single RSA modulus $N$ for their key pairs. Of course each of them does not know the private key of the other. Mathematically, Alice and Bob have their own key pairs $(e_A,d_A)$ and $(e_B,d_B)$ sharing the same $N$. Demonstrate how Bob can derive the private key of Alice. &emsp;&emsp;大意是说，Alice 和 Bob 用传统的 RSA 进行交流，但用的是同一个模数 $N$。问 Bob 如何利用这一点来破解 Alice 的私钥。 \\\\ \\\\ \\\\Solution1&emsp;&emsp;从实际的角度来看：&emsp;&emsp;既然 Bob 拥有 $N$，那他肯定也拥有 $N$ 的构造方法，也就是他知道 $\\varphi(N)$（例如 $N=pq$，其中 $p,q$ 都是质数，那么 $\\varphi(N)=(p-1)(q-1)$）。而对于 Alice 有 $e_Ad_A \\equiv 1 \\pmod{\\varphi(N)}$，那么直接 exgcd 解逆元就完事了。 &emsp;&emsp;（就这？就这？上 google 查了下，还真就这。。。 Solution 2&emsp;&emsp;但如果就这么简单地过掉这个题，也太无聊了。。。 &emsp;&emsp;事实上 Solution 1 是有一个很强的前提条件，就是知道 $\\varphi(N)$，于是就没什么可做的了。&emsp;&emsp;但如果去掉这个条件，那就变成一个有趣的数论题了。 &emsp;&emsp;现在的问题是：已知 Alice 和 Bob 使用了同样的模数 $N$，Bob 拥有 $e_A,e_B,d_B$，求 $d_A$。（这个模数、公钥私钥可以认为是第三方机构提供的，或是地上捡来的，反正你无法知道 $N$ 的构成信息。） \\\\ \\\\&emsp;&emsp;思路就是：既然无法在模 $\\varphi(N)$ 下求逆元，那就想办法在 $\\varphi(N)$ 的倍数下求逆元。因为有一个结论： Lemma1：若 $e_Ad_A \\equiv 1 \\pmod{km}$，则 $e_Ad_A \\equiv 1 \\pmod m$ 。 &emsp;&emsp;即若两个数在模 $km$ 下互为逆元，则在模 $m$ 下也为逆元。证明显然，把同余式写成等式就出来了。&emsp;&emsp;因此我们只要找出 $\\varphi(N)$ 的一个倍数 $k\\varphi(N)$，使得 $e_A$ 在模 $k\\varphi(N)$ 下有逆元，那么这个逆元就是要求的 $d_A$。 &emsp;&emsp;而我们知道，$e_Bd_B-1$ 是一个天然的 $\\varphi(N)$ 的倍数，因为 $e_Bd_B \\equiv 1 \\pmod{\\varphi(N)}$，这是 RSA 保证的。我们从这里开始。&emsp;&emsp;$e_A$ 无法直接在模 $e_Bd_B-1$ 下求逆元，因为它俩可能不互质，那就约去 $d_1=\\gcd(e_A,e_Bd_B-1)$，变成 $e_A$ 在模 $\\frac{e_Bd_B-1}{d_1}$ 下求逆元。&emsp;&emsp;这时候仍然可能没逆元，因为 $e_A$ 跟 $\\frac{e_Bd_B-1}{d_1}$ 可能仍然不互质。那就继续求 $d_2=\\gcd(e_A,\\frac{e_Bd_B-1}{d_1})$，变成 $e_A$ 在模 $\\frac{e_Bd_B-1}{d_1d_2}$ 下求逆元。&emsp;&emsp;……&emsp;&emsp;重复这个过程，直至 $e_A$ 跟这个模数互质。&emsp;&emsp;这是一定可以达到的。因为，初始的时候，假设 $e_Bd_B-1=k\\varphi(N)$，而由于 $\\gcd(e_A,\\varphi(N))=1$（RSA 的性质），因此 $d_1=\\gcd(e_A,e_Bd_B-1)=\\gcd(e_A,k)$，因此模数除以 $d_1$ 也就相当于模数变成 $\\frac{k}{d_1}\\varphi(N)$。以后的步骤同理，模数一直都会是 $\\varphi(N)$ 的倍数。如果除到模数变成 $\\varphi(N)$ 了，那也不会继续进行下去了，因为 $\\gcd(e_A,\\varphi(N))=1$。 &emsp;&emsp;假设最终得到的模数为 $m$，那么就用 exgcd 解 $e_Ad_A \\equiv 1 \\pmod{m}$，按照 Lemma 1 以及上面说的“$m$ 一定是 $\\varphi(N)$ 的倍数”，解出来的 $d_A$ 就是 Alice 的私钥了。 结论&emsp;&emsp;也就是说，在传统的 RSA 中，如果你发现别人跟你是同一个模数，那无论你知不知道这个模数的具体信息，你都可以直接解出别人的私钥了。","categories":[{"name":"随手academy","slug":"随手academy","permalink":"http://kqp.world/categories/%E9%9A%8F%E6%89%8Bacademy/"}],"tags":[]},{"title":"【FZU2020 J】集合并 题解","slug":"【FZU2020 J】集合并 题解","date":"2020-08-25T09:20:44.000Z","updated":"2024-04-24T03:59:22.841Z","comments":true,"path":"【FZU2020 J】集合并 题解/","link":"","permalink":"http://kqp.world/%E3%80%90FZU2020%20J%E3%80%91%E9%9B%86%E5%90%88%E5%B9%B6%20%E9%A2%98%E8%A7%A3/","excerpt":"题目大意&emsp;&emsp;对于集合 $a$，定义集合 $S(a)$ 表示集合 $a$ 生成的集合，生成方式为通过以下步骤任意多次： 初始，$S(a)=a$； 若存在 $x,y \\in S(a)$，但是 $x\\oplus y \\not \\in S(a)$，将其插入到 $S(a)$ 中。 &emsp;&emsp;现在给定集合 $a,b$，你需要维护一个数据结构，支持以下操作，共 $m$ 次： $1\\ x$，表示插入 $x$ 到集合 $a$ 中，保证插入之前 $x \\not\\in a$ $2\\ x$，表示插入 $x$ 到集合 $b$ 中，保证插入之前 $x \\not\\in b$ $3\\ x$，表示从集合 $a$ 中删除元素 $x$，保证删除之前 $x \\in a$ $4\\ x$，表示从集合 $b$ 中删除元素 $x$，保证删除之前 $x \\in b$ $5$，表示询问：输出 $|S(a) \\cup S(b)| \\bmod 998244353$​，即集合并的元素个数 &emsp;&emsp;&emsp;&emsp;$|a|,|b| \\le 10^5,\\ \\ m \\leq 2\\times 10^5$，所有的集合元素 $\\in [0,2^{63})$&emsp;&emsp;多测，时限比较迷。。反正 $O(n \\log^2 x)$ 跑不过","text":"题目大意&emsp;&emsp;对于集合 $a$，定义集合 $S(a)$ 表示集合 $a$ 生成的集合，生成方式为通过以下步骤任意多次： 初始，$S(a)=a$； 若存在 $x,y \\in S(a)$，但是 $x\\oplus y \\not \\in S(a)$，将其插入到 $S(a)$ 中。 &emsp;&emsp;现在给定集合 $a,b$，你需要维护一个数据结构，支持以下操作，共 $m$ 次： $1\\ x$，表示插入 $x$ 到集合 $a$ 中，保证插入之前 $x \\not\\in a$ $2\\ x$，表示插入 $x$ 到集合 $b$ 中，保证插入之前 $x \\not\\in b$ $3\\ x$，表示从集合 $a$ 中删除元素 $x$，保证删除之前 $x \\in a$ $4\\ x$，表示从集合 $b$ 中删除元素 $x$，保证删除之前 $x \\in b$ $5$，表示询问：输出 $|S(a) \\cup S(b)| \\bmod 998244353$​，即集合并的元素个数 &emsp;&emsp;&emsp;&emsp;$|a|,|b| \\le 10^5,\\ \\ m \\leq 2\\times 10^5$，所有的集合元素 $\\in [0,2^{63})$&emsp;&emsp;多测，时限比较迷。。反正 $O(n \\log^2 x)$ 跑不过 \\\\ \\\\ \\\\题解&emsp;&emsp;首先，这个 $S(a)$、$S(b)$ 肯定是考虑维护其线性基了。&emsp;&emsp;这里要用到带删除的线性基，删除有在线和离线两种方式，在线是真正地实现删除操作，看这里学一学；离线是计算出每个元素的过期时间，然后线性基插入操作的时候用更新式的插入法，保持基元都是最新的，参考这题。 &emsp;&emsp;然后看怎么计算答案。容斥一下有 $ans=|S(a)|+|S(b)|-|S(a) \\cap S(b)|$，那怎么算 $|S(a) \\cap S(b)|$ 呢？&emsp;&emsp;可以想到两种方法，一是直接求交，拿 $S(a)$ 的每个基元放到 $S(b)$ 里去看看能不能被表示出来，能就说明它是 $S(a)$ 和 $S(b)$ 交空间的基。（qaq为啥我觉得一点都不显然啊） 但这样是 $O(m \\log^2 x)$ 的，被卡掉了。&emsp;&emsp;第二种方法是再容斥一下，$S(a) \\cap S(b)$ 的基元个数 = $S(a)$ 基元个数 + $S(b)$ 基元个数 - $S(a \\cup b)$ 基元个数。（qaq这个也很不显然啊为啥你们就觉得显然了啊） 于是这样就只需要维护三个线性基：$S(a)$、$S(b)$、$S(a) \\cup S(b)=S(a\\cup b)$，就变成 $O(m \\log x)$ 的了。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;map&gt;#include&lt;iostream&gt;#define fo(i,a,b) for(int i=a;i&lt;=b;i++)#define fd(i,a,b) for(int i=a;i&gt;=b;i--)using namespace std;typedef long long LL;typedef unsigned long long ULL;typedef pair&lt;ULL,int&gt; pr;const int maxop=5e5+5, MX=62;const int inf=1e9;const LL mo=998244353;struct OP&#123; ULL x; bool ab,ty; int endt,t;&#125;;int n,m,q,op0;OP op[maxop];map&lt;ULL,int&gt; Sa,Sb;pr Ba[MX+2],Bb[MX+2],Bab[MX+2];void add(pr *B,pr x)&#123; fd(i,MX,0) if ((x.first&gt;&gt;i)&amp;1) &#123; if (B[i].first) &#123; if (B[i].second&lt;x.second) swap(B[i],x); x.first^=B[i].first; if (!x.first) break; &#125; else &#123; B[i]=x; break; &#125; &#125;&#125;int qry(pr *B,int endt)&#123; int cnt=0; fo(i,0,MX) cnt+=(B[i].first&gt;0 &amp;&amp; B[i].second&gt;endt); return cnt;&#125;LL er[MX+5];int main()&#123; er[0]=1; fo(i,1,MX+2) er[i]=(er[i-1]&lt;&lt;1)%mo; while (scanf(&quot;%d %d&quot;,&amp;n,&amp;m)!=EOF) &#123; Sa.clear(); Sb.clear(); op0=0; fo(i,1,n) &#123; ULL x; scanf(&quot;%llu&quot;,&amp;x); op[++op0]=(OP)&#123;x,0,0,inf,i&#125;; Sa[x]=op0; &#125; fo(i,1,m) &#123; ULL x; scanf(&quot;%llu&quot;,&amp;x); op[++op0]=(OP)&#123;x,1,0,inf,n+i&#125;; Sb[x]=op0; &#125; scanf(&quot;%d&quot;,&amp;q); fo(i,1,q) &#123; int ty; ULL x; scanf(&quot;%d&quot;,&amp;ty); if (ty&lt;=4) scanf(&quot;%llu&quot;,&amp;x); if (ty==1) &#123; op[++op0]=(OP)&#123;x,0,0,inf,n+m+i&#125;; Sa[x]=op0; &#125; else if (ty==2) &#123; op[++op0]=(OP)&#123;x,1,0,inf,n+m+i&#125;; Sb[x]=op0; &#125; else if (ty==3) &#123; op[Sa[x]].endt=n+m+i; &#125; else if (ty==4) &#123; op[Sb[x]].endt=n+m+i; &#125; else &#123; op[++op0]=(OP)&#123;0,0,1,0,n+m+i&#125;; &#125; &#125; fo(i,0,MX) Ba[i]=Bb[i]=Bab[i]=pr(0,0); fo(i,1,op0) if (!op[i].ty) &#123; if (op[i].ab==0) add(Ba,make_pair(op[i].x,op[i].endt)); else add(Bb,make_pair(op[i].x,op[i].endt)); add(Bab,make_pair(op[i].x,op[i].endt)); &#125; else &#123; int x=qry(Ba,op[i].t), y=qry(Bb,op[i].t), z=qry(Bab,op[i].t); LL ans=((er[x]+er[y]-er[x+y-z])%mo+mo)%mo; printf(&quot;%lld\\n&quot;,ans); &#125; &#125;&#125;","categories":[{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[{"name":"算法_位运算","slug":"算法-位运算","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/"}]},{"title":"【2020牛客多校第四场 J】Jumping on the Graph 题解","slug":"【2020牛客多校第四场 J】Jumping on the Graph 题解","date":"2020-08-18T13:05:09.000Z","updated":"2024-04-24T03:59:22.816Z","comments":true,"path":"【2020牛客多校第四场 J】Jumping on the Graph 题解/","link":"","permalink":"http://kqp.world/%E3%80%902020%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A1%E7%AC%AC%E5%9B%9B%E5%9C%BA%20J%E3%80%91Jumping%20on%20the%20Graph%20%E9%A2%98%E8%A7%A3/","excerpt":"题目大意&emsp;&emsp;给定一幅 $n$ 个点 $m$ 条边的无向连通图，边有边权，定义 $D(i,j)$ 表示从 $i$ 到 $j$ 的所有路径中，次大边权最小是多少（如果路径只有一条边那么次大边权为 $0$）。&emsp;&emsp;求 $\\sum_{i=1}^n \\sum_{j=i+1}^n D(i,j)$。 &emsp;&emsp;$n \\leq 10^5,\\ \\ m \\leq 150000$，边权互不相同且 $\\le 10^9$&emsp;&emsp;1s","text":"题目大意&emsp;&emsp;给定一幅 $n$ 个点 $m$ 条边的无向连通图，边有边权，定义 $D(i,j)$ 表示从 $i$ 到 $j$ 的所有路径中，次大边权最小是多少（如果路径只有一条边那么次大边权为 $0$）。&emsp;&emsp;求 $\\sum_{i=1}^n \\sum_{j=i+1}^n D(i,j)$。 &emsp;&emsp;$n \\leq 10^5,\\ \\ m \\leq 150000$，边权互不相同且 $\\le 10^9$&emsp;&emsp;1s \\\\ \\\\ \\\\题解&emsp;&emsp;（第一反应：这不是 JBGG 出的 Pre-Finals ？&emsp;&emsp;（再看一眼：哦每对点都要求一次答案啊那没事了 &emsp;&emsp;考虑每条边的贡献。&emsp;&emsp;假设当前边权为 $w$，由于边权互不相同，可以把小于该边权的边视为 $0$ 边，大于该边权的边视为 $1$ 边。那么 $w$ 边有贡献的路径，就是恰好经过一条 $1$ 边和 $w$ 边的路径。&emsp;&emsp;更具体地说，$0$ 边会形成很多连通块，当前的 $w$ 边如果连在同一个 $0$ 连通块上，显然它是没贡献的（因为任何路径如果有 $w$ 这条边，都可以改用若干 $0$ 边来代替）；否则，设该边连接了 $x,y$ 两个连通块，$x$ 连通块通过 $1$ 边相邻的连通块集合为 $X$，$y$ 连通块通过 $1$ 边相邻的连通块集合为 $Y$，那么 $w$ 边贡献的点对数量为 $size_x \\cdot size_{Y\\backslash X}+size_y \\cdot size_{X\\backslash Y}$。（其中 $X\\backslash Y$ 表示 $\\{a | a\\in X,a\\not\\in Y\\}$） &emsp;&emsp;于是大的框架就是 Kruskal 那样，把边权从小到大做，用并查集维护每个连通块的大小、相邻连通块的大小之和。（相邻就是仅通过一条未加入的边所能到达的连通块） &emsp;&emsp;相邻连通块的大小之和怎么维护呢？首先可以想到，每个连通块把它的邻居全部记下来，做成一个邻居表（顺便维护一下 $size$ 的和）。合并两个连通块的时候，启发式合并邻居表，并通过邻居表去修改邻居的“相邻连通块大小之和”。&emsp;&emsp;但这里有一个问题，根据启发式合并的规则，如果要把 $x$ 连通块合并到 $y$ 连通块上，那么我只能遍历 $x$ 的邻居表，而不能遍历 $y$ 的邻居表，这样就无法完成修改操作了。&emsp;&emsp;所以为了能够遍历 $y$ 的邻居表，采用另一种方式，根号平衡。&emsp;&emsp;所有邻居表的总大小不超过 $2m$，把邻居表大小 $\\le \\sqrt{2m}$ 的叫做“小连通块”，邻居表大小 $&gt;\\sqrt{2m}$ 的叫做“大连通块”，显然大连通块的数量不超过 $\\sqrt{2m}$ 。把每个连通块的邻居表也拆成“小邻居表”和“大邻居表”，大邻居表不直接维护 $size$ 之和，而是要用到的时候一一查询。&emsp;&emsp;具体来说，合并两个连通块的时候，设 $x$ 合并到 $y$ 上，那么首先把 $x$ 的邻居全部遍历一遍，更新邻居的信息（邻居的邻居表里删除 $x$ 加入 $y$、更新“小邻居 $size$ 之和”）（根据启发式合并，这是 $O(m \\log m)$ 的）；然后，如果 $y$ 是小连通块，那么遍历 $y$ 的小邻居更新 $size$ 之和（$O(\\sqrt m)$），否则不管；最后，合并 $x$ 与 $y$ 的邻居表（根据启发式合并，这是 $O(m \\log m)$ 的）。&emsp;&emsp;期间如果 $y$ 从小连通块变成了大连通块，那么会破例遍历一遍 $y$ 的所有邻居，虽然违反启发式合并，但只会发生最多 $\\sqrt{2m}$ 次，不影响复杂度。 &emsp;&emsp;因此总的复杂度是 $O(m \\log m+n \\sqrt m)$。（Kruskal 最多只有 $n-1$ 条有效边）&emsp;&emsp;如果邻居表用了 set，那就再多一个 $\\log$，但是也能过。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include&lt;bits/stdc++.h&gt;#define fo(i,a,b) for(int i=a;i&lt;=b;i++)using namespace std;typedef long long LL;typedef pair&lt;int,bool&gt; pr;const int maxn=1e5+5, maxm=150005;struct EST&#123; int x,y,w;&#125;;bool cmpE(const EST &amp;a,const EST &amp;b) &#123;return a.w&lt;b.w;&#125;int n,m,sqrtm;EST e[maxm];unordered_map&lt;int,bool&gt; M[maxn];int ga[maxn],size[maxn],nbrsize[maxn];unordered_map&lt;int,bool&gt; nbr[maxn],bignbr[maxn];bool issmall[maxn];int get(int x) &#123;return ga[x]==x ?x :ga[x]=get(ga[x]) ;&#125;int main()&#123; scanf(&quot;%d %d&quot;,&amp;n,&amp;m); sqrtm=sqrt(m&lt;&lt;1);//, sqrtm=max(sqrtm,10); fo(i,1,m) &#123; scanf(&quot;%d %d %d&quot;,&amp;e[i].x,&amp;e[i].y,&amp;e[i].w); if (e[i].x==e[i].y) continue; M[e[i].x][e[i].y]=1; M[e[i].y][e[i].x]=1; &#125; fo(i,1,n) issmall[i]=(M[i].size()&lt;=sqrtm); fo(i,1,n) for(pr p:M[i]) if (issmall[p.first]) nbr[i][p.first]=1, nbrsize[i]++; else bignbr[i][p.first]=1; fo(i,1,n) ga[i]=i, size[i]=1; sort(e+1,e+1+m,cmpE); LL ans=0; fo(i,1,m) if (get(e[i].x)!=get(e[i].y)) &#123; int x=get(e[i].x), y=get(e[i].y); if (nbr[x].size()&gt;nbr[y].size()) swap(x,y); if (issmall[x]) nbr[y].erase(x), nbrsize[y]-=size[x]; else bignbr[y].erase(x); if (issmall[y]) nbr[x].erase(y), nbrsize[x]-=size[y]; else bignbr[x].erase(y); #define go p.first int comsize=0, xsize=nbrsize[x], ysize=nbrsize[y]; for(pr p:nbr[x]) if (nbr[y].count(go)) comsize+=size[go]; for(pr p:bignbr[x]) if (!bignbr[y].count(go)) xsize+=size[go]; for(pr p:bignbr[y]) if (!bignbr[x].count(go)) ysize+=size[go]; ans+=((LL)size[x]*(ysize-comsize)+(LL)size[y]*(xsize-comsize))*e[i].w; ga[x]=y; if (issmall[x]) &#123; for(pr p:nbr[x]) nbr[go].erase(x), nbrsize[go]-=size[x]; for(pr p:bignbr[x]) nbr[go].erase(x), nbrsize[go]-=size[x]; &#125; else &#123; for(pr p:nbr[x]) bignbr[go].erase(x); for(pr p:bignbr[x]) bignbr[go].erase(x); &#125; if (issmall[y] &amp;&amp; nbr[y].size()&gt;sqrtm) &#123; for(pr p:nbr[y]) nbr[go].erase(y), nbrsize[go]-=size[y]; for(pr p:bignbr[y]) nbr[go].erase(y), nbrsize[go]-=size[y]; for(pr p:nbr[y]) bignbr[go][y]=1; for(pr p:bignbr[y]) bignbr[go][y]=1; for(pr p:nbr[x]) bignbr[go][y]=1; for(pr p:bignbr[x]) bignbr[go][y]=1; issmall[y]=0; &#125; else &#123; if (issmall[y]) &#123; for(pr p:nbr[y]) nbrsize[go]+=size[x]; for(pr p:bignbr[y]) nbrsize[go]+=size[x]; for(pr p:nbr[x]) if (!nbr[go].count(y)) nbr[go][y]=1, nbrsize[go]+=size[x]+size[y]; for(pr p:bignbr[x]) if (!nbr[go].count(y)) nbr[go][y]=1, nbrsize[go]+=size[x]+size[y]; &#125; else &#123; for(pr p:nbr[x]) bignbr[go][y]=1; for(pr p:bignbr[x]) bignbr[go][y]=1; &#125; &#125; for(pr p:nbr[x]) if (!nbr[y].count(go)) nbr[y][go]=1, nbrsize[y]+=size[go]; nbr[x].clear(); for(pr p:bignbr[x]) bignbr[y][go]=1; bignbr[x].clear(); size[y]+=size[x]; &#125; printf(&quot;%lld\\n&quot;,ans);&#125;","categories":[{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[{"name":"算法_根号平衡","slug":"算法-根号平衡","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E6%A0%B9%E5%8F%B7%E5%B9%B3%E8%A1%A1/"},{"name":"算法_并查集","slug":"算法-并查集","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"name":"算法_启发式合并","slug":"算法-启发式合并","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E5%90%AF%E5%8F%91%E5%BC%8F%E5%90%88%E5%B9%B6/"}]},{"title":"【CF1394C】Boboniu and String 题解","slug":"【CF1394C】Boboniu and String 题解","date":"2020-08-14T03:53:20.000Z","updated":"2024-04-24T03:59:22.835Z","comments":true,"path":"【CF1394C】Boboniu and String 题解/","link":"","permalink":"http://kqp.world/%E3%80%90CF1394C%E3%80%91Boboniu%20and%20String%20%E9%A2%98%E8%A7%A3/","excerpt":"题目大意&emsp;&emsp;给定 $n$ 个由 N 和 B 组成的字符串 $s_1,\\cdots,s_n$，一个字符串可以做如下操作：增加或删去一个 B 我没有骂人、增加或删去一个 N、增加或删去一个 NB、增加或删去一个 BN。定义两个字符串的距离为：对一个字符串做最少多少次操作，可以使两个字符串的 N、B 数量分别相等。&emsp;&emsp;现给定 $s_1,\\cdots,s_n$，求一个也由 N、B 构成的字符串 $t$，使得 $t$ 到 $s_1,\\cdots,s_n$ 的最大距离最小。 &emsp;&emsp;$n \\leq 3\\times 10^5,\\ \\ \\sum|s_i| \\leq 5 \\times 10^5$&emsp;&emsp;3s","text":"题目大意&emsp;&emsp;给定 $n$ 个由 N 和 B 组成的字符串 $s_1,\\cdots,s_n$，一个字符串可以做如下操作：增加或删去一个 B 我没有骂人、增加或删去一个 N、增加或删去一个 NB、增加或删去一个 BN。定义两个字符串的距离为：对一个字符串做最少多少次操作，可以使两个字符串的 N、B 数量分别相等。&emsp;&emsp;现给定 $s_1,\\cdots,s_n$，求一个也由 N、B 构成的字符串 $t$，使得 $t$ 到 $s_1,\\cdots,s_n$ 的最大距离最小。 &emsp;&emsp;$n \\leq 3\\times 10^5,\\ \\ \\sum|s_i| \\leq 5 \\times 10^5$&emsp;&emsp;3s \\\\ \\\\ \\\\题解&emsp;&emsp;我就一直在想，二分之后，怎么给这个奇怪的图形做扫描线求最大覆盖点呢？我就想啊想，想啊想…… &emsp;&emsp;首先一个字符串与其 N、B 的顺序无关，只与 N、B 的数量有关，所以可以表示为平面上一个点 $(x_i,y_i)$。&emsp;&emsp;求最大值最小考虑二分，这个也很平凡。&emsp;&emsp;然后两个点的距离的定义也很显然： dis((x,y),(x_i,y_i)) = \\begin{cases} \\max(|x-x_i|,|y-y_i|), & sgn(x-x_i)=sgn(y-y_i) \\\\ |x-x_i|+|y-y_i|, & sgn(x-x_i)\\not=sgn(y-y_i) \\end{cases}&emsp;&emsp;但二分之后每个点的形状却比较鬼畜&emsp;&emsp;这似乎不好做扫描线求最大覆盖点。。。 &emsp;&emsp;于是换一种方法。&emsp;&emsp;假设当前二分到 $mid$，如果存在答案点 $(x,y)$ 到其他所有点距离不超过 $mid$，那么等价于满足如下条件： \\begin{aligned} \\forall 1 \\le i \\le n,\\ \\ & x_i-mid \\le x \\le x_i+mid \\\\ &y_i-mid \\le y \\le y_i+mid \\\\ &|x-x_i+y_i-y|=|(x-y)-(x_i-y_i)| \\le mid \\end{aligned}&emsp;&emsp;其中前两个条件的作用很显然，否则无论 $sgn(x-x_i)$ 是否等于 $sgn(y-y_i)$，距离都会大于 $mid$。而第三个条件则用来限制 $sgn(x-x_i)\\not=sgn(y-y_i)$ 的情况。（如果 $sgn(x-x_i)=sgn(y-y_i)$，那么满足了前两个条件会自然满足第三个条件；如果 $sgn(x-x_i)\\not=sgn(y-y_i)$，那么 $|x-x_i+y_i-y|$ 就是两点的距离） &emsp;&emsp;于是这样就可以根据 $mid$ 来求出 $x,y,x-y$ 的合法区间，简单判断一下是否存在合法的 $x,y$ 即可。在二分时直接根据区间来判断，求答案时枚举一个 $x$。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;bits/stdc++.h&gt;#define fo(i,a,b) for(int i=a;i&lt;=b;i++)#define fd(i,a,b) for(int i=a;i&gt;=b;i--)using namespace std;typedef long long LL;typedef pair&lt;int,int&gt; pr;const int maxn=3e5+5, maxlen=5e5+5;const int inf=3e6+5;int n,x[maxn],y[maxn];char s[maxlen];int ansb,ansn;bool check(int mid,int ty)&#123; int xmin=0, xmax=inf, ymin=0, ymax=inf, dmin=-inf, dmax=inf; fo(i,1,n) &#123; xmin=max(xmin,x[i]-mid); xmax=min(xmax,x[i]+mid); ymin=max(ymin,y[i]-mid); ymax=min(ymax,y[i]+mid); dmin=max(dmin,x[i]-y[i]-mid); dmax=min(dmax,x[i]-y[i]+mid); &#125; if (xmin&gt;xmax || ymin&gt;ymax || dmin&gt;dmax) return 0; ymin=max(ymin,xmin-dmax); ymax=min(ymax,xmax-dmin); if (ymin&gt;ymax) return 0; if (ty) &#123; fo(x,xmin,xmax) &#123; int rymin=max(ymin,x-dmax), rymax=min(ymax,x-dmin); if (rymin&lt;=rymax &amp;&amp; (x&gt;0 || rymax&gt;0)) &#123; ansb=x, ansn=(x==0) ?rymax :rymin ; break; &#125; &#125; &#125; return 1;&#125;int main()&#123; scanf(&quot;%d&quot;,&amp;n); fo(i,1,n) &#123; scanf(&quot;%s&quot;,s+1); int len=strlen(s+1); fo(j,1,len) if (s[j]==&#x27;B&#x27;) x[i]++; else y[i]++; &#125; int l=0, r=2e6; while (l&lt;=r) &#123; int mid=(l+r)&gt;&gt;1; if (check(mid,0)) r=mid-1; else l=mid+1; &#125; printf(&quot;%d\\n&quot;,++r); check(r,1); fo(i,1,ansb) putchar(&#x27;B&#x27;); fo(i,1,ansn) putchar(&#x27;N&#x27;); puts(&quot;&quot;);&#125;","categories":[{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[{"name":"算法_神奇的脑洞","slug":"算法-神奇的脑洞","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E7%A5%9E%E5%A5%87%E7%9A%84%E8%84%91%E6%B4%9E/"}]},{"title":"【2020全国统一省选】组合数问题 题解","slug":"【2020全国统一省选】组合数问题 题解","date":"2020-08-12T02:53:48.000Z","updated":"2024-04-24T03:59:22.814Z","comments":true,"path":"【2020全国统一省选】组合数问题 题解/","link":"","permalink":"http://kqp.world/%E3%80%902020%E5%85%A8%E5%9B%BD%E7%BB%9F%E4%B8%80%E7%9C%81%E9%80%89%E3%80%91%E7%BB%84%E5%90%88%E6%95%B0%E9%97%AE%E9%A2%98%20%E9%A2%98%E8%A7%A3/","excerpt":"题目大意&emsp;&emsp;求 \\sum_{k=0}^n f(k) \\times x^k \\times \\binom{n}{k} \\pmod p&emsp;&emsp;其中 $n,x,p$ 为给定整数，$f(k)$ 为给定多项式 $f(k)=\\sum_{i=0}^m a_ik^i$ 。 &emsp;&emsp;$n,x,p,a_i \\le 10^9,\\ \\ m \\le \\min(n,1000)$&emsp;&emsp;1s","text":"题目大意&emsp;&emsp;求 \\sum_{k=0}^n f(k) \\times x^k \\times \\binom{n}{k} \\pmod p&emsp;&emsp;其中 $n,x,p$ 为给定整数，$f(k)$ 为给定多项式 $f(k)=\\sum_{i=0}^m a_ik^i$ 。 &emsp;&emsp;$n,x,p,a_i \\le 10^9,\\ \\ m \\le \\min(n,1000)$&emsp;&emsp;1s \\\\ \\\\ \\\\题解&emsp;&emsp;转了一圈，这题的推法似乎多种多样啊。。。（虽然本质相同&emsp;&emsp;就记录一个我觉得比较好的吧。 &emsp;&emsp;核心思路就是 $k^i\\binom{n}{k}$ 写成下降幂多项式，然后发现有奇效。 &emsp;&emsp;设 $f(k)=\\sum_{i=0}^m a_ik^i$ 转化成下降幂多项式为 f(k)=\\sum_{i=0}^m b_i k^{\\underline i} = \\sum_{i=0}^m b_i \\frac{k!}{(k-i)!}&emsp;&emsp;代入原式有 \\begin{aligned} \\sum_{k=0}^n f(k) \\times x^k \\times \\binom{n}{k} &= \\sum_{k=0}^n\\sum_{i=0}^m b_i \\frac{k!}{(k-i)!} \\times x^k \\times \\frac{n!}{k!(n-k)!} \\\\ &= \\sum_{k=0}^n\\sum_{i=0}^m b_i \\times x^k \\times \\frac{n!}{(n-k)!(k-i)!} \\\\ &= \\sum_{k=0}^n\\sum_{i=0}^m b_i \\frac{n!}{(n-i)!} \\times x^k \\times \\binom{n-i}{n-k} \\\\ &= \\sum_{i=0}^m b_i \\frac{n!}{(n-i)!} \\sum_{k=i}^n x^k \\binom{n-i}{n-k} \\\\ &= \\sum_{i=0}^m b_i n^{\\underline i} (x+1)^{n-i} \\end{aligned}&emsp;&emsp;这个东西 $O(m)$ 循环一遍就好了，$(x+1)^{n-i}$ 可以预处理也可以快速幂。 &emsp;&emsp;至于 $b_i$ 的求法，也就是多项式转下降幂多项式，根据 x^i = \\sum_{j=0}^i S(i,j) x^{\\underline j}&emsp;&emsp;（其中 $S(i,j)$ 表示第二类斯特林数）可得 \\begin{aligned} \\sum_{i=0}^m a_ix^i &= \\sum_{i=0}^m a_i \\sum_{j=0}^i S(i,j) x^{\\underline j} \\\\ &= \\sum_{j=0} x^{\\underline j} \\sum_{i=j}^m a_i S(i,j) \\end{aligned}&emsp;&emsp;因此预处理第二类斯特林数，然后 $b_j= \\sum_{i=j}^m a_iS(i,j)$ 即可。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;bits/stdc++.h&gt;#define fo(i,a,b) for(int i=a;i&lt;=b;i++)using namespace std;typedef long long LL;const int maxm=1005;LL n,x,mo,a[maxm];int m;LL S[maxm][maxm];void S_pre(int n)&#123; fo(i,0,m) &#123; fo(j,1,i-1) S[i][j]=(S[i-1][j-1]+j*S[i-1][j])%mo; S[i][i]=1; &#125;&#125;LL b[maxm];void FFP()&#123; fo(i,0,m) fo(j,i,m) (b[i]+=a[j]*S[j][i])%=mo;&#125;LL Pow(LL x,LL y)&#123; LL re=1; for(; y; y&gt;&gt;=1, x=x*x%mo) if (y&amp;1) re=re*x%mo; return re;&#125;int main()&#123; freopen(&quot;problem.in&quot;,&quot;r&quot;,stdin); freopen(&quot;problem.out&quot;,&quot;w&quot;,stdout); scanf(&quot;%lld %lld %lld %d&quot;,&amp;n,&amp;x,&amp;mo,&amp;m); fo(i,0,m) scanf(&quot;%lld&quot;,&amp;a[i]); S_pre(m); FFP(); LL ndown=1, xpow=1, ans=0; fo(i,0,m) &#123; (ans+=b[i]*xpow%mo*ndown%mo*Pow(x+1,n-i))%=mo; (xpow*=x)%=mo; (ndown*=n-i)%=mo; &#125; printf(&quot;%lld\\n&quot;,ans);&#125;","categories":[{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[{"name":"算法_多项式/生成函数","slug":"算法-多项式-生成函数","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E5%A4%9A%E9%A1%B9%E5%BC%8F-%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/"},{"name":"算法_数学","slug":"算法-数学","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E6%95%B0%E5%AD%A6/"}]},{"title":"【2020百度之星复赛 1005】Battle for Wosneth2 题解","slug":"【2020百度之星复赛 1005】Battle for Wosneth2 题解","date":"2020-08-10T03:07:34.000Z","updated":"2024-04-24T03:59:22.817Z","comments":true,"path":"【2020百度之星复赛 1005】Battle for Wosneth2 题解/","link":"","permalink":"http://kqp.world/%E3%80%902020%E7%99%BE%E5%BA%A6%E4%B9%8B%E6%98%9F%E5%A4%8D%E8%B5%9B%201005%E3%80%91Battle%20for%20Wosneth2%20%E9%A2%98%E8%A7%A3/","excerpt":"题目大意&emsp;&emsp;Alice 有 $n$ 血，Bob 有 $m$ 血。Alice 和 Bob 轮流攻击对方，Alice 先手，每次攻击如果命中则对方扣 $1$ 点血，否则无事发生。Alice 命中率为 $p$，Bob 命中率为 $q$。若有人血量 $\\le 0$ 则死亡，游戏结束。&emsp;&emsp;求到最后 Alice 的生命值大于 $0$ 的概率，对 $998244353$ 取模。 &emsp;&emsp;$n,m \\leq 10^5$&emsp;&emsp;多测，$T \\leq 10^4$，$\\sum(n+m) \\leq 5 \\times 10^6$&emsp;&emsp;1s","text":"题目大意&emsp;&emsp;Alice 有 $n$ 血，Bob 有 $m$ 血。Alice 和 Bob 轮流攻击对方，Alice 先手，每次攻击如果命中则对方扣 $1$ 点血，否则无事发生。Alice 命中率为 $p$，Bob 命中率为 $q$。若有人血量 $\\le 0$ 则死亡，游戏结束。&emsp;&emsp;求到最后 Alice 的生命值大于 $0$ 的概率，对 $998244353$ 取模。 &emsp;&emsp;$n,m \\leq 10^5$&emsp;&emsp;多测，$T \\leq 10^4$，$\\sum(n+m) \\leq 5 \\times 10^6$&emsp;&emsp;1s \\\\ \\\\ \\\\解法一&emsp;&emsp;正好前一天做了牛客多校九，H 题生成函数印象深刻，一看这题，好像差不多啊？？ &emsp;&emsp;首先 Alice 恰有 $m$ 次命中。如图，把这 $m$ 次命中看作是 $m$ 块挡板，最后一块挡板的右边不能放东西，而每块挡板的左边都可以插入若干 Alice 失败的攻击和 Bob 的攻击。&emsp;&emsp;在前 $m-1$ 次 Alice 命中的右边都先放一个 Bob 的攻击，那么图中的省略号部分，就可以视为若干组“Alice失败攻击+Bob攻击”。 &emsp;&emsp;如果把 Bob 的命中视为 $x$，那么 Bob 的一次攻击可以表示为 $(1-q+qx)$。那么一个省略号就相当于 1+(1-p)(1-q+qx)+(1-p)^2(1-q+qx)^2+\\cdots\\ \\ =\\frac{1}{1-(1-p)(1-q+qx)}&emsp;&emsp;然后固有的 Alice 的 $m$ 次命中和 Bob 的 $m-1$ 次攻击，多项式为 p^m(1-q+qx)^{m-1}&emsp;&emsp;把两个多项式乘起来（注意共有 $m$ 个省略号），得到 Ans=\\frac{p^m(1-q+qx)^{m-1}}{\\left(1-(1-p)(1-q+qx)\\right)^m}&emsp;&emsp;那么 $\\sum_{i=0}^{n-1}[x^i]Ans$ 就是最终的答案。 &emsp;&emsp;在正常情况下，这里套一个多项式幂、多项式求逆的板子，就 $O(n \\log n)$ 过去了。但这题卡 $\\log$，必须要线性。&emsp;&emsp;可以看到，分子分母都是形如 $(a+bx)^m$ 的二项式，那么分子可以二项式展开直接算，分母用泰勒展开： \\frac{1}{(a+bx)^m} = \\frac{1}{a^m} - \\frac{mb}{a^{m+1}}x + \\frac{m(m+1)b^2}{a^{m+2}\\cdot 2!}x^2 - \\frac{m(m+1)(m+2)b^3}{a^{m+3} \\cdot 3!}x^3\\cdots\\cdots&emsp;&emsp;这个也可以 $O(n)$ 算。&emsp;&emsp;算完之后，要算分子分母卷积的前缀和。这个直接 two pointers 就好了，也都是 $O(n)$ 的。&emsp;&emsp;于是连多项式板子都不用了，几十行完事。 解法二&emsp;&emsp;辛辛苦苦推了半天的生成函数，可能只是发现了归一化。。。&emsp;&emsp;计数姿势太差不配做题 &emsp;&emsp;设初始时人在 $(n,m)$ 这个格子。那么也是捆绑“Alice攻击+Bob攻击”为一组，对一组来说，如果两人都没命中，那么没有意义，直接忽略，因此只有三种转移：$\\frac{p(1-q)}{1-(1-p)(1-q)}$ 的概率转移到 $(n,m-1)$、$\\frac{(1-p)q}{1-(1-p)(1-q)}$ 的概率转移到 $(n-1,m)$、$\\frac{pq}{1-(1-p)(1-q)}$ 的概率转移到 $(n-1,m-1)$。&emsp;&emsp;显然我们的目标是要走到第一列（即形如 $(x,1)$ 的位置），然后 Alice 最后一击打死 Bob。（当然，在这一格也要考虑两人做无意义攻击的情况，因此概率是 $\\frac{p}{p+(1-p)q}$） &emsp;&emsp;枚举最后一种转移的次数，记为 $x$，那么第一种转移的次数就是 $m-1-x$，第二种转移的次数不超过 $n-1-x$。方案数就可以直接用挡板原理算出来，乘上概率累加起来就是答案。（第一种和第三种次数都确定了，可以直接挡板原理；而第一种的次数+第三种的次数是定值 $m-1$，所以第二种相对于它们来说也是个挡板原理，预处理求个前缀和即可。） 代码// 解法一 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include&lt;bits/stdc++.h&gt;#define fo(i,a,b) for(int i=a;i&lt;=b;i++)#define fd(i,a,b) for(int i=a;i&gt;=b;i--)using namespace std;typedef long long LL;const int maxm=1e5+5;const LL mo=998244353;LL Pow(LL x,LL y=mo-2)&#123; LL re=1; for(; y; y&gt;&gt;=1, x=x*x%mo) if (y&amp;1) re=re*x%mo; return re;&#125;int n,m;LL p,q,A[maxm],B[maxm];LL fac[maxm],inv[maxm];void C_pre(int n)&#123; fac[0]=1; fo(i,1,n) fac[i]=fac[i-1]*i%mo; inv[n]=Pow(fac[n],mo-2); fd(i,n-1,0) inv[i]=inv[i+1]*(i+1)%mo;&#125;LL C(int n,int m) &#123;return fac[n]*inv[m]%mo*inv[n-m]%mo;&#125;int T;LL qq[maxm],qqq[maxm];int main()&#123; C_pre(1e5); scanf(&quot;%d&quot;,&amp;T); while (T--) &#123; scanf(&quot;%d %d %lld %lld&quot;,&amp;n,&amp;m,&amp;p,&amp;q); p=p*Pow(100,mo-2)%mo, q=q*Pow(100,mo-2)%mo; qq[0]=qqq[0]=1; fo(i,1,m) &#123; qq[i]=qq[i-1]*q%mo; qqq[i]=qqq[i-1]*(1-q)%mo; &#125; memset(A,0,sizeof(LL)*n); int sz=min(n-1,m-1); fo(i,0,sz) A[i]=C(m-1,i)*qq[i]%mo*qqq[m-1-i]%mo; LL c=(1-(1-p)*(1-q))%mo, d=(p-1)*q%mo; LL invc=Pow(c,mo-2), fm=Pow(invc,m), fz=1; fo(i,0,n-1) &#123; B[i]=fz*fm%mo*inv[i]%mo; (fz*=-d*(m+i)%mo)%=mo; (fm*=invc)%=mo; &#125; fo(i,1,n-1) (A[i]+=A[i-1])%=mo; LL ans=0; fo(i,0,n-1) (ans+=B[i]*A[n-1-i])%=mo; (ans*=Pow(p,m))%=mo; printf(&quot;%lld\\n&quot;,(ans+mo)%mo); &#125;&#125;","categories":[{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[{"name":"算法_多项式/生成函数","slug":"算法-多项式-生成函数","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E5%A4%9A%E9%A1%B9%E5%BC%8F-%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/"},{"name":"算法_计数","slug":"算法-计数","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E8%AE%A1%E6%95%B0/"},{"name":"算法_概率与期望","slug":"算法-概率与期望","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E6%A6%82%E7%8E%87%E4%B8%8E%E6%9C%9F%E6%9C%9B/"}]},{"title":"【2020牛客多校第七场 E】NeoMole Synthesis 题解","slug":"【2020牛客多校第七场 E】NeoMole Synthesis 题解","date":"2020-08-07T07:06:38.000Z","updated":"2024-04-24T03:59:22.814Z","comments":true,"path":"【2020牛客多校第七场 E】NeoMole Synthesis 题解/","link":"","permalink":"http://kqp.world/%E3%80%902020%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A1%E7%AC%AC%E4%B8%83%E5%9C%BA%20E%E3%80%91NeoMole%20Synthesis%20%E9%A2%98%E8%A7%A3/","excerpt":"题目大意&emsp;&emsp;给定一棵 $n$ 个点的目标树，以及 $m$ 棵模板树，每棵模板树有一个单价 $c_i$，数量无限多。这里的树都是无根树。&emsp;&emsp;现在要用若干模板树拼成目标树（就是用模板去覆盖目标树，使得目标树的每个点恰好被覆盖一次），求最小代价。 &emsp;&emsp;$n \\leq 500,\\ m \\leq 200$，所有模板树的结点数总和 $N \\le 500$&emsp;&emsp;$c_i \\leq 10^6$&emsp;&emsp;1s","text":"题目大意&emsp;&emsp;给定一棵 $n$ 个点的目标树，以及 $m$ 棵模板树，每棵模板树有一个单价 $c_i$，数量无限多。这里的树都是无根树。&emsp;&emsp;现在要用若干模板树拼成目标树（就是用模板去覆盖目标树，使得目标树的每个点恰好被覆盖一次），求最小代价。 &emsp;&emsp;$n \\leq 500,\\ m \\leq 200$，所有模板树的结点数总和 $N \\le 500$&emsp;&emsp;$c_i \\leq 10^6$&emsp;&emsp;1s \\\\ \\\\ \\\\题解&emsp;&emsp;妙啊。。。 &emsp;&emsp;首先大的框架是个树形 dp。把目标树当有根树，设 $dp_{i,(j,pj)}$ 表示目标树的第 $i$ 个结点，匹配模板里的结点 $j$，$i$ 连向父亲的边匹配 $j$ 连向 $pj$ 的边，的最小代价；设 $g_i$ 表示目标树以 $i$ 为根的子树完全匹配的最小代价。&emsp;&emsp;$dp$ 数组的状态数是 $O(nN)$ 的。$g_i$ 也可以视为 $\\min_{j} dp_{i,(j,0)}$（$0$ 就表示 $j$ 没有父亲，是所在其模板树的根），所以以下就是求 $dp$ 数组。 &emsp;&emsp;而这个转移就是让 $i$ 的儿子去匹配 $j$ 的儿子。这是一个二分图最小权匹配：左边一排 $deg_j-1$ 个点表示模板树上 $j$ 的儿子（如果是在做 $dp_{i,(j,0)}$，那么 $j$ 没有父亲，左边就有 $deg_j$ 个点），右边一排 $deg_i-1$ 个点表示目标树上 $i$ 的儿子，左边 $x$ 连向右边 $y$ 的边权是 $dp_{y,(x,j)}-g_y$，最后答案加上 $\\sum g_y$。&emsp;&emsp;注意到只有 $j$ 的儿子数 $\\le i$ 的儿子数才有意义，因此这样一次 KM 的时间复杂度是 $O(deg_j^2 \\cdot deg_i)$，如果每一对 $(i,j,pj)$ 都做一次 KM 的话，时间复杂度是 \\sum_i \\sum_j deg_j \\cdot O(deg_j^2 \\cdot deg_i) = O(nN^3)&emsp;&emsp;T 掉了。 &emsp;&emsp;所以这里加一个改进，观察到，$dp_{i,(j,pj)}$ 的二分图匹配，实际上就是 $dp_{i,(j,0)}$ 的二分图匹配删去左边 $pj$ 这个点。既然如此，就没必要重新跑一边 KM，直接用最短路退流就好了。&emsp;&emsp;具体来说，首先做出 $dp_{i,(j,0)}$ 的 KM，答案为 $ans$，然后求出左边每个点走交错路到达右边结点的最短路（从左到右只能退流匹配边，从右到左只能走非匹配边），记为 $aug_{pj}$，那么 $dp_{i,(j,pj)}=ans+aug_{pj}$。这个最短路用 floyd 就好了。 &emsp;&emsp;来分析时间复杂度。KM 的部分现在是 \\sum_i \\sum_j O(deg_j^2 \\cdot deg_i) = O(nN^2)&emsp;&emsp;floyd 的部分需要注意姿势，如果直接对 $deg_i+deg_j$ 个点跑最短路，或者对右边的 $deg_i$ 个点跑最短路，时间都是不对的： \\begin{aligned} &\\sum_i \\sum_j (deg_j+deg_i)^3 = O(n^3N+nN^3) \\\\ &\\sum_i \\sum_j deg_i^3 = O(n^3N) \\end{aligned}&emsp;&emsp;要对左边的点跑 floyd，用到的性质是“左边的点数 $\\le$ 右边的点数”，因此时间复杂度是 \\sum_j deg_j^3 \\cdot \\frac{n}{deg_j} = O(nN^2)&emsp;&emsp;具体来说，对于左边的两点 $x,y$，设它们的 KM 匹配点分别为 $x’,y’$，二分图从 $i$ 到 $j$ 的边权为 $w_{i,j}$，那么在 floyd 的初始距离中，$x$ 到 $y$ 的距离为 $-w_{x,x’}+w_{y,x’}$。这样求出最短路以后，退流 $x$ 的答案为 $aug_x=\\min_{y} dis_{x,y}-w_{y,y’}$ 。 &emsp;&emsp;注意一个细节，如果 $j$ 的儿子数比 $i$ 多 1 个（即 $deg_j=deg_i-1+1=deg_i$），那么 $dp_{i,(j,0)}$ 的 KM 是不合法的，但 $dp_{i,(j,pj)}$ 的 KM 都是合法的。这里可以给右边加一个空点，跑 $dp_{i,(j,0)}$ 的 KM 但不要更新答案，然后退流的时候，强制 floyd 的终点是右边这个空点。 代码// 这里的 KM 跑的是二分图最大权匹配，所以边权取反，floyd 跑最长路 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149#include&lt;bits/stdc++.h&gt;#define fo(i,a,b) for(int i=a;i&lt;=b;i++)using namespace std;typedef long long LL;const int maxn=505;const LL inf=2139062143;int n,m,N,c[maxn];vector&lt;int&gt; e[maxn],em[maxn];map&lt;pair&lt;int,int&gt;,int&gt; M;LL lx[maxn],ly[maxn],slack[maxn],mp[maxn][maxn];int f[maxn],pre[maxn];bool vis[maxn];LL KM(int nl,int nr)&#123; fo(i,1,nl) &#123; lx[i]=-inf; fo(j,1,nr) lx[i]=max(lx[i],mp[i][j]); &#125; memset(ly,0,sizeof(LL)*(nr+1)); memset(f,0,sizeof(int)*(nr+1)); memset(pre,0,sizeof(int)*(nr+1)); fo(i,1,nl) &#123; memset(slack,127,sizeof(LL)*(nr+1)); memset(vis,0,sizeof(bool)*(nr+1)); f[0]=i; int py=0, nextpy; for(; f[py]; py=nextpy) &#123; int px=f[py]; LL d=inf&lt;&lt;3; vis[py]=1; fo(j,1,nr) if (!vis[j]) &#123; if (lx[px]+ly[j]-mp[px][j]&lt;slack[j]) slack[j]=lx[px]+ly[j]-mp[px][j], pre[j]=py; if (slack[j]&lt;d) d=slack[j], nextpy=j; &#125; fo(j,0,nr) if (vis[j]) lx[f[j]]-=d, ly[j]+=d; else slack[j]-=d; &#125; for(; py; py=pre[py]) f[py]=f[pre[py]]; &#125; LL re=0; fo(i,1,nl) re+=lx[i]; fo(i,1,nr) re+=ly[i]; return re;&#125;LL dis[maxn][maxn],aug[maxn];int ff[maxn];void floyd(int nl,int nr,bool ty)&#123; fo(y,1,nr) if (f[y]) ff[f[y]]=y; fo(i,1,nl) fo(j,1,nl) dis[i][j]=(i==j) ?0 :mp[j][ff[i]]-mp[i][ff[i]]; fo(k,1,nl) fo(i,1,nl) if (i!=k) fo(j,1,nl) if (j!=i &amp;&amp; j!=k) dis[i][j]=max(dis[i][j],dis[i][k]+dis[k][j]); if (ty) &#123; fo(x,1,nl) aug[x]=dis[x][f[nr]]; &#125; else &#123; fo(x,1,nl) &#123; aug[x]=-mp[x][ff[x]]; fo(y,1,nl) aug[x]=max(aug[x],dis[x][y]-mp[y][ff[y]]); &#125; &#125;&#125;LL dp[maxn][3*maxn],g[maxn];int s0,s[maxn];void dfs(int k,int last)&#123; for(int son:e[k]) if (son!=last) dfs(son,k); s0=0; LL gsum=0; for(int son:e[k]) if (son!=last) s[++s0]=son, gsum+=g[son]; g[k]=inf; for(int i=1, cnt=0, sz; i&lt;=N; i++, cnt+=sz) &#123; sz=em[i].size(); if (sz-1&gt;s0) &#123; fo(j,0,sz-1) dp[k][cnt+j]=inf; continue; &#125; fo(x,0,sz-1) &#123; int id=M[make_pair(em[i][x],i)]; fo(y,1,s0) mp[x+1][y]=g[s[y]]-dp[s[y]][id]; &#125; if (sz&gt;s0) &#123; s[++s0]=0; fo(x,1,sz) mp[x][s0]=0; &#125; LL ans=gsum-KM(sz,s0); if (s[s0] || !s0) g[k]=min(g[k],c[i]+ans); floyd(sz,s0,(s[s0]==0 &amp;&amp; s0&gt;0)); fo(x,0,sz-1) dp[k][cnt+x]=min(ans-aug[x+1],inf); s0-=(s0&gt;0 &amp;&amp; s[s0]==0); &#125;&#125;int main()&#123; scanf(&quot;%d&quot;,&amp;n); fo(i,2,n) &#123; int x,y; scanf(&quot;%d %d&quot;,&amp;x,&amp;y); e[x].push_back(y), e[y].push_back(x); &#125; scanf(&quot;%d&quot;,&amp;m); fo(i,1,m) &#123; int tn,tc; scanf(&quot;%d %d&quot;,&amp;tn,&amp;tc); fo(j,2,tn) &#123; int x,y; scanf(&quot;%d %d&quot;,&amp;x,&amp;y); em[N+x].push_back(N+y), em[N+y].push_back(N+x); &#125; fo(j,1,tn) c[N+j]=tc; N+=tn; &#125; int tot=0; fo(i,1,N) for(int go:em[i]) M[make_pair(i,go)]=tot++; dfs(1,0); if (g[1]&gt;=inf) puts(&quot;impossible&quot;); else printf(&quot;%lld\\n&quot;,g[1]);&#125;","categories":[{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[{"name":"算法_网络流/匹配","slug":"算法-网络流-匹配","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E7%BD%91%E7%BB%9C%E6%B5%81-%E5%8C%B9%E9%85%8D/"},{"name":"算法_DP","slug":"算法-DP","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-DP/"}]},{"title":"【2020牛客多校第八场 D】Disgusting Relationship 题解","slug":"【2020牛客多校第八场 D】Disgusting Relationship 题解","date":"2020-08-05T02:09:03.000Z","updated":"2024-04-24T03:59:22.815Z","comments":true,"path":"【2020牛客多校第八场 D】Disgusting Relationship 题解/","link":"","permalink":"http://kqp.world/%E3%80%902020%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A1%E7%AC%AC%E5%85%AB%E5%9C%BA%20D%E3%80%91Disgusting%20Relationship%20%E9%A2%98%E8%A7%A3/","excerpt":"题目大意&emsp;&emsp;一个置换可以看成是有 $a_1$ 个长度为 $1$ 的环 + $a_2$ 个长度为 $2$ 的环 + …… + $a_n$ 个长度为 $n$ 的环，满足 $\\sum_{i=1}^n i\\cdot a_i=n$ 。&emsp;&emsp;记 $f(a_1,a_2,\\cdots,a_n)$ 表示各种环的数量分别为 $a_1,\\cdots,a_n$、长度为 $n$ 的置换的数量，现给定 $n,p$（$p$ 是质数），问有多少种不同的数列 $a_1,\\cdots,a_n$，满足 $p \\not|\\ f(a_1,a_2,\\cdots,a_n)$ 。 &emsp;&emsp;$n \\leq 10^{18},\\ \\ 2 \\leq p \\leq 10^5$&emsp;&emsp;多测，$T \\leq 10^5$，2s","text":"题目大意&emsp;&emsp;一个置换可以看成是有 $a_1$ 个长度为 $1$ 的环 + $a_2$ 个长度为 $2$ 的环 + …… + $a_n$ 个长度为 $n$ 的环，满足 $\\sum_{i=1}^n i\\cdot a_i=n$ 。&emsp;&emsp;记 $f(a_1,a_2,\\cdots,a_n)$ 表示各种环的数量分别为 $a_1,\\cdots,a_n$、长度为 $n$ 的置换的数量，现给定 $n,p$（$p$ 是质数），问有多少种不同的数列 $a_1,\\cdots,a_n$，满足 $p \\not|\\ f(a_1,a_2,\\cdots,a_n)$ 。 &emsp;&emsp;$n \\leq 10^{18},\\ \\ 2 \\leq p \\leq 10^5$&emsp;&emsp;多测，$T \\leq 10^5$，2s \\\\ \\\\ \\\\题解&emsp;&emsp;明眼人一看就有 f(a_1,\\cdots,a_n)=\\frac{n!}{\\prod_{i=1}^n i^{a_i} \\cdot a_i!}&emsp;&emsp;所以 $p$ 不整除这个东西，意思是要让分母的 $p$ 因子数量 $\\ge$ 分子的 $p$ 因子数量。&emsp;&emsp;乍一看这个 $n$ 这么大，整数拆分、dp 之类的啥都做不了，吓死个人。 &emsp;&emsp;冷静分析.jpg&emsp;&emsp;首先，这整个分式最终必然得到一个整数（因为这是在计算方案数），这意味着分母的 $p$ 因子数量一定是 $\\leq$ 分子的 $p$ 因子数量的。而我们的目标又是“分母的 $p$ 因子数量 $\\ge$ 分子的 $p$ 因子数量”，因此可得：1、我们要让分母、分子的 $p$ 因子数量相等；2、这等价于让分母的 $p$ 因子数量最大化。 &emsp;&emsp;有了这个目标，就能隐约感觉到，$a$ 数列不会长得太奇怪，肯定有限制的。&emsp;&emsp;接下来就来排除掉一些情况。 会不会有环长 $r&gt;p$ 却又不是 $p$ 的倍数呢？&emsp;&emsp;注意到这时候 $r^{a_r}$ 是没有贡献的，这太浪费了，我们把这 $a_r$ 个长度为 $r$ 的环，每个抽 $p$ 出来，组成 $a_r$ 个长度为 $p$ 的环，发现贡献至少多了 $a_r$。说明这种情况下分母的 $p$ 因子数量没有最大化。 会不会有环长 $r=kp$（$k&gt;1$）呢？&emsp;&emsp;同理啊，全部换成环长为 $p$ 会使贡献增大：单个 $r$ 的贡献从 $1+(k的p因子数量)$ 变成 $k$，正常情况下后者都会大于前者；而 $a_r!$ 部分的贡献从 $a_r!$ 变成 $\\frac{(a_p+a_r)!}{a_p!}$，不会更劣。&emsp;&emsp;唯一使得单个 $r$ 贡献保持不变的是 $k=p=2$，但这会在 $a_r!$ 部分增大贡献。&emsp;&emsp;所以也不合法。 &emsp;&emsp;所以这就说明 $a_i$ 非零的只有 $i \\in [1,p]$ 了。 &emsp;&emsp;我们可以先想像一种初始情况：$a_1=n$，这显然是一个合法解。然后看看怎么能把 $a_1$ 里的东西拿到 $a_2,\\cdots,a_p$ 里去，而保持 $p$ 因子数量不变。 &emsp;&emsp;先考虑 $n \\bmod p=0$。&emsp;&emsp;当然可以想到 $a_1$ 举家迁移到 $a_p$，贡献从 $\\sum_{j=1}^\\infty \\lfloor \\frac{n}{p^j} \\rfloor$ 变成 $\\frac np + \\sum_{j=2}^\\infty \\lfloor \\frac{n}{p^j} \\rfloor$，没有变化。如果只是抽 $a_1$ 的一部分放到 $a_p$ 里去呢？由于在 $p$ 的幂的位置，$a_1!$ 的 $p$ 因子数量都会有一次大的提升，所以构成 $p$ 的幂的连续段不能拆开考虑，否则 $p$ 因子数量一定会减少。比如 $a_1=14, p=2$，那么相当于把 $a_1$ 分成长度为 $8,4,2$ 的三个段，每个段要么留在 $a_1$ 要么搬到 $a_p$&emsp;&emsp;更一般地说，设 $n$ 的 $p$ 进制表示为 $b_1b_2\\cdots b_m$，那么每个二进制位下的每个单位“1”可以选择留在 $a_1$ 或搬到 $a_p$，因此对答案的贡献为 $\\prod_{i=1}^{m-1}(b_i+1)$。（为啥是 $m-1$？最低位一定是 $0$，如果不是 $0$ 的话是下面的情况） &emsp;&emsp;再考虑 $n \\bmod p&gt;0$。&emsp;&emsp;显然这个多出来的部分放哪都无所谓，都不会产生任何 $p$ 因子，因此这里对答案的贡献是 $n \\mod p$ 的可重整数拆分。 &emsp;&emsp;综上，答案为 ans=part(n \\bmod p) \\cdot \\prod_{i=1}^{m-1}(b_i+1)&emsp;&emsp;其中 $b_1b_2\\cdots b_m$ 是 $n$ 的 $p$ 进制表示，$part$ 表示可重整数拆分方案数。后者五边形数 $O(n \\sqrt n)$ 或者 $O(n \\log n)$ 预处理一下就完事了。 代码123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;bits/stdc++.h&gt;#define fo(i,a,b) for(int i=a;i&lt;=b;i++)using namespace std;typedef long long LL;const int maxp=1e5+5;const LL mo=1e9+7;LL n;int p;int w[maxp],w0;LL f[maxp];void Pre_part(int n)&#123; for(int i=1; w[w0]&lt;n; i++) &#123; w[++w0]=i*(3*i-1)&gt;&gt;1; w[++w0]=i*(3*i+1)&gt;&gt;1; &#125; f[0]=1; fo(i,1,n) for(int j=1; w[j]&lt;=i; j++) (f[i]+=((((j-1)&gt;&gt;1)&amp;1) ?-1 :1)*f[i-w[j]])%=mo;&#125;int T;int main()&#123; Pre_part(1e5); scanf(&quot;%d&quot;,&amp;T); fo(ti,1,T) &#123; scanf(&quot;%lld %d&quot;,&amp;n,&amp;p); LL ans=f[n%p]; for(n/=p; n; n/=p) (ans*=n%p+1)%=mo; printf(&quot;Case #%d: %lld\\n&quot;,ti,(ans+mo)%mo); &#125;&#125;","categories":[{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[{"name":"算法_数论","slug":"算法-数论","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E6%95%B0%E8%AE%BA/"},{"name":"算法_计数","slug":"算法-计数","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E8%AE%A1%E6%95%B0/"}]},{"title":"【2020百度之星初赛一 1008】【hdu6750】Function 题解","slug":"【2020百度之星初赛一 1008】【hdu6750】Function 题解","date":"2020-08-01T15:31:19.000Z","updated":"2024-04-24T03:59:22.816Z","comments":true,"path":"【2020百度之星初赛一 1008】【hdu6750】Function 题解/","link":"","permalink":"http://kqp.world/%E3%80%902020%E7%99%BE%E5%BA%A6%E4%B9%8B%E6%98%9F%E5%88%9D%E8%B5%9B%E4%B8%80%201008%E3%80%91%E3%80%90hdu6750%E3%80%91Function%20%E9%A2%98%E8%A7%A3/","excerpt":"题目大意&emsp;&emsp;记 $f(n)$ 表示 $\\sum_{d|n,\\ \\gcd(n,\\frac nd)=1}d$，给定 $n$，求 $\\sum_{i=1}^n f(i) \\bmod 10^9+7$。 &emsp;&emsp;$n \\le 10^{12}$&emsp;&emsp;多测，10 组数据，20s，32768K 。","text":"题目大意&emsp;&emsp;记 $f(n)$ 表示 $\\sum_{d|n,\\ \\gcd(n,\\frac nd)=1}d$，给定 $n$，求 $\\sum_{i=1}^n f(i) \\bmod 10^9+7$。 &emsp;&emsp;$n \\le 10^{12}$&emsp;&emsp;多测，10 组数据，20s，32768K 。 \\\\ \\\\ \\\\首先&emsp;&emsp;明眼人一看就有 f(n) = \\prod_{i=1}^m(1+p_i^{c_i})，其中\\ n=p_1^{c_1}p_2^{c_2}\\cdots p_m^{c_m}&emsp;&emsp;这显然是个积性函数。 解法1&emsp;&emsp;一看，积性函数求和；&emsp;&emsp;再一看，$f(p)=1+p$，意味着 min25 第一步就是求个质数和+质数个数；&emsp;&emsp;再再一看，给了 20s。 &emsp;&emsp;行，min25，不跟你多 BB &emsp;&emsp;。。。&emsp;&emsp;。。。&emsp;&emsp;。。。&emsp;&emsp;（半天后）&emsp;&emsp;。。。 &emsp;&emsp;WOC，0202 年了居然还有内存 32MB 的题！！？？？ 解法2&emsp;&emsp;于是乎 min25 出于它不可压缩的至少 40MB 的内存，惨遭毒手。。。 &emsp;&emsp;所幸积性函数求和不止一种方法。这里用的是 powerful number，用这个到后面化简起来巨优秀。 &emsp;&emsp;先访问这里学一下 powerful number&emsp;&emsp;（第一次学就写详细点。。。）&emsp;&emsp;观察到 $f(p)=1+p$，能跟这个形式凑上的，马上想到 $\\sigma(n)=\\sum_{d|n}d$ 。&emsp;&emsp;于是构造 $h(n)=\\frac{f(n)}{\\sigma(n)}$（狄利克雷卷积的除法），这个 $h(n)$ 就会满足只在 powerful number 处有非 $0$ 值。推一下发现这个 $h(n)$ 长得很好看： h(p^c)=\\begin{cases} 1 &, c=0 \\\\ -p &, c=2 \\\\ 0 &, \\text{else} \\end{cases}&emsp;&emsp;进一步有 h(n)=\\begin{cases} \\mu(\\sqrt n) \\cdot \\sqrt n & , n\\ 是完全平方数 \\\\ 0 &, \\text{else} \\end{cases}&emsp;&emsp;设 $S_{\\sigma}(n) = \\sum_{i=1}^n \\sigma(i)$，于是有： \\begin{aligned} \\sum_{i=1}^n f(i) &= \\sum_{i=1}^n \\sum_{j=1}^{\\lfloor \\frac ni \\rfloor} h(i)\\sigma(j) \\\\ &= \\sum_{i=1}^n h(i) \\cdot S_{\\sigma}(\\lfloor \\frac ni \\rfloor) \\\\ &= \\sum_{i=1}^{\\lfloor \\sqrt n \\rfloor} \\mu(i) \\cdot i \\cdot S_{\\sigma}(\\lfloor \\frac{n}{i^2} \\rfloor) \\end{aligned}&emsp;&emsp;前面 $\\mu$ 线筛出来，后面 $S_{\\sigma}(\\lfloor \\frac{n}{i^2} \\rfloor)$ 每次分块求： S_{\\sigma}(m) = \\sum_{i=1}^m i \\lfloor \\frac mi \\rfloor&emsp;&emsp;总的时间复杂度为 \\sum_{i=1}^{\\sqrt n} \\sqrt{\\lfloor \\frac{n}{i^2} \\rfloor} = \\sqrt n \\sum_{i=1}^{\\sqrt n} \\frac 1i = O(\\sqrt n \\ln n)&emsp;&emsp;以优秀的空间+时间打爆一切。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;bits/stdc++.h&gt;#define fo(i,a,b) for(int i=a;i&lt;=b;i++)using namespace std;typedef long long LL;const int maxsqrtn=1e6+5, maxp0=80000, maxw0=2e6+5;const LL mo=1e9+7, inv2=5e8+4;LL n;int sqrtn;int p[maxp0],p0,mu[maxsqrtn];bool bz[maxsqrtn];void Prime(int n)&#123; mu[1]=1; fo(i,2,n) &#123; if (!bz[i]) p[++p0]=i, mu[i]=-1; fo(j,1,p0) &#123; if ((LL)i*p[j]&gt;n) break; bz[i*p[j]]=1; if (i%p[j]==0) break; else mu[i*p[j]]=-mu[i]; &#125; &#125;&#125;inline LL sum(LL x,LL y) &#123;return (x+y)%mo*((y-x+1)%mo)%mo*inv2%mo;&#125;LL S(LL n)&#123; LL re=0; for(LL i=1, j; i&lt;=n; i=j+1) &#123; LL x=n/i; j=n/x; (re+=sum(i,j)*x)%=mo; &#125; return re;&#125;int T;int main()&#123; Prime(1e6); scanf(&quot;%d&quot;,&amp;T); while (T--) &#123; scanf(&quot;%lld&quot;,&amp;n); sqrtn=sqrt(n); LL ans=0; fo(i,1,sqrtn) if (mu[i]!=0) (ans+=mu[i]*i*S(n/((LL)i*i)))%=mo; printf(&quot;%lld\\n&quot;,(ans+mo)%mo); &#125;&#125;","categories":[{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[{"name":"算法_数论","slug":"算法-数论","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E6%95%B0%E8%AE%BA/"}]},{"title":"【USST2020 I】Immortal Trees 题解","slug":"【USST2020 I】Immortal Trees 题解","date":"2020-06-06T12:08:08.000Z","updated":"2024-04-24T03:59:22.868Z","comments":true,"path":"【USST2020 I】Immortal Trees 题解/","link":"","permalink":"http://kqp.world/%E3%80%90USST2020%20I%E3%80%91Immortal%20Trees%20%E9%A2%98%E8%A7%A3/","excerpt":"题目大意&emsp;&emsp;给定一个 $n$，表示一棵有标号无根树有 $n$ 个结点。&emsp;&emsp;有如下限制： 给定 $m$ 个数对 $(x_i,y_i)$，表示树上一定要有 $(x_i,y_i)$ 这条边； 有 $k$ 个限制 $op_i\\ x_i\\ deg_i$，若 $op_i=0$ 表示 $x$ 的度数至少为 $deg_i$，若 $op_i=1$ 表示 $x$ 的度数至多为 $deg_i$。 &emsp;&emsp;求合法的树的数量。 &emsp;&emsp;$2 \\leq n \\leq 60,\\ 0 \\leq m \\leq n-1,\\ 0 \\leq k \\leq 60$&emsp;&emsp;1s","text":"题目大意&emsp;&emsp;给定一个 $n$，表示一棵有标号无根树有 $n$ 个结点。&emsp;&emsp;有如下限制： 给定 $m$ 个数对 $(x_i,y_i)$，表示树上一定要有 $(x_i,y_i)$ 这条边； 有 $k$ 个限制 $op_i\\ x_i\\ deg_i$，若 $op_i=0$ 表示 $x$ 的度数至少为 $deg_i$，若 $op_i=1$ 表示 $x$ 的度数至多为 $deg_i$。 &emsp;&emsp;求合法的树的数量。 &emsp;&emsp;$2 \\leq n \\leq 60,\\ 0 \\leq m \\leq n-1,\\ 0 \\leq k \\leq 60$&emsp;&emsp;1s \\\\ \\\\ \\\\题解&emsp;&emsp;有趣~ &emsp;&emsp;看到有标号无根树计数，甚至规定了某些点的度数，八九不离十是考虑 prufer 序。&emsp;&emsp;但是有些点已经被初始边连起来了，怎么办呢？ &emsp;&emsp;当然是把它们缩起来，一个连通块当作一个新点来考虑啊！ &emsp;&emsp;比如 $n=4$，有一条初始边 $(1,2)$，那么缩起来成为连通块 $a$，我们只需考虑 $a,3,4$ 的 prufer 序。然后，在不同的 prufer 序中，$a$ 连出去的边的数量是不一样的，这会造成不同的贡献。 &emsp;&emsp;因此需要这么 dp：设 $f_{i,j}$ 表示前 $i$ 个连通块共使用了 $j$ 个 prufer 序位置的方案数。转移就是枚举第 $i$ 个连通块用了多少个 prufer 序位置： f_{i,j}=\\sum_{k=0}^j \\binom{j}{k} \\cdot f_{i-1,j-k} \\cdot g_{i,k+1}&emsp;&emsp;其中 $g_{i,k}$ 表示第 $i$ 个连通块往外连 $k$ 条边的方案数。 &emsp;&emsp;所以现在就是要求 $g_{i,j}$。每个点先求出去掉初始边之后的合法度数区间 $[mindg_i,maxdg_i]$（即除初始边外还需要连这么多边），然后对于每个连通块单独考虑，依次考虑每个点，设 $h_{x,j}$ 表示该连通块前 $x$ 个点用了 $j$ 条边的方案数，那么 h_{x,j}=\\sum_{k=mindg_x}^{maxdg_x} h_{x-1,j-k} \\cdot \\binom{j}{k}&emsp;&emsp;然后就有 $g_{i,j}=h_{size_i,j}$，$size_i$ 表示该连通块的大小。 &emsp;&emsp;这样就是 $O(n^3)$ 的了。（官方题解不知道为什么写了 $O(n^4)$）要再提升的话，就分治 FFT？ 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include&lt;bits/stdc++.h&gt;#define fo(i,a,b) for(int i=a;i&lt;=b;i++)using namespace std;typedef long long LL;const int maxn=65;const LL mo=998244353;int n,m,k,dg[maxn],mindg[maxn],maxdg[maxn];LL f[maxn][maxn],g[maxn][maxn];LL C[maxn][maxn];void C_pre(int n)&#123; fo(i,0,n) &#123; C[i][0]=1; fo(j,1,i) C[i][j]=(C[i-1][j-1]+C[i-1][j])%mo; &#125;&#125;int ga[maxn];int get(int x) &#123;return ga[x]==x ?x :ga[x]=get(ga[x]);&#125;#define NO &#123;puts(&quot;0&quot;); return 0;&#125;map&lt;pair&lt;int,int&gt;,int&gt; M;vector&lt;int&gt; V[maxn];int cc;LL h[maxn][maxn];int main()&#123; C_pre(60); scanf(&quot;%d %d %d&quot;,&amp;n,&amp;m,&amp;k); fo(i,1,n) ga[i]=i, mindg[i]=1, maxdg[i]=n-1; fo(i,1,m) &#123; int x,y; scanf(&quot;%d %d&quot;,&amp;x,&amp;y); if (x&gt;y) swap(x,y); if (++M[make_pair(x,y)]&gt;1) continue; if (get(x)==get(y)) NO; ga[get(x)]=get(y); dg[x]++, dg[y]++; &#125; fo(i,1,k) &#123; int op,x,deg; scanf(&quot;%d %d %d&quot;,&amp;op,&amp;x,&amp;deg); if (op==1) maxdg[x]=min(maxdg[x],deg); else mindg[x]=max(mindg[x],deg); &#125; fo(i,1,n) &#123; mindg[i]=max(0,mindg[i]-dg[i]), maxdg[i]-=dg[i]; if (mindg[i]&gt;maxdg[i]) NO; &#125; fo(i,1,n) V[get(i)].push_back(i); fo(i,1,n) if (get(i)==i) &#123; ++cc; int sz=V[i].size(); memset(h,0,sizeof(h)); h[0][0]=1; fo(x,1,sz) &#123; int cur=V[i][x-1]; fo(curj,mindg[cur],maxdg[cur]) fo(j,curj,n-1) (h[x][j]+=h[x-1][j-curj]*C[j][curj])%=mo; &#125; fo(j,0,n-1) g[cc][j]=h[sz][j]; &#125; if (cc==1) &#123; fo(i,1,n) if (mindg[i]&gt;0) NO; puts(&quot;1&quot;); return 0; &#125; f[0][0]=1; fo(i,1,cc) fo(j,0,cc-2) fo(k,0,j) (f[i][j]+=f[i-1][j-k]*C[j][k]%mo*g[i][k+1])%=mo; printf(&quot;%lld\\n&quot;,f[cc][cc-2]);&#125;","categories":[{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[{"name":"算法_DP","slug":"算法-DP","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-DP/"}]},{"title":"【操统实验】原型操作系统进化（无限断更）","slug":"【操统实验】原型操作系统进化（无限断更）","date":"2020-05-05T09:43:09.000Z","updated":"2024-04-24T03:59:22.877Z","comments":true,"path":"【操统实验】原型操作系统进化（无限断更）/","link":"","permalink":"http://kqp.world/%E3%80%90%E6%93%8D%E7%BB%9F%E5%AE%9E%E9%AA%8C%E3%80%91%E5%8E%9F%E5%9E%8B%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%9B%E5%8C%96%EF%BC%88%E6%97%A0%E9%99%90%E6%96%AD%E6%9B%B4%EF%BC%89/","excerpt":"传说中的，鸭大计科鬼门关","text":"传说中的，鸭大计科鬼门关 &emsp;&emsp;这个东西大概是分成 14 个实验项目，可以从零开始写一个自己的操作系统。&emsp;&emsp;当然，是个古老的操作系统，实模式、使用 1.44MB 软驱、1 MB 内存，用虚拟机跑。开一个 82 年的操作系统压压惊.jpg &emsp;&emsp;然后如果每一个项目都完整记下来的话博客就太长了。正好本来就要写实验报告，实验报告是很完整的，那就把每次的实验报告和源码都 po 出来，把每一个实验报告连起来就是完整的教程+历程了。&emsp;&emsp;点我下载&emsp;&emsp;（似乎 git 打不开 pdf？那就放个百度网盘链接，提取码：0gl6 &emsp;&emsp;然后这里就只是简单写写每一个实验的重点和对实验报告的补充了。 &emsp;&emsp;以及参考资料真的很难找，百度找别人博客真的很难找到靠谱的。所以建议看我的以及我所引用的 &emsp;&emsp;推荐书：《x86汇编语言 从实模式到保护模式》《深入理解计算机系统》《一个64位操作系统的设计与实现》 实验一：裸机控制与扇区引导程序设计&emsp;&emsp;关键词：汇编 x86、软盘分扇区及其格式、引导程序、配置虚拟机 &emsp;&emsp;首先要懂什么是计算机启动，简单来说就是 1、通电；2、指令地址初始化给 BIOS 对硬件做检查；3、检查完之后找存储设备加载引导程序；4、引导程序引导系统启动。&emsp;&emsp;然后了解一下古老的 1.44MB 软盘是怎样的格式，一般来说是分 2880 个扇区，每个扇区 512 字节。扇区有格式的（参考 FAT12 文件系统），首扇区有 448 字节是放引导程序的。实验一的任务就是写这个。&emsp;&emsp;开机自检完后，BIOS 会把存储设备首扇区加载到内存 0x7c00 的位置，一般首扇区的第一句话是一个跳转指令，跳到引导程序的位置，然后就开始了。（不想搞这么复杂的话，也可以首扇区从第一句话开始就是引导程序，计算机都只是在执行指令而已） &emsp;&emsp;引导程序其实没什么，你就随便写点东西（比如往显存里（内存起始地址 0xB800:0x0000）写些字符），然后用 0 填够 512 字节，再把最后两个字节改成 0x55aa（这个是合法首扇区的标志），这就可以直接作为一个 512 字节的存储设备拿去开机了。&emsp;&emsp;这个搞通以后就是把这个“往显存里写东西”搞花哨些，纯粹是个程设练习。 &emsp;&emsp;我感觉最大的操作就是配置各种环境，包括虚拟机、十六进制编辑器、汇编器。&emsp;&emsp;要善用十六进制编辑器去看看 .img 文件里到底是些什么东西。 实验二：加载执行COM格式用户程序的监控程序&emsp;&emsp;关键词：单道批处理系统、监控程序、BIOS 中断、COM 格式 &emsp;&emsp;意思就是说把引导程序换成一个监控程序，它能执行用户程序，执行完后返回来，继续执行下一个用户程序。这是最原始的操作系统。&emsp;&emsp;（此处假设用户程序是能正常执行完毕的，不会死循环的）&emsp;&emsp;最主要思考的问题就是，监控程序如何去到用户程序，完了以后又怎么回来。（UPD：标准的实现在实验五完成了）&emsp;&emsp;最主要学的是 BIOS 中断服务，这个就是最底层的硬件调用了。 实验三：C与汇编开发独立批处理的内核&emsp;&emsp;关键词：C 与汇编混合编程、内核与引导程序分离 &emsp;&emsp;这次实验就是用 C 与汇编混合编程的方式重写上次的监控程序，使其能够更加方便地拓展功能。然后把这个东西与首扇区引导程序分离，成为独立内核（引导程序只有400多字节肯定是塞不下操作系统的）。&emsp;&emsp;重中之重就是学会用 C 和汇编混合编程。这里使用中间文件链接的方式，即两种语言各生成中间文件，然后链接起来。（C内嵌汇编也很资瓷啊）&emsp;&emsp;烦中之烦是配置环境和工具。不是随便找些 C 编译器、汇编器、链接器都能组合在一起用的，必须找到恰当的组合才能跑起来！！！（鸭大童鞋们做到这里应该能理解 lyb 为什么每节课都要强调这个问题了 qaq 有些痛要经历了才能理解别人的啰嗦）&emsp;&emsp;难点是 C 和汇编互相调用对方的变量、函数、过程，这里有很多格式要求、默认规则。 &emsp;&emsp;关于实模式和保护模式，一开始这套操作系统的定位是 16 位实模式的，然而 gcc 实际上并不能编译出 16 位程序，只能用 32 位的寄存器、指令、栈对齐，而使用实模式寻址方式，即“用 32 位模拟 16 位”。这其实是比较尴尬的搭配，但我不想搞那么多事情所以也就这样凑合了。 &emsp;&emsp;资料真的真的很难找，有条件还是把《x86汇编语言 从实模式到保护模式》《深入理解计算机系统》《程序员的自我修养：链接、装载与库》之类的大部头好好读一读吧，在百度上瞎找真的不靠谱。起码也要谷歌，或者读我的实验报告（x 实验四：中断处理与异步事件响应&emsp;&emsp;关键词：中断处理、中断向量 &emsp;&emsp;这次是彻底搞明白中断的原理，并且自己写一些中断处理程序。用系统时钟中断写一个“-\\\\ |/”循环输出的“无敌风火轮”，用键盘中断写一个在用户程序执行期间按键盘会显示“OUCH!OUCH!”的功能。&emsp;&emsp;这次简单很多了，读《x86》第九章读完就都会做了。 实验五：系统调用&emsp;&emsp;关键词：系统中断服务、系统调用，库 &emsp;&emsp;这次实验在技术上没有新东西，就是用中断处理来实现一组基本的系统调用（我其实只做了基础 IO），然后制作相应的库文件，这样用户就能基于这个操作系统来编程了。&emsp;&emsp;算是把操作系统的一些功能服务给标准化、完善化了。 &emsp;&emsp;一些规范：中断处理前后的现场保护及恢复、栈的管理，以及用户程序加载跳转及返回，现在终于正规了——用户程序 PSP 处埋一条 int 20h，初始化用户栈之后 push 0，jmp 到用户程序，用户程序结束后 ret 到开头 PSP，执行 int 20h 返回操作系统。 &emsp;&emsp;这次实现的 int 08h 的现场保护及恢复、CPU 上下文 struct 等东西，可以为接下来的多进程做铺垫了。 实验六：时间片轮转的二态进程模型&emsp;&emsp;关键词：多进程、二状态进程模型 &emsp;&emsp;终于多进程了！！这次实验是分水岭，在此之前叫做基础实验，在此之后叫做拓展实验（可以不按顺序做&emsp;&emsp;众所周知，单核的多进程其实就是轮流执行所有进程，使其看起来像是同时执行一样。用系统时钟中断来触发进程切换，因此叫做“时间片轮转”。而“二态”，就是指进程只有 running 和 ready 两种状态。&emsp;&emsp;其实就是在上一次的实验基础上，增加一些进程管理用的数据结构，增加进程调度过程，修改现场保护及恢复，以及其他相关改动。&emsp;&emsp;最后用之前实验的 4 个射字母的程序作为测试，如果屏幕的四个区域同时射字母，就表示成功了。 实验七：五状态进程模型及多线程&emsp;&emsp;咕 实验八：信号量机制与应用&emsp;&emsp;咕 实验九：FAT12文件系统引导和加载&emsp;&emsp;关键词：FAT12 文件系统、FAT 表、根目录项 &emsp;&emsp;一改以往无格式存储的混沌状态，向专业的文件系统迈进！&emsp;&emsp;就是现在要对软盘的存储进行规范化了。有很多种规范，比如现在一般用 FAT32，我们这个古董操作系统就用 FAT12。&emsp;&emsp;它的基本思想就是，一个文件如果分为多个簇（一簇=一个扇区）储存，那么就用一个链表来把这些簇号记下来。FAT 表就是用来干这个事的，FAT 表每一项对应一个簇，其值为“下一簇是谁”，这样就形成了链表。一个文件的首簇号连同该文件其他信息，一起记录到根目录表中，一个文件信息 32 字节。&emsp;&emsp;FAT 表的一个表项是 1.5 字节，因此“查询某一指定表项”就是本次实验的难点，需要精细的位运算。&emsp;&emsp;那只有根目录表，怎么实现多级目录呢？——把子目录做成一个文件，这个文件的内容就是子目录里的文件信息，同样是 32 字节一个！！ &emsp;&emsp;据说实现了文件系统之后，用 WinImage 之类的东西可以实现“把一个文件直接拖到一个映像盘里”。这是何等的方便啊！可是学期结束了已经没有下次了哈哈哈哈哈哈哈哈哈哈哈 后续实验&emsp;&emsp;学期结束了，老师不发文档，带头咕了","categories":[{"name":"project","slug":"project","permalink":"http://kqp.world/categories/project/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://kqp.world/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"【长更】一句话题解（组队训练的俄罗斯题、oj、camp）","slug":"short_sol_russian","date":"2020-04-15T15:22:32.000Z","updated":"2024-04-24T03:59:22.793Z","comments":true,"path":"short_sol_russian/","link":"","permalink":"http://kqp.world/short_sol_russian/","excerpt":"&emsp;&emsp;还是太长了，第二次分裂。。 &emsp;&emsp;标 * 的为有价值的题，标 ^ 的为欺诈题，标 - 的为知识点待填坑，标 ? 的表示看别人是这样做的但是没懂为什么&emsp;&emsp;组队训练的题，如果是队友过的板刷题，题面又很长，就会标个“队友说是沙雕题”","text":"&emsp;&emsp;还是太长了，第二次分裂。。 &emsp;&emsp;标 * 的为有价值的题，标 ^ 的为欺诈题，标 - 的为知识点待填坑，标 ? 的表示看别人是这样做的但是没懂为什么&emsp;&emsp;组队训练的题，如果是队友过的板刷题，题面又很长，就会标个“队友说是沙雕题” Codeforces ( 主要是 gym )300iq Contest 1&emsp;&emsp;每天起床第一句，300iq TXDE！&emsp;&emsp;*A：每个“*”拆成两个点并相连，一个连上下的“.”，一个连左右的“.”；每个“+”拆成两个点并相连，分别连上下左右的“.”，一般图最大匹配。20000 都敢跑带花树，时代变了&emsp;&emsp;*B：二分答案 $mid$，小于等于 $\\lfloor \\frac{mid}{2} \\rfloor$ 的全部选上，任意两个选了的点之间最多再选一个点&emsp;&emsp;*C：$a$ 数组先铺成 $0 \\sim n-1$，然后 $b$ 数组二分一个 rank，比他大的全是 $n$，比他小的全是 $-n$&emsp;&emsp;*D：从左到右贪心，维护一个 set 表示这里面的点全都放得下当前区间&emsp;&emsp;F：使白边连成森林即可&emsp;&emsp;*H：左边每个点 $i$ 连右边一个前缀 $1,\\cdots,a_i$，按 $a_i$ 从小到大排序，可以覆盖所有的 $k$。dp 或贪心&emsp;&emsp;&emsp;&emsp;看大题解&emsp;&emsp;**K：每个串可以转化成一个唯一的长度 4 以内的基本串，基本串只有 12 种，矩阵乘法求出每种基本串在长度为 $x$ 时有多少种对应的字符串&emsp;&emsp;&emsp;&emsp;看大题解&emsp;&emsp;EGIJ： Bubble Cup 12&emsp;&emsp;D：每个环有 size 那么多种方案，加起来形成一个式子，然后很多个式子做 FWT&emsp;&emsp;E：解法一：暴力卡常冲过去&emsp;&emsp;&emsp;&emsp;解法二：分治 FFT&emsp;&emsp;F：队友说是沙雕题&emsp;&emsp;H：树上的点随便做，环上的点推推式子发现是在距离 $m$ 以内寻找有多少个点的点权是给定值，大力主席树&emsp;&emsp;I：只有“第一列”选或不选两种情况 300iq Contest 2&emsp;&emsp;每天起床第一句，300iq TXDE！&emsp;&emsp;B：解法一：设 $x$ 的最高位为 $w$，所有数按高 $60-w$ 位分类，每一类最多选两个数，建个 trie 平行遍历&emsp;&emsp;&emsp;&emsp;解法二：所有数排序，则只需保证相邻的异或值 $\\geq x$ 即可，dp&emsp;&emsp;I：先找出重心，然后选择若干儿子使其 $size$ 之和 $\\in [\\frac n4,\\frac{3n}4]$（必定存在），然后询问，就可以分治下去了，询问次数之和为 $\\log_{\\frac 43} n$ 2019-2020 Russia Team Open, High School Programming Contest (VKOSHP 19)&emsp;&emsp;AFI：队友说是沙雕题&emsp;&emsp;B：$a$ 线段的端点沿 $\\vec{v}$ 投影到 $b$ 线段上&emsp;&emsp;C：计算出每一项的 $(a,b,c,n)$，上 python 自带高精度判断是大于号还是小于号&emsp;&emsp;*D：如果 $(1,1) \\to (1,\\frac m2) \\to (n,\\frac m2) \\to (n,m)$，那么中线一定有一个点被经过，这样就可以划分成两个部分平行递归下去了&emsp;&emsp;G：相邻的减号之间最多插入一个括号，这样就可以 dp 了&emsp;&emsp;H：从低位到高位一位一位构造，然后把多余的位清掉&emsp;&emsp;*L：$x$ 到 $y$ 经过 $c$ 等价于 $dis_{x,y}=dis_{x,c}+dis_{c,y}$，$k$ 棵树都有 $x$ 到 $y$ 经过 $c$ 等价于 $\\sum dis_{x,y}=\\sum dis_{x,c}+\\sum dis_{c,y}$。$O(n^2k)$ 预处理距离，然后 $O(n^3)$ 枚举&emsp;&emsp;&emsp;&emsp;看大题解 2020 UP ACM Algolympics Final Round&emsp;&emsp;D：略&emsp;&emsp;EK：队友说是沙雕题&emsp;&emsp;A：类似于最长公共子序列的 dp&emsp;&emsp;B：bfs&emsp;&emsp;C：拉格朗日条件极值&emsp;&emsp;L：用拉格朗日插值公式&emsp;&emsp;FGHIJM： MEX Foundation Contest (supported by AIM Tech)&emsp;&emsp;FI：略&emsp;&emsp;**C：动态点分求重心&emsp;&emsp;*E：$\\sum_e \\min\\{c_{e_x},c_{e_y}\\}=\\sum_{k=0}^s\\sum_e[c_{e_x} \\ge k \\land c_{e_y} \\ge k]$，于是状压 dp，设 $f_{s,i}$ 表示已经分配了 $i$ 个 token，$s$ 这个集合还继续参与分配，的最优答案。&emsp;&emsp;*G：状压 dp，对于一个集合 $s$，假设它染红色，那么必存在一个结点，所有包含它的子集都是红色，于是 $s$ 去掉这个结点就成了子问题了&emsp;&emsp;*H：二分，$0 \\sim mid-1$ 每种权值的边至少选一条，选出来的边必须互相具有拓扑关系，这就成了个 2-sat。把 2-sat 写成暴力 dfs 也是能过的&emsp;&emsp;ABDJ： 2018-2019 CTU Open Contest&emsp;&emsp;AC：略&emsp;&emsp;B：队友说是沙雕题&emsp;&emsp;D：AC 自动机解方程&emsp;&emsp;E：建 SA，每个位置由其前 $k$ 个位置的最小 $rank$ 来覆盖&emsp;&emsp;F：数位 dp&emsp;&emsp;G：dp，设 $f_{a,b,c,d}$ 表示先手在 $(a,b)$，后手在 $(c,d)$，先手胜的概率。无视循环转移迭代 1000 次&emsp;&emsp;H：SG 随便搞搞&emsp;&emsp;*I：“不能重叠”等价于“总面积最小”，每次取最左下角的点，用这个点取一个最小正方形&emsp;&emsp;J：按位考虑，每一位相当于数每个连通块的点数 Radewoosh+mnbvmar Contest&emsp;&emsp;A：shuffle 一个区间就是把这个区间所有数变成平均值&emsp;&emsp;*C：二分，第一次找中间竖线的最大值，然后往周围最大的方向走，第二次找横线最大值，依此类推&emsp;&emsp;E：精细地实现 $O(k^2n^2)$ 的 dp，在数据随机的情况下复杂度会变成 $O(k^2n+kn^2)$&emsp;&emsp;G：“010”和“101”会把序列割成若干段，预处理 $SG_{len,s}$ 表示长度为 $len$、序列状压为 $s$（记 111 为 $1$，110 为 $0$）的序列的 $SG$ 值&emsp;&emsp;H：Dijkstra 的顺序倒着 dp，更新别人 dp 值可以 $O(1)$ 实现&emsp;&emsp;J：有解的充要条件是存在两个形如“左下-右上”的结构，且一个能到达另一个&emsp;&emsp;*-K：解法一：LCT+SAM&emsp;&emsp;&emsp;&emsp;解法二：依据 border 划分成 $\\log$ 个等差数列&emsp;&emsp; 2018-2019 Summer Petrozavodsk Camp, Oleksandr Kulkov Contest 2&emsp;&emsp;（以下题号按 statement 来标，但 statement 里的 GHI 对应 codeforces 上的 HIJ）&emsp;&emsp;*B：枚举 $\\gcd$，将 $b$ 排序，二分答案，枚举 $a_i$，相当于问 $b$ 的一段前缀是否有 $\\gcd(i,j)=1$，简单反演一下，$O(n \\log^3 n)$&emsp;&emsp;C：贪心，每次没钱了就找前面最花钱的项目删除&emsp;&emsp;?D：$N \\ge 799039879$ 答案就是 $2^{N-799039877}$，然后 $&lt;799039879$ 就分段打表&emsp;&emsp;*E：这是五边形数公式里让 $x=0.1$&emsp;&emsp;G：（队友做的物理题我物理不及格就不插手了）&emsp;&emsp;*I：对于当前的根 $root$，它的若干儿子 $x_1,\\cdots,x_m$ 同构，那么就构造 $m-1$ 个置换表示子树 $x_1$ 与子树 $x_2$ 互换、子树 $x_1$ 与子树 $x_3$ 互换……，然后递归 $x_1$ 换根&emsp;&emsp;ADFH： 2018-2019 9th BSUIR Open Programming Championship. Semifinal&emsp;&emsp;AF：队友说是沙雕题&emsp;&emsp;B：2-sat&emsp;&emsp;*C：dp，设 $f_{i,j,k}$ 表示第 $i$ 个数到第 $j$ 个数考虑后 $k$ 位，的贡献和。（可能还要再加一维表示当前这位选到了什么数）&emsp;&emsp;E：比较麻烦的讨论题，可以枚举第一个数字的位数，注意判断 $10^{18}$&emsp;&emsp;^G：$n \\ge 31$ 之后循环节为 $4$&emsp;&emsp;H：$10^{18}$ 范围内只要不含 $1,2,3,5,8$ 就行&emsp;&emsp;*I：每个左端点往有 $O(\\log)$ 段，每个右端点往左也是，线段树随便搞搞&emsp;&emsp;J：每个人 21 种状态，枚举第一个人是什么状态&emsp;&emsp;K：算每条边的贡献，树链剖分，线段树暴力&emsp;&emsp;*L：枚举最大和 $sum$，那么 $2n$ 有 $sum-2n$ 种选择，$2n-1$ 除去 $2n$ 选掉的后还是 $sum-2n$ 种选择……往下一段都是 $sum-2n$ 种选择，这部分贡献是 $[x]\\prod \\big((sum-2n-1)+x\\big)$，剩下的贡献就阶乘除一除&emsp;&emsp;D： 2018-2019 9th BSUIR Open Programming Championship. Final&emsp;&emsp;H：略&emsp;&emsp;A：区间 dp，设 $f_{l,r}$ 表示区间 $[l,r]$ 的答案，如果两头都是字母那么就是 $f_{l+1,r-1}$，否则枚举星号匹配了多少长度&emsp;&emsp;*C：答案一定是 2 的幂，枚举答案（最多 $\\log$ 次），算出最终矩阵并判断&emsp;&emsp;&emsp;&emsp;看大题解&emsp;&emsp;D：牌从小到大排序然后 dp&emsp;&emsp;E：FWT&emsp;&emsp;F：枚举两个二进制位算贡献（注意常数，不要在 $O(n \\log ^2 a)$ 的循环里取模）&emsp;&emsp;I：记忆化搜索&emsp;&emsp;*J：分块，预处理块内答案和任意两块之间的答案&emsp;&emsp;BGK： 2019-2020 Saint-Petersburg Open High School Programming Contest (SpbKOSHP 19)&emsp;&emsp;ABCH：队友说是沙雕题&emsp;&emsp;*E：考虑把 $n$ 个数当成 $n$ 个二进制位，$+1$ 放正数，$-1$ 放负数，$0$ 的位放最前面&emsp;&emsp;F：floyd 或者大讨论&emsp;&emsp;G：meet in the middle&emsp;&emsp;I：$n&gt;4$ 时三元组之间会连成一个环，直接把这个环做出来&emsp;&emsp;*J：递推，每次对于一个排列，找到最大值的位置，把它前面的元素放后面，删掉最大值，这就递归下去了，推一推转移式子&emsp;&emsp;K：奇偶分组，每组用 LCT 解决&emsp;&emsp;D： 2017-2018 8th BSUIR Open Programming Contest. Final&emsp;&emsp;EH：队友说是沙雕题&emsp;&emsp;B：暴力&emsp;&emsp;C：对于左边更大和右边更大两种情况分别二分&emsp;&emsp;*F：先对于所有 01 串（$0$ 表示小数，$1$ 表示大数）过一次排序网络看看合不合法，再根据合法的 01 串 dp 出合法的排列数量&emsp;&emsp;G：$1+lcm(n-1,m-1)-(重复经过的格子数)$，重复经过的格子数可以画一下图观察一下&emsp;&emsp;H：&emsp;&emsp;*I：扫描右端点，合法的左端点区间（有 $1$、不含重复数字）是滑窗向右的，树状数组维护桶&emsp;&emsp;J：枚举首项以及 $N$ 是第几项&emsp;&emsp;ADK： 2017-2018 8th BSUIR Open Programming Contest. Semifinal&emsp;&emsp;ABFHJ：略&emsp;&emsp;K：队友说是沙雕题&emsp;&emsp;C：维护线性基&emsp;&emsp;*D：不考虑 $L$ 连向第一排、$R$ 连向最后一排，那么合法的方案跟不合法的方案是成对存在的，直接总方案数除以 $2$&emsp;&emsp;&emsp;&emsp;看大题解&emsp;&emsp;E：每种质数单独考虑，随便 dp 一下&emsp;&emsp;*G：等价于 $\\sum_{i=0}^{k-1} ((a+bi) \\bmod m) \\bmod 9$，把 $\\bmod~m$ 拆成整除的形式然后类欧&emsp;&emsp;&emsp;&emsp;看大题解&emsp;&emsp;?I：$O(n^3)$ 枚举钝角三角形暴力判（钝角三角形的数量是有限的，只要精细地实现程序，使得每次枚举都是一个钝角三角形） 2016-2017 7th BSUIR Open Programming Contest. Final&emsp;&emsp;A：队友说是沙雕题&emsp;&emsp;B：第 $i$ 行就放 $[(i-1)n+1,in]$ 就好了，保持每行的相对顺序一致、行内满足不相邻的条件即可&emsp;&emsp;*C：SG 值是分段的，每次除以 $2$ 或除以 $9$ 得到上一段的左端点&emsp;&emsp;E：GDOI2015粗心的邮差 状压 dp，设 $f_{i,s}$ 表示考虑了前 $i$ 个数，第 $i$ 个数前后 $k$ 项是否被分配记为 $s$，的方案数。$k$ 小 $n$ 大的时候用矩阵乘法&emsp;&emsp;F：枚举一个 swap 的点，预处理其左右的最大子段，以及最大子段+剩余元素最大值&emsp;&emsp;G：设从低位到高位考虑到了第 $i$ 位（总共考虑 $n$ 位），当前的数是 $cur$，若 $cur$ 的第 $i$ 位为 $1$，则放 $1$，否则放 $2$。&emsp;&emsp;H：dp&emsp;&emsp;I：$1,2,1,2,\\cdots$ 这样放，也就是考虑 $s \\bmod 3$ 就行了&emsp;&emsp;DJ： 2015-2016 6th BSUIR Open Programming Contest. Final&emsp;&emsp;DEH：队友说是沙雕题&emsp;&emsp;A：数位 dp&emsp;&emsp;C：每个数暴力枚举它跟前面共有什么质数&emsp;&emsp;*F：解法一：圆方树+树形 dp 分类讨论圆点和方点&emsp;&emsp;&emsp;&emsp;解法二：dfs树+树形 dp 特殊考虑返祖边&emsp;&emsp;G：注意到只跟行、列各翻转了多少次有关，若 $n^2$ 较小，则暴力枚举行、列各翻转了多少次，否则 $nt$ 比较小，对每个询问枚举行翻了多少次&emsp;&emsp;*I：最优一定是 $4000\\cdots000-000\\cdots000$，所以一开始扔个 $4$，收到 $4$ 以后放 $(1,1)$&emsp;&emsp;BJ： 2015-2016 6th BSUIR Open Programming Contest. Semifinal&emsp;&emsp;EFI：略&emsp;&emsp;BH：队友说是沙雕题&emsp;&emsp;A：枚举 $\\gcd$，把 $b_i$ 是它倍数的位置拉出来，求上升子序列数量，然后容斥&emsp;&emsp;C：meet in the middle&emsp;&emsp;^D：把它看成一个四位数，维护一个可选集合，每次从里面随机一个出来问&emsp;&emsp;G：找规律&emsp;&emsp;K：bzoj5016 拆成前缀询问，莫队&emsp;&emsp;J： 2014-2015 V BSUIR Open Programming Championship&emsp;&emsp;EF：队友说是沙雕题&emsp;&emsp;*A：用 $p$ 进制考虑，问题最后转化成：有 $n$ 堆石子，我从一堆拿走一个后，对面要么再选择一堆拿一个，要么从后面的堆拿一个填上我的位置。结论是当石子总数为奇数时先手必胜&emsp;&emsp;B：排序后暴力&emsp;&emsp;C：不停地给 $n$ 开根号&emsp;&emsp;^D：有通式的，写个暴力就找到通式了，比如 $2,3,4,5,7,6,8,9,10,13,12,11$&emsp;&emsp;G：树形dp&emsp;&emsp;J：答案等于最小的 $\\frac{最远点对}{2}$&emsp;&emsp;K：dp，设 $f_{n,m}$ 表示还剩 $n$ 红 $m$ 黑的最大期望收益&emsp;&emsp;HI： 2013-2014 BSUIR Open Programming Championship. Final&emsp;&emsp;完结撒花&emsp;&emsp;BD：队友说是沙雕题&emsp;&emsp;A：这题的考点是如何不爆 long long。两者同号用减法，异号用加法。（当然 0202 年了直接 __int128 或者 python 完事了）&emsp;&emsp;C：SA 随便搞搞&emsp;&emsp;F：每个数按最低位分类，每一类从大到小贪心，注意特殊考虑 $0$&emsp;&emsp;H：直接从左到右贪心&emsp;&emsp;I：有一点点繁琐的树形 dp&emsp;&emsp;J：枚举 $1$ 的个数，然后数位 dp&emsp;&emsp;K：推式子，枚举 $X$ 算答案&emsp;&emsp;E： AGM 2020, Final Round, Day 1&emsp;&emsp;D：队友说是沙雕题&emsp;&emsp;*B：扫描右端点，维护左端点的答案，用单调栈维护最值，用线段树维护最小值的异或和、最大值的异或和、最小值 $\\lor$ 最大值的异或和&emsp;&emsp;E：扫描线&emsp;&emsp;F：贪心模拟最小割&emsp;&emsp;H：$n,m,k$ 恰有一个是奇数的时候，只有一个格子走不到，否则全都走得到&emsp;&emsp;I：最大获利&emsp;&emsp;*K：圆邻域当成方邻域来做，邻居数量是同阶的。剩下的就是个简单 MST&emsp;&emsp;ACGJL： AGM 2020, Final Round, Day 2&emsp;&emsp;CDHJ：队友说是沙雕题&emsp;&emsp;A：最长反链=最小链覆盖，传递闭包+二分图最大匹配&emsp;&emsp;*E：点分 FFT 求出每种长度的路径有多少，然后 FFT 算答案&emsp;&emsp;G：启发式合并，或者 dsu on tree&emsp;&emsp;I：广义圆方树+虚树 dp&emsp;&emsp;BEKL： AGM 2020, Qualification Round&emsp;&emsp;CDI：队友说是沙雕题&emsp;&emsp;A：网络流&emsp;&emsp;B：贪心逐位确定，每次相当于问以 $x$ 为根 $y$ 子树的大小&emsp;&emsp;E：注意到 $a_i$ 很小，枚举 $a_i$ 和 $a_j$ 的值，然后让两数的差的绝对值尽量小&emsp;&emsp;^F：每次排序长度为 2 是最优的，因此等价于求逆序对&emsp;&emsp;G：250 行的打牌题&emsp;&emsp;H：按 $e_i$ 从小到大排序，设 $s_i$ 表示吃到第 $i$ 颗糖所需要吃掉的集合，则 $s_i=s_{i-1}\\cup\\{i的后继\\}$，最后 $\\forall i, e_i \\ge |s_i|$ 即表示合法。因此每个点会从他前驱中最小的 $e_i$ 开始做贡献，反向图拓扑+扫描线&emsp;&emsp;J：维护 $O(n^2)$ 个线段树&emsp;&emsp;K：dominator tree 模板题&emsp;&emsp;-L：top tree 2019 USP Try-outs&emsp;&emsp;BH：略&emsp;&emsp;FG：队友说是沙雕题&emsp;&emsp;*A：分成 $m&gt;\\sqrt{5 \\cdot 10^4}$、$m \\le \\sqrt{5 \\cdot 10^4}$ 两类&emsp;&emsp;*C：用 set 维护当前的集合，每次询问 $id$，从最小的元素开始贪心选尽可能多的能装在 $id$ 里的，然后再从 $id$ 往后贪心选尽可能多的&emsp;&emsp;-D：treap&emsp;&emsp;I：以 $b$ 为第一关键字、$a-b$ 为第二关键字从小到大排序，是最优的&emsp;&emsp;J：最小圆覆盖&emsp;&emsp;K：从小到大排序，若发现存在某个位置 $x$ 使得 $\\sum_{i=1}^x p_i&lt;p_{x+1}-1$，那么答案就是 $\\big(\\sum_{i=1}^x p_i\\big)+1$&emsp;&emsp;E： 2020 Petrozavodsk Winter Camp, Jagiellonian U Contest&emsp;&emsp;L：略&emsp;&emsp;FG：队友说是沙雕题&emsp;&emsp;*A：2020牛客多校第四场 H 去掉 $&gt; \\frac n2$ 的质数和 $1$ 之后，剩下的数必能两两匹配或剩一个，因此就是求 $(\\frac n2,n]$ 的质数个数&emsp;&emsp;B：Lucas 定理简单应用&emsp;&emsp;*H：每次还能到达的可行域是一个区间，dp 设 $f_{l,r,0/1}$ 表示当前能到达的区间是 $[l,r]$，当前在 $l$ 还是在 $r$，的最长距离。把 $[1,n]$ 倍长以后再 dp 可以避免枚举起点&emsp;&emsp;I：每次贪心构造一个尽量匹配高位的、小于等于当前数里最大的，例如 $3450255$ 会构造出 $3449443$，这样理想情况下每次会把原数长度减半&emsp;&emsp;K：容斥+插头 dp&emsp;&emsp;CDEJ： XXI Open Cup. Grand Prix of Korea&emsp;&emsp;*A：最大流，转化成最小割，枚举两边割了多少点，两边的点肯定是从小到大割，推下式子用线段树维护&emsp;&emsp;*D：假设有一个 $mid$，大于等于 $mid$ 的边视为黑边，小于 $mid$ 的边视为白边，那么黑连通块必须全部成团，这样就知道了最终 $\\ge mid$ 的边的数量。从大到小枚举 $mid$ 并查集合并。&emsp;&emsp;-*F：数轴的每个位置不能被超过两个区间覆盖，也等价于找两个内部不相交的子集使得价值和最大（类似于 menger 定理）。因此是个费用流，并且需要 potential method 优化&emsp;&emsp;H：二分，$mid$ 后面的全部变成 $0$，然后从小到大填空位&emsp;&emsp;J：倒推预处理出路径上的每一步在 $(-1,0),(1,0),(0,-1),(0,1)$ 开始的话会在哪里结束&emsp;&emsp;K：找一个点为起点，其他点极角排序，按顺序穿成菊花图&emsp;&emsp;BCEGIL BCPC 2020 Preliminary&emsp;&emsp;ABCE：队友说是沙雕题&emsp;&emsp;D：先算出最大题数，将 $a_i$ 从小到大排序，枚举一个前缀是用 $a_i$ 做题的，其余题是用 $x$ 做题的&emsp;&emsp;F：暴搜&emsp;&emsp;-G：闵可夫斯基和+旋转卡壳&emsp;&emsp;*H：最大就直接两边往中间选，最小相当于选择不相邻的 $k$ 条线段，贪心&emsp;&emsp;I：minmax容斥推式子&emsp;&emsp;*K：FWT 算出区间异或（转化成前缀异或和）的方案数，再用 FWT 算出 $A-B=A \\land \\lnot B$&emsp;&emsp;L：树上莫队&emsp;&emsp;JMN： Samara Farewell Contest 2020 (XXI Open Cup, GP of Samara)&emsp;&emsp;*A：$a_i\\le k,\\ b_i \\ge m-k$ 的叫工作狂，如果没有工作狂那么答案为 0，否则以所有 $a_i-1,\\ b_i$ 为关键点，计算以每个关键点作为起始的工作时间，注意 corner case&emsp;&emsp;^B：二分答案 $mid$，每个 quest 的收益就是 $\\max(b-a \\cdot mid,d-c \\cdot mid)$，看期望是正数还是负数来调整二分&emsp;&emsp;*C：枚举行 shift，维护列 shift 的前缀并查集和后缀并查集（前缀并查集只用记录第一列的连通性，后缀并查集只用记录末尾列的连通性）&emsp;&emsp;&emsp;&emsp;看大题解&emsp;&emsp;D：按 $a_i$ 从大到小排序，简单 dp&emsp;&emsp;E：按 $z$ 排序，线段树维护每个 $y$ 对应的最大 $x$，提神醒脑数据结构题&emsp;&emsp;F：直接 $O(4n)$ dp，一个点如果选就就必须转移到覆盖这个点的线段的最大末端，且不能跨过完整的线段，然后如果在某线段的末尾就一定要选&emsp;&emsp;G：简单贪心&emsp;&emsp;*H：从后往前分 $a_n \\m$ 三种情况倒推&emsp;&emsp;&emsp;&emsp;看大题解&emsp;&emsp;J：基本上是 $\\max(a_i-b_i+1)$，注意讨论“因为种类只剩一种了所以我死了”的情况&emsp;&emsp;K：回血前如果怕回爆了可以先去别的小怪消耗一下（不必直接打死），因此这等价于 2014 WF 的贪心题&emsp;&emsp;L：dp，以 $a_i$ 为第一关键字、$i$ 为第二关键字的顺序 dp&emsp;&emsp;M：大力旋根&emsp;&emsp;IN： 2020-2021 Winter Petrozavodsk Camp, Belarusian SU Contest (XXI Open Cup, Grand Prix of Belarus)&emsp;&emsp;*D：设 $dp_i$ 表示到了第 $i$ 个数的最大答案，枚举 $f_i$ 跟上一个选的数的贡献的最高位，那么上一个选的数就是上一个这一位为 $1$ 的数&emsp;&emsp;*E：每一位单独考虑，如果删掉 $0$ 段，那么合法意味着所有其他 $0$ 段合法；如果删掉 $1$ 段，那么不能存在最小覆盖次数 $\\ge 2$ 的 $0$ 段，且最小覆盖次数为 $1$ 的 $0$ 段的 $1$-覆盖的交集要包含这个 $1$ 段&emsp;&emsp;G：把完美匹配压缩起来，$\\frac n2$ 个点用 Cayley 定理&emsp;&emsp;^I：无论如何交换牌，一轮结束之后答案都是不变的，因此答案等于初始局面的答案&emsp;&emsp;J：一个点确定选不选之后，整个连通块都确定了，因此是连通块黑白染色取小的一边&emsp;&emsp;M：$1,\\ 1\\cdot 2,\\ 2 \\cdot 3,\\ 3\\cdot 5,\\cdots$ 这样，每次选的数字是模 $6$ 为 $1,2,3,5$ 循环的&emsp;&emsp;N：笛卡尔树递归&emsp;&emsp;ABCFHKL： 2020-2021 Winter Petrozavodsk Camp, Day 9 Contest (XXI Open Cup, Grand Prix of Suwon)&emsp;&emsp;C：二分+扫描线&emsp;&emsp;F：做出所有环的线性基（任意做生成树，非树边产生的环即可构成线性基），记 $a_i$ 表示 $i$ 结点到生成树根的路径异或和，$a_i’$ 为去除基元后的 $a_i$，$MAX$ 为基元构成的最大值，那么只需求 $\\bigoplus_{l \\le i &lt; j \\le r}a_i’ \\oplus a_j’ \\oplus MAX$&emsp;&emsp;*G：区间 dp，设 $dp_{l,r}$ 表示区间 $[l,r]$ 的答案，枚举最大值所在位置 $i$ 来转移，注意到当三元组 $(l,r,i)$ 确定时，$i$ 位置的最优取值是唯一的。最优取值可以用斜率优化算出&emsp;&emsp;I：记 $k$ 为数列的连续单调段的数量，最优情况下每次 $k \\gets \\lceil \\frac k2 \\rceil$&emsp;&emsp;J：枚举 $p_2$，二分 $p_3$&emsp;&emsp;ABDEHKL： 2020-2021 “Orz Panda” Cup Programming Contest&emsp;&emsp;CEG：队友说是沙雕题&emsp;&emsp;A：单调栈&emsp;&emsp;*B：只看前两种覆盖，burnside引理+反演一套打下去，发现是特殊的斐波那契数列卷欧拉函数这也太卷了，分块+杜教筛+矩阵快速幂&emsp;&emsp;D：一条边会贡献当且仅当上一次 access 这棵子树内的点，下一次 access 子树外的点，因此是 $\\lim_{m \\to \\infty} \\frac{(m-1)2p(1-p)}{m}=2p(1-p)$，其中 $p$ 表示选子树内的点的概率&emsp;&emsp;*F：看成电路模型，基尔霍夫方程&emsp;&emsp;H：如果一开始就校验通过那就是 good；否则假设错了一位，看 $d(2^i)$ 错了多少个，错 0 个那就是 $d(0)$ 错了，错 1 个那就是 $d(2^i)$ 错了，错多个那就是 $d(\\lor_{2^i})$ 错了，纠正后再校验，通过则是真的错 1 位，否则是 broken&emsp;&emsp;I：叉积一圈&emsp;&emsp;*J：从大到小放数字，容斥算每次方案数，式子形如 $\\sum_{i=0}^x \\sum_{j=0}^y (-1)^{x+y} \\binom{x}{i} \\binom{y}{j} w^{s1}(w-1)^{s2}$，枚举 $i$ 快速算 2020-2021 ICPC Northwestern European Regional Programming Contest (NWERC 2020)&emsp;&emsp;CK：略&emsp;&emsp;*D：一颗一颗来，每次得到一个 $c^2$，枚举 $a \\in [1,10^6]$，判断是否有 $c^2=a^2+b^2$。稀疏得很&emsp;&emsp;E：判断 Alice 胜是简单的 meet-in-the-middle，判断和棋只有在 $n$ 很小时才需要暴力判，$n$ 大的时候一定有可以传送的地方，随机判断。&emsp;&emsp;FH：队友说是沙雕题&emsp;&emsp;*I：解法一：枚举两个人的出发点 $x,y$，每个点上都有两个区间是不能被第三个人用的，第三个人的起点从 $x$ 枚举到 $y$ 或者从 $y$ 枚举到 $x$ 都能快速地维护答案&emsp;&emsp;&emsp;&emsp;解法二：预处理 $b_{i,j}$ 表示两个人从 $i,j$ 出发会不会撞，然后 $O(n^3)$ 枚举起始位置直接判断&emsp;&emsp;*J：做 dfs 树，dfs 过程中会把点分成 栈内点、已遍历点、未遍历点 三部分，一定存在一个时刻使得已遍历点的数量等于未遍历点的数量，此时栈内点就是所求路径&emsp;&emsp;ABG： 2020-2021 ICPC Southeastern European Regional Programming Contest (SEERC 2020)&emsp;&emsp;*^B：$\\sum(1的位置)-\\sum(0的位置)$，reverse 01 使得这个值减 2，其余操作使得这个值减 4&emsp;&emsp;D：每次选一个在柱顶的颜色，已知该颜色一个珠子在柱顶，讨论另外两个珠子的位置，都可以 6 步以内完成&emsp;&emsp;E：队友说是沙雕题&emsp;&emsp;*F：最后一定是变成若干个同色连续段，且颜色的顺序会遵循原序列的顺序。设 $dp_{i,j}$ 表示考虑了前 $i$ 个数，第 $i$ 个数染了 $j$ 色，的方案数&emsp;&emsp;**H：每个询问考虑最后答案二进制有几个 1，比它少的都要 or，比它大的都要 and，跟它一样多的必须全部相等，然后要么全都丢到同一边，要么两边都丢。用主席树预处理对于每个 $x \\in [0,30]$，只考虑 1 的数量等于 $x$ 的 $a_i$ 的区间和、或、数量&emsp;&emsp;&emsp;&emsp;看大题解&emsp;&emsp;*I：强制让 1 放开头并忽略，那么 2 的位置会把排列分成两个下降序列。设 $dp_{i,j}$ 表示把 $3,\\cdots,i$ 分成两个下降序列，其中一个开头是 $i$ 另一个开头是 $j$，的方案数。$i$ 这一维可以扔掉&emsp;&emsp;*L：按 $p+m$ 从大到小排序，一定是前面的人抢，后面的人帮（$m_i-p_j&gt;m_j-p_i \\Rightarrow m_i+p_i&gt;m_j+p_j$），二分答案用堆维护&emsp;&emsp;M：按 bfs 序贪心&emsp;&emsp;ACGJK： 2020-2021 Winter Petrozavodsk Camp, UPC contest&emsp;&emsp;A：转化成问恰好 $k$ 个相邻对的排列的数量，设 $dp_{i,j,0/1}$ 表示从小到大放到第 $i$ 个数，有 $j$ 个相邻对，$i$ 这个数是否跟 $i-1$ 相邻，的方案数&emsp;&emsp;C：队友说是沙雕题&emsp;&emsp;E：大力莫队线段树&emsp;&emsp;I：$b$ 序列减 $a$ 序列得到每个人赢的局数，只要和大于 $n-1$ 且第一个人有赢即可，特判 $n=1,2$&emsp;&emsp;J：即 $4n+1$ 是完全平方数，只需令 $n=x^2+x$ 即可，即第 $k$ 个合法的数是 $k^2+k$&emsp;&emsp;K：边双树求直径&emsp;&emsp;L：解法一：约定任意两行的差不超过 3 格，这样就只有 27 种状态，大力推转移然后矩阵乘法&emsp;&emsp;&emsp;&emsp;解法二：手推使得三行对齐的状态转移&emsp;&emsp;BDFGH： National Taiwan University NCPC Preliminary 2021&emsp;&emsp;B：树形 dp&emsp;&emsp;C：等价于找长度 $&gt;5$ 的奇环&emsp;&emsp;*D：解法一：把询问串也加进 trie 里建 AC 自动机，那么每次就是问一条链上有多少个节点在询问串的 fail 子树中，遍历 trie 维护祖先链的 fail 树 dfs 序+区间查询即可&emsp;&emsp;&emsp;&emsp;解法二：trie 上建 sam&emsp;&emsp;E：bitset 优化背包&emsp;&emsp;*F：对于答案 $ans$ 来说，$a &lt; ans$ 时均有 $(ax\\bmod p+ay\\bmod p)-(a(x+y)\\bmod p)=p$，因此可以二分，用类欧来 check&emsp;&emsp;*H：一个 rank 集可能比另一个 rank 集高分，当且仅当存在一个数 $x$，使得前一个 rank 集小于等于 $x$ 的数量多于另一个 rank 集小于等于 $x$ 的数量，因此可以做出朴素的 $O(n^3)$ dp，用 NTT 优化转移&emsp;&emsp;I：费用流，每条边 $\\langle u,v,a,b \\rangle$ 拆一个新点 $x$，连 $\\langle v,x,1,0 \\rangle, \\langle x,u,1,a \\rangle, \\langle x,T,1,b \\rangle$，源点连向入度超了的点，入度有盈余的连向汇点&emsp;&emsp;J：简单状压&emsp;&emsp;*K：考虑一个 $a_i$ 最多 $x$ 步结束，操作一次以后变成最多 $y$ 步结束，则 $y$ 可以取小于 $x$ 的任意数，因此 $SG(a)=\\log_k a$，对于每个 $a$ 来说 $k$ 的突变点只有 $O(\\log a)$ 个&emsp;&emsp;AGL： XXII Open Cup. Grand Prix of Korea&emsp;&emsp;H：队友说是沙雕题&emsp;&emsp;J：答案有两个部分：第一部分是本身不可能为周期的，枚举两个不同的 $a$ 它们的间隔的约数都不可能为周期；第二部分是如果它为周期那么它的约数也是周期从而它本身不是最小周期，这样的周期最大只有 $n$，枚举判断即可&emsp;&emsp;ABCDEFGIKLM： Anton Trygub Contest 1 (The 1st Universal Cup, Stage 4: Ukraine)&emsp;&emsp;A：从大到小排序，交替两头放&emsp;&emsp;BDFK：队友说是沙雕题&emsp;&emsp;E：如果所有人异或起来不为 0 那么随便断开两段即可；如果所有人异或为 0 则看头尾第一个不为 0 的数，不相等则直接这样断三段，相等则中间再找跟它们不一样的数&emsp;&emsp;I：每格只有两种选择（曼哈顿距离或 $+1$），因此每行也只是选一个位置分开曼哈顿距离及其 $+1$，$n^2$ dp 一下&emsp;&emsp;GHJLMN： OpentrainPetrozavodsk Summer-2013. Moscow IPT Contest&emsp;&emsp;E：略&emsp;&emsp;*A：它是个分层图，每个点 hash 一个出点集，bfs 来定层，每个点的出点按照该 hash 值分为左右两边&emsp;&emsp;C：大力余弦正弦推式子&emsp;&emsp;*F：每列看成是连边，每个连通块如果没有奇环那么就是有一个自由变元，如果有奇环就没有自由变元，$rank=n-$自由变元&emsp;&emsp;I：按二进制 $1$ 的数量的奇偶性分为两个集合，可证 $k&lt;n$ 时一定可行&emsp;&emsp;*J：点分+FFT，注意常数&emsp;&emsp;K：线段树维护 $\\sum a$、$\\sum b$、$\\sum a\\cdot b$，以及 $a$ 和 $b$ 的加法标记 Petrozavodsk Winter-2014. Warsaw U Contest&emsp;&emsp;BH：略&emsp;&emsp;A：暴力 bitset，设 $b_{i,j}$ 表示第 $i$ 位不是 $j$ 的有谁&emsp;&emsp;E：任一自然数能被不超过 3 个形如 $\\frac{n(n+1)}2$ 的数的和表示&emsp;&emsp;*F：做法一：询问拆成 4 个二维前缀的形式，然后对 x 轴 cdq，时间 $O(n \\log^2 n)$&emsp;&emsp;&emsp;&emsp;做法二：询问拆成 4 个二维前缀的形式，然后对于每个小询问，矩形只会有被全包含、踩上边界、踩右边界、踩右上顶点四种情况，最后一种最多只有一个矩形，其余三种可以简单维护，时间 $O(n \\log n)$&emsp;&emsp;*I：对于一棵树，每次贪心找 $deep_i+a_i$ 最大的点（因为这个是瓶颈），然后处理掉那棵子树&emsp;&emsp;*J：每一个 N 开头的后缀都是一个独立的游戏（除了开头其他全是 S），比如 NSNNS，则看作是 NSSSS、NSS、NS 三个独立游戏，暴力算 $SG$，时间 $O(n^2 \\log n)$ Petrozavodsk Summer-2013. Gennady Korotkevich Contest 1&emsp;&emsp;*A：解法一：SA，对于 SA 的每一项，出现次数向上找，那么：$height$ 以外的出现次数为 $1$，二分最大合法长度就行了；$height$ 以内的去掉被覆盖过的，总量是 $O(n)$ 的&emsp;&emsp;&emsp;&emsp;解法二：SAM，每个节点的出现次数、长度区间都是在建树时维护好的，那么每个节点二分一个最长的合法长度就行了&emsp;&emsp;B：枚举分界点&emsp;&emsp;C：枚举加起来等于 10 的组合，然后 $O(n^2)$ dp，注意末位 0 的情况&emsp;&emsp;*E：解扩展 gcd 得到裴蜀系数，可以通过裴蜀系数来推答案的式子&emsp;&emsp;G：要求的是最长的子序列使得拼起来后是排完序的数组中的连续一段。考虑排序后分成若干段相同的数，取 1 段则全取，取 2 段可以在原序列上 $O(n)$，取大于等于 3 段时中间的段是要全取完的&emsp;&emsp;H：队友说是沙雕题&emsp;&emsp;J：余数也是 $n$ 的约数，因此直接枚举 $n$ 的约数，假设是 $d$，则把 $d$ 当作余数的贡献为 $\\frac{n-d}d$ 的大于 $1$ 的约数个数，暴力 XV Open Cup named after E.V. Pankratiev Grand Prix of Siberia&emsp;&emsp;12：略&emsp;&emsp;2：队友说是沙雕题&emsp;&emsp;3：解法一：暴力枚举 $k$，双 hash 判（不知道为什么我们的单 hash 被卡掉了。。&emsp;&emsp;4：FWT&emsp;&emsp;5：分层最短路&emsp;&emsp;7：棋盘黑白染色，跑最大流&emsp;&emsp;8：搞个堆，一开始有 $O(n^2)$ 条边在里面，每次合并两个集合之后往堆里加 $O(n)$ 条边，因此堆总量是 $O(n^2)$ 的&emsp;&emsp;*10：等角螺线公式+弧长积分 Petrozavodsk Winter Training Camp 2018 Day 2: ITMO U 1 Contest&emsp;&emsp;*A：大力积分&emsp;&emsp;C：先取 $\\frac 13$，他剩下的这块 $\\frac 23$ 不动（假设先扔掉），然后大家都取对方最大的 $\\frac 23$，最后我至少剩 $\\frac 19$，再取他一开始那个 $\\frac 23$ 的 $\\frac 23$ 就够了&emsp;&emsp;D：第 $i$ 轮的贡献就是 $\\frac{\\binom{n-k}{2^{i-1}-1}}{\\binom{2^{n}-1}{2^{i-1}-1}}$&emsp;&emsp;*E：题意坑 递推求答案，算 $n!! \\bmod 2^{64}$ 有科技。&emsp;&emsp;&emsp;&emsp;看大题解&emsp;&emsp;G：队友说是沙雕题&emsp;&emsp;^H：考虑最终结构，$p_i$ 向 $p_j$ 连边，会构成一棵树。因此逐位确定跑最小树形图就好了&emsp;&emsp;**I：对于每个 $i$，给 $a_{i}$ 加上一个随机的 $y_i$，给 $a_{p_i}$ 减去 $y_i$。然后读入的数组反过来，跟 $a$ 数组做卷积，$0$ 就表示合法位置&emsp;&emsp;&emsp;&emsp;看大题解&emsp;&emsp;J：设 $f_i$ 表示方案数，$a_i &gt; \\sqrt n$ 时直接跳着转移，$a_i \\leq \\sqrt n$ 时按 $i \\bmod a_i$ 维护一下，避免计重如果跳到相同的格子要停下来 XVIII Open Cup named after E.V. Pankratiev. Grand Prix of Gomel&emsp;&emsp;A：易证 $a \\times h=n$&emsp;&emsp;B：模型转化为有很多物品，第 $i$ 种物品价格为 $i$，数量为 $\\log_2\\text{lowbit}(i)+1$，求 $n$ 元能买多少物品。二分买到第几种物品就好了&emsp;&emsp;*E：把两个序列的循环节求出来，假设循环节长度分别是 $pr,ps$，那么行可以分为 $\\gcd(pr,ps)$ 个相似类，相似类里相邻两行的纵坐标序列是大体相同的，先暴力求一行的纵坐标，用 set 维护答案，然后遍历这个相似类，调整 set&emsp;&emsp;&emsp;&emsp;看大题解&emsp;&emsp;F：先 $p-1$ 个人每人都是 $\\{i,p\\}$，然后两个人都是 $\\{p\\}$，然后 $p-2$ 组人，第 $i$ 组人分别是 $\\{i+1\\},\\{i+2\\},\\cdots,\\{p-1\\}$&emsp;&emsp;*G：枚举斜率 $k$，相当于每个人有一个限制区间 $[l_i+ik,r_i+ik]$ 求区间交的整点数。随着 $k$ 的递增，$f(k)=\\max_{i=1}^n\\{l_i+ik\\}$ 形成一个下凸壳，$g(k)=\\min_{i=1}^n\\{r_i+ik\\}$ 形成一个上凸壳，因此可以求凸包内整点数&emsp;&emsp;J：队友说是沙雕结论一行题&emsp;&emsp;K：只有 $15$ 种质因子，每种质因子都必须要有人全有、有人全无。$O(3^{15})$ 大力容斥 XIV Open Cup named after E.V. Pankratiev. GP of SPb.&emsp;&emsp;AB：略&emsp;&emsp;C：$O(n^4k)$ dp&emsp;&emsp;E：dp，写好一点做到质数个数平方就行了&emsp;&emsp;F：方法一：推出恰好撞 $i$ 个的概率，是个组合数式子，数太大了就先取 $\\ln$ 后面再 $\\exp$&emsp;&emsp;&emsp;&emsp;方法二：$ans=\\lfloor \\frac{LM}N \\rfloor$&emsp;&emsp;G：最小费用可行流，费用是一个 10 维向量&emsp;&emsp;*H：方法一：每个点维护一个 bitset 表示可达性，每次操作暴力重构 $v$ 的 bitset，然后按拓扑序更新能到 $v$ 的点的 bitset，时间 $O(\\frac{qn^3}{64})$&emsp;&emsp;&emsp;&emsp;方法二：把 bitset 换成方案数，时间 $O(qn^2)$&emsp;&emsp;&emsp;&emsp;看大题解&emsp;&emsp;J：每次往上叠一定不会打结&emsp;&emsp;K：等价于做两次消元之后最多有多少全 $0$ 向量。枚举第一个向量，给别人消元；然后看有多少向量全 $0$ 了，以及最多有多少一样的向量 XVII Open Cup named after E.V. Pankratiev. Grand Prix of Europe (CEPC-2016)&emsp;&emsp;A：大模拟&emsp;&emsp;*B：一个点集合法等价于左右各有完美匹配。先左右各用 Holl 定理算出合法的集合，然后双指针算答案&emsp;&emsp;C：找到左右第一个高度为 $1$ 的图形就好算了&emsp;&emsp;*D：设当前在 $(x,y)$ 有长度在 $[a,b]$ 之间的柱子要排序，则把他们按容量分摊到右下矩形的每一个点，递归下去&emsp;&emsp;&emsp;&emsp;看大题解&emsp;&emsp;F：一个点如果他父亲要变就给他和新父亲都打标记，一条链从最深的标记开始向上全都要拆掉&emsp;&emsp;*H：先预处理出每个点作为中心的最大边长，这个可以 $O(n^2)$ dp。然后从大到小激活每个点，每个询问相当于询问两点最早什么时候连通，整体二分或者并查集启发式合并&emsp;&emsp;J：每种点对拿出来，先 $ABA$ 后 $BAB$、先 $BAB$ 后 $ABA$ 这两种策略必有一种是最优的&emsp;&emsp;K：考虑差分序列，奇数项和偶数项分开，$00$ 一次消掉，$010$ 两次消掉&emsp;&emsp;*L：常值变量单独判掉，然后合并本质相同的变量（两个变量相等或相反），最后一定是剩下两个变量&emsp;&emsp;&emsp;&emsp;看大题解 Moscow Pre-Finals Workshop 2016. National Taiwan U Selection&emsp;&emsp;A：解法一：线段树维护矩阵&emsp;&emsp;&emsp;&emsp;解法二：预处理出每个位置往后 $2^k$ 个 easy 在哪，每次询问倍增&emsp;&emsp;B：每一位分为 $0$ 和 $1$ 两个集合，每个集合单独做再连一条边。这相当于 trie 树上先递归处理子树然后启发式合并&emsp;&emsp;*D：非凸包上的点数，如果是奇数则先手必败，是偶数则先手必胜。&emsp;&emsp;&emsp;&emsp;看大题解&emsp;&emsp;F：找循环节&emsp;&emsp;*H：设 $f_i$ 表示某长度下哈希值为 $i$ 的方案数。两个字符串拼起来，$f$ 数组相当于循环卷积。因此这题 FFT+快速幂。&emsp;&emsp;I：数位 dp&emsp;&emsp;^J：每个数组取最大的 5000 个数暴力 Moscow Pre-Finals Workshop 2016. Kent Nikaido Contest 1&emsp;&emsp;J：略&emsp;&emsp;**A：观察对角线，正的图案是 $(2,2)$，反的图案是 $(1,1,1,1)$。&emsp;&emsp;&emsp;&emsp;看大题解&emsp;&emsp;*B：$l=1$ 是 $k^n$，$l=n$ 是 polya，其余的打表可以观察出规律。证明见题解&emsp;&emsp;*D：答案一定是所有边的边权和加上奇点两两配对的最短路，而最短路一定在 MST 上，因此树形 dp 配对奇点。&emsp;&emsp;H：算底层每个点的贡献，相当于算 $(L,j,k)$ 到 $(1,1,1)$ 的方案数，等于 $\\binom{L-1}{k-1} \\cdot \\binom{L-k}{j-k}$，用 Lucas 定理算奇偶性&emsp;&emsp;*I：固定形状杨表填数（该形状可以分为三个子矩形），钩长公式&emsp;&emsp;K：记最小值为 $first$，其他堆减去最小值的和为 $res$，当 $n-1$ 为偶数时取决于 $first+res$ 的奇偶性，当 $n-1$ 为奇数时先手必胜当且仅当 $first$ 或 $res$ 为奇数。 Urozero Autumn 2016. BAPC 2016&emsp;&emsp;BI：队友说是沙雕题&emsp;&emsp;C：bfs&emsp;&emsp;D：从某艘船开始卡一定是卡一整段，预处理每艘船开始卡会卡到哪里，以及相关时间。然后 $dp_i$ 表示前 $i$ 艘船全部过完的答案，转移就枚举从 $i$ 开始卡，卡完之后等到第 $j$ 艘船过了再下桥。&emsp;&emsp;E：二分+最短路&emsp;&emsp;G：转成切比雪夫距离的坐标，然后 $O(n^2)$ 暴力&emsp;&emsp;H：dp，设 $dp_i$ 表示 $i$ 最少分成多少个数乘起来。在 $n$ 的约数的倍数关系图上转移，倍数关系只有 3e6 个&emsp;&emsp;J：二分+二分图匹配&emsp;&emsp;K：先进行链上的递推，再枚举开头的空白&emsp;&emsp;L：枚举 $i$，选 $a_i,a_{i+1}$，再找一个 $\\in (a_{i+1},a_i+a_{i+1})$ 的&emsp;&emsp;AF： Urozero Autumn 2016. UKIEPC 2016&emsp;&emsp;FHI：略&emsp;&emsp;AE：队友说是沙雕题&emsp;&emsp;C：只用两个寄存器，栈只用来做加法，bfs，最多 38 步&emsp;&emsp;D：最小割&emsp;&emsp;G：到达时间模 $2t$，然后人是分段的，枚举起点破环为链，dp，斜率优化&emsp;&emsp;J：每个龙鸣农民只会给一种豆子。$2^B$ 枚举从农民得到的豆子集，判断是不是跟每个农民都有交&emsp;&emsp;L：错排写成 $\\sum \\frac{1}{i!}$ 的形式，$i$ 大的时候就没影响了&emsp;&emsp;BK： NCPC 2017&emsp;&emsp;GJ：略&emsp;&emsp;A：dp，设 $f_i$ 表示前 $i$ 个关键点的时间，若不买咖啡则转移到 $i+1$，若买咖啡则转移到咖啡范围内的最后一个关键点或咖啡范围外的第一个关键点&emsp;&emsp;B：队友说是沙雕题&emsp;&emsp;C：循环链表&emsp;&emsp;*D：把 $0$ 到 $2^k-1$ 视为结点，两个结点如果差一位则连一条边，那么就是个多源 bfs&emsp;&emsp;E：从深到浅激活每一个格子，用并查集维护连通性并记录集合最小值，当与抽水机连通时该最小值就是该集合的贡献&emsp;&emsp;*F：所涉及的范围是，首先一路往最左走，然后有 $O(30)$ 层（以树为层），随(xie)便(dao)搞(ni)搞(tu)&emsp;&emsp;I：每个点 $x$ 建一个汇点 $x’$，连边 $(x,y)$ 的时候多连一条 $(x,y’)$，然后从每个点出发跑 bfs 到自己的汇点，最小值就是最小环&emsp;&emsp;K：二分，然后从速度要求最小的船开始满足&emsp;&emsp;H： XVIII Open Cup named after E.V. Pankratiev. Grand Prix of Korea&emsp;&emsp;A：扫描线，“回”字分上下左右四个矩形，一起走&emsp;&emsp;C：每条路径按桥的沉没概率从大到小做。设路径的成功概率为&emsp;&emsp;D：从小到大枚举 $i$，设 $last$ 为 $i-1$ 是从哪里复制的（没有的话就是 $0$），那么 $last$ 就转移到 $next[last][s_i]$ 或 $0$。&emsp;&emsp;*G：解法一：先做一个初始 MST，然后暴力 LCT&emsp;&emsp;&emsp;&emsp;解法二：先做一个初始 MST。对于每个点，将它及它相邻的点拿出来建虚树（虚树边权为 MST 链上的最大值），那么这个点的答案类似于虚树重新做 Kruscal&emsp;&emsp;&emsp;&emsp;看大题解&emsp;&emsp;F：当有根树状压 dp&emsp;&emsp;*J：大部分 $[l,r]$ 的答案等于 $[l+1,r-1]$ 的答案，于是就这样往里缩，缩到能 $O(1)$ 计算答案为止。&emsp;&emsp;&emsp;&emsp;看大题解&emsp;&emsp;BEHIK： XVI Open Cup named after E.V. Pankratiev. GP of Europe (CEPC-2015)&emsp;&emsp;AH：略&emsp;&emsp;^D：只有前缀 $\\bmod~m=0$ 的位置才能够作为某段的结束位置，因此是 $2^{前缀为 0 的位置数量}$&emsp;&emsp;F：FFT&emsp;&emsp;I：注意到坐标范围非常小，且半径$&lt;1$。竖线直接枚举 $j \\in [y_1,y_2]$，否则假设线段从左下到右上，对 $\\forall i \\in[x_1,x_2]$ 枚举 $j \\in [\\lfloor y(i-1) \\rfloor,\\lceil y(i+1) \\rceil]$ 判断&emsp;&emsp;J：最小割树&emsp;&emsp;K：挑出必选的和必不选的，剩下的形成偶环，选其中一边&emsp;&emsp;BCEGL： Petrozavodsk Summer-2016. Warsaw U Contest, XVI Open Cup Onsite&emsp;&emsp;DG：队友说是沙雕题&emsp;&emsp;B：smart 染色相当于给出了独立集划分，那么如果一个独立集里有一种颜色只出现一次，则整个独立集都换那种颜色，如果造成了别的颜色只剩一种那么就 bfs 一样接着处理其他独立集&emsp;&emsp;E：总数减去不合法，不合法的是滑窗的矩阵乘法&emsp;&emsp;*H：一开始按 $a_i$ 升序排序，则无论如何修剪都是保持单调递增的。所以可以每次二分出要修剪的后缀，然后线段树维护相关的东西&emsp;&emsp;J：枚举直角顶点，其他点按极角序 two pointers XVII Open Cup named after E.V. Pankratiev. Grand Prix of Japan&emsp;&emsp;*B：行和列对应二分图两排点，原图有完美匹配等价于二分图每个连通块都是偶数条边，所以相当于二分图找割边&emsp;&emsp;DE：队友说是沙雕题&emsp;&emsp;H：求每个位置的 SG（滑窗 mex，用值域线段树维护最晚出现位置的最小值），然后 $a_i$ 为奇数的位置异或起来&emsp;&emsp;J：跟这个题类似的 dp Grodno 2015 (Urozero May 2015 Day 5)&emsp;&emsp;数学场，听说你会数学？&emsp;&emsp;IG：略&emsp;&emsp;*B：dp 枚举正贡献的数的和，假设正贡献为 $x$，负贡献为 $y$，则合法的充要条件为 $x \\geq y$ 且正贡献的最大值 $\\geq x-y$&emsp;&emsp;CF：队友说是沙雕题&emsp;&emsp;H：式子是组合数，Lucas+分块打表&emsp;&emsp;K：问题转化为能否将 $A$ 拆成若干正整数的和，使得其平方和等于 $A^2-T$。$300$ 的整数拆分只有 1e7，直接暴力 Petrozavodsk Summer-2017. Warsaw U Contest, XVII OpenCup Onsite&emsp;&emsp;DK：队友说是沙雕题&emsp;&emsp;*A：对于一个点，把它在每种颜色下的并查集根写下来做成哈希，那么哈希值相同的点对就是合法点对。每种颜色启发式合并&emsp;&emsp;*C：连续段最多只有 $2m$ 段，区间 dp，每个区间第一步只会选择端点的颜色，且端点必须是其颜色的左右端点&emsp;&emsp;*E：解法一：KKT 条件&emsp;&emsp;&emsp;&emsp;解法二：设 $g_i^2=p_i$ 这样就能隐含 $0 \\leq p_i \\leq 1$ 了，然后正常的拉格朗日求条件极值&emsp;&emsp;G：设当前区间 $[l,r]$ 要分成一个上升子序列和一个下降子序列，找到最小值所在位置 $mid$（要么是上升的开始，要么是下降的结束），讨论分治 $[l,mid-1]$、$[mid+1,r]$ 中的一段。&emsp;&emsp;H：莫比乌斯反演&emsp;&emsp;J：时间离散化，然后网络流 Makoto Soejima Contest 3 (MIPT Workshop Open 2)&emsp;&emsp;欺诈题大作战&emsp;&emsp;*A：贪心模拟最小割&emsp;&emsp;B：记 $last_i$ 表示 $i$ 后面第一个不是 $\\text{s}$ 的字符，先从前往后删 $last_i&lt;\\text{s}$ 的，再从后往前删 $last_i&gt;\\text{s}$ 的&emsp;&emsp;C：状压 dp，设 $f_s$ 表示 prefer list 做到某一项后，$s$ 这个月份集的食物已经被确定了。从小到大枚举 $s$，然后枚举 prefer list 的下一项 $i$，$i$ 的出现月份必须不是 $s$ 的子集才有意义&emsp;&emsp;^D：每个 $T$ 对应的 $S$ 的数量是一样的，算出来（考虑每个 $t_i$ 前插入一堆 $\\overline{t_i}$）然后乘 $\\binom{c+d}{c}$&emsp;&emsp;^^E：算这种“割”（虚线）的贡献&emsp;&emsp;*F：二分，要么全砍成 $\\frac{mid}{2}$ 以内，要么保留 $\\frac{mid}{2}$ 以上最短的一段，记为 $a$，然后其他砍成 $mid-a$ 以内&emsp;&emsp;G：分类讨论&emsp;&emsp;*H：只需判断 $c \\in (b,a+b)$ 的情况，$\\frac {c!}{a!b!}=\\frac{\\binom{a+b}{a}}{(c+1)(c+2)\\cdots(a+b)}$，因此只用考虑 $c+1,\\cdots,a+b$ 的质因子。考虑质因子 $2$ 的数量，因为 $\\sum_{k=1} \\lfloor \\frac{a+b}{2^k} \\rfloor - (\\lfloor \\frac a{2^k} \\rfloor + \\lfloor \\frac b{2^k} \\rfloor) \\leq k$，因此 $[c+1,a+b]$ 这个区间的长度至多为 $2k$ 即 $O(\\log (a+b))$&emsp;&emsp;*J：分别考虑一个元素、两个元素、三个元素造成的贡献，三个元素的话是 $\\binom n3-(最大值都在一个人身上)-(有两个最大值在一个人身上)$&emsp;&emsp;IK： AIM Fund Contest (MIPT Workshop Open 4)&emsp;&emsp;I：略&emsp;&emsp;EH：队友说是沙雕题&emsp;&emsp;A：字符串必然是 $aaaa\\cdots a$ 或者 $aaa\\cdots abbb\\cdots b$ 的形式&emsp;&emsp;*C：$k \\leq 5$：$(k-1固定) \\times (n-k+1选1)$；$k \\geq 9$：$\\binom{k+1}{k}$；$k=6$：$\\binom 32 \\times \\binom 32 \\times (7选1) \\times (1固定)$；$k=7$：$\\binom 32+\\binom 32+\\binom 32+(5选1)$；$k=8$：$\\binom 43 \\times \\binom 32 \\times \\binom 32 \\times (4选1)$&emsp;&emsp;*F：表示成 $\\sum_{i=1}^k \\frac{n}{a_i}=n$，这样的 $\\{a_1,\\cdots,a_k\\}$ 集合（$lcm$ 互不为倍数）每个 $k$ 最多 15 个，然后容斥，容斥所要算的 $lcm$ 也最多 800 多个&emsp;&emsp;*G：先确定符号，然后二分（每次询问 $\\frac{\\pi}{mid}$）。去你妈的 30 位精度，卡精度很好玩吗？&emsp;&emsp;J：排序区间不会相交，dp，设 $f_i$ 表示前 $i$ 个排好序的最小代价，枚举最后一段排序长度，只有 $\\sqrt i$ 种选择，用单调栈+dsu 啥的求后缀最小值&emsp;&emsp;*K：观察多几个统计量，发现叶子数对于 $type$ 有显著关系&emsp;&emsp;BD： Petrozavodsk Winter-2017. Asia-Tsukuba 2016&emsp;&emsp;ABCDG：略&emsp;&emsp;E：$8!$ 枚举字母与符号的对应关系，然后表达式求值 考程设题很好玩吗？&emsp;&emsp;F：一开始默认都是 negative，然后 bfs 去把必要的东西翻成 positive&emsp;&emsp;H：每个无向连通块必须是树，把无向树缩起来，拓扑排序求最长路（无向树的结点就 dp 换根）&emsp;&emsp;*I：若 $d=\\gcd(x,y) &gt; 5 \\times 10^4$，则 $(0,0),(x-1,y),(\\frac xd,\\frac yd),(x,y-1)$；否则解不定方程 $ax+by=d$，则答案为 $(0,0),(x,y),(|b|,|a|)$&emsp;&emsp;J：设 $f_{x,y}$ 表示圆心在 $(x,y)$ 的答案，这个函数是凸的，模拟退火&emsp;&emsp;*K：surreal number + meet in the middle Petrozavodsk Summer-2017. JOI TST 2012 Selection&emsp;&emsp;A：dsu on tree&emsp;&emsp;B：扫描线得到若干个前缀立方体，要求体积并，枚举一维，set 维护折线&emsp;&emsp;C：暴力&emsp;&emsp;F：扫描线&emsp;&emsp;*G：链覆盖=二分图极大匹配，dp&emsp;&emsp;*I：设满足第 1 个人之后，第 $i$ 个人要顺时针转 $a_i$，那么按 $a_i$ 排序，代价是 $\\min_{j=2}^n(2a_j+n-a_{j+1})$，枚举断点维护这个&emsp;&emsp;DEHJ： XV Open Cup named after E.V. Pankratiev. GP of Central Europe (AMPPZ-2014)&emsp;&emsp;ABCD：队友说是沙雕题&emsp;&emsp;E：分类讨论，若 $p&lt;q \\land n \\ge p$ 则先手胜，根据这个来推导其余情况&emsp;&emsp;*F：先无视障碍物构造一个平凡的哈密顿回路，然后对于每个障碍物进行修正&emsp;&emsp;G：扫描右端点，单调栈维护区间最大最小，并依此用线段树维护可行左端点&emsp;&emsp;*I：每个上升序列会留下一半人，线段树维护上升序列&emsp;&emsp;*J：一个连通块用其 lca 来代表，两个连通块取交等价于两个 lca 取深度较深的那个，最后判断最终得到的点是否合法&emsp;&emsp;*K：每行建一个点，每列建一个点，对于原来的点 $(x,y)$ 将行 $x$ 连向列 $y$ 一条长度为 $0$ 的边，然后相邻两行、相邻两列连边，跑最短路 $x_1$ 到 $x_n$。&emsp;&emsp;H： XV Open Cup named after E.V. Pankratiev. GP of Europe (CEPC-2014)&emsp;&emsp;DEFK：略&emsp;&emsp;*A：离散化时间点，区间 dp，设 $f_{i,j}$ 表示只考虑完全包含在区间 $(i,j)$ 内的怪物的最小代价，转移就是枚举区间内最大的怪在什么时候被干掉&emsp;&emsp;B：回文树 dp，设 $f_i$ 表示 $i$ 这个回文串最后一步执行 2 操作得到该串所需要的最少步数&emsp;&emsp;^G：当前的形状一定是山峰形，状压 dp 设 $f_{i,s}$ 表示考虑了前 $i$ 个数，山峰左半边有 $s$ 这些数（前 $i$ 个数的和减去 $s$ 即可得到山峰右半边），是否可行&emsp;&emsp;*H：结论：若你的 prefer list 是 $(v_1,c_1),\\cdots,(v_{k+1},c_{k+1})$，则必有 $v_1&lt;v_2&lt;\\cdots&lt;v_{k+1}$。知道这个之后就倒着 $O(nk)$ dp&emsp;&emsp;J：比例就是全局的比例，然后贪心&emsp;&emsp;*L：线段树维护区间上凸壳&emsp;&emsp;CI： JAG Autumn 2014, MIPT2014 Round 1&emsp;&emsp;ABDG：队友说是沙雕题&emsp;&emsp;*C：dp，设 $f_i$ 表示走到 $i$ 然后建立存档点的最小期望时间，转移的决策点不会离 $i$ 太远，不然期望距离太大了&emsp;&emsp;F：先做网络流求不翻转的答案，翻转的边必然是一条从汇点集连向源点集、存在剩余流量的边&emsp;&emsp;H：表达式求值+基础几何&emsp;&emsp;J：tarjan+多重背包&emsp;&emsp;*K：一个格子加上往外两圈共 19 个格子，$2^{19}$ 枚举所有的可能性，看是否全部都满足中间格子的第一步等于第二步。这是充分必要条件&emsp;&emsp;EI： XIX Open Cup named after E.V. Pankratiev. Grand Prix of China&emsp;&emsp;F：队友说是沙雕题&emsp;&emsp;A：考虑每个第一次出现的数改成前面出现过的数或者后面第一次出现的数&emsp;&emsp;*D：生成函数推一波&emsp;&emsp;I：burnside+灵活使用组合数公式&emsp;&emsp;BCEGHJK： Petrozavodsk Winter-2019. Yandex Cup-2019&emsp;&emsp;A：满足贪心性质的&emsp;&emsp;C：上下界可行流&emsp;&emsp;-D：拟阵交&emsp;&emsp;H：每行最小值的最大值&emsp;&emsp;I：若不是完美匹配就一定可行，因此只要判断是否可以完美匹配，任意构造一种完美匹配然后判断方向和 $\\bmod 4$ 是否跟初始局面一致&emsp;&emsp;*J：左右晃荡直到到达原点&emsp;&emsp;BEFG： Petrozavodsk Winter-2019. Oleksandr Kulkov Contest 1&emsp;&emsp;F：队友说是沙雕题&emsp;&emsp;-A：类似于 FWT 的推法&emsp;&emsp;*D：固定一个足够大的 $n$，对于每个 $f_{n-b_i}$ 算出它关于 $f_1,\\cdots,f_k$ 的线性组合系数（需要常系数线性递推的优化），然后高斯消元&emsp;&emsp;E：每堆石子的最优处理方法是分裂出单独的一个，因此答案为总数除以 2 上取整&emsp;&emsp;H：二分出答案的下取整，然后推式子算出剩下的分数&emsp;&emsp;J：要么问号全都能推出来，要么问号全相同但不知道是什么。前者直接求完美匹配方案数，后者枚举问号是什么然后算完美匹配方案数（注意去重）&emsp;&emsp;^K：答案等于 $a_1-a_2$，因为后面的都被抵消掉了&emsp;&emsp;BCGI： Moscow Pre-Finals Workshop 2016. Japanese School OI Team Selection&emsp;&emsp;AC：队友说是沙雕题&emsp;&emsp;*D：每个格子按方向拆成两个点，连边，跑拓扑序&emsp;&emsp;*E：二分一个 $mid$（但实际上不需要二分），把队伍最后 $mid$ 个男人扔到最前面，队伍合法的条件是任意一个真后缀的 $F-M \\ge-1$&emsp;&emsp;G：环套树 dp&emsp;&emsp;*H：每个点连 8 条边（向上下左右最远的格子连 $1$ 边，向上下左右相邻的格子连 $2$ 边），跑三队列 bfs&emsp;&emsp;*I：从大到小贪心匹配，若一个人只剩一个名额了也要立即匹配，用线段树维护&emsp;&emsp;BF： XXI Open Cup named after E.V. Pankratiev. Grand Prix of Wroclaw&emsp;&emsp;^B：有两条平行线或大于等于三条线时都是 100%，其余情况讨论一下&emsp;&emsp;C：要么环上选 3 个点，要么全选叶子然后环上最多选两个相邻的点&emsp;&emsp;D：缩环以后设有 $n$ 个点，需要找若干条线段使得能够覆盖 $[1,n]$，这等价于给 $(i,i-1)$ 连了 $0$ 边后从 $1$ 走到 $n$ 的最短路&emsp;&emsp;E：每棵树是一个限制条件，列方程，善用 $\\cos^2 \\alpha+\\sin^2 \\alpha=1$ 化简&emsp;&emsp;FG：队友说是沙雕题&emsp;&emsp;I：$\\gcd(i,j)=xor(i,j)=i-j$，枚举 $i-j$&emsp;&emsp;^J：总周长是 $O(n^2)$ 的，因此只有 $O(n)$ 种不同的周长&emsp;&emsp;K：超边建方点，圆点到方点代价为 $1$，方点到圆点代价为 $0$，时间倒流跑 floyd&emsp;&emsp;M：每个 $a_i$ 二分求出以 $a_i$ 为最大值时能取的最长连续段，这就知道了最多保留多少人；符合“保留最多”的 $a_i$ 再二分求出把最长连续段的最后一个人扔掉换一个更小的能有多小&emsp;&emsp;AHL： SWERC-2020&emsp;&emsp;AE：略&emsp;&emsp;C：二分，判断边界的连通性&emsp;&emsp;D：每条边能到达等价于起点到它任一端点的最短距离 $&lt; U$&emsp;&emsp;F：设 $dp_{i,j}$ 表示前 $i$ 个点共形成了 $j$ 个子树的方案数，转移就是考虑 $i$ 是合并两棵子树、合并一棵子树还是新开一棵子树，如果 $i=R$ 就只能新开一棵子树&emsp;&emsp;G：建出环套树，求每个点往前走 $k$ 步所经过的点权和&emsp;&emsp;H：主席树&emsp;&emsp;*I：等价于求直径的对数且允许两倍误差。任选一个点出发，求其最远点，然后从最远点出发求新的最远点，迭代 100 次&emsp;&emsp;K：任意后缀数据结构&emsp;&emsp;L：稳定婚姻问题&emsp;&emsp;BJM： XX Open Cup named after E.V. Pankratiev. Grand Prix of Eurasia&emsp;&emsp;AC：略&emsp;&emsp;F：先用 $3n$ 步把所有元素按大类分好（依次扫描每个栈，把元素分到相应的大类，属于自己的元素分到下一个大类），然后每个栈 $O(\\log_kn)$ 归并排序&emsp;&emsp;I：平铺即可，注意数字比大小是字典序大小不是数值大小&emsp;&emsp;*J：$n \\le 26$ 状压 dp，$n&gt;26$ 贪心每个位置找最远的，一定能找到无解答案&emsp;&emsp;BDEGHK： Moscow WorkshopByteDance 2020 Online Selection&emsp;&emsp;M：略&emsp;&emsp;A：&emsp;&emsp;C：二分+圆交（面积交大于 0，或者每个交点都判一下合不合法）&emsp;&emsp;*D：黑白染色，最后黑白颜色数量之差就是无法被覆盖的格子数&emsp;&emsp;*E：dp，枚举 $i$，每个出现过的数字最后两次出现的位置假设为 $x$ 和 $y$，把 $x+1$ 到 $y$ 连一条线段，那么线段并就是可以做贡献的位置，位置 $j$ 的贡献是 $f_{j-1}$，线段树实现。&emsp;&emsp;*J：树形 dp，设 $f_{i,0/1,j}$ 表示 $i$ 号点，它连向父亲的边选 $0$ 或是选 $1$，最紧的限制还有 $j$ 的距离，的方案数。如果它选 $0$，意味着它只用考虑 $1$ 的限制了，那么儿子里 $1$ 的限制转移上来，$0$ 就没了。选 $1$ 同理。&emsp;&emsp;K：$1$ 至 $k$ 的逆序对要算进答案里，接下来大于 $k$ 的数字枚举一个分界线，分界线左边的放左边，右边的放右边&emsp;&emsp;K 加强（Cf Round 609）：加个线段树维护一下分界线的枚举&emsp;&emsp;L：队友说是沙雕题 ByteDance 2021 Online Qualification&emsp;&emsp;D：队友说是沙雕题&emsp;&emsp;E：善用 $\\gcd(a_1,a_2,\\cdots,a_n)=\\gcd(a_1,a_2-a_1,\\cdots,a_n-a_{n-1})$&emsp;&emsp;F：每次 fail 了一个 testcase 就把它所在的 subtask 及后继的其他 testcase 标为无效&emsp;&emsp;*G：做三个矩阵：行索引、列索引、逆索引，行 shift 就把行索引矩阵全体加减，列 shift 就把列索引矩阵全体加减，求逆就交换逆索引和行列索引&emsp;&emsp;*H：朴素想法是枚举上下边界，然后从左扫到右，维护线性基。改进是下边界下移的时候线性基不要重新构建，而是基于原有的增量更新&emsp;&emsp;I：类似于威佐夫博弈，求出每个 $x$ 的最小必败 $y$&emsp;&emsp;J：式子化成 $\\max_{选 k 个}\\min(\\sum_{i \\in 选了的 k 个} a_i,\\sum_{i \\in 选了的 k 个} b_i+\\sum_{i \\in 没选的} \\frac{b_i}{2})$，$O(n^4)$ dp&emsp;&emsp;^K：每张牌只跟红蓝谁大有关，跟具体数字无关，于是发现红大于蓝的牌更多就红胜，蓝大于红的牌更多就蓝胜，否则平&emsp;&emsp;*^L：首先观察到如果选定了 $n$ 个合法列，那么列是不用 shuffle 的。于是直接从左到右贪心选列，当前这列合法就保留，不合法就扔了 我不会证&emsp;&emsp;M：算每个格子的贡献，推下式子是个卷积&emsp;&emsp;ABC： Moscow Workshop Pre-Finals 2020Day 2 GP of Tokyo&emsp;&emsp;既然你都放到 cf 上了&emsp;&emsp;*D：先是一大串题意转化，变成每一位初始有若干个 $1$，每次可以选同一位的两个 $1$ 扔到下一位变成 4 个 $1$。题解做法是二分+dp（有用的状态数很少），我是贪心打补丁&emsp;&emsp;E：题意转化成若干不同的 $2$ 的幂乘到 $a_i$ 上，然后 $60\\cdot\\text{2e5}\\cdot200$的 dp 冲过去了&emsp;&emsp;*F：最短距离就是 $a_i$ 跟 $b_i$ 匹配，用数据结构优化一下算个方案&emsp;&emsp;H：$(-1e9,0) (1,1e9) (0,-1e9) (1e9,-1)$&emsp;&emsp;I：分奇偶构造，大概是 $2^i \\bmod n$ 这样轮回&emsp;&emsp;ABCGJKL： 2021 Petrozavodsk and Shanghai ICPC Training CampContest 1&emsp;&emsp;C：$E[x^2+y^2]=E[x^2]+E[y^2]$，考虑 $E[x^2] = E[(\\sum_{i=1}^n r_i\\cos \\theta_i)^2]$，展开之后交叉项都消掉了，自身平方项大力积分&emsp;&emsp;D：对于 $k$，最优方案是先找到一个 $type$ 把最小变最大，然后剩下 $k-1$ 步将全局的前 $k-1$ 小变成第一步的最大。按 $level_i$ 排序，决策单调&emsp;&emsp;E：直接 $O(m 2^n)$ dp&emsp;&emsp;*H：每次询问，从大到小加入 $a_i$，每次加入一个数会合并左右连续段成为一个大的连续段，这个连续段的 $\\min(len,\\max a-\\min a)$ 贡献到答案里&emsp;&emsp;ABFGIJ： Contest 2&emsp;&emsp;破 oj 写啥都 TLE，成心跟我过不去&emsp;&emsp;*E：只有 $C=M$ 和 $C=M+1$ 两种情况，求出最大匹配（随机匈牙利，带花树会 T），枚举一个额外点，每条匹配边恰好选一个点，所以是 2-SAT&emsp;&emsp;*G：每个质因子的每个极长连续段都是独立的游戏，长为 $len$ 的连续段的 $SG$ 值恰好为 $len$。快速分解质因数：先预处理 $10^6$ 的质因子，剩下的数只可能是 $p,p^2,pq$，分别用 Miller_Rabin、开根号、两两求 $\\gcd$ 解决&emsp;&emsp;^I：注意 $p$ 互不相同，所以有效的 $k$ 很小，是 $O(\\sqrt[3]{C})$ 的，因此直接 $O(nk)$ dp&emsp;&emsp;J：以 $B$ 为“升序”，$A$ 只需每次将最大的扔到最后，然后变为子问题即可&emsp;&emsp;^M：样例已经给出了 $10^6$ 的答案了，倒推快速幂即可&emsp;&emsp;ABCDFHKL：","categories":[{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[]},{"title":"【XVIII Open Cup E.V. Pankratiev. Grand Prix of Korea. J】Game of Sorting 题解","slug":"【XVIII Open Cup E.V. Pankratiev. Grand Prix of Korea. J】Game of Sorting 题解","date":"2020-04-10T02:46:41.000Z","updated":"2024-04-24T03:59:22.873Z","comments":true,"path":"【XVIII Open Cup E.V. Pankratiev. Grand Prix of Korea. J】Game of Sorting 题解/","link":"","permalink":"http://kqp.world/%E3%80%90XVIII%20Open%20Cup%20E.V.%20Pankratiev.%20Grand%20Prix%20of%20Korea.%20J%E3%80%91Game%20of%20Sorting%20%E9%A2%98%E8%A7%A3/","excerpt":"题目大意&emsp;&emsp;对于一个序列 $a_1,\\cdots,a_n$，Alice 和 Bob 在上面博弈，Alice 先手，两人轮流操作，每人每次要么拿走第一个元素或者最后一个元素，谁先使得这个序列不增或不降就获胜（如果一开始就不增或不降那么 Bob 获胜）。&emsp;&emsp;现在给定一个序列 $a_1,\\cdots,a_n$，有 $Q$ 个询问，每次询问给出 $l,r$，问 $a_l,a_{l+1},\\cdots,a_r$ 的博弈结果。 &emsp;&emsp;$n,Q \\leq 10^6,\\ \\ a_i \\leq 10^9$&emsp;&emsp;3s","text":"题目大意&emsp;&emsp;对于一个序列 $a_1,\\cdots,a_n$，Alice 和 Bob 在上面博弈，Alice 先手，两人轮流操作，每人每次要么拿走第一个元素或者最后一个元素，谁先使得这个序列不增或不降就获胜（如果一开始就不增或不降那么 Bob 获胜）。&emsp;&emsp;现在给定一个序列 $a_1,\\cdots,a_n$，有 $Q$ 个询问，每次询问给出 $l,r$，问 $a_l,a_{l+1},\\cdots,a_r$ 的博弈结果。 &emsp;&emsp;$n,Q \\leq 10^6,\\ \\ a_i \\leq 10^9$&emsp;&emsp;3s \\\\ \\\\ \\\\题解&emsp;&emsp;这官方题解写得。。。真的想让人大喊“出题人重修离散数学！” &emsp;&emsp;暴力一点想，可以先弄个区间 dp，设 $f_{l,r}$ 表示操作 $[l,r]$ 这个区间时是否是先手必胜。那么 $f_{l,r}=\\lnot f_{l,r-1} \\lor \\lnot f_{l+1,r}$。 &emsp;&emsp;怎么优化这个东西呢？题解的思路是观察发现大部分时候 $f_{l,r}=f_{l+1,r-1}$。 &emsp;&emsp;具体的分类讨论是这样子的：&emsp;&emsp;设区间 $[l,r]$ 里面的最长单调段的长度为 $len$。 $len=r-l+1$，即 $[l,r]$ 本身是单调段，先手必败； $len=r-l$，根据上条可得这种情况先手必胜； $len=r-l-1$，这里又分为 $[l,r-2]$ 是单调段、$[l+1,r-1]$ 是单调段、$[l+2,r]$ 是单调段三种情况:3.1. 若 $[l,r-2]$ 是单调段，那么正常情况下大家都不会拿最后一个（不然对面再拿掉倒数第二个就 over 了），因此都是从左往右拿，直到剩下的是个单调段为止。那么就可以预处理 $L_i$ 表示以 $i$ 为右端点的最长单调段到哪，这样就可以算出步数，根据奇偶性算出先手的胜负；（注意一类特殊情况，例如 $1,2,3,4,4,4,2,3$，当拿剩 $4,4,4,2,3$ 的时候，先手直接拿掉最后一个，获胜）3.2. $[l+2,r]$ 是单调段的情况同理；3.3. 若 $[l+1,r-1]$ 是单调段，先手后手一前一后完事，先手必败。 &emsp;&emsp;以上这三种情况可以称之为“终止态”，因为它们可以 $O(1)$ 计算答案了。 $len&lt;r-l-1$，此时 $[l,r-2]$、$[l+1,r-1]$、$[l+2,r]$ 都是可操作的区间。展开那个暴力的 dp 转移式： \\begin{aligned} f_{l,r}&=\\lnot f_{l,r-1} \\lor \\lnot f_{l+1,r} \\\\ &=(f_{l,r-2} \\land f_{l+1,r-1}) \\lor (f_{l+1,r-1} \\land f_{l+2,r}) \\end{aligned}观察发现，若 $f_{l+1,r-1}=0$，则直接 $f_{l,r}=0$；若 $f_{l+1,r-1}=1$，则必有 $f_{l+1,r-2}=0$ 或 $f_{l+2,r-1}=0$，前者会导致 $f_{l,r-2}=1$，后者会导致 $f_{l+2,r}=1$，两者代入转移式都会使 $f_{l,r}=1$。因此 $f_{l,r}=f_{l+1,r-1}$。 &emsp;&emsp;这样就讨论完了。最终做法的思路就是，将 $[l,r]$ 往里缩，缩到终止态为止。这个终止态是什么呢？可以根据 $[l,r]$ 的对称轴所在的极长单调段算出来。&emsp;&emsp;注意一个元素（或元素间的缝）可能同时属于两个极长单调段。 &emsp;&emsp;具体实现，预处理的时候，可以找出所有极长不降段、极长不升段，合并得到极长单调段覆盖。可以 $O(n \\log n)$ 也可以 $O(n)$。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include&lt;bits/stdc++.h&gt;#define fo(i,a,b) for(int i=a;i&lt;=b;i++)using namespace std;typedef pair&lt;int,int&gt; pr;const int maxn=1e6+5;int n,a[maxn];pr v[2*maxn],seg[2*maxn];int v0,seg0,sr[2*maxn],R[maxn],L[maxn];bool cmpV(const pr &amp;a,const pr &amp;b)&#123; return a.first&lt;b.first || a.first==b.first &amp;&amp; a.second&gt;b.second;&#125;void Pre()&#123; int last=1; fo(i,2,n) if (a[i-1]&gt;a[i]) &#123; v[++v0]=make_pair(last,i-1); last=i; &#125; v[++v0]=make_pair(last,n); last=1; fo(i,2,n) if (a[i-1]&lt;a[i]) &#123; v[++v0]=make_pair(last,i-1); last=i; &#125; v[++v0]=make_pair(last,n); sort(v+1,v+1+v0,cmpV); last=1; fo(i,1,v0) if (v[i].second&gt;seg[seg0].second) &#123; fo(j,last,v[i].first-1) R[j]=seg[seg0].second; last=v[i].first; seg[++seg0]=v[i], sr[seg0]=v[i].second; &#125; fo(j,last,n) R[j]=n; for(int i=n, j=seg0; i&gt;=1; i--) &#123; if (j &amp;&amp; i==seg[j-1].second) j--; L[i]=seg[j].first; &#125;&#125;int T;int main()&#123; scanf(&quot;%d&quot;,&amp;n); fo(i,1,n) scanf(&quot;%d&quot;,&amp;a[i]); Pre(); scanf(&quot;%d&quot;,&amp;T); while (T--) &#123; int l,r,mid; scanf(&quot;%d %d&quot;,&amp;l,&amp;r); mid=(l+r)&gt;&gt;1; int ll, rr, x=lower_bound(sr+1,sr+1+seg0,(l+r+1)&gt;&gt;1)-sr, even=!((r-l+1)&amp;1); int t=min(mid-seg[x].first+even,seg[x].second-mid); if (x+1&lt;=seg0 &amp;&amp; seg[x+1].first&lt;=mid) t=max(t,min(mid-seg[x+1].first+even,seg[x+1].second-mid)); t=min(t,min(mid-l+even,r-mid)); ll=mid-t+even, rr=mid+t; while (l&lt;ll &amp;&amp; rr&lt;r &amp;&amp; (R[ll-1]&gt;=rr-1 || R[ll+1]&gt;=rr+1)) ll--, rr++; if (R[ll]&gt;=rr) puts(&quot;Bob&quot;); else if (R[ll]==rr-1 || R[ll+1]&gt;=rr) puts(&quot;Alice&quot;); else if (R[ll]==rr-2) puts(((rr-ll+1-(rr-L[rr-1])-(R[rr-2]&gt;rr-1))&amp;1) ?&quot;Alice&quot; :&quot;Bob&quot;); else if (R[ll+2]&gt;=rr) puts(((rr-ll+1-(R[ll+1]-ll)-(R[ll]&gt;ll+1))&amp;1) ?&quot;Alice&quot; :&quot;Bob&quot;); else if (R[ll+1]==rr-1) puts(&quot;Bob&quot;); else assert(0); &#125;&#125;","categories":[{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[{"name":"算法_博弈","slug":"算法-博弈","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E5%8D%9A%E5%BC%88/"}]},{"title":"【2017 BSUIR Semifinal D】Friends rescue 题解","slug":"【2017 BSUIR Semifinal D】Friends rescue 题解","date":"2020-03-31T14:40:50.000Z","updated":"2024-04-24T03:59:22.801Z","comments":true,"path":"【2017 BSUIR Semifinal D】Friends rescue 题解/","link":"","permalink":"http://kqp.world/%E3%80%902017%20BSUIR%20Semifinal%20D%E3%80%91Friends%20rescue%20%E9%A2%98%E8%A7%A3/","excerpt":"题目大意&emsp;&emsp;有一个池塘，中间有 $n$ 行 $n+1$ 列的石头阵。&emsp;&emsp;连边只能连相邻的格子，相邻定义为四连通。&emsp;&emsp;现在左边第一列石头已经跟左边大陆 $L$ 相连，右边最后一列石头已经跟右边大陆 $R$ 相连。问剩下的有多少种连边方式，使得 $L$ 与 $R$ 连通。&emsp;&emsp;$n \\leq 42$","text":"题目大意&emsp;&emsp;有一个池塘，中间有 $n$ 行 $n+1$ 列的石头阵。&emsp;&emsp;连边只能连相邻的格子，相邻定义为四连通。&emsp;&emsp;现在左边第一列石头已经跟左边大陆 $L$ 相连，右边最后一列石头已经跟右边大陆 $R$ 相连。问剩下的有多少种连边方式，使得 $L$ 与 $R$ 连通。&emsp;&emsp;$n \\leq 42$ \\\\ \\\\ \\\\题解&emsp;&emsp;观察能力是真nmd缺啊。。。 &emsp;&emsp;看这个图&emsp;&emsp;绿色边不影响连通性，先不考虑。&emsp;&emsp;我们要连的是红色的边，考虑把这幅图的对偶图做出来（蓝边），如果某一条红边没有连上，那么就把对应的蓝边连上。&emsp;&emsp;于是就会发现，每一种连边方案，要么 $LR$ 连通，要么 $UD$ 连通。&emsp;&emsp;进而发现，红边的规模跟蓝边的规模是完全一样的，也就是说，任意一种 $LR$ 连通的方案，都可以翻转一下，成为一种 $UD$ 连通的方案，反之亦然。&emsp;&emsp;所以 $LR$ 连通的方案数等于 $UD$ 连通的方案数。&emsp;&emsp;所以 $LR$ 连通的方案数等于（红边的）总方案数除以 $2$，再乘上绿边的方案数。","categories":[{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[{"name":"算法_神奇的脑洞","slug":"算法-神奇的脑洞","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E7%A5%9E%E5%A5%87%E7%9A%84%E8%84%91%E6%B4%9E/"}]},{"title":"【2017 BSUIR Semifinal G】Digital characteristic 题解","slug":"【2017 BSUIR Semifinal G】Digital characteristic 题解","date":"2020-03-31T13:10:26.000Z","updated":"2024-04-24T03:59:22.802Z","comments":true,"path":"【2017 BSUIR Semifinal G】Digital characteristic 题解/","link":"","permalink":"http://kqp.world/%E3%80%902017%20BSUIR%20Semifinal%20G%E3%80%91Digital%20characteristic%20%E9%A2%98%E8%A7%A3/","excerpt":"题目大意&emsp;&emsp;定义函数 $f(n)$ 表示对 $n$ 一直求数位和直至 $n$ 为个位数，即： f(n)=\\begin{cases} n&n","text":"题目大意&emsp;&emsp;定义函数 $f(n)$ 表示对 $n$ 一直求数位和直至 $n$ 为个位数，即： f(n)=\\begin{cases} n&n","categories":[{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[{"name":"算法_数论","slug":"算法-数论","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E6%95%B0%E8%AE%BA/"}]},{"title":"【JZOJ4939】平均值 题解","slug":"【JZOJ4939】平均值 题解","date":"2020-03-30T03:52:30.000Z","updated":"2024-04-24T03:59:22.854Z","comments":true,"path":"【JZOJ4939】平均值 题解/","link":"","permalink":"http://kqp.world/%E3%80%90JZOJ4939%E3%80%91%E5%B9%B3%E5%9D%87%E5%80%BC%20%E9%A2%98%E8%A7%A3/","excerpt":"题目大意&emsp;&emsp;给定一个长度为 $n$ 的序列 $a_1,\\cdots,a_n$，求所有区间的 $mex$ 平均值之和，即 \\sum_{l=1}^n\\sum_{r=l}^n \\frac{mex(a_l,a_{l+1},\\cdots,a_r)}{r-l+1} \\pmod{998244353}&emsp;&emsp;$1 \\leq n \\leq 5 \\times 10^5,\\ \\ 0 \\leq a_i \\leq 5 \\times 10^5$","text":"题目大意&emsp;&emsp;给定一个长度为 $n$ 的序列 $a_1,\\cdots,a_n$，求所有区间的 $mex$ 平均值之和，即 \\sum_{l=1}^n\\sum_{r=l}^n \\frac{mex(a_l,a_{l+1},\\cdots,a_r)}{r-l+1} \\pmod{998244353}&emsp;&emsp;$1 \\leq n \\leq 5 \\times 10^5,\\ \\ 0 \\leq a_i \\leq 5 \\times 10^5$ \\\\ \\\\ \\\\题解&emsp;&emsp;这题大概是有两种解法，官方题解是转化成 $\\sum_{i=0}^{\\max\\{a\\}}\\sum_{l \\leq r} \\frac{[mex(a_l,\\cdots,a_r) \\geq i]}{r-l+1}$ 来做，但它比较简略我没搞懂。于是又找到了HOWARLI的做法，我这个就是参考他的。被吊打啦 &emsp;&emsp;有一种传统建模是，左端点从右往左移动，用线段树维护右端点的答案。但是在这题，左端点往左移相当于给若干个序列插入一个元素， $mex$ 怎么变就很难搞了。 &emsp;&emsp;但是变通一下，左端点从左往右移，就很好搞了。因为这对于 $mex$ 来说相当于是区间取 $\\min$ 的操作。&emsp;&emsp;当左端点从 $i-1$ 移到 $i$，就相当于删去 $a_{i-1}$，假设 $i-1$ 后面的第一个跟 $a_{i-1}$ 相同的元素是 $a_{next_{i-1}}$，那么删去 $a_{i-1}$ 影响到的右端点范围就是 $[i,next_{i-1})$。在这个范围里所有 $mex$ 值大于 $a_{i-1}$ 的都会变成 $a_{i-1}$。&emsp;&emsp;由于 $mex$ 是分段递增的，我们在这个范围内找到所有 $mex$ 值大于 $a_{i-1}$ 的段，结算它们的贡献，并更新它们。&emsp;&emsp;假设一个段 $[l,r]$，$mex$ 值为 $m$。对于里面的一个元素 $x~(x \\in [l,r])$，它最早在左端点为 $t$ 时把 $mex$ 值更新为 $m$，那么它要结算的贡献就是 $m(\\frac{1}{x-t+1}+\\cdots+\\frac{1}{x-(i-1)+1})$，即 $m(s_{x-t+1}-s_{x-(i-1)})$（记 $s_n=\\sum_{i=1}^n \\frac 1i$）。&emsp;&emsp;于是用线段树维护一下 $mex$ 的分段、区间 $\\sum s_{x-t+1}$ 即可。&emsp;&emsp;每次左端点的移动，最多新增 2 个段，删除若干个段，因此段的总量也是 $O(n)$ 的。时间复杂度 $O(n \\log n)$。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define fo(i,a,b) for(int i=a;i&lt;=b;i++)#define fd(i,a,b) for(int i=a;i&gt;=b;i--)using namespace std;typedef long long LL;const int maxn=5e5+5;const LL mo=998244353;struct TR&#123; int minmex,maxmex; LL st;&#125;;int n,a[maxn];LL Pow(LL x,LL y)&#123; LL re=1; for(; y; y&gt;&gt;=1, x=x*x%mo) if (y&amp;1) re=re*x%mo; return re;&#125;int ap[maxn],nxt[maxn],init_mex[maxn];LL s[maxn],ss[maxn];void Pre()&#123; fd(i,n,1) &#123; nxt[i]=(!ap[a[i]]) ?n+1 :ap[a[i]]; ap[a[i]]=i; &#125; memset(ap,0,sizeof(ap)); int mex=0; fo(i,1,n) &#123; ap[a[i]]=1; while (ap[mex]) mex++; init_mex[i]=mex; &#125; fo(i,1,n) s[i]=(s[i-1]+Pow(i,mo-2))%mo, ss[i]=(ss[i-1]+s[i])%mo;&#125;TR tr[4*maxn];pair&lt;int,int&gt; bz[4*maxn];TR merge(const TR &amp;a,const TR &amp;b)&#123; return (TR)&#123;min(a.minmex,b.minmex),max(a.maxmex,b.maxmex),(a.st+b.st)%mo&#125;;&#125;void update(int k,int t,int l,int mid,int r)&#123; if (!bz[k].first) return; tr[t]=(TR)&#123;bz[k].second,bz[k].second,(ss[mid-bz[k].first+1]-ss[l-bz[k].first]+mo)%mo&#125;; tr[t+1]=(TR)&#123;bz[k].second,bz[k].second,(ss[r-bz[k].first+1]-ss[mid+1-bz[k].first]+mo)%mo&#125;; bz[t]=bz[t+1]=bz[k]; bz[k]=make_pair(0,0);&#125;void tr_js(int k,int l,int r)&#123; if (l==r) &#123; tr[k]=(TR)&#123;init_mex[r],init_mex[r],s[r]&#125;; return; &#125; int t=k&lt;&lt;1, mid=(l+r)&gt;&gt;1; tr_js(t,l,mid), tr_js(t+1,mid+1,r); tr[k]=merge(tr[t],tr[t+1]);&#125;pair&lt;int,int&gt; cx_bs(int k,int l,int r,int x,int z)&#123; if (l==r) return (tr[k].maxmex&gt;z) ?make_pair(l,tr[k].maxmex) :make_pair(-1,-1) ; int t=k&lt;&lt;1, mid=(l+r)&gt;&gt;1; update(k,t,l,mid,r); return (x&lt;=mid &amp;&amp; tr[t].maxmex&gt;z) ?cx_bs(t,l,mid,x,z) :cx_bs(t+1,mid+1,r,x,z);&#125;int cx_r(int k,int l,int r,int x,int z)&#123; if (l==r) return l; int t=k&lt;&lt;1, mid=(l+r)&gt;&gt;1; update(k,t,l,mid,r); return (x&lt;=mid &amp;&amp; tr[t+1].minmex&gt;z) ?cx_r(t,l,mid,x,z) :cx_r(t+1,mid+1,r,x,z);&#125;LL cx_st(int k,int l,int r,int x,int y)&#123; if (x&lt;=l &amp;&amp; r&lt;=y) return tr[k].st; int t=k&lt;&lt;1, mid=(l+r)&gt;&gt;1; update(k,t,l,mid,r); LL re=0; if (x&lt;=mid) re=cx_st(t,l,mid,x,y); if (mid&lt;y) (re+=cx_st(t+1,mid+1,r,x,y))%=mo; return re;&#125;void tr_xg(int k,int l,int r,int x,int y,pair&lt;int,int&gt; z)&#123; if (x&lt;=l &amp;&amp; r&lt;=y) &#123; tr[k]=(TR)&#123;z.second,z.second,(ss[r-z.first+1]-ss[l-z.first]+mo)%mo&#125;; bz[k]=z; return; &#125; int t=k&lt;&lt;1, mid=(l+r)&gt;&gt;1; update(k,t,l,mid,r); if (x&lt;=mid) tr_xg(t,l,mid,x,y,z); if (mid&lt;y) tr_xg(t+1,mid+1,r,x,y,z); tr[k]=merge(tr[t],tr[t+1]);&#125;int main()&#123; freopen(&quot;average.in&quot;,&quot;r&quot;,stdin); freopen(&quot;average.out&quot;,&quot;w&quot;,stdout); scanf(&quot;%d&quot;,&amp;n); fo(i,1,n) scanf(&quot;%d&quot;,&amp;a[i]); Pre(); tr_js(1,1,n); LL ans=0; fo(i,1,n) &#123; if (i&gt;1) &#123; for(int l=i, r; l&lt;nxt[i-1]; l=r+1) &#123; pair&lt;int,int&gt; t=cx_bs(1,1,n,l,a[i-1]); l=t.first; if (l==-1 || l&gt;=nxt[i-1]) break; r=min(cx_r(1,1,n,l,t.second),nxt[i-1]-1); (ans+=(cx_st(1,1,n,l,r)-ss[r-(i-1)]+mo+ss[l-(i-1)-1])%mo*t.second)%=mo; tr_xg(1,1,n,l,r,make_pair(i,a[i-1])); &#125; &#125; (ans+=cx_st(1,1,n,i,i)*(a[i]==0))%=mo; &#125; printf(&quot;%lld\\n&quot;,ans);&#125;","categories":[{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[{"name":"算法_线段树","slug":"算法-线段树","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E7%BA%BF%E6%AE%B5%E6%A0%91/"}]},{"title":"【2018 BSUIR Final C】Partial Sums 题解","slug":"【2018 BSUIR Final C】Partial Sums 题解","date":"2020-03-28T15:06:16.000Z","updated":"2024-04-24T03:59:22.804Z","comments":true,"path":"【2018 BSUIR Final C】Partial Sums 题解/","link":"","permalink":"http://kqp.world/%E3%80%902018%20BSUIR%20Final%20C%E3%80%91Partial%20Sums%20%E9%A2%98%E8%A7%A3/","excerpt":"题目大意&emsp;&emsp;给定一个 $n \\times m$ 的 01 矩阵 $A_0$。定义一次操作为将这个矩形每个元素求异或前缀和，即 $A_k[i,j]=(\\sum_{u=1}^i\\sum_{v=1}^j A_{k-1}[u,v]) \\bmod 2$。&emsp;&emsp;求一个最小的正整数 $k$，使得 $A_0=A_k$。 &emsp;&emsp;$n\\times m \\leq 10^6$","text":"题目大意&emsp;&emsp;给定一个 $n \\times m$ 的 01 矩阵 $A_0$。定义一次操作为将这个矩形每个元素求异或前缀和，即 $A_k[i,j]=(\\sum_{u=1}^i\\sum_{v=1}^j A_{k-1}[u,v]) \\bmod 2$。&emsp;&emsp;求一个最小的正整数 $k$，使得 $A_0=A_k$。 &emsp;&emsp;$n\\times m \\leq 10^6$ \\\\ \\\\ \\\\题解&emsp;&emsp;首先，可以发现答案一定是 $2$ 的幂。&emsp;&emsp;可以这么说明这个结论，设 $k_{i,j}$ 表示左上角为 $(1,1)$ 右下角为 $(i,j)$ 的子矩形的答案，那么 $k_{i,j}$ 至少为 $lcm(k_{i-1,j},k_{i,j-1})$，如果这 $lcm$ 轮过后 $(i,j)$ 的元素没变，那么 $k_{i,j}$ 就等于这个，否则还要再来 $lcm$ 轮把它变回来，即 $k_{i,j}=lcm \\cdot 2$。而又因为 $k_{1,1}=1$，因此可以归纳证明任意 $k_{i,j}$ 一定是 $2$ 的幂。 &emsp;&emsp;然后想一个问题，如果经过 $k$ 轮操作，那么一个格子 $(x,y)$ 对其右下的一个格子 $(x+\\Delta x,y+\\Delta y)$ 的贡献是多少？&emsp;&emsp;这等价于一个棋子从 $(x,y)$ 开始，每次跳到其右下方的一个位置（包括自己本身），跳 $k$ 步跳到 $(x+\\Delta x,y+\\Delta y)$，的方案数是多少。&emsp;&emsp;这显然是 $\\binom{\\Delta x+k-1}{k-1} \\cdot \\binom{\\Delta y+k-1}{k-1}$。&emsp;&emsp;而根据 Lucas 定理，当 $k$ 为 $2$ 的幂时，只有当 $\\Delta x$ 和 $\\Delta y$ 都是 $k$ 的倍数的时候，这个式子才 $\\bmod~2=1$。 &emsp;&emsp;于是我们就可以 $k=1,2,4,8,\\cdots$ 这样枚举答案，每次枚举中，每个位置只考虑 $\\Delta x$ 和 $\\Delta y$ 是 $k$ 倍数的位置的贡献，可以 $O(nm)$ 得出最终矩阵并判断。（看代码）&emsp;&emsp;同时这样也说明答案不会很大，最多判断 $\\log nm$ 次。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;bits/stdc++.h&gt;#define fo(i,a,b) for(int i=a;i&lt;=b;i++)using namespace std;typedef long long LL;const int maxn=1e6+5;int n,m;bool a[maxn];inline int id(int i,int j) &#123;return (i-1)*m+j;&#125;void ReadBit(bool &amp;data)&#123; char ch=getchar(); while (ch!=&#x27;0&#x27; &amp;&amp; ch!=&#x27;1&#x27;) ch=getchar(); data=(ch==&#x27;1&#x27;);&#125;bool b[maxn];bool check(int k)&#123; fo(i,1,n) fo(j,1,m) &#123; b[id(i,j)]=a[id(i,j)]; if (i&gt;k) b[id(i,j)]^=b[id(i-k,j)]; if (j&gt;k) b[id(i,j)]^=b[id(i,j-k)]; if (i&gt;k &amp;&amp; j&gt;k) b[id(i,j)]^=b[id(i-k,j-k)]; if (b[id(i,j)]!=a[id(i,j)]) return 0; &#125; return 1;&#125;int main()&#123; scanf(&quot;%d %d&quot;,&amp;n,&amp;m); fo(i,1,n) fo(j,1,m) ReadBit(a[id(i,j)]); int k=1; while (!check(k)) k&lt;&lt;=1; printf(&quot;%d\\n&quot;,k);&#125;","categories":[{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[]},{"title":"【AtCoder Grand 028E】High Elements 题解","slug":"【AtCoder Grand 028E】High Elements 题解","date":"2020-03-25T15:20:15.000Z","updated":"2024-04-24T03:59:22.824Z","comments":true,"path":"【AtCoder Grand 028E】High Elements 题解/","link":"","permalink":"http://kqp.world/%E3%80%90AtCoder%20Grand%20028E%E3%80%91High%20Elements%20%E9%A2%98%E8%A7%A3/","excerpt":"题目大意&emsp;&emsp;给定一个长度为 $n$ 的排列。&emsp;&emsp;现在有两个空数组 $X$ 和 $Y$，你要依次把排列的每个元素放到 $X$ 数组或者 $Y$ 数组，使得最后 $X$ 数组和 $Y$ 数组的 high element 个数相同。定义数组中一个元素为 high element 当且仅当它是其前缀最大值。&emsp;&emsp;一个元素放 $X$ 数组记为 $0$，放 $Y$ 数组记为 $1$，你要求字典序最小的方案，或输出无解。 &emsp;&emsp;$n \\leq 2 \\times 10^5$","text":"题目大意&emsp;&emsp;给定一个长度为 $n$ 的排列。&emsp;&emsp;现在有两个空数组 $X$ 和 $Y$，你要依次把排列的每个元素放到 $X$ 数组或者 $Y$ 数组，使得最后 $X$ 数组和 $Y$ 数组的 high element 个数相同。定义数组中一个元素为 high element 当且仅当它是其前缀最大值。&emsp;&emsp;一个元素放 $X$ 数组记为 $0$，放 $Y$ 数组记为 $1$，你要求字典序最小的方案，或输出无解。 &emsp;&emsp;$n \\leq 2 \\times 10^5$ \\\\ \\\\ \\\\题解&emsp;&emsp;（看题解学的思路，这里差不多就是把题解翻译了一遍。。。 &emsp;&emsp;首先大的框架肯定是贪心，贪心考虑每一位能不能放 $X$，不行的话能不能放 $Y$。&emsp;&emsp;所以问题相当于，现在 $X$ 数组里最大值为 $h_X$，high element 数量为 $c_X$，$Y$ 数组里最大值为 $h_Y$，high element 数量为 $c_Y$，排列里剩下的元素是否存在分配方案使得最后 $c_X=c_Y$。 &emsp;&emsp;然后需要观察两条性质：&emsp;&emsp;1、原排列里的 high element 分配到数组里以后仍然是 high element。（很显然)&emsp;&emsp;2、假设成功分配的话最后各数组的 high element 长这样： $h_X &lt; a_1 &lt; a_2 &lt; \\cdots a_x$ $h_Y &lt; b_1 &lt; b_2 &lt; \\cdots b_y$ 满足 $c_X+x=c_Y+y$ &emsp;&emsp;那么必然存在一种分配方案，使得 $a_1,\\cdots,a_x$ 全是原排列的 high element，或使得 $b_1,\\cdots,b_y$ 全是原排列的 high element。&emsp;&emsp;（证明：不然的话，$a_1,\\cdots,a_x$ 中存在一项不是原排列的 high element，那把它丢到 $Y$ 数组去它就不产生贡献了，同理也把 $b$ 中的一个非原排列 high element 项丢到 $X$ 去。这样不会破坏 $c_X+x=c_Y+y$ 这条性质。） &emsp;&emsp;于是首先假设 $a_1,\\cdots,a_x$ 全是原排列的 high element（反过来同理）。那么我们只需要考虑 $b_1,\\cdots,b_y$ 怎么选，选好之后剩下的 high element 丢给 $X$ 组成 $a_1,\\cdots,a_x$，剩下的非 high element 在哪边不产生贡献就留在哪边，即可。&emsp;&emsp;设排列（当前剩余部分）有 $Q$ 个元素是原来的 high element，那么我们需要选择 $b_1,\\cdots,b_y$ 使得 $c_X+Q-k=c_Y+y$，其中 $k$ 表示 $b_1,\\cdots,b_y$ 中的原排列 high element 的数量。&emsp;&emsp;移项得 $c_X-c_Y+Q=y+k=2k+(y-k)$。而等式左边是个定值。这相当于，我从剩余的排列中选一个上升子序列，其中如果这个元素是原排列的 high element 就得 2 分，否则得 1 分，问能否凑出 $c_X-c_Y+Q$ 分。&emsp;&emsp;再观察发现，如果我有选 1 分元素，所能获得的最大得分是 $m$，那么 $[0,m]$ 这个区间的得分都是可以达到的。如果我只选了 2 分元素，能获得的最大得分是 $m$，那么 $[0,m]$ 这个区间的偶数得分也都是可以达到的。&emsp;&emsp;因此只需要求最大得分就行了。这是个类似 LIS 的 dp，设 $f_{i,0/1}$ 表示从排列的第 $i$ 项开始，不选 / 选过 1 分元素所能获得的最大得分。&emsp;&emsp;把这个 dp 值保存在线段树上（$f_{i}$ 的值保存在 $p_i$ 的位置），这样就一边贪心一边询问了，时间复杂度 $O(n \\log n)$。 代码// 自从学了日语，变量名都开始用日语了。。人家日语题面就是“高い項”嘛肯定是用 takai 啦 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include&lt;bits/stdc++.h&gt;#define fo(i,a,b) for(int i=a;i&lt;=b;i++)#define fd(i,a,b) for(int i=a;i&gt;=b;i--)using namespace std;typedef long long LL;const int maxn=2e5+5;int n,a[maxn],Q;bool takai[maxn];int tr[2][4*maxn];int tr_cx(int ty,int k,int l,int r,int x)&#123; if (x&gt;n) return 0; int re=0; while (l&lt;r) &#123; int t=k&lt;&lt;1, mid=(l+r)&gt;&gt;1; if (x&lt;=mid) re=max(re,tr[ty][t+1]), k=t, r=mid; else k=t+1, l=mid+1; &#125; return max(re,tr[ty][k]);&#125;void tr_xg(int ty,int k,int l,int r,int x,int z)&#123; if (l==r) &#123; tr[ty][k]=z; return; &#125; int t=k&lt;&lt;1, mid=(l+r)&gt;&gt;1; if (x&lt;=mid) tr_xg(ty,t,l,mid,x,z); else tr_xg(ty,t+1,mid+1,r,x,z); tr[ty][k]=max(tr[ty][t],tr[ty][t+1]);&#125;bool check(int hx,int hy,int cx,int cy,int ai)&#123; if (ai&gt;hx) hx=ai, cx++; int ned=cx-cy+Q; if (ned&gt;=0 &amp;&amp; (tr_cx(1,1,1,n,hy+1)&gt;=ned || !(ned&amp;1) &amp;&amp; tr_cx(0,1,1,n,hy+1)&gt;=ned)) return 1; ned=cy-cx+Q; if (ned&gt;=0 &amp;&amp; (tr_cx(1,1,1,n,hx+1)&gt;=ned || !(ned&amp;1) &amp;&amp; tr_cx(0,1,1,n,hx+1)&gt;=ned)) return 1; return 0;&#125;char ans[maxn];int main()&#123; scanf(&quot;%d&quot;,&amp;n); int maxa=0; fo(i,1,n) &#123; scanf(&quot;%d&quot;,&amp;a[i]); if (a[i]&gt;maxa) &#123; takai[i]=1; maxa=a[i]; Q++; &#125; &#125; fd(i,n,1) &#123; int tr0=tr_cx(0,1,1,n,a[i]+1), tr1=tr_cx(1,1,1,n,a[i]+1), f0, f1; if (takai[i]) f0=tr0+2, f1=(tr1) ?tr1+2 :0 ; else f0=0, f1=max(tr0,tr1)+1; tr_xg(0,1,1,n,a[i],f0); tr_xg(1,1,1,n,a[i],f1); &#125; int hx=0, hy=0, cx=0, cy=0; fo(i,1,n) &#123; Q-=takai[i]; tr_xg(0,1,1,n,a[i],0); tr_xg(1,1,1,n,a[i],0); if (check(hx,hy,cx,cy,a[i])) &#123; ans[i]=&#x27;0&#x27;; if (a[i]&gt;hx) hx=a[i], cx++; &#125; else if (check(hy,hx,cy,cx,a[i])) &#123; ans[i]=&#x27;1&#x27;; if (a[i]&gt;hy) hy=a[i], cy++; &#125; else &#123; puts(&quot;-1&quot;); return 0; &#125; &#125; printf(&quot;%s\\n&quot;,ans+1);&#125;","categories":[{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[{"name":"算法_神奇的脑洞","slug":"算法-神奇的脑洞","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E7%A5%9E%E5%A5%87%E7%9A%84%E8%84%91%E6%B4%9E/"},{"name":"算法_DP","slug":"算法-DP","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-DP/"}]},{"title":"析合树形态计数 dp","slug":"析合树形态计数 dp","date":"2020-03-10T15:56:39.000Z","updated":"2024-04-24T03:59:22.883Z","comments":true,"path":"析合树形态计数 dp/","link":"","permalink":"http://kqp.world/%E6%9E%90%E5%90%88%E6%A0%91%E5%BD%A2%E6%80%81%E8%AE%A1%E6%95%B0%20dp/","excerpt":"&emsp;&emsp;正儿八经的用析合树本身的题没见着，析合树形态计数倒是一大堆。。。","text":"&emsp;&emsp;正儿八经的用析合树本身的题没见着，析合树形态计数倒是一大堆。。。 &emsp;&emsp;名词注释：&emsp;&emsp;子段：一个排列中的连续子序列&emsp;&emsp;非平凡子段：长度大于 $1$、且不为排列本身的子段&emsp;&emsp;连续段：若把一个子段的元素重排后是连续的，那么这个子段是一个连续段，比如 $[3,5,4,7,6]$ V1 题源：【2018-2019 ICPC, NEERC, Northern Eurasia Finals】I. Interval-Free Permutations 题目大意&emsp;&emsp;给定 $n$，求有多少长度为 $n$ 的排列，满足该排列任意一个非平凡子段都不是连续段。 &emsp;&emsp;$n \\leq 400$&emsp;&emsp;多测，$T \\leq 50000$，同一个数据点的所有 test case 模数相同，模数 $\\in [10^8,10^9]$&emsp;&emsp;1.5s 题解&emsp;&emsp;学习了析合树之后，就知道这等价于问有多少析合树，根节点为析点，它有 $n$ 个儿子，且全是叶子。（$n \\leq 3$ 特判） &emsp;&emsp;设 $X_i$ 表示根节点是析点、有 $i$ 个叶子儿子的方案数。也就是答案。&emsp;&emsp;基本思路是 $X_i=i!-(根是合点)-(根是析点但儿子数量 \\in [4,i-1])$。 &emsp;&emsp;第一种情况，根是合点：先假设这是个单调上升的合点。枚举它的第一个儿子的大小 $j$，后面的儿子就任意了。由于这是第一个儿子，因此这个儿子任意一个严格前缀不能是 $1$ 开头的连续段。&emsp;&emsp;因此算一个 $H_i$ 表示“长度为 $i$、任意一个严格前缀都不是以 $1$ 开头的连续段”的排列的数量。容斥一下即可得 $H_i=i!-\\sum_{j=1}^{i-1}H_j \\cdot (i-j)!$。&emsp;&emsp;最后，根单调下降的方案数等于单调上升的方案数，所以根是合点且有 $i$ 个儿子的方案数就是 $2\\sum_{j=1}^{i-1} H_j \\cdot (i-j)!$。 &emsp;&emsp;第二种情况，根是析点但儿子数量 $\\in [4,i-1]$：假设有 $j$ 个儿子，由于它们的任意非平凡组合都不能是连续段，所以这 $j$ 个儿子的排列顺序有 $X_j$ 种。&emsp;&emsp;再设 $B_{i,j}$ 表示把 $i$ 个数划分为 $j$ 个排列的方案数，即 $B_{i,j}=\\sum_{k=1}^i B_{i-k,j-1} \\cdot k!$。&emsp;&emsp;那么这种情况的方案数就是 $\\sum_{j=4}^{i-1} B_{i,j}\\cdot X_j$。 &emsp;&emsp;综上，$X_i=i!-\\big(2\\sum_{j=1}^{i-1} H_j \\cdot (i-j)!\\big)-\\big(\\sum_{j=4}^{i-1} B_{i,j}\\cdot X_j\\big)$，时间复杂度 $O(n^3)$。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;bits/stdc++.h&gt;#define fo(i,a,b) for(int i=a;i&lt;=b;i++)using namespace std;typedef long long LL;const int maxn=405;int n;LL mo;LL fac[maxn];void Pre(int n)&#123; fac[0]=1; fo(i,1,n) fac[i]=fac[i-1]*i%mo;&#125;LL X[maxn],H[maxn],B[maxn][maxn];void dp(int n)&#123; fo(i,1,n) &#123; H[i]=fac[i]; fo(j,1,i-1) H[i]=(H[i]-H[j]*fac[i-j]%mo+mo)%mo; &#125; B[0][0]=1; fo(i,1,n) fo(j,1,i) fo(k,1,i) (B[i][j]+=B[i-k][j-1]*fac[k])%=mo; fo(i,1,n) &#123; X[i]=fac[i]; fo(j,1,i-1) X[i]=(X[i]-2*H[j]*fac[i-j]%mo+mo)%mo; fo(j,4,i-1) X[i]=(X[i]-X[j]*B[i][j]%mo+mo)%mo; &#125;&#125;int T;int main()&#123; scanf(&quot;%d %lld&quot;,&amp;T,&amp;mo); Pre(400); dp(400); while (T--) &#123; scanf(&quot;%d&quot;,&amp;n); if (n==1) puts(&quot;1&quot;); else if (n==2) puts(&quot;2&quot;); else if (n==3) puts(&quot;0&quot;); else printf(&quot;%lld\\n&quot;,X[n]); &#125;&#125; V1.5 题源：【Comet OJ - Contest #6】F. permutation 题目大意&emsp;&emsp;（题意同 V1）&emsp;&emsp;给定 $n$，求有多少长度为 $n$ 的排列，满足该排列任意一个非平凡子段都不是连续段。 &emsp;&emsp;$n \\leq 10^5$&emsp;&emsp;1s 题解&emsp;&emsp;其实就是 V1 的加强版，把裸的 dp 用生成函数搞成了一个多项式牛逼题。。。&emsp;&emsp;待填坑吧。。 V2 题源：【2018 EC Final】B. Mysterious … Host 题目大意&emsp;&emsp;对于一个排列，它的每一个子段都可以标上一个“是否是连续段”。&emsp;&emsp;两个长度为 $n$ 的排列本质不同，当且仅当存在一个子段 $[l,r]$，它在其中一个排列里是连续段，在另一个排列里不是连续段。&emsp;&emsp;现在给定 $n$，对于 $\\forall i \\in [1,n]$，求有多少本质不同的、长度为 $i$ 的排列。 &emsp;&emsp;$n \\leq 5000$，模数是个大质数。&emsp;&emsp;1s 题解&emsp;&emsp;这题其实就是问，有多少大小为 $i$ 的本质不同的析合树形态。 &emsp;&emsp;设 $f_i$ 表示大小为 $i$ 的本质不同的析合树形态（即答案），依然是按照“根是合点”以及“根是析点”来分类讨论。 &emsp;&emsp;第一种情况，根是合点：只需把 $i$ 长度的排列分成若干段即可，这一定能对应合点的儿子划分。因此需要一个 $B_{i,j}$ 表示长度为 $i$ 的排列、划分成 $j$ 个子段的不同的析合树形态数量，即 $B_{i,j}=\\sum_{k=1}^i B_{i-k,j-1} \\cdot f_k$。&emsp;&emsp;于是这种情况的贡献就是 $\\sum_{j=2}^i B_{i,j}$。 &emsp;&emsp;第二种情况，根是析点：只需把 $i$ 长度的排列划分成至少 $4$ 个子段即可，这一定能对应析点的儿子划分（因为只需把儿子按恰当的顺序排起来即可，根据 V1 我们知道这一定有解的）。因此这种情况的贡献就是 $\\sum_{j=4}^i B_{i,j}$。 &emsp;&emsp;综上，$f_i=\\big(\\sum_{j=2}^i B_{i,j}\\big)+\\big(\\sum_{j=4}^i B_{i,j} \\big)$，这比 V1 还要简洁。。&emsp;&emsp;不过这是 $O(n^3)$ 的，还要再优化一下。&emsp;&emsp;观察发现 $B$ 数组开两维真是太浪费了，$j$ 这一维显然可以去掉，设 $g_i=\\sum_{j=2}^i B_{i,j}$，那么就有 $f_i=2g_i-B_{i,2}-B_{i,3}$，其中 $B_{i,2}$ 每次 $O(n)$ 算即可，$B_{i,3}$ 借助 $B_{i,2}$ 也是每次 $O(n)$ 算的。这样时间复杂度就是 $O(n^2)$ 了。 代码// $g$ 数组的含义比较灵活，贡献完 $f_i$ 之后它的含义就变成把 $B_{i,1}$ 也加进去了。 12345678910111213141516171819202122232425262728293031323334#include&lt;bits/stdc++.h&gt;#define fo(i,a,b) for(int i=a;i&lt;=b;i++)using namespace std;typedef long long LL;const int maxn=5005;int n;LL mo;LL f[maxn],g[maxn],g2[maxn];void dp()&#123; g[1]=f[1]=1; fo(i,2,n) &#123; fo(j,1,i-1) (g[i]+=g[j]*f[i-j])%=mo; fo(j,1,i-1) (g2[i]+=f[j]*f[i-j])%=mo; f[i]=(g[i]*2-g2[i]+mo)%mo; fo(j,1,i-2) f[i]=(f[i]-g2[i-j]*f[j]%mo+mo)%mo; (g[i]+=f[i])%=mo; &#125;&#125;int T;int main()&#123; scanf(&quot;%d %lld&quot;,&amp;n,&amp;mo); dp(); fo(i,1,n) printf(&quot;%lld\\n&quot;,f[i]);&#125; V3 题源：【CTSC2018】青蕈领主 题目大意&emsp;&emsp;给定 $n$，表示排列长度，然后给出 $L_1,\\cdots,L_n$ 表示每个元素以它为右端点的最长连续段长度。问有多少种排列，答案模 $998244353$。 &emsp;&emsp;$n \\leq 50000$&emsp;&emsp;多测，$T \\leq 100$，但每个 test case 的 $n$ 都相同&emsp;&emsp;3s 题解&emsp;&emsp;这个 $L_i$ 就是析合树建树要用的那个数组。。但是根据这个 $L$ 数组是不能唯一确定析合树形态的，比如 $[1,2,3]$ 和 $[2,1,3]$ 是不同的析合树形态，但拥有同样的 $L$ 数组。&emsp;&emsp;所以这题不算是严格的析合树形态计数。不过作为析合树的启蒙题，对于连续段还是很有研究的。 &emsp;&emsp;首先这个 $L$ 数组需要满足极长连续段不相交，否则是无解。&emsp;&emsp;虽然 $L$ 数组不能还原析合树，但是如果把每个点连向它后面第一个能覆盖到它的点，还是能形成一个树形结构的。&emsp;&emsp;对于一个结点来说，假设儿子加上自己共 $len$ 个，那么它的方案数就是长度为 $len$、满足“不存在不含最后一个元素的非平凡连续段”的排列的数量。最终答案就等于每个结点的贡献乘起来。&emsp;&emsp;我们就需要计算一个 $f_i$ 表示长度为 $i$、满足“不存在不含最后一个元素的非平凡连续段”的排列的数量，最终答案即 $\\prod f_{len}$。 &emsp;&emsp;至于这个 $f$ 数组怎么算，我感觉网上几乎所有的博客都有细节错误。&emsp;&emsp;首先转换一下模型，若排列 $p$ 满足“不存在不含最后一个元素的非平凡连续段”，那么它唯一对应一个排列 $q$（$q_{p_i}=i$），$q$ 满足“不存在不含最大值的非平凡连续段”。&emsp;&emsp;所以来求 $q$ 的数量。&emsp;&emsp;设 $q$ 长度为 $i$，考虑删掉 $q$ 的最小值，即 $1$。&emsp;&emsp;第一种情况：删掉 $1$ 后排列依然合法，那么这个 $1$ 只要不放在 $2$ 的旁边都是可以的，方案数为 $(i-2)f_{i-1}$。（证明：放在 $2$ 旁边肯定不行，若不放在 $2$ 旁边却造成了非平凡连续段，那么把 $1$ 删掉它仍然会是个非平凡连续段，矛盾）&emsp;&emsp;第二种情况：删掉 $1$ 后排列不合法，出现了非平凡连续段（不含 $2$ 也不含 $i$）。枚举最长的非平凡连续段长度 $j$，这个连续段插入 $1$ 后就不存在非平凡连续段了，即原本所有的非平凡连续段都经过 $1$ 这个位置，这就等价于有一个长度为 $j+1$ 的合法排列把最大值删掉换成 $1$，所以贡献为 $f_{j+1}$。把这个连续段缩起来以后排列必须合法，即$f_{i-j}$，这个连续段的值域选取有 $i-j-2$ 种。因此这种情况的方案数就是 $\\sum_{j=2}^{i-3}(i-j-2)f_{j+1}f_{i-j}$，即 $\\sum_{j=3}^{i-2}(j-2)f_{j}f_{i+1-j}$&emsp;&emsp;综上： f_i=(i-2)f_{i-1}+\\sum_{j=3}^{i-2}(j-2)f_{j}f_{i+1-j}&emsp;&emsp;于是分治 NTT 预处理出来就好了，时间 $O(n \\log^2 n)$。 思考&emsp;&emsp;就是求 $f$ 的时候，我脑补了另一种方法。 &emsp;&emsp;现在要求长度为 $i$、满足“不存在不含最后一个元素的非平凡连续段”的排列数量。我就考虑这样的排列对应的析合树。转化成析合树是什么限制呢？第一，任意非叶子结点除去最后一个儿子外必须是单个元素；第二，合点只能有两个儿子；第三，上升合点的合儿子必须下降，下降合点的合儿子必须上升。&emsp;&emsp;设 $g_i$ 表示根节点为上升合点的合法排列数（下降合点方案数跟上升是一样的），$h_i$ 表示根节点为析点的合法排列数，那么就有 $f_i=2g_i+h_i$。&emsp;&emsp;第一种情况：根是上升合点，那么它只能有两个儿子，且第二个儿子是析点或下降合点，所以 $g_i=g_{i-1}+h_{i-1}=f_{i-1}-g_{i-1}$&emsp;&emsp;第二种情况：根是析点，那么根的儿子所构成的排列就必须满足“任意非平凡子段都不是连续段”，即 V1 所求的那种，沿用那个数组 $X_i$ 表示“不存在非平凡连续段”的排列数量。因此 $h_i=\\sum_{j=4}^i X_jf_{i+1-j}$&emsp;&emsp;综上，$f_i=2g_i+\\sum_{j=4}^i X_jf_{i+1-j}=2(f_{i-1}-f_{i-2}+f_{i-3}\\cdots)+\\sum_{j=4}^i X_jf_{i+1-j}$ &emsp;&emsp;但这种方法由于要求 $X$ 数组因此直接 dp 的话要 $O(n^3)$。&emsp;&emsp;然后就不明白了，两种方法求的 $f$ 是一样的，但时间复杂度却不同，那是不是说 $X$ 和 $f$ 存在更深层的关联，要么可以把方法 2 的式子推导成方法 1，要么可以利用潜在的关联通过更优秀的复杂度求解 $X$？&emsp;&emsp;（由于 V1.5 的存在，这种关联很可能是生成函数上的关联。。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124#include&lt;bits/stdc++.h&gt;#define fo(i,a,b) for(int i=a;i&lt;=b;i++)#define fd(i,a,b) for(int i=a;i&gt;=b;i--)using namespace std;typedef long long LL;const int maxn=5e4+5, maxlen=2e5+5;const LL mo=998244353, g=3;int n,a[maxn];void ReadInt(int &amp;data)&#123; data=0; char ch=getchar(); while (ch&lt;&#x27;0&#x27; || ch&gt;&#x27;9&#x27;) ch=getchar(); do&#123; data=(data&lt;&lt;3)+(data&lt;&lt;1)+ch-&#x27;0&#x27;; ch=getchar(); &#125; while (ch&gt;=&#x27;0&#x27; &amp;&amp; ch&lt;=&#x27;9&#x27;);&#125;LL Pow(LL x,LL y)&#123; LL re=1; for(; y; y&gt;&gt;=1, x=x*x%mo) if (y&amp;1) re=re*x%mo; return re;&#125;LL tp[maxlen],gpow[maxlen],ginv[maxlen];int rv[maxlen];void NTT(LL *a,int len,int sig)&#123; fo(i,0,len-1) tp[rv[i]]=a[i]; for(int m=2; m&lt;=len; m&lt;&lt;=1) &#123; int hal=m&gt;&gt;1; LL gw=(sig==1 ?gpow[m] :ginv[m]), w=1; for(int j=0; j&lt;hal; j++, (w*=gw)%=mo) for(int k=j; k&lt;len; k+=m) &#123; LL u=tp[k], v=tp[k+hal]*w%mo; tp[k]=(u+v)%mo; tp[k+hal]=(u-v+mo)%mo; &#125; &#125; memcpy(a,tp,sizeof(LL)*len);&#125;void FFT(LL *a,LL *b,int n,int m)&#123; int len=1; while (len&lt;=n+m) len&lt;&lt;=1; for(int i=0, j, k, l; i&lt;len; rv[k]=i++) for(j=i, k=0, l=1; l&lt;len; j&gt;&gt;=1, l&lt;&lt;=1) k=(k&lt;&lt;1)+(j&amp;1); fo(i,n+1,len) a[i]=0; fo(i,m+1,len) b[i]=0; NTT(a,len,1), NTT(b,len,1); fo(i,0,len-1) (a[i]*=b[i])%=mo; NTT(a,len,-1); LL invlen=Pow(len,mo-2); fo(i,0,len-1) (a[i]*=invlen)%=mo;&#125;LL f[maxn],fa[maxlen],fb[maxlen];void cdq(int l,int r)&#123; if (l==r) &#123; (f[l]+=f[l-1]*(l-2))%=mo; return; &#125; int mid=(l+r)&gt;&gt;1; cdq(l,mid); if (l==3) &#123; fo(i,l,mid) fa[i-l]=(i-2)*f[i]%mo, fb[i-l]=f[i]; FFT(fa,fb,mid-l,mid-l); fo(i,max(mid+1,l+2),r) (f[i]+=fa[i+1-l-3])%=mo; &#125; else &#123; fo(i,l,mid) fa[i-l]=f[i]; fo(i,l,r) fb[i-l]=f[i-l+3]; FFT(fa,fb,mid-l,r-l); fo(i,max(mid+1,l+2),r) (f[i]+=fa[i+1-l-3]*(i-3))%=mo; &#125; cdq(mid+1,r);&#125;int T,z0,z[maxn],son[maxn];int main()&#123; ReadInt(T), ReadInt(n); for(int m=2; m&lt;=131072; m&lt;&lt;=1) gpow[m]=Pow(g,(mo-1)/m), ginv[m]=Pow(gpow[m],mo-2); f[1]=1, f[2]=2; if (n&gt;=3) cdq(3,n); while (T--) &#123; fo(i,1,n) ReadInt(a[i]); if (a[n]!=n) &#123;puts(&quot;0&quot;); continue;&#125; memset(son,0,sizeof(son)); z[z0=1]=n; bool insec=0; fd(i,n-1,1) &#123; while (z0 &amp;&amp; i+a[z[z0]]&lt;=z[z0]) z0--; son[z[z0]]++; if (i-a[i]&lt;z[z0]-a[z[z0]]) &#123;insec=1; break;&#125; z[++z0]=i; &#125; if (insec) &#123;puts(&quot;0&quot;); continue;&#125; LL ans=1; fo(i,1,n) (ans*=f[son[i]+1])%=mo; printf(&quot;%lld\\n&quot;,ans); &#125;&#125;","categories":[{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[{"name":"算法_DP","slug":"算法-DP","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-DP/"},{"name":"算法_多项式/生成函数","slug":"算法-多项式-生成函数","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E5%A4%9A%E9%A1%B9%E5%BC%8F-%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/"},{"name":"算法_计数","slug":"算法-计数","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E8%AE%A1%E6%95%B0/"},{"name":"算法_析合树","slug":"算法-析合树","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E6%9E%90%E5%90%88%E6%A0%91/"}]},{"title":"【2019 NWERC B】Balanced Cut 题解","slug":"【2019 NWERC B】Balanced Cut 题解","date":"2020-03-06T16:28:54.000Z","updated":"2024-04-24T03:59:22.810Z","comments":true,"path":"【2019 NWERC B】Balanced Cut 题解/","link":"","permalink":"http://kqp.world/%E3%80%902019%20NWERC%20B%E3%80%91Balanced%20Cut%20%E9%A2%98%E8%A7%A3/","excerpt":"题目大意&emsp;&emsp;给定一棵 $n$ 个点的 AVL 树（点权恰好为 $1$ 到 $n$），你需要选择其中的 $k$ 个点，满足： 如果要选一个点，那么它的祖先也必须选。也就是选出来的 $k$ 个点会组成一棵新的树。 这棵新的树也必须是 AVL 树。 &emsp;&emsp;（放个传送门里面有图片可以看看例子 &emsp;&emsp;每种选法可以表示为一个长度为 $n$ 的 01 串（表示每个点选或不选），你需要求出字典序最大的方案。 &emsp;&emsp;$1 \\leq k \\leq n \\leq 5 \\times 10^5$&emsp;&emsp;4s，256MB","text":"题目大意&emsp;&emsp;给定一棵 $n$ 个点的 AVL 树（点权恰好为 $1$ 到 $n$），你需要选择其中的 $k$ 个点，满足： 如果要选一个点，那么它的祖先也必须选。也就是选出来的 $k$ 个点会组成一棵新的树。 这棵新的树也必须是 AVL 树。 &emsp;&emsp;（放个传送门里面有图片可以看看例子 &emsp;&emsp;每种选法可以表示为一个长度为 $n$ 的 01 串（表示每个点选或不选），你需要求出字典序最大的方案。 &emsp;&emsp;$1 \\leq k \\leq n \\leq 5 \\times 10^5$&emsp;&emsp;4s，256MB \\\\ \\\\ \\\\题解&emsp;&emsp;做这种全服个位数通过的题其实挺有快感的 &emsp;&emsp;首先大的框架肯定是贪心，从小到大 check 每个点能不能选。 &emsp;&emsp;check 的依据就是两点：会不会跟已选的点冲突，会不会必需结点数目超过 $k$ 的限制。AVL 树的一个性质是，树高是 $O(\\log n)$ 的。基于这个我们可以设计出一个粗略的 check 的方法：&emsp;&emsp;（$lson,rson$ 表示一个结点的左右儿子）&emsp;&emsp;设要 check $s$ 这个点，从 $s$ 开始不断往父亲跳，维护当前子树最少要选的点数 $nownum$，以及所选的层数 $nowdeep$。假设当前点是 $x$，父亲为 $y$。&emsp;&emsp;若 $x$ 是 $y$ 的右儿子，则 $y$ 的左儿子肯定已经全部考虑过了，定死了不能变了，所以只需判断这俩兄弟的层数差是否在 $1$ 以内即可，然后更新 $nowdeep$ 和 $nownum$；&emsp;&emsp;若 $x$ 是 $y$ 的左儿子，则 $y$ 的右儿子肯定全都没考虑，我们预处理一个 dp 数组 $f_{i,j}$ 表示以 $i$ 为根的子树选 $j$ 层的最少花费，那么这时只需要使 $nownum$ 加上 $f_{rson_y,nowdeep-1}$ 即可。&emsp;&emsp;最后判断 $nownum \\leq k$ 即是合法。 &emsp;&emsp;会有一些问题：当 $x$ 是 $y$ 左儿子时，$y$ 的右儿子可能曾经被 $x$ 子树里的其他结点提出过更大的层数要求，记为 $tag_{rson_y}$，是的这其实就是一个不断打 tag 的过程，所以实际上右儿子要选的层数应该是 $f_{rson_y,\\max\\{nowdeep-1,tag_{rson_y}\\}}$。&emsp;&emsp;然后，当 check 一个点成功时，它必须沿着祖先链上去给所有右兄弟更新 tag。 &emsp;&emsp;这时又会有新的问题：当前结点 $x$ 本身可能会有一个 $tag_x$ 的任务，然而我们为了使点数最少我们一直都只选必需的点，这导致 $nowdeep$ 可能完不成 $tag_x$ 这个任务，我们就需要计算现在 $nowdeep$ 层补到 $tag_x$ 层需要额外付出多少代价。&emsp;&emsp;记 $h_i (i \\ge nowdeep)$ 表示当前子树从选 $nowdeep$ 层追加到选 $i$ 层需要额外补多少代价。这个东西也很好维护，当 $nowdeep$ 变大成 $nowdeep’$ 时，所有的 $h_i-=h_{nowdeep’}$；当往上跳遇到右兄弟时，再维护 $h_i=\\min\\{h_{i-1}+f_{rson,i}-f_{rson,t},~h_i+f_{rson,i-1}-f_{rson,t}\\}$。（其中 $t=\\max\\{nowdeep-1,tag_{rson}\\}$，因为我们维护的是额外补的差价，而 $f_{rson,t}$ 是已经付出的） &emsp;&emsp;时间复杂度：每个点往上跳是 $O(\\log n)$ 步的，每跳一次维护一下 $h$ 数组又是 $O(\\log n)$ 的，因此总的是 $O(n \\log^2 n)$。但它跑得飞快，甚至这题其他人写的像是 $O(n \\log n)$ 的（我都没看懂）用时是我的若干倍。。 &emsp;&emsp;（另外有些小技巧，比如如果一个点它的(左)子树中有人确定要选了，那么它作为祖先就一定要选，就不用 check 了，这样的话任何要 check 的点都必然是左子树不选的，于是各变量的初值也方便多了。。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#include&lt;bits/stdc++.h&gt;#define fo(i,a,b) for(int i=a;i&lt;=b;i++)#define fd(i,a,b) for(int i=a;i&gt;=b;i--)using namespace std;typedef long long LL;const int maxn=5e5+5, MX=30;const int inf=522133279;int n,k,root,son[maxn][2],p[maxn];int f[maxn][MX+2],nmax[maxn],deep[maxn];void dfs_dp(int k)&#123; nmax[k]=k; int l=son[k][0], r=son[k][1]; if (l) &#123; deep[l]=deep[k]+1; dfs_dp(l); &#125; if (r) &#123; deep[r]=deep[k]+1; dfs_dp(r); nmax[k]=max(nmax[k],nmax[r]); &#125; f[k][1]=1; fo(j,2,MX) f[k][j]=min(f[k][j],min(f[l][j-1]+f[r][j-2],f[l][j-2]+f[r][j-1])+1);&#125;int tag[maxn],maxdeep[maxn],num[maxn],h[MX+2];void Make_tag(int st)&#123; for(int x=st; x!=-1; x=p[x]) &#123; maxdeep[x]=max(maxdeep[x],deep[st]); num[x]++; int y=p[x]; if (y!=-1 &amp;&amp; son[y][0]==x) tag[son[y][1]]=max(tag[son[y][1]],maxdeep[x]-1-deep[y]); &#125;&#125;bool check(int x)&#123; if (num[x]) return 1; int nowdeep=0, nownum=0; memset(h,31,sizeof(h)); h[0]=f[son[x][1]][0], h[1]=f[son[x][1]][1]; for(; x!=-1; x=p[x]) &#123; int y=p[x]; nownum++; if (nowdeep+1&lt;tag[x]) &#123; nownum+=h[nowdeep=tag[x]-1]; if (nownum&gt;=inf) return 0; fd(i,MX,nowdeep) if (h[i]&lt;inf) h[i]-=h[nowdeep]; &#125; nowdeep++; fd(i,MX,nowdeep) h[i]=h[i-1]; if (y!=-1 &amp;&amp; son[y][0]==x &amp;&amp; son[y][1]) &#123; int r=son[y][1], t=max(tag[r],nowdeep-1); if (f[r][t]&gt;=inf) return 0; nownum+=f[r][t]; fd(i,MX,nowdeep+1) &#123; h[i]=min(h[i-1]+f[r][i]-f[r][t],h[i]+f[r][i-1]-f[r][t]); if (h[i]&gt;n) h[i]=inf; &#125; h[nowdeep]=0; &#125; else if (y!=-1 &amp;&amp; son[y][1]==x &amp;&amp; son[y][0]) &#123; int l=son[y][0]; if (nowdeep-(maxdeep[l]-deep[y])&gt;1) return 0; nowdeep=max(nowdeep,maxdeep[l]-deep[y]); h[nowdeep]=0; nownum+=num[son[y][0]]; &#125; &#125; return nownum&lt;=k;&#125;bool ans[maxn];int main()&#123; scanf(&quot;%d %d&quot;,&amp;n,&amp;k); fo(i,1,n) &#123; scanf(&quot;%d&quot;,&amp;p[i]); if (p[i]==-1) root=i; else son[p[i]][(i&gt;p[i])]=i; &#125; memset(f,31,sizeof(f)); fo(i,0,n) f[i][0]=0; deep[root]=1; dfs_dp(root); fo(i,1,n) if (check(i)) &#123; ans[i]=1; Make_tag(i); &#125; fo(i,1,n) putchar(ans[i] ?&#x27;1&#x27; :&#x27;0&#x27;); puts(&quot;&quot;);&#125;","categories":[{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[{"name":"算法_DP","slug":"算法-DP","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-DP/"}]},{"title":"【VKOSHP 19 L】Time Travel 题解","slug":"【VKOSHP 19 L】Time Travel 题解","date":"2020-02-20T15:35:22.000Z","updated":"2024-04-24T03:59:22.869Z","comments":true,"path":"【VKOSHP 19 L】Time Travel 题解/","link":"","permalink":"http://kqp.world/%E3%80%90VKOSHP%2019%20L%E3%80%91Time%20Travel%20%E9%A2%98%E8%A7%A3/","excerpt":"题目大意&emsp;&emsp;有 $k$ 棵树，每棵树有 $n$ 个点，对于所有的点对 $(s,t)$（$1 \\leq s,t \\leq n$），求出有多少个点在每棵树的 $s$ 到 $t$ 的链上都存在。&emsp;&emsp;（以防表述不清，给一下传送门&emsp;&emsp;$n,k \\leq 500$&emsp;&emsp;2s","text":"题目大意&emsp;&emsp;有 $k$ 棵树，每棵树有 $n$ 个点，对于所有的点对 $(s,t)$（$1 \\leq s,t \\leq n$），求出有多少个点在每棵树的 $s$ 到 $t$ 的链上都存在。&emsp;&emsp;（以防表述不清，给一下传送门&emsp;&emsp;$n,k \\leq 500$&emsp;&emsp;2s \\\\ \\\\ \\\\题解&emsp;&emsp;一开始怎么想都是 4 次方的复杂度，尝试了暴力+bitset 也 T 了。 &emsp;&emsp;这题的关键是要注意到一个性质：在一棵树上，$x$ 到 $y$ 经过 $c$，等价于 $dis_{x,y}=dis_{x,c}+dis_{c,y}$。&emsp;&emsp;而且 $dis_{x,y}$ 是小于等于 $dis_{x,c}+dis_{c,y}$ 的。&emsp;&emsp;那么 $x$ 到 $y$ 在所有树上都经过 $c$，就等价于 $\\sum dis_{x,y}=\\sum dis_{x,c}+\\sum dis_{c,y}$。 &emsp;&emsp;那么就 $O(kn^2)$ 预处理 $\\sum dis_{x,y}$，然后 $O(n^3)$ 枚举点对与中间点，判断合不合法。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;bits/stdc++.h&gt;#define fo(i,a,b) for(int i=a;i&lt;=b;i++)using namespace std;const int maxn=505;int n,k;int tot[maxn],go[maxn][2*maxn],nxt[maxn][2*maxn],f1[maxn][maxn];void ins(int ty,int x,int y)&#123; go[ty][++tot[ty]]=y; nxt[ty][tot[ty]]=f1[ty][x]; f1[ty][x]=tot[ty];&#125;int dis[maxn][maxn];void dfs(int ty,int tp,int k,int last,int s)&#123; dis[tp][k]+=s; for(int p=f1[ty][k]; p; p=nxt[ty][p]) if (go[ty][p]!=last) dfs(ty,tp,go[ty][p],k,s+1);&#125;int main()&#123; scanf(&quot;%d %d&quot;,&amp;n,&amp;k); fo(i,1,k) fo(j,1,n-1) &#123; int x,y; scanf(&quot;%d %d&quot;,&amp;x,&amp;y); ins(i,x,y), ins(i,y,x); &#125; fo(i,1,k) fo(j,1,n) dfs(i,j,j,0,0); fo(a,1,n) &#123; fo(b,1,n) &#123; int sum=0; fo(c,1,n) sum+=(dis[a][c]+dis[c][b]==dis[a][b]); printf(&quot;%d &quot;,sum); &#125; puts(&quot;&quot;); &#125;&#125;","categories":[{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[{"name":"算法_神奇的脑洞","slug":"算法-神奇的脑洞","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E7%A5%9E%E5%A5%87%E7%9A%84%E8%84%91%E6%B4%9E/"}]},{"title":"【THUSC2017】杜老师 题解","slug":"【THUSC2017】杜老师 题解","date":"2020-02-18T07:02:43.000Z","updated":"2024-04-24T03:59:22.867Z","comments":true,"path":"【THUSC2017】杜老师 题解/","link":"","permalink":"http://kqp.world/%E3%80%90THUSC2017%E3%80%91%E6%9D%9C%E8%80%81%E5%B8%88%20%E9%A2%98%E8%A7%A3/","excerpt":"题目大意&emsp;&emsp;给定 $L,R$，求从 $L$ 到 $R$ 的这 $R-L+1$ 个数中能选出多少个不同的子集，满足子集中所有的数的乘积是一个完全平方数。特别地，空集也算一种选法，定义其乘积为 $1$。 &emsp;&emsp;多测，$T \\leq 100$&emsp;&emsp;$1 \\leq L \\leq R \\leq 10^7,\\ \\ \\sum_{i=1}^T R_i-L_i+1 \\leq 6 \\times 10^7$&emsp;&emsp;5s","text":"题目大意&emsp;&emsp;给定 $L,R$，求从 $L$ 到 $R$ 的这 $R-L+1$ 个数中能选出多少个不同的子集，满足子集中所有的数的乘积是一个完全平方数。特别地，空集也算一种选法，定义其乘积为 $1$。 &emsp;&emsp;多测，$T \\leq 100$&emsp;&emsp;$1 \\leq L \\leq R \\leq 10^7,\\ \\ \\sum_{i=1}^T R_i-L_i+1 \\leq 6 \\times 10^7$&emsp;&emsp;5s \\\\ \\\\ \\\\题解&emsp;&emsp;在 thu 门外哭哭的日子 &emsp;&emsp;感觉一开始没有这个方向的话就想不到这个方向了。。还是说我太菜了。。 【50%】$T \\leq 10,\\ \\ \\sum R_i-L_i+1 \\leq 5000$&emsp;&emsp;假设 $[1,maxR]$ 范围内的质数有 $pnum$ 个，分别为 $p_1,\\cdots,p_{pnum}$。&emsp;&emsp;把每个数字 $i$ 看成一个 $pnum$ 维 01 向量 $\\vec{v_i}$，其中第 $j$ 维为 $1$ 当且仅当 $i$ 含有奇数个质因子 $p_j$。&emsp;&emsp;那么原数相乘，相当于向量异或，于是就想到线性基。于是发现答案等于 $2^{R-L+1-基的数量}$。 &emsp;&emsp;然后优化，质数以 $\\sqrt{maxR}$ 为界分为大质数和小质数，每个数最多含有 1 个大质数，因此出现过的大质数的位置一定是基，因此线性基就只用考虑小质数了。小质数共 446 个。&emsp;&emsp;时间 $O(T (\\sum R_i-L_i+1) \\cdot 446 \\cdot \\frac{446}{64})。$ 【100%】&emsp;&emsp;思考第 11、12 个数据点的条件：$R_i-Li \\geq 999990$，是要说什么呢？&emsp;&emsp;是要引导发现一个性质：当区间长度 $R_i-L_i+1 \\geq 2\\sqrt{maxR}$ 时，所有小质数的位置都是基。 &emsp;&emsp;口胡证明：相当于证明所有的小质数都与别的质数线性独立。设有小质数 $p_1$，设质数 $p_2&gt;p_1$。&emsp;&emsp;当区间长度 $\\geq 2\\sqrt{maxR}$ 时，$p_1$ 至少出现两次了，且这两次里至少有一次是有 $p_1$ 而没有 $p_2$ 的，（$p_1$ 出现的间隔为 $p_1$，这个间隔不可能使 $p_2$ 也出现两次。）然后区间内必然还有数是既不含 $p_1$ 也不含 $p_2$ 的。&emsp;&emsp;也就是说，在不含 $p_2$ 的数里，既可以含有 $p_1$，也可以不含有 $p_1$，那么 $p_1$ 和 $p_2$ 就线性独立了。&emsp;&emsp;$p_1$ 取遍所有的小质数，那么就有：所有的小质数都与别的质数线性独立，因此所有小质数的位置都是基。 &emsp;&emsp;这题可以偷懒直接把 $2\\sqrt{maxR}$ 当成 $6000$ 省点常数。也就是区间长度 $\\geq 6000$ 之后就不用做线性基了，可以扫一遍统计大质数然后输出。&emsp;&emsp;那么时间就是 $O((\\sum R_i-L_i+1)+T \\cdot 6000 \\cdot 446 \\cdot \\frac{446}{64})$，满打满算应该是跑不过的，但是它跑过去了。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include&lt;bits/stdc++.h&gt;#define fo(i,a,b) for(int i=a;i&lt;=b;i++)#define fd(i,a,b) for(int i=a;i&gt;=b;i--)using namespace std;typedef long long LL;const int maxn=1e7+5, sqrtn=446;const LL mo=998244353;int l,r;int p0,p[maxn],minp[maxn],divp[maxn],maxp[maxn];bool bz[maxn],cnt[maxn];void Prime(int n)&#123; fo(i,2,n) &#123; if (!bz[i]) p[++p0]=i, cnt[i]=1, minp[i]=maxp[i]=p0, divp[i]=1; fo(j,1,p0) &#123; if ((LL)i*p[j]&gt;n) break; int nxt=i*p[j]; bz[nxt]=1; minp[nxt]=j; maxp[nxt]=maxp[i]; if (i%p[j]==0) &#123; cnt[nxt]=cnt[i]^1; divp[nxt]=divp[i]; break; &#125; else &#123; cnt[nxt]=1; divp[nxt]=i; &#125; &#125; &#125;&#125;LL Pow(LL x,int y)&#123; LL re=1; for(; y; y&gt;&gt;=1, x=x*x%mo) if (y&amp;1) re=re*x%mo; return re;&#125;bitset&lt;sqrtn+2&gt; zero,base[sqrtn+2],x,f[6005];int basenum,bignum,big[maxn];void add()&#123; fd(i,sqrtn,1) if (x[i]) &#123; if (base[i][i]) x^=base[i]; else &#123; base[i]=x; basenum++; break; &#125; &#125;&#125;int T,bigP[maxn];bool apr[maxn];int main()&#123; Prime(10000000); scanf(&quot;%d&quot;,&amp;T); while (T--) &#123; scanf(&quot;%d %d&quot;,&amp;l,&amp;r); if (r-l+1&gt;6000) &#123; int num=0; fo(i,l,r) if (maxp[i]&gt;sqrtn &amp;&amp; !apr[maxp[i]]) num++, apr[maxp[i]]=1; printf(&quot;%lld\\n&quot;,Pow(2,r-l+1-num-sqrtn)); fo(i,l,r) if (maxp[i]&gt;sqrtn) apr[maxp[i]]=0; &#125; else &#123; basenum=bignum=0; fo(i,1,sqrtn) base[i]=zero; fo(i,l,r) &#123; x=zero; for(int ii=i; ii&gt;1; ii=divp[ii]) if (minp[ii]&gt;sqrtn) bigP[i]=minp[ii]; else x[minp[ii]]=cnt[ii]; if (bigP[i] &amp;&amp; !big[bigP[i]]) &#123; big[bigP[i]]=++bignum; f[bignum]=x; &#125; else &#123; if (bigP[i]) x^=f[big[bigP[i]]]; add(); &#125; if (basenum==sqrtn) break; &#125; printf(&quot;%lld\\n&quot;,Pow(2,r-l+1-basenum-bignum)); fo(i,l,r) big[bigP[i]]=0; &#125; &#125;&#125;","categories":[{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[{"name":"算法_数论","slug":"算法-数论","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E6%95%B0%E8%AE%BA/"},{"name":"算法_位运算","slug":"算法-位运算","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/"}]},{"title":"【THUSC2017】大魔法师 题解","slug":"【THUSC2017】大魔法师 题解","date":"2020-02-17T13:00:41.000Z","updated":"2024-04-24T03:59:22.866Z","comments":true,"path":"【THUSC2017】大魔法师 题解/","link":"","permalink":"http://kqp.world/%E3%80%90THUSC2017%E3%80%91%E5%A4%A7%E9%AD%94%E6%B3%95%E5%B8%88%20%E9%A2%98%E8%A7%A3/","excerpt":"题目大意&emsp;&emsp;维护三个长度为 $n$ 的序列 $A,B,C$，支持以下 7 种操作：（操作数为 $m$） $1\\ l\\ r$：对 $[l,r]$，$A_i \\gets A_i+B_i$； $2\\ l\\ r$：对 $[l,r]$，$B_i \\gets B_i+C_i$； $3\\ l\\ r$：对 $[l,r]$，$C_i \\gets C_i+A_i$； $4\\ l\\ r\\ v$：对 $[l,r]$，$A_i \\gets A_i+v$； $5\\ l\\ r\\ v$：对 $[l,r]$，$B_i \\gets B_i \\cdot v$； $6\\ l\\ r\\ v$：对 $[l,r]$，$C_i \\gets v$； $7\\ l\\ r$：求 $\\sum_{i=l}^r A_i,\\ \\sum_{i=l}^r B_i,\\ \\sum_{i=l}^r C_i$，在模 $998244353$ 意义下。 &emsp;&emsp;$n,m \\leq 2.5 \\times 10^5,\\ 0 \\leq A_i,B_i,C_i &lt; 998244353$&emsp;&emsp;5s","text":"题目大意&emsp;&emsp;维护三个长度为 $n$ 的序列 $A,B,C$，支持以下 7 种操作：（操作数为 $m$） $1\\ l\\ r$：对 $[l,r]$，$A_i \\gets A_i+B_i$； $2\\ l\\ r$：对 $[l,r]$，$B_i \\gets B_i+C_i$； $3\\ l\\ r$：对 $[l,r]$，$C_i \\gets C_i+A_i$； $4\\ l\\ r\\ v$：对 $[l,r]$，$A_i \\gets A_i+v$； $5\\ l\\ r\\ v$：对 $[l,r]$，$B_i \\gets B_i \\cdot v$； $6\\ l\\ r\\ v$：对 $[l,r]$，$C_i \\gets v$； $7\\ l\\ r$：求 $\\sum_{i=l}^r A_i,\\ \\sum_{i=l}^r B_i,\\ \\sum_{i=l}^r C_i$，在模 $998244353$ 意义下。 &emsp;&emsp;$n,m \\leq 2.5 \\times 10^5,\\ 0 \\leq A_i,B_i,C_i &lt; 998244353$&emsp;&emsp;5s \\\\ \\\\ \\\\题解&emsp;&emsp;开始补高中的眼泪了，在 thu 门外哭哭的日子 &emsp;&emsp;这种序列互加的要想到矩阵运算。&emsp;&emsp;比如令一个向量 $\\vec{x_i}$ 等于 $[A_i,B_i,C_i]$，那么 $\\vec{x_i} \\cdot \\begin{bmatrix} 1 &amp; 0 &amp; 0 \\\\ 1 &amp; 1 &amp; 0 \\\\ 0 &amp; 0 &amp; 1 \\end{bmatrix}$ 就实现了第一种操作。&emsp;&emsp;其他操作同理。&emsp;&emsp;对于 4~6 操作，再把向量加一维就可以了。 &emsp;&emsp;那么就用线段树维护区间向量和，上面的 7 个操作相当于给区间打矩阵乘法标记。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define fo(i,a,b) for(int i=a;i&lt;=b;i++)using namespace std;typedef long long LL;const int maxn=250005;const LL mo=998244353;struct ARR&#123; LL n[4][4];//=&#123;&#123;1,0,0,0&#125;,&#123;0,1,0,0&#125;,&#123;0,0,1,0&#125;,&#123;0,0,0,1&#125;&#125;; ARR() &#123;n[0][0]=n[1][1]=n[2][2]=n[3][3]=1;&#125;&#125; rea,I;struct VEC&#123; LL n[4];&#125; rev;ARR operator * (const ARR &amp;a,const ARR &amp;b)&#123; fo(i,0,3) fo(j,0,3) rea.n[i][j]=(a.n[i][0]*b.n[0][j]+a.n[i][1]*b.n[1][j] +a.n[i][2]*b.n[2][j]+a.n[i][3]*b.n[3][j])%mo; return rea;&#125;VEC operator * (const VEC &amp;a,const ARR &amp;b)&#123; fo(i,0,3) rev.n[i]=(a.n[0]*b.n[0][i]+a.n[1]*b.n[1][i]+a.n[2]*b.n[2][i]+a.n[3]*b.n[3][i])%mo; return rev;&#125;VEC operator + (const VEC &amp;a,const VEC &amp;b)&#123; return (VEC)&#123;(a.n[0]+b.n[0])%mo,(a.n[1]+b.n[1])%mo,(a.n[2]+b.n[2])%mo,(a.n[3]+b.n[3])%mo&#125;;&#125;int n,m,a[maxn],b[maxn],c[maxn];void ReadInt(int &amp;data)&#123; data=0; char ch=getchar(); while (ch&lt;&#x27;0&#x27; || ch&gt;&#x27;9&#x27;) ch=getchar(); do&#123; data=(data&lt;&lt;3)+(data&lt;&lt;1)+ch-&#x27;0&#x27;; ch=getchar(); &#125; while (ch&gt;=&#x27;0&#x27; &amp;&amp; ch&lt;=&#x27;9&#x27;);&#125;VEC tr[4*maxn],ans;ARR tag[4*maxn],C;bool bz[4*maxn];int x,y;void tr_js(int k,int l,int r)&#123; if (l==r) &#123; tr[k]=(VEC)&#123;&#123;a[l],b[l],c[l],1&#125;&#125;; return; &#125; int t=k&lt;&lt;1, mid=(l+r)&gt;&gt;1; tr_js(t,l,mid), tr_js(t+1,mid+1,r); tr[k]=tr[t]+tr[t+1];&#125;void update(int k,int t)&#123; if (!bz[k]) return; tr[t]=tr[t]*tag[k], tr[t+1]=tr[t+1]*tag[k]; tag[t]=tag[t]*tag[k], tag[t+1]=tag[t+1]*tag[k]; bz[t]=bz[t+1]=1; tag[k]=I; bz[k]=0;&#125;void tr_xg(int k,int l,int r)&#123; if (x&lt;=l &amp;&amp; r&lt;=y) &#123; tr[k]=tr[k]*C; tag[k]=tag[k]*C; bz[k]=1; return; &#125; int t=k&lt;&lt;1, mid=(l+r)&gt;&gt;1; update(k,t); if (x&lt;=mid) tr_xg(t,l,mid); if (mid&lt;y) tr_xg(t+1,mid+1,r); tr[k]=tr[t]+tr[t+1];&#125;void tr_cx(int k,int l,int r)&#123; if (x&lt;=l &amp;&amp; r&lt;=y) &#123; ans=ans+tr[k]; return; &#125; int t=k&lt;&lt;1, mid=(l+r)&gt;&gt;1; update(k,t); if (x&lt;=mid) tr_cx(t,l,mid); if (mid&lt;y) tr_cx(t+1,mid+1,r);&#125;int main()&#123; ReadInt(n); fo(i,1,n) ReadInt(a[i]), ReadInt(b[i]), ReadInt(c[i]); tr_js(1,1,n); ReadInt(m); while (m--) &#123; int opt,v; ReadInt(opt), ReadInt(x), ReadInt(y); if (opt&gt;=4 &amp;&amp; opt&lt;=6) ReadInt(v); C=I; switch (opt) &#123; case 1: &#123;C.n[1][0]=1; tr_xg(1,1,n); break;&#125; case 2: &#123;C.n[2][1]=1; tr_xg(1,1,n); break;&#125; case 3: &#123;C.n[0][2]=1; tr_xg(1,1,n); break;&#125; case 4: &#123;C.n[3][0]=v; tr_xg(1,1,n); break;&#125; case 5: &#123;C.n[1][1]=v; tr_xg(1,1,n); break;&#125; case 6: &#123;C.n[2][2]=0, C.n[3][2]=v; tr_xg(1,1,n); break;&#125; case 7: &#123; ans=(VEC)&#123;&#123;0,0,0,0&#125;&#125;; tr_cx(1,1,n); printf(&quot;%lld %lld %lld\\n&quot;,ans.n[0],ans.n[1],ans.n[2]); &#125; &#125; &#125;&#125;","categories":[{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[{"name":"算法_线段树","slug":"算法-线段树","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"name":"算法_矩阵乘法","slug":"算法-矩阵乘法","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95/"}]},{"title":"【XVIII Open Cup E.V. Pankratiev. Grand Prix of Korea. G】MST with Metropolis 题解","slug":"【XVIII Open Cup E.V. Pankratiev. Grand Prix of Korea. G】MST with Metropolis 题解","date":"2020-02-14T04:43:11.000Z","updated":"2024-04-24T03:59:22.873Z","comments":true,"path":"【XVIII Open Cup E.V. Pankratiev. Grand Prix of Korea. G】MST with Metropolis 题解/","link":"","permalink":"http://kqp.world/%E3%80%90XVIII%20Open%20Cup%20E.V.%20Pankratiev.%20Grand%20Prix%20of%20Korea.%20G%E3%80%91MST%20with%20Metropolis%20%E9%A2%98%E8%A7%A3/","excerpt":"题目大意&emsp;&emsp;有一幅 $n$ 个点 $m$ 条边的简单带权无向图，对于每个点 $i$，你要求出一棵生成树，满足： 与 $i$ 相连的边全部在这棵生成树中； 生成树边权和最小。 &emsp;&emsp;$n \\leq 10^5,~m \\leq 3 \\times 10^5,~边权w_i \\leq 10^9$&emsp;&emsp;5s","text":"题目大意&emsp;&emsp;有一幅 $n$ 个点 $m$ 条边的简单带权无向图，对于每个点 $i$，你要求出一棵生成树，满足： 与 $i$ 相连的边全部在这棵生成树中； 生成树边权和最小。 &emsp;&emsp;$n \\leq 10^5,~m \\leq 3 \\times 10^5,~边权w_i \\leq 10^9$&emsp;&emsp;5s \\\\ \\\\ \\\\题解&emsp;&emsp;首先做出一个初始的 MST，然后每个点考虑更正这个 MST。 &emsp;&emsp;怎么更正呢？就是每次删一条链上最大边然后新连一条边，于是我就被骗去写了一发 LCT。。。但这个做法太暴力了。 &emsp;&emsp;事实上是有性质的。对于每个点 $i$，把 $i$ 及其相邻的点拿出来建虚树，虚树的树边对应原 MST 上的一条树链，那么这里每一条树链最多删一条边（不然就断开了）。&emsp;&emsp;于是虚树的树边权就定为对应树链的最大边权。对于点 $i$，把虚树的树边拿出来，在并查集上把 $i$ 及其相邻的点合并了，然后对于虚树边做 Kruscal。时间复杂度 $O(m \\log m)$。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115#include&lt;bits/stdc++.h&gt;#define fo(i,a,b) for(int i=a;i&lt;=b;i++)#define fd(i,a,b) for(int i=a;i&gt;=b;i--)using namespace std;typedef long long LL;const int maxn=1e5+5, maxm=3e5+5, MX=17;struct E&#123; int x,y,w;&#125;;bool cmpE(const E &amp;a,const E &amp;b) &#123;return a.w&lt;b.w;&#125;int n,m;E e[maxm];vector&lt;pair&lt;int,int&gt;&gt; eg[maxn],et[maxn];LL ans;int ga[maxn];int get(int x) &#123;return (ga[x]==x) ?x :ga[x]=get(ga[x]) ;&#125;void Kruscal()&#123; sort(e+1,e+1+m,cmpE); fo(i,1,n) ga[i]=i; fo(i,1,m) if (get(e[i].x)!=get(e[i].y)) &#123; ans+=e[i].w; ga[get(e[i].x)]=get(e[i].y); et[e[i].x].push_back(make_pair(e[i].y,e[i].w)), et[e[i].y].push_back(make_pair(e[i].x,e[i].w)); &#125;&#125;int deep[maxn],fa[maxn][MX+2],maxv[maxn][MX+2],dfn[maxn],en[maxn],tot;void dfs_pre(int k,int last,int s)&#123; deep[k]=deep[last]+1; fa[k][0]=last, maxv[k][0]=s; fo(j,1,MX) fa[k][j]=fa[fa[k][j-1]][j-1], maxv[k][j]=max(maxv[k][j-1],maxv[fa[k][j-1]][j-1]); dfn[k]=++tot; for(pair&lt;int,int&gt; son:et[k]) if (son.first!=last) dfs_pre(son.first,k,son.second); en[k]=tot;&#125;int lca(int x,int y)&#123; if (deep[x]&lt;deep[y]) swap(x,y); fd(j,MX,0) if (deep[fa[x][j]]&gt;=deep[y]) x=fa[x][j]; if (x==y) return x; fd(j,MX,0) if (fa[x][j]!=fa[y][j]) x=fa[x][j], y=fa[y][j]; return fa[x][0];&#125;int dis(int x,int y)&#123; int re=0; fd(j,MX,0) if (deep[fa[x][j]]&gt;=deep[y]) re=max(re,maxv[x][j]), x=fa[x][j]; return re;&#125;int p0,p[2*maxn],z0,z[2*maxn];bool cmp(const int &amp;a,const int &amp;b) &#123;return dfn[a]&lt;dfn[b];&#125;void vtree(int x)&#123; LL ans1=0; p0=0; for(pair&lt;int,int&gt; go:eg[x]) &#123; p[++p0]=go.first; ans1+=go.second; &#125; p[++p0]=x; sort(p+1,p+1+p0,cmp); int tmp=p0-1; fo(i,1,tmp) p[++p0]=lca(p[i],p[i+1]); sort(p+1,p+1+p0,cmp); z0=m=0; fo(i,1,p0) if (i==1 || p[i]!=p[i-1]) &#123; while (z0 &amp;&amp; en[z[z0]]&lt;dfn[p[i]]) z0--; if (z0) &#123; ans1-=dis(p[i],z[z0]); e[++m]=(E)&#123;z[z0],p[i],dis(p[i],z[z0])&#125;; &#125; z[++z0]=p[i]; &#125; fo(i,1,p0) ga[p[i]]=p[i]; for(pair&lt;int,int&gt; go:eg[x]) ga[go.first]=x; sort(e+1,e+1+m,cmpE); fo(i,1,m) if (get(e[i].x)!=get(e[i].y)) &#123; ans1+=e[i].w; ga[get(e[i].x)]=get(e[i].y); &#125; printf(&quot;%lld\\n&quot;,ans1+ans);&#125;int main()&#123; scanf(&quot;%d %d&quot;,&amp;n,&amp;m); fo(i,1,m) &#123; scanf(&quot;%d %d %d&quot;,&amp;e[i].x,&amp;e[i].y,&amp;e[i].w); eg[e[i].x].push_back(make_pair(e[i].y,e[i].w)), eg[e[i].y].push_back(make_pair(e[i].x,e[i].w)); &#125; Kruscal(); dfs_pre(1,0,0); fo(i,1,n) vtree(i);&#125;","categories":[{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[{"name":"算法_图论","slug":"算法-图论","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E5%9B%BE%E8%AE%BA/"}]},{"title":"真·O(n^3) 的非递归的 KM","slug":"km","date":"2020-02-12T10:51:59.000Z","updated":"2024-04-24T03:59:22.780Z","comments":true,"path":"km/","link":"","permalink":"http://kqp.world/km/","excerpt":"由来&emsp;&emsp;2019 年南京 Regional 充分暴露了这个问题，市面上大多数标着 $O(n^3)$ 的 KM 板子实际上是 $O(n^4)$ 的，以致选手如果是用了经典书籍上的板子，或者是网上随便扒的板子，就会 TLE。&emsp;&emsp;然后最近做题做到了 KM，就想补一个自己的真·$O(n^3)$ 的 KM。网上的 $O(n^3)$ 也都没有教程只能自己啃代码，就想把思路写一下。&emsp;&emsp;大二了才会 KM 你丢不丢人","text":"由来&emsp;&emsp;2019 年南京 Regional 充分暴露了这个问题，市面上大多数标着 $O(n^3)$ 的 KM 板子实际上是 $O(n^4)$ 的，以致选手如果是用了经典书籍上的板子，或者是网上随便扒的板子，就会 TLE。&emsp;&emsp;然后最近做题做到了 KM，就想补一个自己的真·$O(n^3)$ 的 KM。网上的 $O(n^3)$ 也都没有教程只能自己啃代码，就想把思路写一下。&emsp;&emsp;大二了才会 KM 你丢不丢人 &emsp;&emsp;一个简单粗暴的判断板子是 $O(n^4)$ 还是 $O(n^3)$ 的办法：非递归是 $O(n^3)$，递归（用了匈牙利一样的东西）是 $O(n^4)$。&emsp;&emsp;更加正确的判断方法：拿去交正确的模板题，比如 uoj#80、2019 南京 Regional J（计蒜客复现）。 前置&emsp;&emsp;要解决的是二分图最大权匹配问题。这是一个线性规划问题，它的对偶问题是最小顶标和问题，KM 的思路就是计算最小顶标和。 $O(n^4)$&emsp;&emsp;看这位大佬生动的解释就懂了：https://www.cnblogs.com/wenruo/p/5264235.html&emsp;&emsp;匈牙利是 $O(n^2)$ 的，修改顶标也是 $O(n^2)$ 的，每个点最多 $n$ 次修改顶标，共 $n$ 个点，因此是 $O(n^4)$。 $O(n^3)$&emsp;&emsp;现在是对于左边的点 $i$，我们来优化它的匹配过程。按照 $O(n^4)$ 的思想，我们是每次匈牙利找增广路，失败了就修改顶标。&emsp;&emsp;如果我们默认每一次增广都会失败，那么实际上每一次增广的目的就成了最小化 $d$（最小的顶标增量使得相等子图能新加入一条边）。我们把这个 $d$ 挂在右边的结点上，记为 $slack_j$，表示增广路最后到达的右边结点为 $j$ 时，能达到的最小的 $d$。&emsp;&emsp;那么这就如同 Dijkstra，我们从 $i$ 出发，把右边的结点的 $slack$ 全部松弛一遍，然后找到 $slack$ 最小的 $j$，$slack_j$ 就是本次的顶标增量。（若 $slack_j=0$ 则顶标不动，相当于匈牙利继续，若 $slack_j&gt;0$ 相当于匈牙利失败了要修改顶标。）&emsp;&emsp;然后尝试匹配 $i$ 和 $j$。若 $j$ 单身，则牵手成功；若 $j$ 名花有主，则尝试绿掉原配增广原配，即从原配出发，把右边的结点的 $slack$ 又松弛一遍……&emsp;&emsp;直到最后找到了单身的 $j$，就增广成功了。&emsp;&emsp;于是每个 $j$ 只会被尝试匹配一次，每个原配只会被绿一次增广一次，这样就相当于 $i$ 只做了一次如同 BFS 般的多路增广，所以总时间复杂度为 $O(n^3)$。 &emsp;&emsp;回头看我们默认每一次都增广失败，实际上如果增广成功的话就意味着一路 $slack_j=0$，这种情况被包括了。 &emsp;&emsp;我觉得把它称为多路增广，或者 BFS，都不如 Dijkstra 贴切。 代码&emsp;&emsp;UPD：区分了左边点数 $nl$ 和右边点数 $nr$ 12345678910111213141516171819202122232425262728293031323334353637383940414243LL lx[maxn],ly[maxn],slack[maxn];int f[maxn],pre[maxn]; // f[y]表示右边的 y 匹配了左边的谁bool vis[maxn];LL KM()&#123; fo(i,1,nl) &#123; lx[i]=-inf; fo(j,1,nr) lx[i]=max(lx[i],mp[i][j]); // 初始化顶标 &#125; fo(i,1,nl) &#123; memset(slack,127,sizeof(LL)*(nr+1)); memset(vis,0,sizeof(bool)*(nr+1)); f[0]=i; // 给 i 一个假的原配，统一格式 int py=0, nextpy; for(; f[py]; py=nextpy) // 当前的左结点为 px，原配 py &#123; int px=f[py]; LL d=inf; vis[py]=1; fo(j,1,nr) if (!vis[j]) // 松弛 slack，及找最小的 slack &#123; if (lx[px]+ly[j]-mp[px][j]&lt;slack[j]) slack[j]=lx[px]+ly[j]-mp[px][j], pre[j]=py; if (slack[j]&lt;d) d=slack[j], nextpy=j; &#125; fo(j,0,nr) if (vis[j]) lx[f[j]]-=d, ly[j]+=d; // 修改顶标 else slack[j]-=d; // 用于松弛它的顶标已经改了，所以它也要改 &#125; for(; py; py=pre[py]) f[py]=f[pre[py]]; // 修改增广路 &#125; LL re=0; fo(i,1,nl) re+=lx[i]; fo(i,1,nr) re+=ly[i]; return re;&#125;int main()&#123; // nl表示左边的结点数，nr表示右边的结点数，要保证 nl&lt;=nr，即左边有完美匹配 // (i,j)边权为 mp[i][j] printf(&quot;%lld\\n&quot;,KM());&#125;","categories":[{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[{"name":"算法_网络流/匹配","slug":"算法-网络流-匹配","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E7%BD%91%E7%BB%9C%E6%B5%81-%E5%8C%B9%E9%85%8D/"}]},{"title":"【Goodbye Jihai】【UOJ#497】新年的复读机 题解","slug":"【Goodbye Jihai】【UOJ#497】新年的复读机 题解","date":"2020-02-09T03:47:51.000Z","updated":"2024-04-24T03:59:22.842Z","comments":true,"path":"【Goodbye Jihai】【UOJ#497】新年的复读机 题解/","link":"","permalink":"http://kqp.world/%E3%80%90Goodbye%20Jihai%E3%80%91%E3%80%90UOJ#497%E3%80%91%E6%96%B0%E5%B9%B4%E7%9A%84%E5%A4%8D%E8%AF%BB%E6%9C%BA%20%E9%A2%98%E8%A7%A3/","excerpt":"题目大意&emsp;&emsp;有一个长度为 $n$ 的数组 $a_1,\\cdots,a_n$，每次选相邻的两个数 $a_i,a_{i+1}$，花费代价 $a_i+a_{i+1}$ 把它们合并成 $\\gcd(a_i,a_{i+1})$。求把整个序列合并起来的最小代价。 &emsp;&emsp;$n \\leq 2 \\times 10^5,~1 \\leq a_i \\leq 10^{12}$&emsp;&emsp;2s","text":"题目大意&emsp;&emsp;有一个长度为 $n$ 的数组 $a_1,\\cdots,a_n$，每次选相邻的两个数 $a_i,a_{i+1}$，花费代价 $a_i+a_{i+1}$ 把它们合并成 $\\gcd(a_i,a_{i+1})$。求把整个序列合并起来的最小代价。 &emsp;&emsp;$n \\leq 2 \\times 10^5,~1 \\leq a_i \\leq 10^{12}$&emsp;&emsp;2s \\\\ \\\\ \\\\题解&emsp;&emsp;这题推性质好强啊。。 【35%】$n \\leq 3000$&emsp;&emsp;首先可以 $O(n^3)$ 区间 dp：$O(n^2)$ 枚举状态 $[l,r]$，$O(n)$ 转移。（可能带个 $\\log$） &emsp;&emsp;然后发现 $O(n)$ 转移是不必要的，最优情况肯定是从一个点出发不停地往左右扩展，即已合并的区域总是一个区间（反证法，假设最后一步合并 $[l,mid],[mid+1,r]$，那么两个区间必有一个 $\\gcd$ 更小，先做出小的再蚕食大的肯定更优），于是就 $O(n^2)$ 了。（可能带个 $\\log$） 【65%】$n \\leq 30000$&emsp;&emsp;这时需要两条性质：（此处直接搬uoj题解） &emsp;&emsp;引理 1：给 $k$ 个数求 $\\gcd$，直接递推调用欧几里得算法，时间复杂度为 $Θ(k+\\log a)$。&emsp;&emsp;注意到欧几里得算法执行 $(a,b)$ 的过程与 $(\\frac a{\\gcd(a,b)},\\frac b{\\gcd(a,b)})$ 相同，所以我们可以得到一个复杂度的表示 $Θ(\\log \\frac a{\\gcd(a,b)})=Θ(\\log a−\\log \\gcd(a,b))$。&emsp;&emsp;我们进行递推的时候，复杂度裂项相消就得到了 $Θ(k+\\log a)$。 &emsp;&emsp;引理 2：对于一个数列 $n$，前缀 $\\gcd$ 的连续段有最多 $\\lfloor \\log_2a \\rfloor+1$ 个。&emsp;&emsp;由于前缀 $\\gcd$ 如果有变化则至少除以 $2$，得证。 &emsp;&emsp;从一个点出发每次往一个方向走的时候，肯定是走到 $\\gcd$ 变了才停（不然没意义），或者是走到边界。左右都只有 $\\log a_i$ 段，因此从一个点出发的区间 dp 的复杂度就是 $O(n \\log^2 a)$ 了。&emsp;&emsp;然后求 $\\gcd$ 的时候注意往引理 1 上套。（一开始先 ST 表预处理区间 $\\gcd$，然后求出每一段的 $\\gcd$，然后基于正确的顺序合并区间） 【100%】$n \\leq 2 \\times 10^5$&emsp;&emsp;然后又要注意到，对于 $[l,r]$，如果 $r$ 不是从 $l$ 出发的变化点，$l$ 也不是从 $r$ 出发的变化点，那么 $[l,r]$ 的 dp 也是没有意义的。（因为必先走到 $[l,r-1]$ 或 $[l+1,r]$，这样的话在 $[l,r]$ 停下来是没有意义的。）&emsp;&emsp;因此有用的区间的总量就是 $O(n \\log a)$ 的了，基于这个做 dp 就是 $O(n \\log a)$ 的了。 &emsp;&emsp;实现的一些方法：一开始先预处理出所有的区间（利用一个性质：设 $L_i$ 为 $i$ 的左变化点集合，那么 $L_{i+1} \\subset L_i \\cup \\{i+1\\}$，右边同理）。按区间长度从小到大 dp，找到左端点的上一个区间，和右端点的上一个区间，进行转移。排序要用基数排序，有 $10^7$ 个区间。 \\\\&emsp;&emsp;（为啥把思路整理一遍，就像把题解抄了一遍一样 qaq） 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#define fo(i,a,b) for(int i=a;i&lt;=b;i++)#define fd(i,a,b) for(int i=a;i&gt;=b;i--)using namespace std;typedef long long LL;const int maxn=2e5+5, maxq=80*maxn;const LL inf=1e18;struct QST&#123; int l,r; LL gcd;&#125;;bool cmpQ(const QST &amp;a,const QST &amp;b)&#123; return a.r-a.l+1&lt;b.r-b.l+1 || a.r-a.l+1==b.r-b.l+1 &amp;&amp; a.l&lt;b.l;&#125;int n,p0,q0;LL a[maxn],s[maxn],f[maxq];QST p[maxq],q[maxq];int idl[maxq],idr[maxq];vector&lt;QST&gt; V[maxn];int main()&#123; scanf(&quot;%d&quot;,&amp;n); fo(i,1,n) scanf(&quot;%lld&quot;,&amp;a[i]), s[i]=s[i-1]+a[i]; fo(i,1,n) &#123; fo(j,1,p0) p[j].r=i, p[j].gcd=__gcd(p[j].gcd,a[i]); p[++p0]=(QST)&#123;i,i,a[i]&#125;; int newp0=0; fo(j,1,p0) if (j==1 || j==p0 || p[j].gcd!=p[j+1].gcd) V[i-p[j].l+1].push_back(p[++newp0]=p[j]); p0=newp0; &#125; p0=0; fd(i,n,1) &#123; fo(j,1,p0) p[j].l=i, p[j].gcd=__gcd(p[j].gcd,a[i]); p[++p0]=(QST)&#123;i,i,a[i]&#125;; int newp0=0; fo(j,1,p0) if (j==1 || j==p0 || p[j].gcd!=p[j+1].gcd) V[p[j].r-i+1].push_back(p[++newp0]=p[j]); p0=newp0; &#125; fo(i,1,n) for(QST j:V[i]) q[++q0]=j; int newq0=1; fo(i,2,q0) if (q[i].l!=q[i-1].l || q[i].r!=q[i-1].r) q[++newq0]=q[i]; q0=newq0; fo(i,1,q0) if (q[i].l==q[i].r) idl[q[i].l]=idr[q[i].r]=i; else &#123; int l=q[i].l, r=q[i].r, x=idl[l], y=idr[r]; f[i]=min(f[x]+q[x].gcd*(r-q[x].r)+s[r]-s[q[x].r], f[y]+q[y].gcd*(q[y].l-l)+s[q[y].l-1]-s[l-1]); idl[l]=idr[r]=i; &#125; printf(&quot;%lld\\n&quot;,f[q0]);&#125;","categories":[{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[{"name":"算法_数论","slug":"算法-数论","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E6%95%B0%E8%AE%BA/"},{"name":"算法_DP","slug":"算法-DP","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-DP/"}]},{"title":"【Pre-Finals 2016, Kent Nikaido Contest A】Tetris Puzzle 题解","slug":"【Pre-Finals 2016, Kent Nikaido Contest A】Tetris Puzzle 题解","date":"2020-02-04T14:34:44.000Z","updated":"2024-04-24T03:59:22.864Z","comments":true,"path":"【Pre-Finals 2016, Kent Nikaido Contest A】Tetris Puzzle 题解/","link":"","permalink":"http://kqp.world/%E3%80%90Pre-Finals%202016,%20Kent%20Nikaido%20Contest%20A%E3%80%91Tetris%20Puzzle%20%E9%A2%98%E8%A7%A3/","excerpt":"题目大意&emsp;&emsp;你有无限个这种 S 型的牌（一开始都如左上角那样放置），每次你可以选择一张牌，将其 Rotate，或将其 Flip，或将其放入一个 $N \\times N$ 的棋盘。棋盘上不能有牌重叠，被操作过的牌最后都必须放入棋盘。&emsp;&emsp;你有一个计数器，每当执行 Rotate 或 Flip 操作的时候，计数器会加 $1$。&emsp;&emsp;现在给你最终的棋盘状态（01 矩阵，表示每个格子有没有被覆盖），求计数器的奇偶性。（保证奇偶性唯一） &emsp;&emsp;$N \\leq 50$","text":"题目大意&emsp;&emsp;你有无限个这种 S 型的牌（一开始都如左上角那样放置），每次你可以选择一张牌，将其 Rotate，或将其 Flip，或将其放入一个 $N \\times N$ 的棋盘。棋盘上不能有牌重叠，被操作过的牌最后都必须放入棋盘。&emsp;&emsp;你有一个计数器，每当执行 Rotate 或 Flip 操作的时候，计数器会加 $1$。&emsp;&emsp;现在给你最终的棋盘状态（01 矩阵，表示每个格子有没有被覆盖），求计数器的奇偶性。（保证奇偶性唯一） &emsp;&emsp;$N \\leq 50$ 这可真是个有趣的问题 题解&emsp;&emsp;为什么奇偶性会唯一呢？到底是什么特征决定了它的唯一性呢？ &emsp;&emsp;聪明的 Zayin 想到了斜着看，发现按副对角线的方向来看，贡献为 0 的图形相当于是一个 $(2,2)$ 的覆盖，贡献为 1 的图形相当于是一个 $(1,1,1,1)$ 的覆盖。 &emsp;&emsp;于是就有很多办法了。比如先统计出每条对角线的奇偶性，因为 $(2,2)$ 是对奇偶性没有影响的，所以直接拿 $(1,1,1,1)$ 去覆盖这个数组，就知道了有多少 $(1,1,1,1)$。&emsp;&emsp;也可以像题解那样，直接统计下标 $\\bmod 4=0$ 的对角线的和的奇偶性就是答案。","categories":[{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[{"name":"算法_神奇的脑洞","slug":"算法-神奇的脑洞","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E7%A5%9E%E5%A5%87%E7%9A%84%E8%84%91%E6%B4%9E/"}]},{"title":"【长更】一句话题解（Official及相关camp）","slug":"short_sol_official+camp","date":"2020-01-18T15:04:10.000Z","updated":"2024-04-24T03:59:22.791Z","comments":true,"path":"short_sol_official+camp/","link":"","permalink":"http://kqp.world/short_sol_official+camp/","excerpt":"&emsp;&emsp;原来的太长了，更新和使用都不方便，就分裂一下。又水一篇blog &emsp;&emsp;标 * 的为有价值的题，标 ^ 的为欺诈题，标 - 的为知识点待填坑，标 ? 的表示看别人是这样做的但是没懂为什么&emsp;&emsp;组队训练的题，如果是队友过的板刷题，题面又很长，就会标个“队友说是沙雕题”","text":"&emsp;&emsp;原来的太长了，更新和使用都不方便，就分裂一下。又水一篇blog &emsp;&emsp;标 * 的为有价值的题，标 ^ 的为欺诈题，标 - 的为知识点待填坑，标 ? 的表示看别人是这样做的但是没懂为什么&emsp;&emsp;组队训练的题，如果是队友过的板刷题，题面又很长，就会标个“队友说是沙雕题” 2019 Official2019ccpc网络赛&emsp;&emsp;1001 1007：略&emsp;&emsp;1002：建一棵值域线段树，维护区间最大值&emsp;&emsp;1003：建 SA，用主席树找第 $k$ 小&emsp;&emsp;1004：用堆找第 $k$ 小，更新堆时，对于一条路径，要么加入末端点连出去最短的边，要么把最后一条边变大&emsp;&emsp;1005：$a$ 和 $b$ 互质的话就变成 $\\sum_{i=1}^n \\sum_{j=1}^i (i-j)[\\gcd(i,j)=1]$ 了，再化成 $\\sum i\\phi(i)$ 然后杜教筛&emsp;&emsp;1006：倒着做&emsp;&emsp;1008：按 $t_i$ 从大到小排序，前面每煮一条鱼会剩下 $t_i \\mod k$ 的时间，存到堆里，到后面没鱼可煮了要钓一条煮一条的时候，就拿这个堆来优化&emsp;&emsp;1009：分层递推（设 $f_{i,x,y,now}$ 表示当前到了第 $i$ 层，黑点放了 $x$ 个，白点放了 $y$ 个，当前层共有 $now$ 个点，的答案，$i$ 这一维可以优化掉） 2019 ICPC 银川 网络赛&emsp;&emsp;当年他 tourist 用 4 小时 AK WF，我 *** 今天用 5 分钟 AK 网络赛，不是问题&emsp;&emsp;ABC：队友说是沙雕题&emsp;&emsp;D：第一问是 $\\frac 12$，第二问递推一下&emsp;&emsp;*E：数据结构课练习题&emsp;&emsp;F：动态 Floyd&emsp;&emsp;G：暴力 dp 是 $O(nk)$ 的&emsp;&emsp;H：按 $\\frac{局数}{ATK}$ 从小到大打&emsp;&emsp;K：&emsp;&emsp;*L：像析合树的预处理部分那样，扫描右端点，线段树维护左端点是否可行&emsp;&emsp;&emsp;&emsp;方法一：维护 $区间最大值-区间最小值-不同的数的个数$&emsp;&emsp;&emsp;&emsp;方法二：维护 $区间长度-[有多少个 x满足x和x+1都在区间内]-最大值的个数$&emsp;&emsp;&emsp;&emsp;方法二的代码长度是方法一的两倍 2019 ICPC 南京 网络赛&emsp;&emsp;A：剥洋葱那样从外到里一圈一圈地确定给定坐标的权值，然后线段树维护一下&emsp;&emsp;*B：暴力递归，欧拉降幂，指数很快就 $0$ 的了&emsp;&emsp;**C：解法一：打表，每 $\\sqrt n$ 打一次表，每组询问 $O(n \\sqrt n)$&emsp;&emsp;&emsp;&emsp;解法二：$2^{ij}=\\sqrt 2^{i^2+j^2-(i-j)^2}$，推式子 NTT&emsp;&emsp;D：求的是 $\\frac{E(d^2)+E(d)}{2}$，$E(d)$ 和 $E(d^2)$ 都是简单的拓扑递推&emsp;&emsp;E：莫比乌斯反演一套打下去，前面 $\\sum_{i=2}^k x^i$ 是等比数列求和，后面 $\\mu \\ast id^2$ 用杜教筛&emsp;&emsp;F：对于每个 $i$ 在 $[pos_i-k,pos_i+k]$ 找最大的转移过来&emsp;&emsp;H：暴力 Floyd&emsp;&emsp;*I：按照 $t_i$ 从大到小排序，假设前 $k$ 个人机洗，那么随着 $x$ 递减，$k$ 是递增的，维护一个凸壳 2019 ICPC 徐州 网络赛&emsp;&emsp;CJM：略&emsp;&emsp;BEI：随便维护&emsp;&emsp;*A：斐波那契博弈&emsp;&emsp;D：SAM&emsp;&emsp;*F：通过容斥转化为求某个点子树内距离它不超过 $x$ 的点的点权和，这是个二维数点&emsp;&emsp;G：回文树&emsp;&emsp;H：要求的是 $\\sum_{i=1}^n f(i)$ 和 $\\sum_{i=1}^n f(i)i$，考虑每个质数的贡献，前 $O(\\sqrt n)$ 个质数暴力做，后面的质数用 min25&emsp;&emsp;K：$O(n^2)$ 枚举对称中心，$O(n)$ 计算答案&emsp;&emsp;L：状压 dp，求两点距离打个表观察一下有惊喜（ 2019 ICPC 南昌 网络赛&emsp;&emsp;BG：略&emsp;&emsp;*A：方法一：每 100 个数取一次样，看下在不在给定的数组里，在的话就暴力判一下&emsp;&emsp;&emsp;&emsp;方法二：&emsp;&emsp;C：矩阵乘法优化递推&emsp;&emsp;*D：要求 $[k]x:\\prod_{i=1}^n(1+a^{s_i}x)$，分治模任意模数 FFT，敢写敢过&emsp;&emsp;E：约瑟夫，递推&emsp;&emsp;F：考虑 $S$ 每个本质不同的子串的贡献，因此用 SAM 维护&emsp;&emsp;H：求个通项，然后大步小步预处理&emsp;&emsp;*I：设 $b_i=[a_i\\not= a_{i-1}]a_i$，那么每次就是问一个矩形中（$[l,r]$，$[x,y]$）有多少个点，树套树或者 cdq 2019 ICPC 沈阳 网络赛&emsp;&emsp;FH：略&emsp;&emsp;BCD：队友说是沙雕题&emsp;&emsp;*E：$n \\leq p$ 预处理，$n&gt;p$ 利用 Touchard 同余记忆化搜索&emsp;&emsp;G：大力推式子，发现是递推&emsp;&emsp;J：$f_i=\\sum_{j=1}^{\\min(X,i)} \\binom{i-1}{j-1}\\cdot (j-1)! \\cdot f_{i-j}$，移项就是 $O(n)$ 递推，然后该递推的前 $X$ 项都是 $1$（卡常）&emsp;&emsp;K：高斯消元解出 $p$ 然后矩阵乘法递推 2019 ICPC 上海 网络赛&emsp;&emsp;BJL：略&emsp;&emsp;*A：方法一：线段树维护树的直径，修改时只用修改子树 dfs 序区间的两个端点，然后维护一下每个点到根的距离以便询问两点距离，共 $O(n \\log^2 n)$&emsp;&emsp;&emsp;&emsp;方法二：动态点分&emsp;&emsp;C：每个 $C$ 的贡献是有多少对 $A,B$ 满足 $A+B \\geq C \\geq |A-B|$，用 $A$ 和 $B$ FFT 一下就好&emsp;&emsp;D：大于 $1$ 的数不会很多，暴力搜索就好&emsp;&emsp;E：&emsp;&emsp;G：&emsp;&emsp;*H：每个元素维护从队尾乘到它是多少，路径压缩，bitset 加速矩阵乘法&emsp;&emsp;F：贪心逐位确定，用 dp 算方案数&emsp;&emsp;K：分别画半径为 $a$ 和 $b$ 的圆，然后分别求圆上整点，然后 two pointers 找答案 2019ccpc 秦皇岛&emsp;&emsp;A：作为直角点时极角排序扫一遍，作为非直角点时离线枚举直角点，然后把其余点极角排序扫一遍&emsp;&emsp;D：判断 $n$ 是否只含 $2$ 和 $5$&emsp;&emsp;E：每个机器人的路线不会重叠，因此每个格子拆成横点和竖点，跑最大流&emsp;&emsp;F：tarjan 求边双&emsp;&emsp;G：狠狠地压状态&emsp;&emsp;I：简单 bfs&emsp;&emsp;J：倒过来 kmp&emsp;&emsp;^K：如果有叶子的父亲多于一个儿子，则必胜；否则看叶子到父亲的链长，全是偶数必败，否则可以归约到第一种情况&emsp;&emsp;*L：二分，然后中间每个人按照到达左出口的距离从大到小排序，贪心往右出口塞&emsp;&emsp;BCHL： 2019ccpc 哈尔滨&emsp;&emsp;F：略&emsp;&emsp;*A：解法一：二分，然后差分约束，判负环&emsp;&emsp;B：$O(2^mm^2)$ dp（设 $f_{i,j,k}$ 表示第 $i$ 个数，与 $r$ 的 lca 深度为 $j$，与 $r+1$ 的 lca 深度为 $k$，的贡献）&emsp;&emsp;E：根只有一个，直接算每个叶子要给根贡献多少次&emsp;&emsp;**H：首先只有开始和结束两个时刻是有用的。图可以看作是一棵树加 50 条边。全局按照 $dis_x+cost_x$ 进行 Dijkstra，每个点只会被松弛一次。每个点分中心维护距离队列，每个点在他点分树祖先以及 50 个关键点的队列里进行松弛。&emsp;&emsp;I：递推，$h_i&gt;h_{i-1}$ 就乘 $2$，$h_i=h_{i-1}$ 就相当于插空&emsp;&emsp;J：$n$ 为奇数则 $3+(n-3)$，为偶数则 $2+(n-2)$，$5$ 以内无解&emsp;&emsp;K：$w_i+k\\cdot\\frac{w_i}{sum}$&emsp;&emsp;L：$O(n^2)$ 预处理所有可能的状态，然后 $O(nq)$ 回答询问。 2019 ICPC Regional 南京&emsp;&emsp;A：取后一半&emsp;&emsp;*B：最后一定是在四个角落结束，且是沿着矩形的边界从一个角落走到另一个角落这样的，因此就是推个组合数式子&emsp;&emsp;D：DAG 计数&emsp;&emsp;H：最坏情况是 $b+c$ 个假人一起演真人，因此真人至少要 $b+c+1$ 个，特判 $1~0~0$&emsp;&emsp;*I：暴力 dp，整数拆分压状态&emsp;&emsp;J：算出每个 $b$ 匹配每个 $c$ 的收益，跑 KM&emsp;&emsp;K：若给定点在三角形顶点上，则连到对边中点；否则按比例算一下连到对边去 2019 ICPC Regional 沈阳&emsp;&emsp;AH：略&emsp;&emsp;D：把 $e^{\\min\\{a_i\\}}$ 提取出来&emsp;&emsp;-E：圆的反演&emsp;&emsp;G：区间 dp，设 $f_{i,j}$ 表示 $i$ 到 $j$ 这段点加上 $(i,j)$ 这条边形成的多边形的划分数，$i$ 和 $j$ 必然同时连向 $[i+1,j-1]$ 中的一个 $k$&emsp;&emsp;*J：每条边算出一个存活时间。按时间分治，每条边有 $\\log$ 个小区间是完全存活的，用并查集维护当前连通情况，边在完全存活时加入并查集，退出时撤销，分治到底就询问&emsp;&emsp;-K：答案为 $n-1$ 的整数拆分，五边形数&emsp;&emsp;L：贪心 2019 ICPC Regional 南昌&emsp;&emsp;L：略&emsp;&emsp;A：解法一：可持久化并查集&emsp;&emsp;&emsp;&emsp;解法二：按时间树 dfs，维护一个可撤销并查集，删点或者更换集合的时候不用真删，开一个数组用于记录每个点的实际指向即可&emsp;&emsp;*B：状压 dp，左边前 $i$ 个点和右边后 $n-i$ 个点合起来形成一个状态&emsp;&emsp;&emsp;&emsp;看大题解&emsp;&emsp;C：枚举 $i$ 最高位的 $1$ 在哪，对于 $n$ 的 $1$ 的位，有 $3$ 种选择，对于 $n$ 的 $0$ 的位，有 $2$ 种选择&emsp;&emsp;*D：每个 $d$ 单独做，设 $f_{i,0/1}$ 表示以全 $0$ 或者全 $1$ 进入这棵子树所得到的答案，这可以 $O(n)$ 递推&emsp;&emsp;E：队友说是沙雕题&emsp;&emsp;^G：那个模数不是质数，最大的质因子为 $2803$，因此等价于 $n&lt;2803$&emsp;&emsp;*J：burnside+矩阵快速幂 2019 ICPC Regional 银川&emsp;&emsp;GILN：略&emsp;&emsp;A：dp，设 $f_{i,j,k}$ 表示前 $i$ 张卡，选了 $j$ 张，加成为 $k$，的最大获利。&emsp;&emsp;B：设 $a_{x,y}=-1$，找另一行另一列的一个点 $(x’,y’)$，则 $a_{x,y}=a_{x’,y}+a_{x,y’}-a_{x’,y’}$&emsp;&emsp;*C：dp，枚举 $i$，每个点到 $i$ 的极差可以用单调栈和树状数组维护出来，极差从左往右是下降的。考虑每次询问二分，然后发现有类似于决策单调的性质，就不用二分了。注意卡常！&emsp;&emsp;D：简单莫比乌斯反演（可能直接叫容斥比较好），注意欧拉降幂&emsp;&emsp;*E：按位考虑，考虑第 $i$ 位和第 $j$ 位，那么所有的 $a$ 分为 4 类（00、01、10、11），其中 00 和 11、01 和 10 配对能产生 $2^{i+j}$ 的贡献，这个 $O(n)$ 遍历一遍即可。&emsp;&emsp;F：队友说是沙雕题&emsp;&emsp;H：按有向边的拓扑序，对每个无向连通块跑最短路&emsp;&emsp;*J：老套路，如果最后在 $1$ 结束则是环边计一次树边计两次，如果不在 $1$ 结束则把树边边权取负跑最短路，类似于退流&emsp;&emsp;K：注意到左右矩阵的元素是一一对应的，就可以精细地写出 $O(n^2)$ 的枚举 2019 EC Final&emsp;&emsp;A：队友说是沙雕题&emsp;&emsp;C：方法一：dp，设 $dp_{i,j}$ 表示把 $i$ 分配成 $j$ 个元素的贡献。幸好厦门的 F 比你早出&emsp;&emsp;&emsp;&emsp;方法二（未验证）：$f=g^{k^{-1}}$&emsp;&emsp;E：$最大流=\\frac{总容量}{路径长}$，每条路径都可以有若干个阶梯状的 $(x,y)$ 表示增加一个单位的流量需要花费 $x$，最多 $y$ 次。然后用堆取 $(x,y)$ 取到最大流为止。&emsp;&emsp;G：$10!$ 枚举&emsp;&emsp;H：把所有的 $\\frac{a_{i+2}}{a_i}$ 和 $\\frac{a_{i+1}}{a_i}$ 统计出来，取出现最多的 12 个。若有长度 $\\geq \\frac n2$ 的等比子序列，则公比必在其中&emsp;&emsp;M：把每一类 $a,a^2,\\cdots,a^k$ 抽出来暴力 2019 Sichuan Province Programming Contest&emsp;&emsp;A：暴力&emsp;&emsp;B：一定有一条直线使矩形在两侧，讨论两个矩形的放法&emsp;&emsp;C：队友说是沙雕题&emsp;&emsp;*D：树形 dp，每个点要么把它的儿子全部断掉，要么它本身作为某种颜色的根，然后保留这个颜色的虚树，其他断掉&emsp;&emsp;E：meet in the middle&emsp;&emsp;*G：若 Alice 先手，必胜当且仅当存在两个大于 $k$ 的质数 $p_1,p_2$，使得 $|(x-p_1)-(y-p_2)|=1$，for 一遍判断即可；若 Bob 先手，枚举 Bob 第一步转化为 Alice 先手&emsp;&emsp;H：略&emsp;&emsp;^I：根据 $\\sqrt{x_i}$ 为比例来分配&emsp;&emsp;J：每种选择的次数都是 $O(\\sqrt{k})$ 的，枚举两种选择的次数，unordered_map 判断另一种选择的次数&emsp;&emsp;K：建一个有向图，地图上一个点能走到相邻点，当且仅当有一种问号安排方式使它走过去，那么如果从起点开始能走到环，或是走到一个点使其可以无路可走，那么就无解，否则就是最长路&emsp;&emsp;F： 2020 Official2020 CCPC 网络赛&emsp;&emsp;CGJ：略&emsp;&emsp;-**A：横边贡献是线段并长度，竖边的贡献是 $\\sum |a_i-a_{i+1}|$，用 segment tree beats 维护&emsp;&emsp;B：min25 卡常&emsp;&emsp;*D：对于一个询问，二分一个 $mid$（实际不用二分），权值大于 $mid$ 的点叫黑点，否则叫白点。从黑点开始反向 bfs，黑点能到达的先手点也都是黑点，只能到达黑点的后手点也是黑点。然后去掉二分，改为点权从大到小加入&emsp;&emsp;E：解法一：打表看 $SG$&emsp;&emsp;&emsp;&emsp;解法二：如果没有因子 $2$ 那么就是“质因子个数”的 nim 游戏；质因子 2 的话只要点了就会变成 $SG=0$，所以假设质因子 2 是最后点的，那么就相当于所有的质因子 2 都合并成一个，所以 $SG(n)=n 的奇质因子个数+[n是偶数]$&emsp;&emsp;*H：每一层已探索的门一定是连续的一段区间，因此可以 dp 设 $f_{i,l,r,0/1}$ 表示当前在第 $i$ 层，已探索了 $[l,r]$ 的门，当前在 $l$ 还是 $r$，的期望&emsp;&emsp;^K：$K$ 矩阵相当于重新分配 $A$ 矩阵的元素权值，若 $K_{1,1} \\not =1$，则无穷步之后 $A$ 的值都会泄漏到矩阵外面去&emsp;&emsp;*L：容斥转化成 $x-y&gt;K$ 或 $y-x&gt;K$，然后大力数位 dp&emsp;&emsp;M：转化成若干个单项式相乘&emsp;&emsp;FI： 2020 ccpc 威海&emsp;&emsp;DH：队友说是沙雕题&emsp;&emsp;A：$\\min(\\max(2nt,2t+x),\\max((2n+1)t,t+x))+2nt$&emsp;&emsp;B：每个障碍周围 8 个点都是关键点，关键点之间做 Floyd，算答案的时候枚举起点到哪个关键点，终点到哪个关键点，又注意到每个障碍物对于起点、终点各只有一个关键点是有用的，因此 $O(qk^2)$&emsp;&emsp;C：考虑每条边的贡献，当且仅当这条边一侧有 1 人、另一侧有 2 人时有贡献&emsp;&emsp;*F：opentrain6277D 逐层分解，每次找到度数最小的点（一定是最外层的），然后用双源 bfs 剥离最外层&emsp;&emsp;G：线段树维护 hash，要双 hash&emsp;&emsp;*J：黑堆的 $SG$ 值只与黑堆最小值及其重复次数、是否等于最大值有关，枚举最小的黑堆及其重复次数，后面就是个线性基&emsp;&emsp;*K：$p_1,\\cdots,p_{l-1}$ 分出了若干个大区间，每个大区间独立操作，每个大区间里又会被 $p_l,\\cdots,p_r$ 分成 $O(r-l)$ 个小区间，在这里做区间 dp&emsp;&emsp;L：$x_i$ 只考虑质数，多重背包&emsp;&emsp;EI： 2020 ZJCPC&emsp;&emsp;AK：略&emsp;&emsp;BE：队友说是沙雕题&emsp;&emsp;C：建 trie 或者直接字符串哈希，卡常&emsp;&emsp;F：把 AI 实验课写的 PLA 贴上来&emsp;&emsp;G：只能是从起点开始沿 $v_i$ 递增的路线走到某个风洞，然后从这个风洞直接走到终点，因此 $O(n^2)$ 枚举&emsp;&emsp;H：共 $O(nm)$ 个关键点，相邻关键点之间的线段逐一判断&emsp;&emsp;I：这是一幅若干简单环组成的图，最大环即为答案&emsp;&emsp;*L：快排法求第 $k$ 小&emsp;&emsp;DJ： 2020 ICPC 小米邀请赛&emsp;&emsp;中国大陆全明星赛&emsp;&emsp;**B：分治，跨过当前分治中线的区间的答案只有三种：左边后缀的最大子段、右边前缀的最大子段、左边后缀的最大后缀+右边前缀的最大前缀，预处理出左边每个后缀的最大子段、最大后缀，枚举右边前缀，讨论三种情况都是二维数点算方案数&emsp;&emsp;*E：要么除以 2 然后调整，要么会拆成 $a,b$ 两个数，其中 $a$ 比 $b$ 多一位，dp 求最优&emsp;&emsp;G：$O(3^n)$ 状压 dp，$SG$ 从小到大做的话每次找一个极大独立集，从大到小做的话每次找一个集合连向已选的所有点&emsp;&emsp;I：只要发现爆阈值是一定不会发生的话（因为爆之前回答问题一定会更优），就是个简单 dp 了&emsp;&emsp;J：状压，从上往下放，已有的书的重心要么在新书的左边界，要么在右边界&emsp;&emsp;K：暴搜，bfs 的队列最大只会到 1300 多&emsp;&emsp;ACDFHLM： 2020 ccpc 秦皇岛&emsp;&emsp;AE：略&emsp;&emsp;F：每个连通块的 $\\max(0,边数-点数)$ 加起来&emsp;&emsp;G：枚举开根后的数&emsp;&emsp;H：记 $f_{i,j}$ 表示前 $i$ 个数最大值为 $j$ 的方案数（这是正着 dp），同理搞个倒着的 dp 记 $g_{i,j}$ 表示 $i$ 开始的后缀“第一次出现的数”最小是 $j$ 的方案数，算答案时就是前缀后缀合并&emsp;&emsp;J：枚举 $d$ 然后枚举余数段，余数段每次往右移一段时对方案数的影响是 $O(1)$ 计算的&emsp;&emsp;K：树形 dp，假设每棵子树 1 个兵开局，则这个兵最后会在最深的叶子上，那么就把儿子按最深叶子深度排序，依次枚举，如果把兵从它最深的叶子提上来的代价超过从根再派一个过来，就从根再派一个过来&emsp;&emsp;BDIL： 2020 ccpc 长春2020 ICPC Regional 南京&emsp;&emsp;^D：度数本身就 $\\le \\frac n2$ 的点直接 Kruskal 合并，剩下的边 random_shuffle 1000 次左右&emsp;&emsp;EF：队友说是沙雕题&emsp;&emsp;H：若 $n=1$ 或 $m=1$ 无解；若 $n&gt;7$ 或 $m&gt;7$ 则任意方案都合法；否则爆搜&emsp;&emsp;*I：二分答案，按 $y$ 关键点从小到大维护可行的 $x$ 坐标段&emsp;&emsp;*J：询问操作等价于找有多少个 $a_i$ 满足它的二进制第 $b$ 位为 $1$（其中 $b$ 是这次游戏 $SG$ 值的最高位），因此 segment tree beats 维护区间异或和、区间每个二进制位为 $1$ 的数量&emsp;&emsp;K：前 $k$ 位 shift 一下&emsp;&emsp;L：找区间最长的 $a$ 连续段&emsp;&emsp;M：经典的“看上去是 $O(n^3)$ 实际上是 $O(n^2)$ 的树型 dp”&emsp;&emsp;ABCG： 2020 ICPC Regional 济南&emsp;&emsp;A：每一列单独考虑，对 $A$ 矩阵推一下式子是一个线性基&emsp;&emsp;C：尽量避免两个 $2$ 合并&emsp;&emsp;D：队友说是沙雕题&emsp;&emsp;*F：&emsp;&emsp;G：根据 $y$ 的最高位在 $x$ 那里是不是 $1$ 讨论一下&emsp;&emsp;*H：min-max 容斥，转化为求各种链并大小的方案数。设 $dp_{i,j,k}$ 表示 $i$ 这棵子树，链并为 $j$，目前有条链往上最长延伸了 $k$，的方案数。转移都是前后缀转移，因此是 $O(n^3)$ 的&emsp;&emsp;*J：2 位作为奇偶层标记位（奇 $01$ 偶 $10$，这样使得同为奇层或同为偶层的不会相互连边），然后选择奇层和偶层较小的一方作为标记层（最多 50 个点），标记层的结点获得 $1$ 至 $50$ 的编号，在 $50$ 位中把它编号的那一位填 $0$ 其他位填 $1$；非标记层的结点默认 $50$ 位全 $0$，相邻的标记结点编号填 $1$。&emsp;&emsp;L：直接枚举 $x$ 的最后 8 位、8 位后的连续 1 的数量、总共的 1 的个数&emsp;&emsp;M：$\\max(2,\\lceil\\frac{2n}{k}\\rceil)$&emsp;&emsp;BEFIK： 2020 ICPC Regional 昆明&emsp;&emsp;好耶，大学生和中学生互相给对方出原题&emsp;&emsp;A：可撤销贪心。问题转化成有若干个元素，每个元素有代价 $v_i$，相邻元素不能同时选，问 $m$ 代价以内最多选多少个。每选一个元素，就把左右的元素合并起来，代价为 $v_{i-1}+v_{i+1}-v_i$，用堆维护。&emsp;&emsp;*B：上下界最小费用可行流，先假设全放白棋，那么第 $i$ 行连向第 $j$ 列两条边，一条费用 $-sw_{ij}$ 表示不放棋，一条费用 $sb_{ij}$ 表示放黑棋，注意负环消圈&emsp;&emsp;*C：区间 dp，设 $dp_{l,r}$ 表示区间 $[l,r]$ 合并成同色的最小步数，观察到最后该区间的颜色一定是端点的颜色，因此可以只对该区间内端点颜色的点做背包，复杂度 $O(n^2+n\\cdot 15^2)$&emsp;&emsp;*D：$n | k^n$&emsp;&emsp;-F：出题人说是抄 17 集训队论文的回文树&emsp;&emsp;G：按生日排序，设 $dp_{i,j,k}$ 表示考虑了前 $i$ 个人，空了 $j$ 个人没做蛋糕（如果 $j&gt;m$ 就视为 $j=m$），总共花了 $k$ 天做蛋糕，的最大收益&emsp;&emsp;H：$2020+x$&emsp;&emsp;I：队友说是沙雕题&emsp;&emsp;J：观察到，任意的环可以一步变成若干个二元环，因此答案最多为 2&emsp;&emsp;K：依次枚举：摸到哪张牌、打掉哪张牌、雀头、刻子&emsp;&emsp;L：$ans_i=(a_1,\\cdots,a_i 的最长下降子序列长度)$&emsp;&emsp;*M：每次询问，置 $mex$ 初始为 $1$，看 $(last_mex,mex]$ 之间是否有数，有就把 $last_mex \\gets mex$，把 $mex += (last_mex,mex] 中的数求和$，否则结束。可以证明这是 $O(\\log a)$ 的&emsp;&emsp;E： 第十一届山东省大学生程序设计竞赛&emsp;&emsp;B：$n \\le 1000$ 时直接 Kruskal，$n$ 大时直接是 $n-1$，注意 $L=R$&emsp;&emsp;C：倍增。一棵子树如果加一个兄弟和父亲，那么方案 $\\times 2+1$；如果只加一个父亲，那么方案 $+1$&emsp;&emsp;D：队友说是沙雕题&emsp;&emsp;F：两个字符串拼起来，一定是一个串形如 $a$ 另一个串形如 $bab$，因此枚举每个串的 boarder 然后 hash 寻找有没有 $a$&emsp;&emsp;G：高精度除法&emsp;&emsp;H：队友说是沙雕题&emsp;&emsp;I：用线段树维护每个位置的权重，以及区间和，乘法标记可不下传，注意模数是 3 和 7 的倍数因此要记下这两个因子的次数&emsp;&emsp;*J：解法一：设 $dp_{i,j}$ 表示考虑了能力值前 $i$ 的人，当前剩余 $j$ 个老师，的最大收益。$j$ 只开 500 然后卡常&emsp;&emsp;*M：$A$ 矩阵奇数行全 1 且第 1 列全 1，$B$ 矩阵偶数行全 1 且最后一列全 1&emsp;&emsp;AEKL： 2021 Official2021 CCPC 网络赛 1&emsp;&emsp;A：略&emsp;&emsp;B：一个周期不超过 27720，直接求出来然后随便搞搞&emsp;&emsp;*E：解法一：写成矩阵乘法：$ans=v_{init}\\sum_{i=1}^n\\sum_{j=1}^n\\binom{i+j}{i}A^iB^j$，然后 NTT&emsp;&emsp;&emsp;&emsp;解法二：写成通项公式：$ans=\\sum_{i=1}^n\\sum_{j=1}^n\\binom{i+j}{i}(\\alpha_i \\lambda_1^j+\\beta_i \\lambda_2^j)$，然后 NTT&emsp;&emsp;&emsp;&emsp;解法三：令 $f(i)=\\sum_{j=1}^n\\binom{i+j}{i}A^iB^j$，求出 $f(i)$ 与 $f(i+1)$ 的递推关系&emsp;&emsp;F：$(8^2-7^2)-(6^2-5^2)=4$，即连续 4 个数可以得到一个 4。利用这个来构造&emsp;&emsp;G：枚举 $g(x)$，最值只在端点和对称轴取，因此在符合条件的 $x$ 里找 lowerbound 和 upperbound&emsp;&emsp;I：前缀和 hash&emsp;&emsp;*J：最多走 6 步就全是 $b_i$ 了，因此用高斯消元算出全 $b_i$ 的情况，前 6 步 dp&emsp;&emsp;K：简单 dp&emsp;&emsp;L：每个 $i$ 实际上是转移到前面的某个 $p$ 的倍数，而由于答案是单调的，所以这个 $p$ 应是 $i$ 的质因子里最大的&emsp;&emsp;*M：讨论三种情况的凸包求切&emsp;&emsp;BCH： 2021 CCPC 网络赛 2&emsp;&emsp;1002：提神醒脑讨论题&emsp;&emsp;^1004：解法一：质数间隔很小，直接上 Miller_Rabin，暴力枚举 $f(x)$ 和 $f(f(x))$&emsp;&emsp;&emsp;&emsp;解法二：如果 $f(x)&gt;2$，那么 $g(x)$ 一定是整数，且在两个相邻的素数之间，所以一定是合数&emsp;&emsp;1005：求出周期 $p$，假设 $p&gt;0$，记 $s_i$ 为 $a_i$ 的前缀和，那么就是求 $\\min_{i|s_i\\equiv x\\pmod p} \\frac{x-s_i}{p}+i$，将 $-\\frac{s_i-(s_i \\bmod p)}{p}+i$ 按 $s_i \\bmod p$ 分类放好，那么求答案就是个前缀最小值&emsp;&emsp;1006：找到所有的 nunhehheh，统计后面的 a 的个数&emsp;&emsp;1007：假做法：格子要么是链（两头可能封闭）要么是环，先把有开口的链全部归先手，剩下的两头封闭链和环从小到大排序分奇偶给先手后手&emsp;&emsp;1009：队友说是沙雕题&emsp;&emsp;*1010：最终形态就是 $2n$ 个点形成一个大环，所以贪心，左边每个点依次去找右边的不跟它同一连通块的最小点&emsp;&emsp;1011：按点权从小到大激活每个点，激活一个点意味着它相邻的连通块全部跳到它，因此每个点跳跃路径形成一棵树&emsp;&emsp;1001 1003 1008 1012： 2021 Jiangxi Provincial Collegiate Programming Contest&emsp;&emsp;A：$O(n^3)$ dp，注意空间&emsp;&emsp;BCD：队友说是沙雕题&emsp;&emsp;*E：最多只能跑一个兵，所以判断：1、是否有兵能直接逃；2、是否有两个兵的横差大于纵差，这样这两个兵不能同时被吃；3、特判一个兵在另一个兵的直接左上角，这时两个都可以吃&emsp;&emsp;F：dp&emsp;&emsp;*G：按 $\\sqrt{1e6}$ 分为小质数和大质数，小质数暴力，大质数相当于求区间众数，莫队&emsp;&emsp;*H：如果不能开局打死后手，那么后手必胜&emsp;&emsp;*I：每个人要么是 $a_i$，要么是某个 $a_j+dis(j,i)$，旋根 dp&emsp;&emsp;J：解法一：二分+链表 check&emsp;&emsp;&emsp;&emsp;解法二：预处理每个数至少要多大的 cache 才能使其命中&emsp;&emsp;K：平方和公式&emsp;&emsp;L：线段树求区间并 2021 ICPC Regional 澳门&emsp;&emsp;A：任找一条哈密顿路，如果正着走不合法那么反着走一定合法&emsp;&emsp;C：队友说是沙雕题&emsp;&emsp;*E：根号平衡，大小在 $\\sqrt n$ 以内的环暴力枚举每种置换，大小超过 $\\sqrt n$ 的环做卷积&emsp;&emsp;F：模 $n$ 意义下各数的差不变，因此枚举 $a_1$ 的增量，$n$ 次枚举即可&emsp;&emsp;G：设 $dp_{i,0/1}$ 表示要读 $i$ 这个数而它在左端点/右端点的最小代价，用线段树预处理 $i$ 在左端点/右端点时下一个读不到的数&emsp;&emsp;*H：考场解法：考虑 $i$ 下一个是 $j$ 的贡献，要么 $i$ 是 $j$ 的直接父亲，$O(n)$ dp；要么 $i$ 和 $j$ 没有祖先关系，拓扑序会形成一个小环，$O(n^2)$ dp。总共 $O(n^4)$ 但是除以很多个 $2$&emsp;&emsp;I：所有串拼起来做 SA，只有 SA 上相邻的两个串可以连边做 MST。评测机过慢导致 SA 会被卡常，需要改成 SAM&emsp;&emsp;K：MST&emsp;&emsp;BDJ： The 17th Heilongjiang Provincial Collegiate Programming Contest (2022 黑龙江省赛)&emsp;&emsp;A：题目的隐藏条件是横放的书的右端点不能超出竖放的书。二分或者推式子 $O(1)$&emsp;&emsp;C：2-SAT 用主席树优化连边 从底往上 dp，设 $f_i$ 表示 $i$ 划到 $A$ 集合里时，子树里的 $B$ 集合的点最小是多少；设 $g_i$ 表示 $i$ 划到 $B$ 集合里时，子树里的 $A$ 集合的点最大是多少&emsp;&emsp;*D：第一个圆心切向第二个圆（半径为 $2$）并作切线的垂线得到第二个圆的运动区域，由此判断第三个圆是否落在区域内。&emsp;&emsp;*E：先清洗掉 $b_i$ 含有的平方因子，然后式子变成 $\\sum_i \\sum_j \\frac{b_i \\cdot b_j}{\\gcd(b_i,b_j)^2}$，正常反演&emsp;&emsp;FGH：队友说是沙雕题&emsp;&emsp;I：$O(k^2)$&emsp;&emsp;L：扩展 kmp&emsp;&emsp;BJK： 2022 Hubei Provincial Collegiate Programming Contest (2022 湖北省赛)&emsp;&emsp;A：核酸点之间 MST，非核酸点一定是走到最近的核酸点&emsp;&emsp;BJ：队友说是沙雕题&emsp;&emsp;*C：（队友做了不想看了）&emsp;&emsp;*E：从高位到低位考虑，每一位一定是选最后一个 or 1 或者最后一个 and 1 作为它 1 的来源（初始也可以看作是一个 or 1），然后后面的 and 0 全部反转，这等价于一个后缀的 and 全部反转，所以从高位到低位依次处理即可&emsp;&emsp;*F：$2, 3, \\cdots, n-1, n-1, n-2, \\cdots, 2$&emsp;&emsp;G：枚举答案的奇偶性，这样就知道每个位置所需的奇偶性，从左往右每个奇数跟其下标奇偶性相反的奇数配对，横着填过去，中间再加一层横着的消掉对中间的影响，其他竖着填&emsp;&emsp;H：一步操作之后的状态数很少，数位 dp 一下&emsp;&emsp;K：略&emsp;&emsp;L：直接线段树懒标记即可，$s_i$ 转换是单点修改，一定会把相关标记全部推下去的&emsp;&emsp;DI： 2022 Official2022 ICPC Regional 西安&emsp;&emsp;*A：鬼脚图，每条 bridge 本质上是交换排列中的两项。时间分治&emsp;&emsp;*B：对于每个 $k$，染非 0 色就相当于选尽可能多的点使得每一行选不超过 $k$ 个、每一列选不超过 $k$ 个，因此枚举 $k$，增量网络流&emsp;&emsp;C：最优一定是先大家一起克隆，然后大家一起出题&emsp;&emsp;*D：每个人有个 $m$ 维数组表示他在各比赛中的名次，各比赛也可以对这个五维数组做后缀和，因此每走一步相当于五个后缀和取 $\\min$。对每个人预处理倍增即可&emsp;&emsp;E：$f(x)$ 相当于三进制下的数位和加位数，先给 $r$ 加 $1$，然后枚举第一个比 $r$ 小的数位，后面全填 $2$&emsp;&emsp;F：每个队单独考虑&emsp;&emsp;G：队友说是沙雕题&emsp;&emsp;H：超级无敌大分类讨论&emsp;&emsp;J：最多选两个数，所以求最大和次大就行&emsp;&emsp;*L：可以证明如果有反链，一定是全体叶子，所以一层一层地剥掉叶子即可 2022 ICPC Regional 南京&emsp;&emsp;AGI：队友说是沙雕题&emsp;&emsp;*B：考虑修改点是否被选，如果选，那就是前后缀合并（前后缀分别都是单调队列优化 dp）；如果不选，枚举一下修改点上一个被选的位置，也是前后缀合并和单调队列&emsp;&emsp;D：二分，然后每个没满足要求的点可以给起始点贡献一个区间&emsp;&emsp;*E：考场解法：长链剖分，记 $dp_{x,i}$ 表示 $x$ 子树往下 $i$ 层的最小代价，把数组从 $x$ 转移给 $x$ 的父亲时可能有更新，但更新的形式是 $\\min$ 上 $a$ 数组的区间最小值，可以懒标记&emsp;&emsp;&emsp;&emsp;题解解法：每一层建虚树&emsp;&emsp;&emsp;&emsp;看大题解&emsp;&emsp;*J：二分图左边的点表示 $i-a_i$，右边的点表示 $i+a_i$，每个 $i$ 是一条边。对于每个连通块，大小为奇数无解，大小为偶数任建生成树从底往上贪心&emsp;&emsp;K：NaN 点相当于把堆分为两个独立部分，大力推式子&emsp;&emsp;M：求出下凸壳的数量，注意一吨细节&emsp;&emsp;CFHL： 2023 OfficialThe 2023 ICPC Asia EC Regionals Online Contest (I)&emsp;&emsp;AL：略&emsp;&emsp;*B：$T$ 在 $S_1$ 的 SAM 中对应一个 fail 子树，在 $S_2$ 的 SAM 中也对应一个 fail 子树，问题就是两个子树共有的 $j$ 有多少个，二维数点&emsp;&emsp;D：每个连通块补成团&emsp;&emsp;F：找规律加归纳可得 当三个数不同的时候必胜，所以仅需考虑形如 $0,0,x$ 的情况，$x$ 所含的质因子 $2$ 的数量如果是奇数则必胜，偶数则必败。总数减掉不合法的，建个 trie&emsp;&emsp;G：只需每次判断 $a_i$ 所在连通块连向 $b_i$ 所在连通块是否合法即可，合法那么答案一定是乘上 $\\frac{1}{size_{a_i} \\cdot size_{b_i}}$，判断合法就启发式一下，按度数或者 size 启发式都可以&emsp;&emsp;I：直接 dp，滚动数组或者把最后三个 0/1 的维度容斥掉&emsp;&emsp;JK：积分推式子，基本都是跟圆心有关&emsp;&emsp;CEH： 2023 ICPC Regional 杭州&emsp;&emsp;A：恶心大模拟&emsp;&emsp;*B：只需判断每个区间 $[2^i,2^{i+1})$ 是否有解，有解输出 $2^i$ 即可。判断有解用 FFT&emsp;&emsp;*D：$x, a, 1-a, \\cdots, a, 1-a, 1$&emsp;&emsp;F：每个询问二分，相当于问 $[1,mid]$ 是否有点到询问点的距离超过 $k$。预处理每个前缀的直径，只需考虑直径端点&emsp;&emsp;G：最短路，特殊处理初始被蛇身占领的格子&emsp;&emsp;H：环套树，树边都可以递推（注意递推是求一个长度，不是概率也不是期望），环上的点如果 $a$ 全相同那么谁都不会加 $w$，如果 $a$ 不全相同则必有 $x$ 连向 $y$ 且 $a_x &lt; a_y$，那么 $x$ 必然加 $w$，从这里破环为链&emsp;&emsp;J：队友说是沙雕题&emsp;&emsp;K：带区间修改的主席树&emsp;&emsp;M：略&emsp;&emsp;CEIL： 2023 ICPC Regional 南京&emsp;&emsp;A：bfs 求出所有 $(x_1,y_1,x_2,y_2)$ 表示 $(x_1,y_1)$ 的袋鼠能否把 $(x_2,y_2)$ 的袋鼠干掉&emsp;&emsp;^C：相当于求有多少个 $k$ 使得 $(kp+1) \\oplus (p-1) \\le m$，可以像数位 dp 一样扫一遍，也可以略加分析然后只判断 $O(1)$ 个 $k$&emsp;&emsp;*D：记 $dp_{i,j}$ 表示以 $i$ 为根的子树每条路径有 $j$ 个黑点的最小代价，$dp$ 关于 $j$ 是凸的，维护其差分&emsp;&emsp;F：实际上是问 DAG 有没有不是 $1 \\to 2 \\to \\cdots \\to n$ 的拓扑序&emsp;&emsp;G：将物品按照价值从小到大排序，必有一个后缀是全选的，且全选的后缀中，代价最大的 $k$ 个被免费选走，所以枚举这个后缀，前面普通背包&emsp;&emsp;*K：从左到右的最短路等价于从上到下的最小割等价于从上到下的最大流，相当于每条边衍生出一条容量无穷、费用为 1 的边，求最小费用增加 $k$ 的流量&emsp;&emsp;L：首先把重量为 1 的物品合并，于是重量就没有用了，所以从大到小贪心即可&emsp;&emsp;M：线段树维护区间的水平面之和、柱高最大值，每次修改一根柱子，会修改左右一片的水平面&emsp;&emsp;I：队友说是沙雕题&emsp;&emsp;BEHJ： 2023 ICPC Regional 济南&emsp;&emsp;AD：队友说是沙雕题&emsp;&emsp;*B：当 $k \\le \\sqrt n$ 时，$dp_{i,j}$ 表示以 $i$ 为根的子树，根所在块大小为 $j$，的方案数，子树卷积 dp；当 $k &gt; \\sqrt n$ 时，$j$ 的含义变成该子树切了多少个大小为 $k$ 的块出去&emsp;&emsp;E：先求一个最大匹配，然后新增的边一定是从源点能到的左边点到能到汇点的右边点（这样才能流残余网络），也可以用交错路来讨论&emsp;&emsp;G：第 $j$ 列和第 $c-j+1$ 列总共最多两个 1（中间的列最多一个 1），这两个 1 所在的行可以视为连了一条边，给每个连通块 01 染色，成功就答案乘 2，失败就输出 0&emsp;&emsp;*H：大讨论修改字符对每个后缀的影响&emsp;&emsp;I：每次从左到右找第一个 $a_i &gt; i$ 的，然后以它为左端点，找到尽可能远的右端点进行一次操作&emsp;&emsp;K：考虑固定左端点，右端点怎么算答案，这样就会推导出滑窗维护 $\\sum_{j=1}^i 1-(a_j-a_{j-1})$ 的中位数的做法&emsp;&emsp;M：凸包凹一点，想办法枚举凹的那个点即可&emsp;&emsp;CFHJL： 其他 ICPC/CCPCThe 13th Chinese Northeast Collegiate Programming Contest (2019CNCPC)&emsp;&emsp;BCJ：略&emsp;&emsp;^*D：数据结构诈胡大师：关键点只有 $O(m)$ 个，建棵虚树跑暴力，时间 $O(m^2)$&emsp;&emsp;E：非叶子节点把它相关的所有边连向其中最小的那个&emsp;&emsp;*F：拆点，从出度为 0 的开始倒着拓扑求 $SG$，注意演员不能当作对面的人&emsp;&emsp;G：横纵坐标独立，聪明一点就取中位数，不聪明就三分&emsp;&emsp;H：noip2018 铺设道路 2010 ICPC Regional Dhaka&emsp;&emsp;ABC：略&emsp;&emsp;D：状态数很少，暴力&emsp;&emsp;E：$O(n^3)$ 的 dp 能过（设 $f_{i,j}$ 表示区间 $[i,j]$ 的答案）&emsp;&emsp;F：可以先让某对对称位置不一样，然后把别的换完，最后换这对位置。要讨论一下&emsp;&emsp;G：合法的场数是连续的一段数，调和级数求和&emsp;&emsp;*H：方法一：短边所对应的顶点一定是距离最远的，直接三分套三分&emsp;&emsp;&emsp;&emsp;方法二：分别假定每个点是最远的，然后跑局部搜索（阉割的模拟退火），得到三个答案，可证取最小即为最后答案&emsp;&emsp;*J：最大点权独立集（网络流）+字典序最小方案（贪心让每个点归属于 $S$ 集或 $T$ 集） 2013 Southwestern Europe Regional Contest (SWERC 13)&emsp;&emsp;CEI：略&emsp;&emsp;A：给了 20s，直接 $O(n^4)$ dp&emsp;&emsp;B：费用流 或 最小流 或 最大权匹配&emsp;&emsp;*D：套路题。暴力生成前几个串 $A_i$，直到 $|A_i| \\geq |S|$。然后先判断 $A_i$ 是否包含 $S$，再判断 $A_i L A_i^{-1}$ 之类的是否包含 $S$&emsp;&emsp;F：数位 dp&emsp;&emsp;G：暴力搜索&emsp;&emsp;H：dp $f_i$ 表示 $T$ 串从 $i$ 开始往后的不同的方案数 2018 ICPC Regional Seoul&emsp;&emsp;BDF：略&emsp;&emsp;A：扫描线，扫描 y 轴枚举第一条线，用线段树查找覆盖最多的位置作为第二条线&emsp;&emsp;*C：先放 $a_{\\frac n2}$，然后 $a_{\\frac n2-1}$，然后 $a_{\\frac n2+1}$，然后 $a_{\\frac n2-2}$，然后 $a_{\\frac n2+2}$……&emsp;&emsp;E：&emsp;&emsp;*I：计蒜之道2016复赛 青云的网络设计方案。基本思想就是，分层确定，最后讨论第二第三层怎么搞&emsp;&emsp;&emsp;&emsp;看大题解&emsp;&emsp;K：2-SAT&emsp;&emsp;L：算出每天需要新开多少个人，然后每天贪心地选人，优先选工作狂 2015 ICPC Regional 沈阳&emsp;&emsp;*B：$i$ 和 $j$ 以 two pointers 的形式往前枚举（若 $s_j$ 是 $s_i$ 的子串则 $j$ 往前走，否则 $i$ 往前走）&emsp;&emsp;D：队友说是沙雕题&emsp;&emsp;F：把 $a_i$ 变成 $\\gcd(a_i,m)$，最多只有 $m$ 的约数个不同的 $a_i$。在由 $m$ 的约数构成的整除关系图上模拟容斥&emsp;&emsp;G：讨论三种情况：A 直接在 2-3 这条边上蹲 B；A 直接在 3-4 这条边上蹲 B；A 先摸了 2 然后去 3-4 这条边上蹲 B。注意 corner case 和精度&emsp;&emsp;^H：大家一起走，每一条指令最多会产生 2000 次合并，记录偏移量，暴力并查集&emsp;&emsp;I：三维偏序，有两维在 1000 以内这个可以写得暴力一点&emsp;&emsp;K：首先发现它是个卷积，然后写个模任意质数 NTT&emsp;&emsp;M：每个集合新建一个方点，跑最短路 2015 ICPC Regional 上海&emsp;&emsp;F：略&emsp;&emsp;A：队友说是沙雕题&emsp;&emsp;B：用 $2$ 的幂来构造，$n$ 为偶数时先构造 $n-1$ 再给 $2^{k-1}$ 加 $1$&emsp;&emsp;*D：把挡板建出笛卡尔树，然后分治&emsp;&emsp;E：记忆化搜索 $f_{a,b,c,k}$ 表示枚举三位，第一位数字为 $a$，第二位数字为 $b$（乘号视为 $10$），第三位数字为 $c$，进行了 $k$ 次交换，的贡献和&emsp;&emsp;K：预处理前后缀的答案，枚举换哪一位&emsp;&emsp;L：模拟往回走，路径是一条链来的 2014 ICPC Regional 西安&emsp;&emsp;A：队友说是沙雕题&emsp;&emsp;B：大模拟&emsp;&emsp;*C：二分，然后二元关系网络流&emsp;&emsp;E：平移可以看作是一个平行四边形加上端点的两个扇形；旋转就是一个大扇形&emsp;&emsp;F：推式子，是个容斥&emsp;&emsp;G：两个串拼起来建个回文树&emsp;&emsp;H：总共 $O(n^2)$ 个游戏状态形成一幅 DAG，递推一下就好了&emsp;&emsp;I：建个 trie 乱搞&emsp;&emsp;K：相当于更相减损术中所有元素都会出现一次 2011 ICPC Regional 成都&emsp;&emsp;A：无脑递推（设 $f_{i,j}$ 表示有 $i$ 堆 $1$、其他和为 $j$，是必胜还是必败）&emsp;&emsp;B：手掰是点数减一，刀切是 $\\log$&emsp;&emsp;D：状压 dp（设 $f_{i,s}$ 表示到了第 $i$ 个点，状态为 $s$ 的最小代价，状态是三进制的）&emsp;&emsp;E：每一局 Alice 只有两种选择，是个 2-sat&emsp;&emsp;*H：考虑每条边的贡献，就是两棵子树的 size 的 $\\min$ 的两倍&emsp;&emsp;I：大模拟&emsp;&emsp;*J：根据二阶差分可以算出腿数 $\\leq k-1$ 的动物，剩下的大讨论 2019 ICPC Regional Southern and Volga Russian (NERC)&emsp;&emsp;AH：略&emsp;&emsp;BCFLN：队友说是沙雕题&emsp;&emsp;E：对于两个点，若他们必须相同或相反，则连一条边，那么一个连通块只有两种染色方案&emsp;&emsp;G：枚举最后一次 Reset 在哪，前面的只要贪心让自己不爆牌就行了，后面的就找到最远的位置使自己恰好不爆牌，看对面爆不爆牌。后面的部分可以 two pointers&emsp;&emsp;J：二分&emsp;&emsp;*M：对于边长为 $n$ 的矩阵，取掉左下的最大矩形、右上的最大矩形，还剩下的左上矩形和右下矩形是可以并行操作的，因此操作数大约是 $f(n)=f(\\frac n2)+4$ 2019 ICPC Regional Jakarta&emsp;&emsp;ACGH：队友说是沙雕题&emsp;&emsp;B：dp，设 $f_{i,j}$ 表示 $i$ 这棵子树，$i$ 状态为 $j$ 的方案数，一个点有 3 种状态：作为终止端点、作为非终止端点、不是端点&emsp;&emsp;E：贪心然后调整&emsp;&emsp;F：枚举根，然后 hash&emsp;&emsp;J：dp，设 $f_{i,j}$ 表示到了第 $i$ 块石头，选了 $j$ 个 $G_3$，所能达到的最少的奇数段数量是多少&emsp;&emsp;K：线段树维护矩阵&emsp;&emsp;L：网络流 2014 ICPC Regional 鞍山&emsp;&emsp;EI：队友说是沙雕题&emsp;&emsp;B：$n$ 只有 $5000$，暴力&emsp;&emsp;*C：不合法的三元组是，有两对互质一对不互质，或者有一对互质两对不互质。对于每个数算出 $(跟它互质的数\\times跟它不互质的数)$，那么不合法的三元组每个被算了两次&emsp;&emsp;D：距离平方和最小是取平均数，用 $n-k$ 的滑窗算一遍&emsp;&emsp;G：每个 byte 只有两种取值（阈值以上和以下分别取 $w$ 最大的），然后二元关系&emsp;&emsp;H：打表，暴力写得优美可以 10s 出解&emsp;&emsp;K：暴力旋转（枚举一条边，再枚举另一条边套上去）套 Burnside&emsp;&emsp;L：题意转化成：点集的子树并全体 +1、点集的祖先链并求和，线段树维护 2014 ICPC Regional 北京&emsp;&emsp;A：队友说是沙雕题&emsp;&emsp;B：搜索剪枝冲过去了&emsp;&emsp;C：x 轴 y 轴独立，解同余方程&emsp;&emsp;D：区间 dp（设 $f_{i,j}$ 表示 $[i+1,j-1]$ 全部删掉的最小代价）&emsp;&emsp;E：总的减去不合法的，不合法的就枚举交点算一算&emsp;&emsp;*F：$X^3$ 转化成，枚举 $i,j,k$，问有多少种方案使得这三盏灯全亮。状压 dp&emsp;&emsp;**G：解法一：暴力找出前 1e8 个解，剪枝冲过去了？？？&emsp;&emsp;&emsp;&emsp;-解法二：DAG 轻重链剖分，在重链上二分跳出去的位置，每个询问两个 $\\log$&emsp;&emsp;H：折半搜索，FWT&emsp;&emsp;I：圆环交板子&emsp;&emsp;*J：dp，设 $f_{i,j,0/1}$ 表示考虑 $i$ 的子树，$i$ 这个点在它的子树里排第 $j$，它是否被选，的答案。&emsp;&emsp;K：如果一个数后面有比它小的，它就一定要操作一次 2019 ICPC Regional North-Western Russia&emsp;&emsp;A：队友说是沙雕题&emsp;&emsp;B：第 $i$ 个数为 $11+710i$&emsp;&emsp;*C：每个叉的左右两条竖线都加上，跑欧拉回路&emsp;&emsp;*E：以一个关键点为根，在其他关键点的深度为 $\\frac{deep_i}{2}$ 的祖先处打标记，标记可以下传到他其他儿子上。最后 dfs 一遍看谁的标记数量是关键点减 1&emsp;&emsp;H：每种 $t$ 只算一次，暴力复杂度是 $O(\\sum a \\ln \\sum a \\log n)$ 跑不满&emsp;&emsp;I：先求出一个矩形边框作为金字塔底边的必要条件，再取矩形的较长的边长作为金字塔底边长&emsp;&emsp;J：倒着逐位确定&emsp;&emsp;K：使 A 极大，然后每个字母默认是一行，某一行空了就沿用它上一行或下一行&emsp;&emsp;*L：SAM 上枚举每个结点作为 border，那么最小的 period 就是这个结点的出现位置集合的最小差分&emsp;&emsp;M：$O(n^2)$ 写优美一点 2019 ICPC Regional Taipei-Hsinchu&emsp;&emsp;CDHJK：略&emsp;&emsp;A：暴力&emsp;&emsp;*B：树形 dp 疯狂讨论&emsp;&emsp;*E：考场解法：$-inf,-inf,0,0,\\cdots,0,-1,a$，则 std 是 $1997(a-1)$，他是 $a$，理想情况下 $1996(a-1)=k+1$。若 $1996$ 不整除 $k+1$，则把 $k+1$ 变大，并且修改第一位。&emsp;&emsp;&emsp;&emsp;别人解法：$-1,a_2,a_3,\\cdots,a_{1999}$，其中 $\\sum_{i=2}^{1999} a_i=k+1999$，则 std 是 $1999(k+1998)$，他是 $1998(k+1999)$。妙啊&emsp;&emsp;I：暴力&emsp;&emsp;L：四边形的四个点一定都在凸包上，旋转卡壳&emsp;&emsp;*M：魔改的组合数取模，主要目标是修正组合数中 $D$ 各质因子的数量，使其成为正常的组合数取模。 2019 ICPC Subregional Brazil&emsp;&emsp;ABDGHJM：队友说是沙雕题&emsp;&emsp;*E：找到♀最少（有多个时♂最多）的缸，称为♂缸，如果♂缸里有♂则需要再找一个♂最少的缸作为♀缸。剩下的每个缸有一个扔♂的代价和扔♀的代价，一个空缸可以减少一点扔♂的代价，于是 dp 确定最小值。注意一堆特殊情况！！&emsp;&emsp;F：&emsp;&emsp;I：&emsp;&emsp;*K：大力推式子（枚举开头所在列和结尾所在列），最后是个斐波那契数列求和&emsp;&emsp;L：出烂掉的广州一模题，$ans=2^{n的二进制的1的位数}$ 2019 ICPC Regional North American Southeast (Div 1)&emsp;&emsp;H：略&emsp;&emsp;A：暴力&emsp;&emsp;B：预处理每个询问是哪个数组的哪个版本，然后每个数组单独处理&emsp;&emsp;D：二分图最大独立集&emsp;&emsp;E：预处理 $f_{i,j,k}$ 表示长度为 $i$ 的序列、前 $j$ 个位置不算 fixed point、共放了 $k$ 个 fixed point 的方案数（全错排+组合数），然后贪心放&emsp;&emsp;F：&emsp;&emsp;G：树上 LIS，正常地用线段树做 LIS，每个点临走时把自己造成的影响还原回去&emsp;&emsp;I：字符串处理题，每个封闭的区域都需要破一道墙&emsp;&emsp;J：把每个数字的最后出现位置集合记为 $s$，那么就是在 $[1,s.begin()-1]$ 里选最小的，这样一直贪心下去 2019 ICPC Regional Northwestern European (NWERC 2019)&emsp;&emsp;FI：略&emsp;&emsp;AEG：队友说是沙雕题&emsp;&emsp;*B：贪心 check 每一个点，判断依据是会不会跟已选结点冲突、必需结点数量是否超过 $k$&emsp;&emsp;&emsp;&emsp;看大题解&emsp;&emsp;C：贪心，先放交点&emsp;&emsp;H：二分，转化成求最长的区间使得 $h_r-mid \\cdot r \\ge h_l-mid \\cdot l$，区间必有一端点在整点上，枚举整点，预处理前后缀最值&emsp;&emsp;*J：从大到小枚举最大改变量，相当于每次有一个元素从自由符号变成固定符号，只需判断每相邻两个固定符号是否会贡献一个删除操作&emsp;&emsp;K：dp&emsp;&emsp;D： 2019 ICPC Regional Southwestern European (SWERC 2019-20)&emsp;&emsp;ABCFGI：队友说是沙雕题&emsp;&emsp;D：模拟&emsp;&emsp;H：打表找循环节（大概几亿），然后分段打表&emsp;&emsp;J：设当前处理 $[l,r]$，把这个区间的最小值全部提取出来，贡献是个卡特兰数，剩下分成的区间递归处理&emsp;&emsp;K：边拆点无脑 dominator tree&emsp;&emsp;*L：观察发现每条河流的每段陆地连通块大小不超过 20，因此可以每段状压暴力算 SG&emsp;&emsp;E： 2019 ICPC Regional Latin American&emsp;&emsp;KLM：略&emsp;&emsp;EFGI：队友说是沙雕题&emsp;&emsp;A：$10^5$ 个点的 DAG 求最长反链，Dinic 跑最小链覆盖&emsp;&emsp;*H：dp，设 $f_{i,j,k}$ 表示先手 $i$ 分，后手 $j$ 分，先手手上握着 $k$ 点，的获胜概率。发现存在循环转移：&emsp;&emsp;&emsp;&emsp;解决方法一：无视循环迭代 100 次&emsp;&emsp;&emsp;&emsp;解决方法二：对 $f_{i,j,0}$ 进行二分，就会破掉这个环&emsp;&emsp;*J：从一个点出发肯定先到左右最大值较小的那个，然后再往对面跳一步，随便维护一下&emsp;&emsp;BCD： 2018 ICPC Regional Southwestern European (SWERC 2018)&emsp;&emsp;ADE：队友说是沙雕题&emsp;&emsp;B：二分，判断长度为 $mid$ 的连续段是否合法&emsp;&emsp;C：暴力&emsp;&emsp;F：枚举一个点，极角排序 two pointers&emsp;&emsp;*G：每个串如果是 APP 则可以直接得到 ascii 码的和，如果是 SUB 则递归求 ascii 码和，转化成前缀询问，每次只走一个方向&emsp;&emsp;H：三次最短路以后三维数点&emsp;&emsp;I：先把边框和噪音去掉，然后对每一个连通块做模式识别&emsp;&emsp;*J：先对前两个数、后两个数分别生成足够的后 $\\frac n3$ 位相同的数对，然后暴力枚举两边的数对&emsp;&emsp;K：区间 dp 2018-2019 ICPC, NEERC, Northern Eurasia Finals&emsp;&emsp;EG：略&emsp;&emsp;A：枚举比分情况，判断是否合法&emsp;&emsp;B：把每个 cavalier 拆成两个点，并连一条边，跑一般图最大匹配&emsp;&emsp;*C：每步暴力 $O(n^2)$ 找重心，询问重心，然后删去不合法的点&emsp;&emsp;F：若 $n$ 为质数的幂则二进制分组；否则找两个互质的因子就可以解了&emsp;&emsp;H：把 2-sat 做成 DAG 之后满足三个条件即可：$\\forall$ 不能互相到达、$\\exists$ 不能到达它后面的 $\\forall$、$\\exists$ 不能到达自己的反&emsp;&emsp;**I：析合树计数 dp&emsp;&emsp;&emsp;&emsp;看大题解&emsp;&emsp;K：$ans=\\max_{i:t_i \\leq T}\\{t_i+d_i+\\sum_{j:t_i&lt;t_j \\leq T} t_j\\}$，线段树随便维护一下&emsp;&emsp;L：贪心&emsp;&emsp;M：队友说是沙雕题&emsp;&emsp;DJ： 2019 ICPC NERC Northern Eurasia Finals&emsp;&emsp;BEK：队友说是沙雕题&emsp;&emsp;A：带很多细节的贪心&emsp;&emsp;*F：考场解法：先把第二个序列补全到总长为 $n+m-1$，然后 prufer 还原，途中若第一个序列不够长则把第二个序列的补全位让给第一个序列&emsp;&emsp;&emsp;&emsp;正常解法：把第一个序列任意补全到长度为 $n-1$，把第二个序列任意补全到长度为 $m-1$，一定有解&emsp;&emsp;J：暴力枚举 $s$，复杂度是 $O(n)$ 的&emsp;&emsp;*L：先贪心前 $k$ 个一位一位地放&emsp;&emsp;CDGHI： 2017 ICPC Regional Latin American&emsp;&emsp;BCEH：略&emsp;&emsp;A：（队友做了不想看了）&emsp;&emsp;*D：用 set 维护连续段。势能分析，每次操作最多增加 2 个连续段，所以连续段的总量是 $O(n)$ 的&emsp;&emsp;F：二维数点&emsp;&emsp;G：dp，设 $f_{i,s,t}$ 表示以 $i$ 为根的子树，原本应该是 $s$ 但现在却是 $t$ 的方案数&emsp;&emsp;I：MST 上找最大边&emsp;&emsp;J：$n$ 的约数都 $O(n)$ 判断一下&emsp;&emsp;*K：黑白染色，网络流，源点连向黑格子，黑格子连向白格子，白格子连向汇点，o 的位置流量为 $1$，其余位置流量为 $2$，这样一种流的方案就对应原图一种画法。&emsp;&emsp;*L：假设从左下走到右上，竖直距离大于水平距离，那么就是找一列宽度为 $1$ 的来游走补回多出的竖直距离，其他情况同理，稍微推推式子&emsp;&emsp;M：把一个栈看成一个字符串，每次贪心找字典序最小的那个 ICPC Egyptian Collegiate Programming Contest (ECPC 2018)&emsp;&emsp;BFLM：队友说是沙雕题&emsp;&emsp;A：折半搜索&emsp;&emsp;*C：dp，设 $f_{i,j}$ 表示 $A$ 数组前 $i$ 个位置匹配了 $j$ 个，的最小代价。转移条件是转移点到 $i$ 之间不能有正在匹配的数字。单调队列转移&emsp;&emsp;D：简单莫比乌斯反演&emsp;&emsp;E：dp，设 $f_{i,j,k}$ 表示用了 $i$ 个数、最后一段长度为 $j$、最后一个数相对大小为 $k$ 的方案数。转移就考虑是新开一段还是接在最后一段末尾&emsp;&emsp;H：等价于 $u$ 往外走 $L-k$ 步能走到的最小边&emsp;&emsp;I：枚举直角点，极角排序+two pointers&emsp;&emsp;*J：GDKOI2015 青蛙跳环 $x$ 和 $x+\\frac n2$ 的连边情况是一样的，把它们缩为一个点，去除重边，就成了欧拉回路&emsp;&emsp;K：分为 $P$ 在左边、$P$ 在右边、$P$ 在中间被劈开分别计数&emsp;&emsp;G： 2020 ICPC Asia Taipei-Hsinchu Site Programming Contest&emsp;&emsp;ABM：队友说是沙雕题&emsp;&emsp;C：$O(n^2)$ 暴力冲过去了 std 甚至连空间都是 $O(n^2)$ 的&emsp;&emsp;*D：先把度数 $&gt;28$ 的点去掉，剩下的搜索&emsp;&emsp;*E：区间 dp，设 $dp_{l,r}$ 表示 $[l,r]$ 消掉是否可行，再设 $f_{l,r}$ 表示 $[l,r]$ 这段消掉某些区间之后最多剩下多少个颜色 $s_l$&emsp;&emsp;F：环套树最小点覆盖，对于一条环边枚举某一端点作根然后断掉这条边形成树做 dp&emsp;&emsp;G：树哈希+最小表示&emsp;&emsp;H：MST&emsp;&emsp;I：点双模板题&emsp;&emsp;K：数位 dp 但是不用 dp，从高位到低位依次枚举前 $i$ 位压线，用排列算方案数&emsp;&emsp;JL： EC-Final 2017&emsp;&emsp;A：$2^n-\\sum_{i=0}^{k-1}\\binom{n}{i}$&emsp;&emsp;B：均值是固定的，每个 $a_i$ 关于 $m_i$ 的代价的一阶导也是递增的，所以直接贪心&emsp;&emsp;*C：只要等了红灯接下来必定全程绿灯，而他一定可以选择在某个灯下等红灯，因此是 $\\sum s+\\max b_i$&emsp;&emsp;H：LIKE就是全部选元音或全部选辅音，存在DISLIKE可以用 dp 或者贪心&emsp;&emsp;J：实际上是每次选的长度 $\\ge 3$ 都可以，差分之后贪心&emsp;&emsp;KM：略&emsp;&emsp;*L：只要摆出 S _ _ S 这样的局面，且其余的空位数量是偶数，那么先手必胜了，因此：$n \\le 6$ 暴力（全部是平局）；$7 \\le n \\le 15$ 若 $n$ 奇数则先手胜否则平局；$n&gt;15$ 若 $n$ 奇数则先手胜否则后手胜&emsp;&emsp;DEFGI： 2018-2019 ICPC Northwestern European Regional Programming Contest (NWERC 2018)&emsp;&emsp;*A：两维独立，每一维任务是找出 $x_1 \\le x_2 \\le \\cdots \\le x_n$ 使得 $\\sum(x_i-a_i)^2$ 最小。枚举 $i$，若当前 $x_{i-1} \\le a_i$ 则令 $x_i=a_i$；否则 $x_i$ 要跟 $x_{i-1}$ 相等（可能还要跟更前的相等），并整体左移&emsp;&emsp;B：按拓扑序的倒序依次贪心确定&emsp;&emsp;C：取 $\\alpha=\\frac{180\\degree}{n}$，然后各点按 dfs 序依次确定角度，间隔 $\\alpha$&emsp;&emsp;*D：二分答案 $mid$，找出 $[a,b]$ 时间段内能游走的子图，按 $dis(1,x) \\le a+mid-dis(x,n)$ 标出子图的起点，如果子图有环则一定合法，否则在 DAG 上 dp 出最长逗留时间&emsp;&emsp;&emsp;&emsp;看大题解&emsp;&emsp;E：shuffle 和 sort 都相当于是在一个集合上标注这是 shuffle 还是 sort&emsp;&emsp;*F：解法一：朱刘硬艹&emsp;&emsp;&emsp;&emsp;解法二：$s$ 边形成环套外向树，默认每个点都是通过树边通关的，每棵树默认都是用 $n$ 来破开环的，所以问题转化成从 $0$ 通关 $n$ 的最短时间，$O(n^2)$ dp&emsp;&emsp;G：从起点往外分成若干圈，每一步都要走到更外面的一圈即可&emsp;&emsp;H：贪心即可，注意相邻的 0 之间的贡献只能是偶数&emsp;&emsp;IJK：队友说是沙雕题 2020-2021 ACM-ICPC Latin American Regional Programming Contest&emsp;&emsp;A：归纳可证所有数都形如 $1/n$，因为 $1/n$ 与 $1/m$ 运算得到 $1/(n+m)$，因此暴力+打表&emsp;&emsp;B：枚举段长，预处理每个数的左右上升下降&emsp;&emsp;CDE：队友说是沙雕题&emsp;&emsp;F：$O(n^2)$ dp&emsp;&emsp;*H：相当于问有向图从 1 出发，有些边能经过无数次，有些边只能经过一次，问最多经过 1 号点多少次。将 1 号点拆点，网络流&emsp;&emsp;*J：合法的机器数和包含关系不多，建出图，按度数根号平衡&emsp;&emsp;K：$O(kn)$ dp&emsp;&emsp;L：暴力枚举初始时刻，$O(n)$ 判断&emsp;&emsp;*M：后缀平衡树&emsp;&emsp;N：看小数点后的数的和模 $100$&emsp;&emsp;GI： hdu 多校2019 Multi-University Training Contest 1&emsp;&emsp;*A：最小表示 dp（设 $f_{i,j,k,l}$ 表示到了第 $i$ 位，最小表示后第一个 $2$ 在第 $j$ 位，第一个 $3$ 在第 $k$ 位，第一个 $4$ 在第 $l$ 位的方案数）&emsp;&emsp;*B：每个点更新维护一个线性基，使得基元都是最新的&emsp;&emsp;&emsp;&emsp;看大题解&emsp;&emsp;D：逃生模型（$f_i=\\max(f_{i+1},\\frac{dis_{i}}{v_i})$）&emsp;&emsp;E：最短路图最小割&emsp;&emsp;I：贪心&emsp;&emsp;*K：枚举三次根，然后正常 $gcd$ 反演套路&emsp;&emsp;**L：三种前缀和分别对应三次组合数卷积&emsp;&emsp;&emsp;&emsp;看大题解&emsp;&emsp;*M：判断 $1$ 的凸包和 $-1$ 的凸包是否有交 2019 Multi-University Training Contest 2&emsp;&emsp;hdu多校怎么出成介个亚子啊&emsp;&emsp;B：合唱队形，字典序方案符合贪心性质&emsp;&emsp;E：考虑每一对的贡献，因此是 $\\frac{\\sum_{i=1}^n \\binom{i}{2} \\times \\frac12 \\times [\\sum_{j=0}^{\\infty} (\\frac14)^j]}{n}=\\frac{\\sum_{i=1}^n i(i-1)}{3n}$&emsp;&emsp;*F：每两点都会产生贡献，因此用 FWT 算 $cnt_i$ 表示有多少个点的 $x \\oplus y \\oplus z=i$&emsp;&emsp;-G：超现实数不平等博弈，详见 WC2018 杜老师课件&emsp;&emsp;H：二元关系&emsp;&emsp;I：回文树瞎搞&emsp;&emsp;J：每个二进制位都问一下，所以是 $n!$&emsp;&emsp;K：每个区间找最大的 50 个左右暴力判断&emsp;&emsp;L：枚举右端点，线段树维护左端点是否可行，那么是区间 $\\pm1$ 的操作 2019 Multi-University Training Contest 3&emsp;&emsp;B：dominator tree，写 DAG 版就好了&emsp;&emsp;D：二分，然后 dp 判断&emsp;&emsp;*E：式子最后化出来，前面是质数幂和（洲阁筛或 min25），后面是 $i^2\\phi(i)$（杜教筛或 min25）&emsp;&emsp;&emsp;&emsp;看大题解&emsp;&emsp;F：素数分布很密集的，$n$ 往前暴力找，Miller_Rabin 判一下，求阶乘用 Willson 定理&emsp;&emsp;G：线段树二分&emsp;&emsp;H：前缀异或和，询问区间有多少对数是不同的，带修莫队&emsp;&emsp;I：暴力连边费用流卡常加乱水&emsp;&emsp;K：dp，换根 2019 Multi-University Training Contest 4&emsp;&emsp;A：$n=2^k-1$ 时答案为 $1$，否则答案为 $0$&emsp;&emsp;C：分奇偶大讨论&emsp;&emsp;F：吃树和休息的贡献是独立的，贪心吃树的贡献，dp（斜率优化）休息的贡献&emsp;&emsp;*G：用逆序对来判断华容道是否有解，有解必有 120 步以内的解&emsp;&emsp;H：二分+主席树&emsp;&emsp;**I：$ans$ 初值为 $\\sum a_i$，每次默认加上 $\\sum b_i$，预处理 $-p_i$ 标记。用一个巧妙的分块优化&emsp;&emsp;&emsp;&emsp;看大题解&emsp;&emsp;J：先把 100 以内的质数判掉，那么剩下的质数指数都 $&lt;10$，最小指数 $cnt$ 满足 $(\\lfloor \\sqrt[cnt] n \\rfloor)^{cnt}=n$ 2019 Multi-University Training Contest 5&emsp;&emsp;*A：化成 $\\frac px \\leq \\frac bk \\leq \\frac p{x-1}$，套法雷序列&emsp;&emsp;B：两个数组放一起建棵 trie，然后 $n$ 次贪心&emsp;&emsp;*C：分别设 $S$ 和 $T$ 划分线段比例为 $x$ 和 $y$，根据面积相等列出两个等式，大讨论解方程&emsp;&emsp;D：$n$ 个关键点把函数划分成 $n+1$ 段，每段分别求解&emsp;&emsp;E：打个表观察一下就知道如何 next_permutation 了&emsp;&emsp;F：扩展 kmp&emsp;&emsp;G：$[x,y]$ 外面的走法是唯一的，因此问题化成 $1$ 走到 $y-x+1$，递推一下&emsp;&emsp;H：枚举对称轴暴力判，会有恶心的情况 2019 Multi-University Training Contest 6&emsp;&emsp;*A：最大获利，贪心模拟网络流，合并用长链剖分&emsp;&emsp;&emsp;&emsp;看大题解&emsp;&emsp;B：随机下 LIS 长度只有 $O(\\sqrt n)$，按这个分层来跑 LIS 的 dp&emsp;&emsp;D：队友说是沙雕题&emsp;&emsp;E：枚举上下边界，线段树维护区间最大值&emsp;&emsp;F：划分成 $n^2$ 个小区域，每个区域分别算答案&emsp;&emsp;H：$\\gcd(f(n,m)-n,n)=1$，因此 $f(n,m)-n$ 非常小，大概前 160 个质数那么大&emsp;&emsp;-I：杨氏图表&emsp;&emsp;*J：枚举根，dfs 序 dp，有用的 $m$ 只有 $O(\\sqrt m)$ 个&emsp;&emsp;*K：解法一：有用的问号不会太多，大概最后几十个，所以逐位确定就好了&emsp;&emsp;&emsp;&emsp;解法二：倍增式的逐位确定，详见题解&emsp;&emsp;L：贪心取叶子中的最大值，可证最优 2019 Multi-University Training Contest 7&emsp;&emsp;A：队友说是沙雕题&emsp;&emsp;*B：选 1 作根，对于每个点 $i$，它的儿子根据子树的形态（用 hash 来判）分为若干个类，那么这个点的贡献 $ans_i=\\frac{(儿子数量)!}{\\prod (每个类的个数)!}$，这棵树的答案为 $\\prod ans_i$，然后换根&emsp;&emsp;*F：让复习最少的 $n-k+1$ 题时间和大于 $m$，即前 $n-k+1$ 题不能全被卡，那么至少能做 $k$ 题&emsp;&emsp;G：本质上是每次带权二分，用 dp 实现，设 $f_i$ 表示区间长度为 $i$ 时的答案，由于 $f_i$ 单调递增，因此决策点也是单调的，可以 $O(n)$&emsp;&emsp;*H：四个象限都可以归约为第一象限，然后 $a=\\min(a,2b)$、$b=\\min(a,b)$，那么所有情况都可以归约为先 右左右左…… 地蛇形扭，再直走&emsp;&emsp;J：按 $a_i-b_i$ 排序（这是先手的收益），先手和后手分别从两端开始取，注意判断 $a_i=0$ 或 $b_i=0$ 的情况&emsp;&emsp;^k：设 $f_i$ 表示从 $i$ 走到 $i+1$ 的期望花费 2019 Multi-University Training Contest 9&emsp;&emsp;*A：一顿乱推得到 $g_m(n)$ 是两个调和级数相加（再加一些杂项），那么每 $\\sqrt n$ 打一次表，要用的时候再 $O(\\sqrt n)$ 去递推&emsp;&emsp;B：$ans=1+$交点数&emsp;&emsp;C：先折半搜索得到两个集合，然后对于每一位单独统计，枚举这一位是 $x+y+($是否进位$)=4$（或 $14$），然后提取出这一位是 $x$ 和 $y$ 的数，双指针扫一遍统计符合进位规定的数对&emsp;&emsp;E：开头一段 y 是不动的，然后看这段 y 后面是不是跟一个 z，如果是就会翻成 b，否则不动&emsp;&emsp;F：枚举 10、20、50 分别用多少&emsp;&emsp;*G：一条边分成两棵树，总共得到 $n-1$ 个直径对，双指针扫一遍统计贡献&emsp;&emsp;H：$n$ 次贪心，每次取异或和最大的一对&emsp;&emsp;*K：设 $g_i$ 表示 $i$ 个叶子的线段树的 叶子深度乘叶子 id 的和，$G_i$ 表示 $g_i$ 的前缀和，当然还要有一些辅助函数。记忆化搜索，每次只会到 $\\lfloor \\frac n2 \\rfloor$、$\\lfloor \\frac n2 \\rfloor \\pm1$ 两个数，再往下走会交的，因此总量是 $O(\\log^2 n)$ 的&emsp;&emsp;&emsp;&emsp;看大题解 2019 Multi-University Training Contest 10&emsp;&emsp;C：从大到小排序，答案一定是一个前缀&emsp;&emsp;E：按 $x$ 从小到大排序，枚举最后一个选 $x$ 的，那么它后面的全选 $y$，前面的用 set 维护与当前 $x$ 最接近的 $x$，其余选 $y$&emsp;&emsp;H：$a_i \\geq b_i$ 的可拆成独立的两个物品，这些散装的肯定是从大到小排序取前缀；$a_i&lt;b_i$ 的最多只有一个人是只选 $a$ 的，因此枚举 $a_i&lt;b_i$ 的这些里面选了多少个 $a_i+b_i$ 就行了，这个有单调性&emsp;&emsp;I：模拟&emsp;&emsp;*K：解法一：枚举长度 $len$，会激活 $a_i \\leq len$ 的点，然后对于每个被激活的区间算它的贡献（即假设这个区间就是这么长了，然后计算每个点作为左端点时的贡献）。然后再处理那些以它为左端点长度为 $len$ 时会遇到重复值的点&emsp;&emsp;&emsp;&emsp;解法二：分治，每次考虑跨过中线的区间，枚举左边的端点快速计算右边有多少个端点，枚举右边的端点快速计算左边有多少个端点 2020 Multi-University Training Contest 1&emsp;&emsp;D：特判 $n \\le 3$，当 $n&gt;3$ 时字符串一定是 $abcabcabc\\cdots$ 的形式&emsp;&emsp;E：直接用斐波那契的通项公式来推，二项式展开+等比数列&emsp;&emsp;*F：lxl 时间 以度数是否大于 $\\sqrt n$ 分为大点和小点&emsp;&emsp;I：按初始距离从大到小进栈（保证栈底到栈顶依次称王），每新来一个人，如果它能在栈顶称王之前就取代它，那么栈顶退栈&emsp;&emsp;L：凸多边形往内缩 $r$ 的距离得到新凸包（用半平面交实现），然后做半径为 $r$ 的圆角凸包，这就是能被圆覆盖到的面积&emsp;&emsp;ABCGHJK： 2020 Multi-University Training Contest 2&emsp;&emsp;A：每次肯定选整个连通块一直减，直到连通块分裂。倒序做，每次合并的时候计算贡献&emsp;&emsp;E：最小权匹配，每个工人只用连二次函数最值点附近 60 条边即可。用单路增广费用流&emsp;&emsp;G：二分一个 $mid$，然后树形 dp 判定，设 $f_{i,j}$ 表示以 $i$ 为根的子树，改了 $j$ 条边，保证自身直径不超过 $mid$ 的情况下，到 $i$ 的路径的最大长度最小是多少&emsp;&emsp;H：李超树&emsp;&emsp;I：暴力枚举框出来的每个格子，时间复杂度是对的。具体实现用射线法判断每个格子是否在多边形中&emsp;&emsp;J：爆搜+剪枝&emsp;&emsp;L：dp，设 $f_{i,j,k}$ 表示 $A$ 到了第 $i$ 位，$B$ 到了第 $j$ 位，lcs 为 $k$，的最大左端点是谁。查询时从大到小枚举 $ans$，若发现 $f_{r,*,ans} \\ge l$，则 $ans$ 合法&emsp;&emsp;BCDFK： 2020 Multi-University Training Contest 3&emsp;&emsp;DE：队友说是沙雕题&emsp;&emsp;C：每一位单独考虑，动态开点线段树维护子树的 $0,1$ 数量以及每个点的祖先链的 $0,1$ 数量&emsp;&emsp;*F：像数位 dp 那样依次枚举前 $i$ 位压线，后面是个组合排列问题，用整数拆分压状态&emsp;&emsp;I：贪心&emsp;&emsp;ABGHJK： 2020 Multi-University Training Contest 4&emsp;&emsp;BD：队友说是沙雕题&emsp;&emsp;^*C：dp，设 $f_{i,j}$ 表示考虑了 $i$ 个数，两个班重量差为 $j$，的最大 beauty 值。将数组随机打乱，限制 $j \\in [-10^5,10^5]$&emsp;&emsp;E：求出每个相邻对是否能换位，然后随便 dp 一下&emsp;&emsp;G：左边一排点表示 $x+t$ 的值，右边一排点表示 $x-t$ 的值，一个人代表一条连边，$n-最大匹配$ 即为答案。dinic 冲过去&emsp;&emsp;*I：考虑每条边的贡献，把 $\\min$ 拆掉是个组合数式子，预处理一些递推就能算了&emsp;&emsp;&emsp;&emsp;看大题解&emsp;&emsp;^K：引力太小可以忽略，物体几乎不动，直接输出初始距离&emsp;&emsp;AFHJL： 2020 Multi-University Training Contest 5&emsp;&emsp;A：$abc=h \\cdot S_{\\triangle ABC}$，最后推出 $\\frac{1}{h^2} = \\frac{1}{a^2}+\\frac{1}{b^2}+\\frac{1}{c^2}$&emsp;&emsp;C：大模拟&emsp;&emsp;*E：把 $i$ 连向 $a_i$ 可得环套树森林，$k=0$ 答案为 $0$，$k=1$ 答案为 $E(n-环套树数量)$，$k=2$ 答案为 $E(n-环套树数量+叶子数量)$。$E(环套树数量)$ 用 EGF 推一推，$E(叶子数量)=\\frac{n(n-1)^n}{n^n}$&emsp;&emsp;G：树形 dp&emsp;&emsp;*H：dp，每有一个数要当作某次删除的最小数时，可以视作新增一个大小为 $k$ 的篮子，最终要把篮子填满。设 $f_{i,j}$ 表示当前到了第 $i$ 个数，篮子总共还有 $j$ 个空位，的方案数。转移就枚举当前数是当作最小数，还是填篮子，还是不选。&emsp;&emsp;I：最终折痕形成的每个小格子都被划了十字，因此纸片数 $=(2^{横折次数}+1)(2^{竖折次数}+1)$&emsp;&emsp;K：二分 + 2sat 判断 + 线段树优化连边&emsp;&emsp;L：前 $\\lfloor\\frac n2 \\rfloor$ 个答案为 $0$，对于第 $i$ 个数存活的方案数，考虑后面 $n-i$ 个人连向前面的谁，因此方案数为 $\\frac{(i-1)!}{(i-1-n+i)!}(i-1-n+i-1)!!$&emsp;&emsp;BJM： 2020 Multi-University Training Contest 6&emsp;&emsp;ABK：队友说是沙雕题&emsp;&emsp;C：先归一化到均值为 0，设 $f_x$ 表示正数的和为 $x$ 时的期望步数，分“两正一负”和“一正两负”讨论递推&emsp;&emsp;E：方法一：设 $dp_{sum,x,y}$ 表示选出了一个区间得到值为 $sum$，区间左端点 $\\bmod 10=x$，区间右端点 $\\bmod 10=y$，的最小代价。打表&emsp;&emsp;&emsp;&emsp;方法二：打表发现答案 13 以内，于是可以做得更暴力&emsp;&emsp;F：保留 MST 的边即可&emsp;&emsp;G：莫比乌斯反演一套打下去&emsp;&emsp;*H：$k &lt;\\sqrt n$ 的时候仿照 min25 进行 dp（设 $f_{i,j}$ 表示考虑了前 $i$ 个质数、除去这些质数的贡献后这个数最大只能是 $j$，的方案数，这个是 $O(\\frac{n^{\\frac 34}}{\\log n})$ 的）；$k&gt;\\sqrt n$ 的时候即要去掉含 $&gt;\\sqrt n$ 质因子的数，分块+min25 求素数个数&emsp;&emsp;I：$ans=[(b-1) \\bmod x=0]$&emsp;&emsp;J：每一位单独考虑，是个矩阵树定理&emsp;&emsp;D： 2020 Multi-University Training Contest 7&emsp;&emsp;D：&emsp;&emsp;G：对于当前点集，找出所有可能成为最远点对的点，把它们叫第一层，删掉，递归下去。先手必胜当且仅当起点不在最后一层或最后一层大小 $&gt;1$&emsp;&emsp;**H：解法一：子集卷积，按最高位从小到大做子集卷积，以避免重复&emsp;&emsp;&emsp;&emsp;解法二：子集卷积 $exp$&emsp;&emsp;I：划分成 $x$ 个组，每个组至多 $y$ 个元素，且递减排列。那么显然贪心地塞满后面的组，前面的组尽量放单个元素&emsp;&emsp;*J：若走到主对角线或坐标轴则能走到无限远，此时答案为 $0$；否则可行区域是有限的（上下左右会被素数夹住），答案为 $\\frac{起点度数}{连通块内所有点的度数和}$，其中度数包括连向自己的那条边&emsp;&emsp;ABCEFK： 2020 Multi-University Training Contest 8&emsp;&emsp;C：略&emsp;&emsp;B：dp，设 $f_i$ 表示前 $i$ 个数划分的答案。$i$ 每向右移动一位，只有 $O(1)$ 种前缀和的转移发生了变化。前缀和的每个位置维护一个单调队列，基于这个再用线段树或堆实现前缀后缀最大值。&emsp;&emsp;D：tow pointers + LCT 求出每个左端点最右能到哪里使得这个区间内没有环&emsp;&emsp;F：老 flappy bird 了 从左到右+从右到左即可求出合法区间&emsp;&emsp;*G：假题害人 设 $g_i$ 表示游戏在 $i$ 轮之内结束的概率，这等价于选 $i$ 个数使得它们互质的概率，莫比乌斯容斥算出来。算出 $g_i$ 之后类似差分一下，就算出恰好 $i$ 轮结束的概率，取偶数下标的和就是答案&emsp;&emsp;*H：从外往里一圈一圈绕进去，参考题解的图&emsp;&emsp;*I：枚举 $k$，$O(k)$ 的时间算出 $s_1$ 的所有循环同构的哈希，然后看后面每个子串的哈希是否合法&emsp;&emsp;*K：$x \\oplus y \\in B \\iff x \\oplus B = y \\oplus B$，因此两个数组每个元素都异或掉线性基，然后哈希或者 kmp&emsp;&emsp;*L：每个点产生代价当且仅当它跟父亲最后权值不相同。dp，设 $f_{i,[l,r]}$ 表示 $i$ 这个点取值在 $[l,r]$ 这个区间的时候的最小代价，本质不同的区间只有 $O(n)$ 个。&emsp;&emsp;AEJ： 2020 Multi-University Training Contest 9&emsp;&emsp;A：新加的边终点肯定是根节点最优&emsp;&emsp;*C：先推博弈得到形如 $(a_i,b_i)$ 的必败态对的规律，然后 betty 定理算出 $a_i,b_i$ 关于 $i$ 的式子 为啥全世界都会啊&emsp;&emsp;E：&emsp;&emsp;G：平衡树&emsp;&emsp;BDFHIJ： 2020 Multi-University Training Contest 10&emsp;&emsp;CDG：队友说是沙雕题&emsp;&emsp;*E：dp，设 $f_{i,j}$ 表示 $i$ 这棵子树，根到叶子距离不超过 $j$，的最小代价。长链剖分优化&emsp;&emsp;I：PCA，维护一些必要的信息以快速计算&emsp;&emsp;^J：去掉的两个格子必然属于两行两列，剩下的一行一列每个格子拿空即输，也就是剩 $1$ 就赢，也就是 $a_{ij}-1$ 的 nim 堆；与去掉的两个格子同行同列的其他格子则是普通 nim 堆，因此这些格子异或起来判断是否为 0&emsp;&emsp;K：按 $t$ 降序排列，注意 $k=0$ 时不用排序&emsp;&emsp;ABFH： 2021“MINIEYE杯”中国大学生算法设计超级联赛（1）&emsp;&emsp;中超好耶&emsp;&emsp;AE：队友说是沙雕题&emsp;&emsp;*B：题解解法：kd tree&emsp;&emsp;&emsp;&emsp;考场解法：大力猜时间复杂度是 $O(n^2/20)$，因此把平面分成 $80\\times80$ 个小格，每画一个圆，格子就分为完全在圆内、完全在圆外、与圆有交 这三种情况，只用对于最后一种情况枚举小格内的所有点，这个面积占 $4*80/80*80\\approx1/20$&emsp;&emsp;*C：解法一：每条边设一个变元，高斯消元&emsp;&emsp;&emsp;&emsp;未尝试的解法：插头 DP，轮廓线上每个顶点用 0/1 表示它是不是线的端点，那么一条轮廓线上一定是相邻的两个 1 配对。&emsp;&emsp;F：求出异或前缀和 $s$，枚举右端点，左端点的 $s$ 建 trie，维护子树的最大左端点，在 trie 上每次只用往一个方向走&emsp;&emsp;*G：设 $f_t$ 表示 $t$ 时刻传回自己的方案，那么 $f_t=(n-1)^{t-1}-f_{t-1}$，通项是等比数列求和，最后解离散对数&emsp;&emsp;H：枚举上边界，可以知道每列往下延伸到哪里，然后左起右起单调栈&emsp;&emsp;I：MST&emsp;&emsp;*J：解法一：莫队+值域分块，$O(m \\sqrt n)$&emsp;&emsp;&emsp;&emsp;解法二：cdq&emsp;&emsp;K：burnside 引理，每个不动点写出来的式子可以直接暴力，复杂度 $O(k \\ln k)$&emsp;&emsp;D： 2021“MINIEYE杯”中国大学生算法设计超级联赛（2）&emsp;&emsp;签了一小时到，抬头一看 pku 差一题 AK&emsp;&emsp;AE：队友说是沙雕题&emsp;&emsp;B：对于链来说，在 $x$ 位置开始加一个二次函数，对 $y$ 的影响是 $(y-x)^2$，拆开来，每个位置维护修改的 0、1、2 次方和。&emsp;&emsp;D：每个询问拆成 trie 树上的 $\\log c$ 次询问，转化成二维数点&emsp;&emsp;*G：解法一：每个位置维护六元向量 $(a,b,a^2,b^2,ab,1)$，线段树维护矩阵乘法&emsp;&emsp;H：先每科预处理 $g_i$ 表示这科考 $i$ 分要多少天，然后再 dp 合并&emsp;&emsp;*J：排列逆序对奇偶性 $sign$ 的式子列出来得到 $a^{\\frac{p-1}{2}}$&emsp;&emsp;&emsp;&emsp;看大题解&emsp;&emsp;*K：高维前缀和&emsp;&emsp;L：贪心&emsp;&emsp;CFI： 2021“MINIEYE杯”中国大学生算法设计超级联赛（3）&emsp;&emsp;1003：每种符号做一次 FFT&emsp;&emsp;1004：每次使得互相平行的直线数量最少即可，按斜率分类，倒着做，每次删掉 size 多大的一类的一条线段&emsp;&emsp;1007 1011：队友说是沙雕题&emsp;&emsp;*1010：考场解法：大胆猜测具有 $k$ 条折扣边的 MST 是具有 $k-1$ 条折扣边的 MST 替换一条边而得来的，这也导致有用的边只有原始 MST 和折扣 MST 这 $2(n-1)$ 条，因此每次暴力找最优替换并重构 MST 即可&emsp;&emsp;&emsp;&emsp;题解解法：有用边只有原始 MST 和折扣 MST 这 $2(n-1)$ 条，设 $f(k)$ 是具有 $k$ 条折扣边的最优答案，则 $f(k)$ 是凸的，类似于 wqs 二分&emsp;&emsp;1001 1002 1005 1006 1008 1009 1012： 2021“MINIEYE杯”中国大学生算法设计超级联赛（4）&emsp;&emsp;1001：非 0 即发散&emsp;&emsp;1002：略&emsp;&emsp;1004：二分答案，然后使用任意一种后缀数据结构 check 即可&emsp;&emsp;*1005：HNOI2016 序列 每个区间先找出最大值，然后左右两边 $O(1)$ 求，最小值同理&emsp;&emsp;&emsp;&emsp;看大题解&emsp;&emsp;*1007：cdq，分治区间里的数从小到大排序，左半和右半各维护一个单调栈&emsp;&emsp;&emsp;&emsp;看大题解&emsp;&emsp;1008：障碍点使得有障碍的行被分为总共 $O(k)$ 段空白段，依据空白段来维护可达段&emsp;&emsp;1009：字母和数字一定只有 1 个连通块，因此从右往左，去掉 6 个连通块以后就是汉字了&emsp;&emsp;1003 1006 1010 1011： 2021“MINIEYE杯”中国大学生算法设计超级联赛（6）&emsp;&emsp;A：长度只能为 $1,2,p,2p$，讨论一下&emsp;&emsp;D：2021 bytecamp day2 对于 $1\\sim n-1$ 节点用旋转法构造 $\\frac{n-2}{2}$ 条不相交的长度为 $n-1$ 的哈密顿路径，用 $n$ 号点把它们连起来&emsp;&emsp;E：队友说是沙雕题&emsp;&emsp;*G：观察数字对应的颜色，每次交换会使两个数字的颜色反色（相邻无关），因此如果有奇环就只与各颜色的奇偶性有关，否则是二分图，需要每个数字每侧的颜色数量完全相等&emsp;&emsp;BCFHIJK： CCPC Wannafly Camp 2020Day1 - Rikka Contest&emsp;&emsp;BF：队友说是沙雕题&emsp;&emsp;A：按 $\\frac{l_i+r_i}{2}$ 从小到大放&emsp;&emsp;C：每种颜色平均分是最优的，答案等于总边数减去每种颜色的团。式子写出来可以分块&emsp;&emsp;**D：带 $x$ 的基尔霍夫矩阵，求导&emsp;&emsp;&emsp;&emsp;看大题解&emsp;&emsp;*E：dp旋根。若根把一条链分成 $a$ 和 $b$ 两部分，那么往 $a$ 处移动产生的贡献是 $(a-1)(b+1)-ab=a-b-1$，因此记录每个子树的一直到根的链数及链长和即可&emsp;&emsp;*G：去掉被包含的圆，两两求公切线，得到所有切点，做凸包，对于凸包上的每条线段，若它被一个圆完全覆盖，则它的贡献是一段圆弧，否则是它本身&emsp;&emsp;H：$k$ 乘上 $\\lfloor \\frac nk \\rfloor$ 以内的质数，高精度&emsp;&emsp;*I：分块，每个块维护一个值域前缀和（用树状数组），查询时二分。&emsp;&emsp;J：大模拟，卡常 Day2 - Legilimens Contest&emsp;&emsp;A：略&emsp;&emsp;B：每个 $m_i$ 拆成 $\\log$ 个小区间（这个区间表示 $x_i$ 的后若干位是任选的），分组背包，$k$ 只决定有无解，有解的话每一位的解的数量由覆盖该位的 $x$ 的数量决定。&emsp;&emsp;C：每个前缀假设异或和为 $s$，其最高位是第 $w$ 位，那么第 $w$ 位为 $1$ 的 $a_i$ 有唯一操作方法。&emsp;&emsp;*D：mex 实际上是最大 LCP 加 1，而最大 LCP 随着字符的插入是递增的，因此建 SAM 时每次分裂出来的结点的 $maxlen$ 就可以更新答案。注意特判 mex=0&emsp;&emsp;E：启发式合并&emsp;&emsp;*F：维护子树的 $x$ 的和，询问时每个点枚举往父亲的边和往链剖重儿子的边，轻儿子的答案在修改时维护&emsp;&emsp;H：实质上是个欧拉回路&emsp;&emsp;I：黑白染色，则实际上是求最小顶标和，等于最大权匹配&emsp;&emsp;J：如图&emsp;&emsp;*K：dp，设 $f_i$ 表示前 $i$ 个字符的答案，找合法后缀可以 AC 自动机（fail 链最长为 $\\sqrt n$），也可以把模板串按大于或小于 $\\sqrt n$ 分类然后 hash。 Day 6&emsp;&emsp;CLM：略&emsp;&emsp;*A：2019 南京网络赛 C&emsp;&emsp;*D：分成了 $O(n)$ 个段，dp，设 $f_{i,j}$ 表示前 $i$ 个段放了 $j$ 个数的方案数&emsp;&emsp;F：正难则反，总数减去异色三角形&emsp;&emsp;G：贪心，第 $i$ 轮记当前最左边的空位为 $w$，先倒序把 $f$ 为 $i$ 的位置全部放数字，然后如果 $w$ 还空着就放它&emsp;&emsp;H：先转化成前缀询问。考虑 $[0,2^{30})$ 有多少数字异或 $x$ 之后落在 $[0,r]$ 内，会发现实际上是有 $\\log$ 个区间&emsp;&emsp;I：dp，设 $f_{i,j}$ 表示前 $i$ 个数用了 $j$ 次操作的最大和。转移就是枚举一个后缀，然后这个后缀全部变成最大值。&emsp;&emsp;J：整数拆分枚举环长，判断是否合法，合法就算方案数&emsp;&emsp;K：大数放中间，小数放两边&emsp;&emsp;^N：两两乘起来 Day 7&emsp;&emsp;H：略&emsp;&emsp;A：正难则反，算不得分的数对&emsp;&emsp;G：该矩阵一定存在哈密顿回路，因此 $k \\geq nm$ 时一定可以遍历完整个地图，$k&lt;12$ 时暴力&emsp;&emsp;J：相邻两项之间会对 $j$ 产生一个上界和下界的限制。于是枚举开头，二分最远的结尾 Tsinghua University BootcampTsinghua University Bootcamp Qualification Round 2023&emsp;&emsp;A：队友说是沙雕题&emsp;&emsp;B：维护一下每个元素被包含的次数即可&emsp;&emsp;C：枚举三点定圆，排序优化一下&emsp;&emsp;D：每个子树维护一个堆，表示 $T$ 时间内能获得的收益，堆外加维护一个总和和 offset。启发式合并每个子树的堆&emsp;&emsp;E：如果有两个栈顶相同，则可以两步搞掉两个栈顶，然后想办法处理掉这两个大小为 $1$ 的栈。最后剩下的栈一定是每个栈顶指着另一个栈底，形成若干个环，每个环的代价是环长 $+1$&emsp;&emsp;F：总的减去不合法的，不合法的随便哈希一下&emsp;&emsp;H：拆位，线段树维护每个区间的 $a_i$ 当位为 $0/1$、$i$ 当位为 $0/1$ 共四种情况的数量&emsp;&emsp;I：状压树形 dp，维护三种结构：从 $i$ 出发去子树又回到 $i$、从 $i$ 出发去到子树不回来、从子树出发又回到子树&emsp;&emsp;J：枚举 $a_i$ 再枚举 $b_j$，这样就知道 $baseline$ 了，$a_i$ 的上一个是 $a_{i-1}$，$b_j$ 的上一个是 $a_{i-1}+baseline$，用个桶快速找到 $b_j$ 的上一个，并判断这两个 $b$ 之间有没有大于 $baseline$ 的&emsp;&emsp;GKL：","categories":[{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[]},{"title":"【Pre-Finals 2016, NTU Contest D】Drawing Hell 题解","slug":"【Pre-Finals 2016, NTU Contest D】Drawing Hell 题解","date":"2020-01-16T15:46:36.000Z","updated":"2024-04-24T03:59:22.864Z","comments":true,"path":"【Pre-Finals 2016, NTU Contest D】Drawing Hell 题解/","link":"","permalink":"http://kqp.world/%E3%80%90Pre-Finals%202016,%20NTU%20Contest%20D%E3%80%91Drawing%20Hell%20%E9%A2%98%E8%A7%A3/","excerpt":"题目大意&emsp;&emsp;平面上有 $n$ 个点，两人轮流博弈。每人每回合画一条线段连接两个点，不能在端点外的地方穿过已画的线段或其他端点。不能操作者输。问先手必胜或必败。 &emsp;&emsp;$n,|x_i|,|y_i| \\leq 1000$，可以三点共线，没有重点。&emsp;&emsp;多测，$T \\leq 1000$&emsp;&emsp;2s","text":"题目大意&emsp;&emsp;平面上有 $n$ 个点，两人轮流博弈。每人每回合画一条线段连接两个点，不能在端点外的地方穿过已画的线段或其他端点。不能操作者输。问先手必胜或必败。 &emsp;&emsp;$n,|x_i|,|y_i| \\leq 1000$，可以三点共线，没有重点。&emsp;&emsp;多测，$T \\leq 1000$&emsp;&emsp;2s \\\\ \\\\ \\\\题解&emsp;&emsp;从简单情况入手。如果给定的是一个凸包，且没有三点共线，那么最终局面就是三角划分，边数为 $2n-3$，这个一定是奇数，因此先手必胜。 &emsp;&emsp;这启示我们用三角划分来考虑。 &emsp;&emsp;对于一般情况：如果所有点共线，那么没有凸包也没有三角划分，边数就是 $n-1$，是奇数则先手胜。&emsp;&emsp;如果不是所有点共线，那么就有凸包，最终局面一定是三角划分，形成一个平面图。设最终边数为 $m$，平面上区域数为 $F$，凸包上的点数（含凸包边上的点）为 $c$，联立平面图欧拉定理和极大三角划分的边数关系得： \\begin{cases} n-m+F=2 \\\\ 3(F-1)=2(m-c)+c \\\\ \\end{cases} \\\\&emsp;&emsp;解得 $m=3n-3-c=(2n-3)+(n-c)$，也就是说凸包内的点数的奇偶性决定了先手胜负。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;bits/stdc++.h&gt;#define fo(i,a,b) for(int i=a;i&lt;=b;i++)#define fd(i,a,b) for(int i=a;i&gt;=b;i--)using namespace std;typedef long long LL;const int maxn=1005;struct P&#123; int x,y;&#125;;P operator - (const P &amp;a,const P &amp;b) &#123;return (P)&#123;a.x-b.x,a.y-b.y&#125;;&#125;int operator * (const P &amp;a,const P &amp;b) &#123;return a.x*b.y-a.y*b.x;&#125;bool cmpP(const P &amp;a,const P &amp;b) &#123;return a.x&lt;b.x || a.x==b.x &amp;&amp; a.y&lt;b.y;&#125;int n;P p[maxn];P h[2*maxn];int h0;bool fuck;void Hell()&#123; sort(p+1,p+1+n,cmpP); h0=0; fo(i,1,n) &#123; while (h0&gt;=2 &amp;&amp; (h[h0]-h[h0-1])*(p[i]-h[h0])&gt;0) h0--; h[++h0]=p[i]; &#125; fd(i,n-1,1) &#123; while (h0&gt;=2 &amp;&amp; (h[h0]-h[h0-1])*(p[i]-h[h0])&gt;0) h0--; h[++h0]=p[i]; &#125; fuck=(h0==2*n-1); h0--;&#125;int T;int main()&#123; scanf(&quot;%d&quot;,&amp;T); while (T--) &#123; scanf(&quot;%d&quot;,&amp;n); fo(i,1,n) scanf(&quot;%d %d&quot;,&amp;p[i].x,&amp;p[i].y); Hell(); bool ans=(fuck) ?((n-1)&amp;1) :((n-h0+1)&amp;1) ; puts(ans ?&quot;T^T&quot; :&quot;OwO&quot;); &#125;&#125;","categories":[{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[{"name":"算法_几何","slug":"算法-几何","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E5%87%A0%E4%BD%95/"},{"name":"算法_博弈","slug":"算法-博弈","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E5%8D%9A%E5%BC%88/"}]},{"title":"【2019icpc Regional 南昌 B】A Funny Bipartite Graph 题解","slug":"【2019icpc Regional 南昌 B】A Funny Bipartite Graph 题解","date":"2020-01-15T13:49:13.000Z","updated":"2024-04-24T03:59:22.812Z","comments":true,"path":"【2019icpc Regional 南昌 B】A Funny Bipartite Graph 题解/","link":"","permalink":"http://kqp.world/%E3%80%902019icpc%20Regional%20%E5%8D%97%E6%98%8C%20B%E3%80%91A%20Funny%20Bipartite%20Graph%20%E9%A2%98%E8%A7%A3/","excerpt":"题目大意&emsp;&emsp;给定一幅 $n$ 个点的二分图。左边的每个点度数至少为 $1$ 至多为 $3$，且左边每个点只会连向右边编号大于等于它的点。&emsp;&emsp;现在你要选择一些边，限制如下： 右边的每一个点都要被覆盖到； 有一个 01 矩阵 $A_{n\\times n}$，若 $A_{i,j}=1$ 则表示左边第 $i$ 个点和第 $j$ 个点不能同时被覆盖到； 对于左边的每一个点，如果它没被覆盖到则代价为 $0$，否则代价为 $M_i^{d_i}$，其中 $d_i$ 表示被它覆盖了多少次。满足上面两条的情况下要使得代价最小。 &emsp;&emsp;求最小代价，或输出无解。 &emsp;&emsp;$n \\leq 18,~1 \\leq M_i \\leq 100$&emsp;&emsp;多测，$T \\leq 10$&emsp;&emsp;1s","text":"题目大意&emsp;&emsp;给定一幅 $n$ 个点的二分图。左边的每个点度数至少为 $1$ 至多为 $3$，且左边每个点只会连向右边编号大于等于它的点。&emsp;&emsp;现在你要选择一些边，限制如下： 右边的每一个点都要被覆盖到； 有一个 01 矩阵 $A_{n\\times n}$，若 $A_{i,j}=1$ 则表示左边第 $i$ 个点和第 $j$ 个点不能同时被覆盖到； 对于左边的每一个点，如果它没被覆盖到则代价为 $0$，否则代价为 $M_i^{d_i}$，其中 $d_i$ 表示被它覆盖了多少次。满足上面两条的情况下要使得代价最小。 &emsp;&emsp;求最小代价，或输出无解。 &emsp;&emsp;$n \\leq 18,~1 \\leq M_i \\leq 100$&emsp;&emsp;多测，$T \\leq 10$&emsp;&emsp;1s \\\\ \\\\ \\\\题解&emsp;&emsp;考虑状压，首先会想到一个比较暴力的状压，设 $f_{i,s_L,s_R}$ 表示左边考虑了前 $i$ 个点，左边已选点集为 $s_L$，右边已选点集为 $s_R$，的最小代价。 &emsp;&emsp;进而发现好难优化，好像无论如何都要记录两个集合？ &emsp;&emsp;然后就需要发现题目的性质：考虑了左边前 $i$ 个点的时候，左边后 $n-i$ 个点一定未选；而由于左边的点只能连向右边编号大于等于它的点，所以右边前 $i$ 个点必须全部已选（不然以后没机会了）。&emsp;&emsp;因此，$s_L$ 的后 $n-i$ 位和 $s_R$ 的前 $i$ 位都是没有用的！把 $s_L$ 的前 $i$ 位和 $s_R$ 的后 $n-i$ 位拼起来形成一个 $2^n$ 的状态，这样状压就是 $O(n\\cdot2^n)$ 的了！ &emsp;&emsp;这就很像计组里面学的 32 位整数乘除法，它把乘数和结果同时存在了一个 64 位整数上，这也是灵活地把两个状态叠在一起。&emsp;&emsp;您好，请重修计组 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include&lt;bits/stdc++.h&gt;#define fo(i,a,b) for(int i=a;i&lt;=b;i++)using namespace std;typedef long long LL;const int maxn=20, maxN=262150;const int inf=2139062143;int n,N,AA[maxn],v[maxn][4],v0[maxn],M[maxn],f[maxn][maxN],er[maxn];bool G[maxn][maxn],A[maxn][maxn];void ReadBit(bool &amp;data)&#123; char ch=getchar(); while (ch!=&#x27;0&#x27; &amp;&amp; ch!=&#x27;1&#x27;) ch=getchar(); data=(ch==&#x27;1&#x27;);&#125;inline void Min(int &amp;a,const int &amp;b) &#123;a=(a&lt;b) ?a :b ;&#125;int T;int main()&#123; er[0]=1; fo(i,1,18) er[i]=er[i-1]&lt;&lt;1; scanf(&quot;%d&quot;,&amp;T); while (T--) &#123; scanf(&quot;%d&quot;,&amp;n); N=(1&lt;&lt;n)-1; fo(i,1,n) &#123; v0[i]=0; fo(j,1,n) &#123; ReadBit(G[i][j]); if (G[i][j]) v[i][++v0[i]]=j; &#125; &#125; fo(i,1,n) &#123; AA[i]=0; fo(j,1,n) &#123; ReadBit(A[i][j]); AA[i]|=A[i][j]&lt;&lt;(j-1); &#125; &#125; fo(i,1,n) scanf(&quot;%d&quot;,&amp;M[i]); memset(f,127,sizeof(f)); f[0][0]=0; fo(i,0,n-1) fo(s,0,N) if (f[i][s]&lt;inf) &#123; int nowL=s&amp;(er[i]-1), nowR=s^nowL, nxt=i+1; bool alrdy=nowR&amp;er[i]; int cho=s|er[i]; if (alrdy) Min(f[i+1][s^er[i]],f[i][s]); if (AA[nxt]&amp;nowL || v0[nxt]==0) continue; if (alrdy || v[nxt][1]==nxt) Min(f[i+1][cho|er[v[nxt][1]-1]],f[i][s]+M[nxt]); if (v0[nxt]&gt;1) &#123; if (alrdy || v[nxt][2]==nxt) Min(f[i+1][cho|er[v[nxt][2]-1]],f[i][s]+M[nxt]); if (alrdy || v[nxt][1]==nxt || v[nxt][2]==nxt) Min(f[i+1][cho|er[v[nxt][1]-1]|er[v[nxt][2]-1]],f[i][s]+M[nxt]*M[nxt]); &#125; if (v0[nxt]&gt;2) &#123; if (alrdy || v[nxt][3]==nxt) Min(f[i+1][cho|er[v[nxt][3]-1]],f[i][s]+M[nxt]); if (alrdy || v[nxt][1]==nxt || v[nxt][3]==nxt) Min(f[i+1][cho|er[v[nxt][1]-1]|er[v[nxt][3]-1]],f[i][s]+M[nxt]*M[nxt]); if (alrdy || v[nxt][2]==nxt || v[nxt][3]==nxt) Min(f[i+1][cho|er[v[nxt][2]-1]|er[v[nxt][3]-1]],f[i][s]+M[nxt]*M[nxt]); if (alrdy || v[nxt][1]==nxt || v[nxt][2]==nxt || v[nxt][3]==nxt) Min(f[i+1][cho|er[v[nxt][1]-1]|er[v[nxt][2]-1]|er[v[nxt][3]-1]],f[i][s]+M[nxt]*M[nxt]*M[nxt]); &#125; &#125; int ans=inf; fo(s,0,N) Min(ans,f[n][s]); printf(&quot;%d\\n&quot;,(ans==inf) ?-1 :ans); &#125;&#125;","categories":[{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[{"name":"算法_神奇的脑洞","slug":"算法-神奇的脑洞","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E7%A5%9E%E5%A5%87%E7%9A%84%E8%84%91%E6%B4%9E/"},{"name":"算法_DP","slug":"算法-DP","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-DP/"}]},{"title":"【2020 Wannafly Camp Day1 D】生成树 题解","slug":"【2020 Wannafly Camp Day1 D】生成树 题解","date":"2020-01-15T11:17:07.000Z","updated":"2024-04-24T03:59:22.813Z","comments":true,"path":"【2020 Wannafly Camp Day1 D】生成树 题解/","link":"","permalink":"http://kqp.world/%E3%80%902020%20Wannafly%20Camp%20Day1%20D%E3%80%91%E7%94%9F%E6%88%90%E6%A0%91%20%E9%A2%98%E8%A7%A3/","excerpt":"题目大意&emsp;&emsp;给出两幅 $n$ 个点的无向图 $G_1,G_2$，对于 $G_1$ 的每一棵生成树，贡献是有多少条边在 $G_2$ 中出现。求 $G_1$ 的所有生成树的贡献和。 &emsp;&emsp;$n \\leq 400$，4s","text":"题目大意&emsp;&emsp;给出两幅 $n$ 个点的无向图 $G_1,G_2$，对于 $G_1$ 的每一棵生成树，贡献是有多少条边在 $G_2$ 中出现。求 $G_1$ 的所有生成树的贡献和。 &emsp;&emsp;$n \\leq 400$，4s \\\\ \\\\ \\\\题解&emsp;&emsp;您好，请重修线性代数 &emsp;&emsp;题目相当于说 $G_1$ 里的每一条边有一个权值（在 $G_2$ 中出现过则为 $1$，没出现则为 $0$），求所有生成树的权值和。 &emsp;&emsp;这种情况一般用 $1$ 代表 $0$ 权的边，$x$ 代表 $1$ 权的边，那么基尔霍夫矩阵的 $n-1$ 阶主子式是个多项式，$x^k$ 的系数代表权值为 $k$ 的生成树的方案数。&emsp;&emsp;一些比较传统的方法是，直接用多项式类算行列式，或者 $n$ 次点值再插值。这样都是 $O(n^4)$ 的，就不行。 &emsp;&emsp;因此这里要用到题目的性质，记 $a_i$ 表示 $x^i$ 的系数，$f(x)=\\det=\\sum_{i=0}^{n-1} a_ix^i$，则所求为 ans=\\sum_{i=0}^{n-1} i\\cdot a_i=f'(1)&emsp;&emsp;这相当于要给 $\\det$ 求导。设基尔霍夫矩阵前 $n-1$ 阶主子式为 $J(x)$，每个元素的余子式为 $A_{i,j}(x)$，则 ans=f'(1)=\\sum_{i=1}^{n-1}\\sum_{j=1}^{n-1} J'_{i,j}(1)\\cdot A_{i,j}(1)&emsp;&emsp;余子式由 $J^{-1}\\cdot \\det J$ 算出。 考场上 fail 的想法&emsp;&emsp;另一种想法是枚举强制选一条边，快速计算修改基尔霍夫矩阵后的行列式。想到这个是因为以前做过这个题。&emsp;&emsp;但发现这个方法不大行。之前用这个方法的时候题目是求树形图，每次只用修改一行，而到这里无向图则需要修改两行，以前的方法都 fail 了。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define fo(i,a,b) for(int i=a;i&lt;=b;i++)using namespace std;typedef long long LL;const int maxn=405;const LL mo=998244353;int n,m,g1[maxn][maxn],w[maxn][maxn],x[maxn];char s[maxn];LL Pow(LL x,LL y)&#123; LL re=1; for(; y; y&gt;&gt;=1, x=x*x%mo) if (y&amp;1) re=re*x%mo; return re;&#125;LL D,J[maxn][maxn];void Det(int n)&#123; D=1; fo(i,1,n) &#123; fo(j,i,n) if (J[j][i]!=0) &#123; swap(J[i],J[j]); if (i!=j) D*=-1; break; &#125; fo(j,i+1,n) &#123; LL c=J[j][i]*Pow(J[i][i],mo-2)%mo; fo(k,i,n) (J[j][k]-=c*J[i][k])%=mo; &#125; &#125; fo(i,1,n) (D*=J[i][i])%=mo; D=(D+mo)%mo;&#125;LL G[maxn][maxn],inv[maxn][maxn],c[maxn];void Gauss(int n)&#123; fo(i,1,n) &#123; fo(j,i,n) if (G[j][i]!=0) &#123; swap(G[i],G[j]), swap(inv[i],inv[j]); break; &#125; LL c=Pow(G[i][i],mo-2); fo(j,1,n) (G[i][j]*=c)%=mo, (inv[i][j]*=c)%=mo; fo(j,1,n) if (j!=i) &#123; LL c=G[j][i]; fo(k,1,n) (G[j][k]-=c*G[i][k])%=mo, (inv[j][k]-=c*inv[i][k])%=mo; &#125; &#125;&#125;void Inv(int n)&#123; fo(i,1,n) &#123; inv[i][i]=1; fo(j,1,n) G[i][j]=J[j][i]; &#125; Gauss(n);&#125;int main()&#123; scanf(&quot;%d&quot;,&amp;n); fo(i,1,n) &#123; scanf(&quot;%s&quot;,s+1); fo(j,1,n) &#123; g1[i][j]=s[j]-&#x27;0&#x27;; if (i&lt;j &amp;&amp; g1[i][j]) &#123; J[i][i]++; J[j][j]++; J[i][j]--; J[j][i]--; &#125; &#125; &#125; fo(i,1,n) &#123; scanf(&quot;%s&quot;,s+1); fo(j,1,n) &#123; w[i][j]=g1[i][j]&amp;(s[j]-&#x27;0&#x27;); x[i]+=w[i][j]; &#125; &#125; Inv(n-1); Det(n-1); LL ans=0; fo(i,1,n-1) fo(j,1,n-1) &#123; int d=(i==j) ?x[i] :-w[i][j]; (ans+=inv[j][i]*D%mo*d)%=mo; &#125; printf(&quot;%lld\\n&quot;,(ans+mo)%mo);&#125;","categories":[{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[{"name":"算法_线性代数","slug":"算法-线性代数","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"}]},{"title":"新的开始Ⅱ","slug":"New_Starting_2","date":"2019-12-23T02:16:30.000Z","updated":"2024-04-24T03:59:22.784Z","comments":true,"path":"New_Starting_2/","link":"","permalink":"http://kqp.world/New_Starting_2/","excerpt":"新的开始&emsp;&emsp;11 月沈阳赛区结束，我们莫得出线也莫得 EC，那么 SYSU_FateBlueBird 这支队也 end 了。","text":"新的开始&emsp;&emsp;11 月沈阳赛区结束，我们莫得出线也莫得 EC，那么 SYSU_FateBlueBird 这支队也 end 了。&emsp;&emsp;然后就很困扰了，一边是 Zayin 大哥的盛情邀请，努力一年又是一次冲 final 的机会，另一边是升学的压力，再不进实验室大三 4 月 final 结束可就只有 3 个月准备夏令营了。跑去问了左左、fanvree、一大圈人，都得不到什么妥善的解决方案，毕竟要出成绩就要花时间，哪都是这个道理。 &emsp;&emsp;最后决定采取左左的意见，再打一年，能出线的话 4 月 final 结束冲刺三个月的科研。&emsp;&emsp;而这一年必须兼顾实验室、课业、训练。重心是训练（保证训练、改题的时间），次重心是实验室（没事就学，有事就咕），非重点是课业（尽最大可能压缩时间，你鸭大的课就这副水平），特权是 LoveLive （有 live、国会等活动时优先级置顶）&emsp;&emsp;忙是必然的了。反正你这个人，不忙就只会颓废，现在就连补番都是靠边站的了，连颓废的效率都极低，都不知道大学毁了你多少好习惯。倒不如忙一点刺激一下你，兴许你还能挤出时间补番（不是 &emsp;&emsp;于是就和邓老板、Zayin 开始了一支队。&emsp;&emsp;队名 无人之境 unhindered。站在无人可达的高度，神挡杀神，佛挡杀佛。临兵斗者皆阵列在前 &emsp;&emsp;“新手赛+毛营网络赛 9 小时无缝衔接”作为磨合的第一战，虽然结果是三人连着演了 9h。。 &emsp;&emsp;开始努力吧。 &emsp;&emsp;然后还找了 wh，正式开始了实验室打工生涯。选他一来是熟，二来是 TCS 研究所除去量子以外就他了。想学 TCS，理论、经典算法、符号主义流派的东西果然还是最好玩的，比 machine learning 好玩。&emsp;&emsp;一点点做起，读文章，跑实验，目标是学东西和积累。 总结&emsp;&emsp;发现现在写游记都不总结了，symbol 辛苦培养的习惯都丢了。&emsp;&emsp;那就来一次，好好的总结一下这一年下来的问题吧。 &emsp;&emsp;我们距离金牌不远（现在的局势是签完到就有金），但是距离出线就很远了，题数差很大。首先是脑速不够，中期题会做但是做一万年，根本没时间顾及后期；然后是有硬伤，姿势水平还差很远。很多平时看起来不训练的人姿势也比我们多得多。&emsp;&emsp;第一是投入训练的时间不够，补题补不完。没法停课所以做作业花了很多时间，然后空余时间又有点颓废。现在找到的方法是，只要坚持一段时间一直做题（刷水题都好），就能找到努力的感觉，就能进入训练状态了。会很自然地开始想翘课&emsp;&emsp;第二是现在国内水平提升很快，像五边形数这种东西居然都是板刷题了，打破了我很多 stereotype。所以那些以前标记了还没学的东西，得开始啃了。 &emsp;&emsp;还有些突出的问题。&emsp;&emsp;队伍的配合。哈尔滨是我们配合的最低点，读错题没人救，自闭了也没有三人讨论。题一定要开多些，不要赛后还有没读的题，队友不明原因自闭的时候要换另一个人读一遍题。第一次给队友讲题意的时候不要报算法不然容易带跑队友，但从第二轮交流开始必须能多 bb 就多 bb，思路别藏着。&emsp;&emsp;老套路。我今年一大半时间没有重视这个，补题基本补最新的题，忽略了老题。因此，首先是 4+2 栽了跟头，考了一堆老套路我全忘掉了导致 4+2 直接爆炸。后来做几年前的区域赛，由于会那个年代不普及的东西而随手金甚至出线，也不是很重视，结果今年的区域赛，还是考的经典套路，结果我又不会了。所以补题，新题老题都要补，要有时间温习一下以前的课件，高中时没补的 t3 t4 可以去补一下了。&emsp;&emsp;新姿势。新鲜出炉的东西（比如析合树）不会马上就考，因为出题人也还没学会，但是出题人总有学会的一天，你得在出题人学会之前学会。&emsp;&emsp;练的题目。这一年我是想方设法让我们队做难题，一场拼两套 agc 啥的，被队友说了几次好高骛远。确实，我有时为了补题而补题，至少在 medium 没补完的情况下，不应该着急着去动 hard，在赛场上 medium 都不稳定。不过明确的是，光做 easy 是练不了 easy 的，必须补充 medium，光做 medium 也是练不了 medium 的，必须补充 hard。练难题是有效果的，最近这几周我有几次能够独立想出难题了。&emsp;&emsp;时间分配。零碎的时间还是可以想想题的，手机里常备杂题选讲。补题最好还是花连续的时间，有时候一道题分成太多段零碎的时间，每一次都要重新回忆之前想了什么思路，这样的话一种思路被无数次重复，形成了 stereotype，反而会思维僵化。上半年就是这样，因为总是做作业所以补题时间被分成很多段零碎的，所以不仅没做多少题，反而还加重了思维僵化。&emsp;&emsp;发展方向。最好是啥都会一点，然后有一些方向精通。 前些日子发生的事&emsp;&emsp;就是上海那一段时间，某 Gg 工程师出题被喷，引发一系列热议，主要围绕如何才算是出一套好题。（忽略掉关于出题态度和人身攻击的东西吧。。出题态度底线要求了（我们厦门是提前两个月开始准备的），网络素质现在知乎也不是很好，说话都不好好说，非要对线） &emsp;&emsp;我也算是出过一次题了，但不是组题人，所以还不很有资格说怎样才是好题。要有区分度，要有 easy 照顾国内现状，要有 hard 招呼前排选手，要有 medium 让榜开花，这就跟左左组 GDOI 一样，既要招呼省队选手又要顾及 rk400 的做题体验，很难的。&emsp;&emsp;不过我觉得还是坚持一个原则，不要签太多的到，不然真的没意思，后排选手做题体验太差的话就不要先打 icpc，先从当地校赛省赛开始搞起。&emsp;&emsp;我校今年出了 ccpc 厦门获得好评，我就觉得很开心了（虽然基本没我什么事就是了。。 &emsp;&emsp;明年据说优秀出题人都要退休了，许多人担忧题目质量要再下降了。那么就期待新的优秀的出题人站出来吧。&emsp;&emsp;不过也以选手的身份提一个要求，不准出假题。 \\\\ \\\\ \\\\&emsp;&emsp;UPD：似乎有些担心的事情发生了。众所周知 claris 老师第二年 final 前的训练发生了不愉快的故事，在知乎上若干篇 claris 与 wkc 的故事令人心痛。其实，我很害怕，我害怕如果我是 wkc 的话，队友，身边的人，会以什么样的评价来对待我。我喜欢算法竞赛，是把它当作一门艺术来对待的，是喜欢艺术，不是喜欢奖牌、出线、final，说到底，我不希望驱使我走下去的，“对算法竞赛的热爱”，只是被人催促着努力一通之后得到奖牌、奖杯、决赛名额。当生活中不止有 ICPC 一个理想的时候，我能不能堂堂正正地，为别的理想分配时间；当希望生活慢下来的时候，我能不能大方自然地，把心里头催促补题学习打比赛的声音抹掉；当为了别的重要的事情需要咕训练的时候，队友能不能坦然接受。我想打 ICPC，但我并不只想打 ICPC，我不想被 ICPC 绑架。如果规定了一个 final 选手必须全心全意心无杂念，两耳不闻窗外事，我选择退出。","categories":[{"name":"总结与游记","slug":"总结与游记","permalink":"http://kqp.world/categories/%E6%80%BB%E7%BB%93%E4%B8%8E%E6%B8%B8%E8%AE%B0/"},{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[]},{"title":"【Ynoi2016】【bzoj4939】掉进兔子洞 题解","slug":"【Ynoi2016】【bzoj4939】掉进兔子洞 题解","date":"2019-12-06T03:20:33.000Z","updated":"2024-04-24T03:59:22.874Z","comments":true,"path":"【Ynoi2016】【bzoj4939】掉进兔子洞 题解/","link":"","permalink":"http://kqp.world/%E3%80%90Ynoi2016%E3%80%91%E3%80%90bzoj4939%E3%80%91%E6%8E%89%E8%BF%9B%E5%85%94%E5%AD%90%E6%B4%9E%20%E9%A2%98%E8%A7%A3/","excerpt":"题目大意&emsp;&emsp;一个长为 $n$ 的序列 $a$。&emsp;&emsp;有 $m$ 个询问，每次询问三个区间，把三个区间中同时出现的数一个一个删掉，问最后三个区间剩下的数的个数和，询问独立。&emsp;&emsp;注意这里删掉指的是一个一个删，不是把等于这个值的数直接删完，&emsp;&emsp;比如三个区间是 $[1,2,2,3,3,3,3]$，$[1,2,2,3,3,3,3]$ 与 $[1,1,2,3,3]$，就一起扔掉了 1 个 $1$，1 个 $2$，2 个 $3$。 &emsp;&emsp;$n,m \\leq 10^5,~1 \\leq a_i \\leq 10^9$&emsp;&emsp;3s，512M","text":"题目大意&emsp;&emsp;一个长为 $n$ 的序列 $a$。&emsp;&emsp;有 $m$ 个询问，每次询问三个区间，把三个区间中同时出现的数一个一个删掉，问最后三个区间剩下的数的个数和，询问独立。&emsp;&emsp;注意这里删掉指的是一个一个删，不是把等于这个值的数直接删完，&emsp;&emsp;比如三个区间是 $[1,2,2,3,3,3,3]$，$[1,2,2,3,3,3,3]$ 与 $[1,1,2,3,3]$，就一起扔掉了 1 个 $1$，1 个 $2$，2 个 $3$。 &emsp;&emsp;$n,m \\leq 10^5,~1 \\leq a_i \\leq 10^9$&emsp;&emsp;3s，512M \\\\ \\\\ \\\\题解&emsp;&emsp;这题的 bitset 技巧很妙的。 &emsp;&emsp;每个询问有三个区间，如果 $a$ 序列的数两两不同，那么把每个区间内包含的数做成 bitset，则每个询问的三个区间 and 起来就好了。&emsp;&emsp;求每个区间的 bitset，就用莫队。（其他方法似乎空间都不大好。。 &emsp;&emsp;现在 $a$ 序列的数可以相同，则可以这样：离散化的时候为每个数留出它出现次数那么多的空位，比如 $[10,10,20,20,20,30,30,30,30]$ 离散化成 $[1,1,3,3,3,5,5,5,5]$，这样的话在莫队加入删除一个数 $x$ 时修改 bitset 的 $x+cnt_x-1$ 这一位（$cnt_x$ 表示莫队过程中 $x$ 的出现次数）。 &emsp;&emsp;还有一个问题是如果为每一个询问存一个 bitset 的话空间不够。所以可以把询问分 3 段，即当成有 3 个 case 的多测来做。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;bitset&gt;#define fo(i,a,b) for(int i=a;i&lt;=b;i++)using namespace std;const int maxn=1e5+5;struct QST&#123; int l,r,i,k;&#125;;bool cmpQ(const QST &amp;a,const QST &amp;b) &#123;return a.k&lt;b.k || a.k==b.k &amp;&amp; a.r&lt;b.r;&#125;int n,m,sqrtn,a[maxn],l1[maxn],r1[maxn],l2[maxn],r2[maxn],l3[maxn],r3[maxn];struct B&#123;int val,i;&#125; b[maxn];bool cmpB(const B &amp;a,const B &amp;b) &#123;return a.val&lt;b.val;&#125;int maxr;void discretize()&#123; fo(i,1,n) b[i]=(B)&#123;a[i],i&#125;; sort(b+1,b+1+n,cmpB); int cnt=1; fo(i,1,n) &#123; if (i==1 || b[i].val&gt;b[i-1].val) maxr+=cnt, cnt=1; else cnt++; a[b[i].i]=maxr; &#125;&#125;int Ans[maxn],q0,tong[maxn];QST q[2*maxn];bitset&lt;maxn&gt; bs[maxn/3],nowbs;void add(int x) &#123; nowbs[x+(++tong[x])-1]=1; &#125;void del(int x) &#123; nowbs[x+(tong[x]--)-1]=0; &#125;void solve(int ql,int qr)&#123; int qnum=qr-ql+1; q0=0; fo(i,ql,qr) &#123; q[++q0]=(QST)&#123;l1[i],r1[i],i-ql+1,l1[i]/sqrtn&#125;; q[++q0]=(QST)&#123;l2[i],r2[i],i-ql+1,l2[i]/sqrtn&#125;; q[++q0]=(QST)&#123;l3[i],r3[i],i-ql+1,l3[i]/sqrtn&#125;; &#125; sort(q+1,q+1+q0,cmpQ); fo(i,1,qnum) bs[i].set(); nowbs.reset(); memset(tong,0,sizeof(tong)); memset(Ans,0,sizeof(Ans)); fo(i,1,q0) Ans[q[i].i]+=q[i].r-q[i].l+1; int nowl,nowr; fo(i,1,q0) if (i==1) &#123; fo(j,q[i].l,q[i].r) add(a[j]); bs[q[i].i]&amp;=nowbs; nowl=q[i].l, nowr=q[i].r; &#125; else &#123; for(; q[i].l&lt;nowl; nowl--) add(a[nowl-1]); for(; nowr&lt;q[i].r; nowr++) add(a[nowr+1]); for(; nowl&lt;q[i].l; nowl++) del(a[nowl]); for(; q[i].r&lt;nowr; nowr--) del(a[nowr]); bs[q[i].i]&amp;=nowbs; &#125; fo(i,1,qnum) &#123; Ans[i]-=bs[i].count()*3; printf(&quot;%d\\n&quot;,Ans[i]); &#125;&#125;int main()&#123; scanf(&quot;%d %d&quot;,&amp;n,&amp;m); fo(i,1,n) scanf(&quot;%d&quot;,&amp;a[i]); fo(i,1,m) scanf(&quot;%d %d %d %d %d %d&quot;,&amp;l1[i],&amp;r1[i],&amp;l2[i],&amp;r2[i],&amp;l3[i],&amp;r3[i]); discretize(); sqrtn=sqrt(n); int m1=m/3, m2=m1&lt;&lt;1; if (1&lt;=m1) solve(1,m1); if (m1&lt;m2) solve(m1+1,m2); if (m2&lt;m) solve(m2+1,m);&#125;","categories":[{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[{"name":"算法_莫队/分块","slug":"算法-莫队-分块","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E8%8E%AB%E9%98%9F-%E5%88%86%E5%9D%97/"},{"name":"算法_位运算","slug":"算法-位运算","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/"}]},{"title":"【计组大作业】单周期CPU","slug":"【计组大作业】单周期CPU","date":"2019-12-04T14:43:57.000Z","updated":"2024-04-24T03:59:22.880Z","comments":true,"path":"【计组大作业】单周期CPU/","link":"","permalink":"http://kqp.world/%E3%80%90%E8%AE%A1%E7%BB%84%E5%A4%A7%E4%BD%9C%E4%B8%9A%E3%80%91%E5%8D%95%E5%91%A8%E6%9C%9FCPU/","excerpt":"&emsp;&emsp;奋战一星期，造台单周期","text":"&emsp;&emsp;奋战一星期，造台单周期 Task&emsp;&emsp;实现基于MIPS 指令集的单周期CPU，可执行如下34 种指令：&emsp;&emsp;用 vivado 编写 CPU 工程，编写完成后，通过运行一份包含所有指令的汇编代码（将二进制代码储存于指令内存中），观察仿真信号及 FPGA 显示来检验 CPU 的正确性。 Sol&emsp;&emsp;当你读这篇 blog 的时候，你应当熟悉单周期 CPU 的工作流程、数据通路。这里给放一个简化版的数据通路图： Sol 1 CPU设计Sol 1.1 设计总述&emsp;&emsp;设计 CPU 应将 CPU 视作一个大的模块，自顶向下进行分解。&emsp;&emsp;首先，确定其输入输出。由于 CPU 主要与内存进行数据交换，因此对外输入输出非常少。输入：时钟信号 clk、reset；输出：overflow 信号，若烧写至 FPGA 则增加 ALU 运算结果、当前指令等需要显示的信息。&emsp;&emsp;然后，设计 CPU 的工作流程。根据单周期 CPU 的工作流程，当时钟上升沿到来时，一个新的周期开始，依次执行下列操作：&emsp;&emsp;根据该工作流程，可以将 CPU 下分为几个子模块： Sol 1.2 实现细节&emsp;&emsp;代码其实很好写的，写 verilog 就跟写高级语言一样。&emsp;&emsp;此处只放简略代码或伪代码，详细代码见最后下载。&emsp;&emsp;约定一个周期由时钟上升沿开始，时钟由高电平到低电平。 1) NextPC&emsp;&emsp;该模块储存有指令寄存器 PC，负责计算下一条 PC。&emsp;&emsp;每当时钟上升沿到来，PC+=4。待控制信号准备好后，通过 branch 和 zero 决定是否进行 branch 型跳转，再根据 jmp 决定是否进行 J 型跳转。共 2 次经过选择器。第二次选择时有 j、jr 两种类型，故使用三选一选择器，jmp 使用 2 位信号。123456789101112131415161718192021222324MUX32 m4( // 是否branch型跳转 .A(PCplus4), .B(PCplus4+&#123;imm[29:0],2&#x27;b00&#125;), .switch(branch&amp;zero), .res(nextPC1));MUX32_3 m5( // 是否J型跳转 .A(nextPC1), .B(&#123;PCplus4[31:28],jmpInst,2&#x27;b00&#125;), // jmpInst=instruction[25:0] .C(ra), .switch(jmp), .res(nextPC2));always @ (posedge clk) if (reset) begin PC=0; PCplus4=4; end else begin PC=nextPC2; PCplus4=PC+4; end 2) memory&emsp;&emsp;该模块负责管理内存，包括指令内存和数据内存。&emsp;&emsp;该部分使用系统 IP 核实现，指令内存用单口 ROM，数据内存用双口 RAM（一个口读，一个口写）。&emsp;&emsp;为了方便并行读写 1 个 word（4 byte）的数据，使用 8 位宽度的 IP 核，实例化 4 次，分别代表一个 word 的 31~24位、23~16位、15~8位、7~0 位。该 word 的 4 份内存的地址高 30 位相同，因此实际操作中，使用实际地址的高 30 位作为每个 IP 核的地址。1234567891011121314151617Instruction_Memory31_24 imem31_24( .clka(rclk), // 读时钟频率非常高，等价于随时可读 .ena(1&#x27;b1), .addra(PC[effiPCwidth+1:2]), // effiPCwidth为ip核的地址大小 .douta(instruction[31:24]));Data_Memory dmem31_24( .clka(wclk), .ena(1&#x27;b1), .wea(memWrite), .addra(DMadd[effiDATAwidth+1:2]), // effiDATAwidth为ip核的地址大小 .dina(DMdata[31:24]), .clkb(rclk), .enb(memRead), .addrb(DMadd[effiDATAwidth+1:2]), .doutb(DMres[31:24]));&emsp;&emsp;本次实验没有实现半字、字节读写操作，但在此设计上要添加这些操作是很容易的，只需根据地址的最后 2 位模 4 的余数选择对应的 IP 核即可。 3) control&emsp;&emsp;该模块计算控制信号。使用 case 语句，对 aluop 或 funct 进行讨论即可。&emsp;&emsp;由于 R 型指令判断较为复杂，故此处再分成两个子模块，一个是通用 control 模块，计算不针对 R 型指令的控制信号；一个是 alucontrol 模块，计算针对 R 型指的控制信号。&emsp;&emsp;控制信号作用表如下：（其中 zero 不在该模块计算）&emsp;&emsp;示例代码如下： 12345678910111213141516171819202122module control(); assign memRead=(opcode==6&#x27;b100011); assign memWrite=(opcode==6&#x27;b101011); always @ (opcode) case (opcode) // 讨论确定regDst,aluSrcB,memToReg,regWrite,branch,aluop,jmp,ExtOp endcaseendmodulemodule alucontrol(); always @ (aluop or funct) if (aluop==4&#x27;b1111) begin casex (funct) // 讨论确定aluCtr endcase end else aluCtr =aluop; // sll,slr,sra assign aluSrcA=(aluop==4&#x27;b1111 &amp;&amp; (funct==6&#x27;d0 || funct==6&#x27;b000010 || funct==6&#x27;b000011)); // jr 由于jr是R型指令，故其jmp需要在这里判断 assign outjmp=(aluop==4&#x27;b1111 &amp;&amp; funct==6&#x27;b001000) ?2&#x27;b10 :injmp ;endmodule 4) Register&emsp;&emsp;该模块储存有 32 个常规寄存器、hi、lo，其中 31 号寄存器为 ra。&emsp;&emsp;该部分主要实现寄存器的读写，比较简单。12345678910111213reg [width-1:0] tmp [0:31]; // 需要初始化always @ (posedge clk) // 写 if (regWrite) begin tmp[addrW]=W; hi=calcHi; // hi和lo的写入值用calcHi和calcLo表示 lo=calcLo; endassign A=tmp[addrA]; // 读assign B=tmp[addrB];assign ra=tmp[5&#x27;d31]; 5) ALU&emsp;&emsp;该模块进行运算，并计算 ovf 和 zero。&emsp;&emsp;使用 case 语句，根据 aluCtr 讨论进行相应的运算即可。注意一些细节，区分有符号数和无符号数。默认是无符号数，只需用 $signed() 这个东西把变量套起来，就是有符号数了。 123456789always @(A or B or aluCtr or hi or lo)begin ovf=0; zero=0; case (aluCtr) // 讨论计算 ALUres、calcHi、calcLo // 加法时判断ovf，减法时判断zero endcaseend 6) MUX&emsp;&emsp;该模块提供不同型号的选择器。&emsp;&emsp;在该 CPU 中，共用到 3 种选择器：5 位三选一、32 位二选一、32 位三选一。12345678assign res=(switch) ?B :A ; // 二选一always @ (A or B or C or switch) // 三选一 case (switch) 2&#x27;b00: res=A; 2&#x27;b01: res=B; 2&#x27;b10: res=C; endcase 7) extended&emsp;&emsp;该模块提供有/无符号立即数扩展。若有符号扩展，则 31~16 位为原数第 15 位；若无符号扩展，则 31~16 位为 0。12always @ (in or ExtOp) out=(ExtOp) ?&#123;&#123;half&#123;in[half-1]&#125;&#125;,in&#125; :&#123;&#123;half&#123;1&#x27;b0&#125;&#125;,in&#125; ; 8) top&emsp;&emsp;千辛万苦来到了总模块。该模块作为数据通路，连接各子模块。具体来说，就是实例化各子模块，并通过 wire 连接起来。1234567891011NextPC nxtpc();memory mem();control ctr();alucontrol aluct();MUX5 m1(); // 根据regDst选择寄存器写地址Register regfile();extended ex();MUX32 m2A(); // 根据aluSrcA选择ALU运算A口MUX32 m2B(); // 根据aluSrcB选择ALU运算B口ALU alu();MUX32_3 m3(); // 根据memToReg选择寄存器写数据&emsp;&emsp;同时需要在 top 模块定义主时钟。输入的时钟信号是 10^8 Hz 的，此处分频做一个 1 MHz 的主时钟（还可以更快，但是懒得加速了。反正就这种玩具 CPU 的速度，四舍五入约等于没有）。而 10^8 Hz 的时钟信号正好用作内存模块的读时钟。123456789101112integer clk_cnt;reg clk_1MHz;always @(posedge clk) if(clk_cnt==32&#x27;d50) begin clk_cnt &lt;= 1&#x27;b0; clk_1MHz &lt;= ~clk_1MHz; end else clk_cnt &lt;= clk_cnt + 1&#x27;b1;initial begin clk_cnt=0; clk_1MHz=1;end&emsp;&emsp;该模块还需要处理一些细节，如指令为 bne 时 zero 需要取反等。 &emsp;&emsp;到这里，CPU 工程就编写完成啦。 Sol 2 仿真检验&emsp;&emsp;根据实现的 34 种指令，设计出以下用于检验的 MIPS 程序。该程序有三个 Test 函数，Test1 是 ALU 测试，Test2 是内存读写测试，Test3 是控制测试。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455.textmain: addi $t1, $0, 5 addi $t2, $0, 6 jal Test1 # ALU Test jal Test2 # Memory Test j Test3 # Jump and Branch Test Test1: div $t2, $t1 # ALU Test mult $t1, $t2 add $t5, $t1, $t2 addu $t6, $t1, $t2 addiu $t7, $t1, 34 # addi has already been tested sub $t5, $t1, $t2 subu $t6, $t1, $t2 mfhi $t3 mflo $t4 and $t5, $t1, $t4 andi $t6, $t1, 30 or $t5, $t1, $t4 ori $t6, $t1, 30 xor $t5, $t1, $t4 xori $t6, $t1, 30 nor $t5, $t1, $t4 addi $t4, $0, -10 div $t4, $t1 mult $t4, $t1 slt $t5, $t1, $t2 sltu $t6, $t1, $t4 slti $t7, $t1, -1 sll $t1, $t1, 17 sltiu $t8, $t1, -1 srl $t5, $t4, 2 sra $t6, $t4, 2 sllv $t5, $t4, $t2 srlv $t6, $t4, $t2 srav $t7, $t4, $t2 jr $ra Test2: sw $t1, 0x0($0) # Memory Test sw $t2, 0x4($0) lw $t5, 0x0($0) lw $t6, 0x4($0) jr $ra Test3: beq $t3, $0, label1 # Jump and Branch Test addi $t5, $0, 16label1: bne $t1, $t2, label2 addi $t5, $0, 16label2: beq $t1, $t2, label3 addi $t6, $0, 17label3: bne $t3, $0, label4 addi $t6, $0, 18label4: addi $a0, $0, 10Exit: syscall&emsp;&emsp;使用 Mars 编辑器可以方便地导出指令代码。16 进制代码及测试详解如下表：&emsp;&emsp;不过 Mars 导出的指令代码是一个 text 的，而我们实例化了 4 次 ROM，因此需要写一个简单的脚本程序，做成 4 个 ROM 初始化文件，分别代表 31~24 位、23~16 位、15~8 位、7~0 位。 &emsp;&emsp;然后编写简单的仿真模块。vivado 中默认的周期是 1 ns，为了与 Basys3 板对应，需要分频形成一个 10^8 Hz 的时钟作为 CPU 的输入时钟信号（再由 top 自行分频形成 1 Mz 的主时钟）。123456789101112131415top tp(.clk(clkin),.reset(reset),.ovf(ovf));parameter PERIOD = 10; always begin clkin = 1&#x27;b0; #(PERIOD / 2) clkin = 1&#x27;b1; #(PERIOD / 2) ; endinitial begin // Initialize Inputs clkin = 0; reset=1; # 100; reset=0;end&emsp;&emsp;仿真结果如下：&emsp;&emsp;（说明1：W 为寄存器写数据、A 为寄存器 A 口、B 为寄存器 B 口、aluA 为 ALU 运算 A 口、aluB 为 ALU 运算 B 口、memres 为内存读取结果、zerobne 为 zero^(opcode==bne) ）&emsp;&emsp;（说明2：乘除法的计算结果储存在 calcHi 和 calcLo，周期结束时才写入 hi 和 lo）&emsp;&emsp;篇幅限制，就只截两张图好了。&emsp;&emsp;对照代码详解表的检测指标，所有指令执行正确。 Sol 3 FPGA检验&emsp;&emsp;这种玩具 CPU 真的有上板子的必要么。。&emsp;&emsp;在 Basys3 板上，ovf 信号用一个 LED 灯显示，数码管一共 4 个，前两个显示 PC 最后两位，后两个显示 ALU 运算结果最后两位。&emsp;&emsp;数码管需要添加一个 display 模块，该模块分四部分：分频、位选控制（即 0111 循环计数）、段选控制（根据位选，选择对应的数据段）、解码（将数据转化为 7 段管信号）。1234567891011121314151617181920212223// 分频// 同top的分频，此处分400Hz// 位选控制reg [3:0]wei_ctrl=4&#x27;b1110;always @(posedge clk_400Hz) wei_ctrl &lt;= &#123;wei_ctrl[2:0],wei_ctrl[3]&#125;; // 段选控制always @(wei_ctrl) case(wei_ctrl) 4&#x27;b1110:duan_ctrl=data[3:0]; 4&#x27;b1101:duan_ctrl=data[7:4]; 4&#x27;b1011:duan_ctrl=data[11:8]; 4&#x27;b0111:duan_ctrl=data[15:12]; default:duan_ctrl=4&#x27;hf; endcase// 解码always @ (duan_ctrl) case(duan_ctrl) // 根据duan_ctrl确定7位七段管信号。 endcase&emsp;&emsp;并在 top 模块中调用。123456display dsp( .clk(clk), .data(&#123;PC[7:0],W[7:0]&#125;), .sm_wei(sm_wei), .sm_duan(sm_duan));&emsp;&emsp;接下来是实验结果。受篇幅限制，只展示部分指令。&emsp;&emsp;选择 0x0000001C 开始的 6 条指令，检测 ALU 运算，结果如下：（前两位是指令地址，后两位是 ALU 结果）&emsp;&emsp;对照代码详解表的检测指标，指令执行正确。&emsp;&emsp;选择 0x0000009C 开始的 11 条指令（含跳转到别处的指令），检测跳转，结果如下：&emsp;&emsp;对照代码详解表的检测指标，指令执行正确。 &emsp;&emsp;至此，完成。 Sources&emsp;&emsp;点我下载","categories":[{"name":"project","slug":"project","permalink":"http://kqp.world/categories/project/"}],"tags":[{"name":"CPU","slug":"CPU","permalink":"http://kqp.world/tags/CPU/"}]},{"title":"2019ICPC沈阳捡漏记","slug":"2019_ICPC_shenyang","date":"2019-11-18T03:24:31.000Z","updated":"2024-04-24T03:59:22.771Z","comments":true,"path":"2019_ICPC_shenyang/","link":"","permalink":"http://kqp.world/2019_ICPC_shenyang/","excerpt":"从南京回来&emsp;&emsp;从南京回来，我们就二连银了。&emsp;&emsp;我们互相说得最多的就是：“求求你做个人吧！”&emsp;&emsp;做个人，别演了，题要读要沟通，数据范围要看，智商在线一点，我不信我们连金牌队都不是。&emsp;&emsp;心好累的，不敢奢望什么校排、出线啥的，至少先把金保了，帮队友保个研。","text":"从南京回来&emsp;&emsp;从南京回来，我们就二连银了。&emsp;&emsp;我们互相说得最多的就是：“求求你做个人吧！”&emsp;&emsp;做个人，别演了，题要读要沟通，数据范围要看，智商在线一点，我不信我们连金牌队都不是。&emsp;&emsp;心好累的，不敢奢望什么校排、出线啥的，至少先把金保了，帮队友保个研。 &emsp;&emsp;回来之后共有三周，第一周是期中考，复习了大半周给我考个小学生都会做的题（真的是第一次感觉到什么叫侮辱智商），对你鸭大建设双一流失去信心。&emsp;&emsp;第一周和第二周尝试了一周四场训练，尝试跟大熊软糖和业余门槛一起玩，他们很稳，我们不行，印象最深的都是什么“赛中过四题，赛后一分钟过四题”。&emsp;&emsp;这三周不做难题，全部做签到和中期，先学会做人再冲前排。不过一些做题计划由于太摸鱼了也没有完成。 去沈阳&emsp;&emsp;要 5 点半起来赶飞机，结果前一晚舍友熬夜学习搞到我睡不好觉，心态崩了。&emsp;&emsp;看天气预报，我们是刚好在下完雪之后去到，又冷又不能看下雪，心态崩了。 &emsp;&emsp;但是满大街的积雪也真的好看啊啊啊啊！！ （我是南方人不要拦我 &emsp;&emsp;一下飞机，收到了总队长的消息： 死命令：拿下校排前10 &emsp;&emsp;真是抱歉，我们自身难保。。死就死了吧。 &emsp;&emsp;晚上去恰以前去过的餐厅，点了一些生海鲜，大家吃得很开心，看起来非常和谐。 &emsp;&emsp;第二天，路面都结冰了，然后就有一个南方人在拼命地滑呀滑。。 &emsp;&emsp;试机。&emsp;&emsp;这个桌子感觉巨容易广播题解。&emsp;&emsp;再次卡 dp 题，虽然很容易设状态，但是转移给转移乱了，在队友的救助下完成了这个题。&emsp;&emsp;对面古手羽入似乎没有想到正解，弄了个假算法压状态过了。果然是“深不可测”的队，如果换做我们脑瘫想了假做法，我们能救回来吗？ Day 1&emsp;&emsp;周日开始了。 &emsp;&emsp;一起床，发现我校两个人倒了，上吐下泻啥的，以至于从酒店到学校这么点路需要打车。他们心态崩了。&emsp;&emsp;我意识到寒冷+生海鲜似乎出事了。。 &emsp;&emsp;队友买了药，稳定了心态，比赛开始了。 &emsp;&emsp;上来 ADHL 4 个签到题，很稳。&emsp;&emsp;然后对面古手羽入一血了 M。&emsp;&emsp;我想了想 Manacher 又想了想回文树，觉得不大行，就扔给队友了。过了一会儿队友想了个法子，枚举中间串的对称轴，然后让左右的回文串极长，再让中间的回文串极长。写了写然后过了。&emsp;&emsp;然后开始搞 K。我想到如果我枚举第二层多少个点，那么第三层就是个固定个数的整数拆分。然后想了很久。&emsp;&emsp;队友开始干 E，我也参与了一下，推几个式子发现巨恶心（因为我们把极点选在两圆心中间，所以根号还带加减法的），不推式子直接二分三分又 T 了。&emsp;&emsp;然后开了 G，很明显要区间 dp，然后不懂枚举了区间之后如何划分下去。&emsp;&emsp;这时榜上 EGK 都一片了，我回去在 K 和 G 之间反复横跳。&emsp;&emsp;突然发现，如果把第二层和第三层一起看，这不就是 $n-1$ 的整数拆分吗？&emsp;&emsp;然后上杭电的 $O(n\\sqrt n)$ 板，T 了。卡常卡了一个多小时，卡到 1.08s，打了个表强行艹了过去。&emsp;&emsp;这时候封榜了，队友的 E 没推出来，J 试图不用 LCT 结果假了。&emsp;&emsp;最后 45min 终于会了 G，把 dp 写出来让队友判连线合不合法，队友假了两次，最后在赛后一分钟过了样例。 &emsp;&emsp;开榜，rk 17，手快捡了个金屁股。感谢 cjb，劝走了大量一队，让我们这种没签完到的也摸到了金。如果换做大赛区，这又是个银了。可怜被假题演了的 cjb。。 &emsp;&emsp;K 不会杨表不会五边形数并且住的酒店房间号是 1926，活该 T。&emsp;&emsp;出门，大家的 M 题都是假做法，因为数据弱逊水所以什么乱搞甚至暴力都能过。队友的做法还算是坚挺，直到晚上回酒店了才被叉（&emsp;&emsp;然后爆出 B 和 I 也是假题。发现好多我认识的人都被假题演了。 &emsp;&emsp;晚上觅食，我开始食欲不振，邓老板被迫单刷了烤肉双人餐，第二天也吐了。第二天得知前晚又吐了两个人，至此，寒冷+生海鲜疑似 gank 了六个人。&emsp;&emsp;以后如果还来沈阳的话，我请所有一队吃饭，极限一换十（逃 end&emsp;&emsp;大概率去不了 EC，那么这个赛季就终了。又一年过去了，又到了终的时刻。 &emsp;&emsp;这一年，从颓废进步到了一丝积极。大一是迷茫与玩耍，9 月以前是半颓半积极，从 9 月开始重新找回了努力的感觉。是的，一段时间坚持每天刷很多题，就找到努力的感觉了。&emsp;&emsp;这一年，有了补题的计划。&emsp;&emsp;这一年，学了很多姿势，包括以前会过的，和以前不会的，还有新出的。&emsp;&emsp;这一年，已经不可以把不会做的题丢给队友了，自己要承担许多方向。&emsp;&emsp;这一年，开头很好，毛营，校赛省赛，前中期题做得快乐。&emsp;&emsp;这一年，学会了深度厨水水，开始战上映会，以后可能还要现地。&emsp;&emsp;但这一年结束了。不只是犯了很多错误，如果那些错误没犯，也离前排有很大的距离。&emsp;&emsp;无论是脑瘫几小时推出的K，还是赛后一分钟的G，&emsp;&emsp;又或者是不读题不看数据范围的哈尔滨，不会整数拆分的南京。&emsp;&emsp;做不到赛季三金，没完成一诺的死命令。&emsp;&emsp;离不开那个终极问题：又练了一年了，我到底有没有进步？&emsp;&emsp;范进还是没有中举。&emsp;&emsp;柴门闻犬吠，风雪夜归人。 &emsp;&emsp;和别人约好的，今年风光打完，退役。风光打完是没了。退役呢？我感觉要真香。明年可能会有更强的队友。&emsp;&emsp;似乎今年不那么伤感了，可能是因为决定了要真香，所以我知道还没完。又能多苟一年。 &emsp;&emsp;接下来，大二下学期忙课业，大三上边实验室边打比赛吧。你鸭大的文化课我反正失去了信心，总得在文化课之外干点啥。那就实验室+比赛吧，大家都这样都没问题，甚至还能进 final。 &emsp;&emsp;不出意外的话，明年还会有新的开始。","categories":[{"name":"总结与游记","slug":"总结与游记","permalink":"http://kqp.world/categories/%E6%80%BB%E7%BB%93%E4%B8%8E%E6%B8%B8%E8%AE%B0/"},{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[]},{"title":"【XVII Open Cup E.V. Pankratiev. Grand Prix of Europe. D】Dancing Disks 题解","slug":"【XVII Open Cup E.V. Pankratiev. Grand Prix of Europe. D】Dancing Disks 题解","date":"2019-11-07T08:58:31.000Z","updated":"2024-04-24T03:59:22.871Z","comments":true,"path":"【XVII Open Cup E.V. Pankratiev. Grand Prix of Europe. D】Dancing Disks 题解/","link":"","permalink":"http://kqp.world/%E3%80%90XVII%20Open%20Cup%20E.V.%20Pankratiev.%20Grand%20Prix%20of%20Europe.%20D%E3%80%91Dancing%20Disks%20%E9%A2%98%E8%A7%A3/","excerpt":"题目大意&emsp;&emsp;有一个 $6 \\times 6$ 的网格图，每个格子上有一根柱子。&emsp;&emsp;现在有 $n$ 个盘子套在 $(1,1)$ 的柱子上，自底向上分别为 $a_1,a_2,\\cdots,a_n$（构成一个大小为 $n$ 的排列）。&emsp;&emsp;每次操作你可以选择一根柱子，将其最上面的连续若干个盘子拿起，往下走一格或往右走一格。&emsp;&emsp;请构造一种方案使得盘子最后有序套在 $(6,6)$（自底向上是 $n,n-1,\\cdots,1$）。 &emsp;&emsp;$n \\leq 40000$","text":"题目大意&emsp;&emsp;有一个 $6 \\times 6$ 的网格图，每个格子上有一根柱子。&emsp;&emsp;现在有 $n$ 个盘子套在 $(1,1)$ 的柱子上，自底向上分别为 $a_1,a_2,\\cdots,a_n$（构成一个大小为 $n$ 的排列）。&emsp;&emsp;每次操作你可以选择一根柱子，将其最上面的连续若干个盘子拿起，往下走一格或往右走一格。&emsp;&emsp;请构造一种方案使得盘子最后有序套在 $(6,6)$（自底向上是 $n,n-1,\\cdots,1$）。 &emsp;&emsp;$n \\leq 40000$ \\\\ \\\\ \\\\题解&emsp;&emsp;假设现在要处理 $(x,y)$ 上的大小在 $[l,r]$ 之间的盘子（我们设计方案让每次处理的盘子的大小都是一段连续区间），我们肯定是要将它们分摊到其他地方，分治下去。&emsp;&emsp;具体来说，以 $(x,y)$ 为左上角、$(6,6)$ 为右下角的矩形（除去 $(x,y)$ 本身）都是可以用来分摊的，至于每个格子分摊多少，要看它的容量，即从它开始最多可以把多少个盘子排序。 &emsp;&emsp;设 $f_{x,y}$ 表示 $(x,y)$ 的容量。显然 $f_{6,6}=1$。按照上面的分摊思想，可以得出 f_{x,y}=\\sum_{i=x}^6\\sum_{j=y}^6 [(i,j)\\not=(x,y)] f_{i,j}&emsp;&emsp;于是就根据每个格子的容量安排它需要处理的大小区间，把当前 $(x,y)$ 的柱子一个个放到相应的格子去就好了。 &emsp;&emsp;还剩一个问题是，如果容量直接按那个递推式来搞的话，$f_{1,1}$ 只有两万多，是不够 $n$ 大的。因此特殊考虑 $f_{5,6}$ 和 $f_{6,5}$，它们按照那个式子算的是 $1$，但实际可以处理 $2$ 个盘子，所以把这个初值也加上去的话 $f_{1,1}$ 就够大了。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include&lt;bits/stdc++.h&gt;#define fo(i,a,b) for(int i=a;i&lt;=b;i++)#define fd(i,a,b) for(int i=a;i&gt;=b;i--)using namespace std;const int maxn=40005;int n,f[8][8];vector&lt;int&gt; a;void Move(int x1,int y1,int x2,int y2,int num)&#123; fo(i,x1,x2-1) printf(&quot;%d %d D %d\\n&quot;,i,y1,num); fo(j,y1,y2-1) printf(&quot;%d %d R %d\\n&quot;,x2,j,num);&#125;void dfs(int x,int y,vector&lt;int&gt; a,int l,int r)&#123; if (x==6 &amp;&amp; y==6) return; if (x+y==11) &#123; if (a.size()==1) Move(x,y,6,6,1); else &#123; if (a[0]&gt;a[1]) Move(x,y,6,6,2); else Move(x,y,6,6,1), Move(x,y,6,6,1); &#125; return; &#125; vector&lt;int&gt; ned[7][7]; int lo[7][7],hi[7][7]; int now=r; fd(i,6,x) &#123; fd(j,6,y) &#123; lo[i][j]=max(l,now-f[i][j]+1); hi[i][j]=now; now-=hi[i][j]-lo[i][j]+1; ned[i][j].clear(); if (now&lt;l) break; &#125; if (now&lt;l) break; &#125; for(int k=a.size()-1; k&gt;=0; k--) &#123; int e=a[k]; bool pd=0; fd(i,6,x) &#123; fd(j,6,y) if (lo[i][j]&lt;=e &amp;&amp; e&lt;=hi[i][j]) &#123; ned[i][j].push_back(e); Move(x,y,i,j,1); pd=1; break; &#125; if (pd) break; &#125; &#125; now=r; fd(i,6,x) &#123; fd(j,6,y) &#123; dfs(i,j,ned[i][j],lo[i][j],hi[i][j]); now-=hi[i][j]-lo[i][j]+1; if (now&lt;l) break; &#125; if (now&lt;l) break; &#125;&#125;int main()&#123; //freopen(&quot;d.in&quot;,&quot;r&quot;,stdin); //freopen(&quot;d.out&quot;,&quot;w&quot;,stdout); scanf(&quot;%d&quot;,&amp;n); fo(i,1,n) &#123; int x; scanf(&quot;%d&quot;,&amp;x); a.push_back(x); &#125; f[6][6]=1; f[5][6]=f[6][5]=2; f[5][5]=5; fd(i,6,1) fd(j,6,1) if (i&lt;5 || j&lt;5) fo(x,i,6) fo(y,j,6) f[i][j]+=f[x][y]; dfs(1,1,a,1,n);&#125;","categories":[{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[{"name":"算法_神奇的脑洞","slug":"算法-神奇的脑洞","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E7%A5%9E%E5%A5%87%E7%9A%84%E8%84%91%E6%B4%9E/"},{"name":"算法_构造题","slug":"算法-构造题","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E6%9E%84%E9%80%A0%E9%A2%98/"},{"name":"算法_分治","slug":"算法-分治","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E5%88%86%E6%B2%BB/"}]},{"title":"【XVII Open Cup E.V. Pankratiev. Grand Prix of Europe. L】Lost Logic 题解","slug":"【XVII Open Cup E.V. Pankratiev. Grand Prix of Europe. L】Lost Logic 题解","date":"2019-11-03T12:34:43.000Z","updated":"2024-04-24T03:59:22.872Z","comments":true,"path":"【XVII Open Cup E.V. Pankratiev. Grand Prix of Europe. L】Lost Logic 题解/","link":"","permalink":"http://kqp.world/%E3%80%90XVII%20Open%20Cup%20E.V.%20Pankratiev.%20Grand%20Prix%20of%20Europe.%20L%E3%80%91Lost%20Logic%20%E9%A2%98%E8%A7%A3/","excerpt":"题目大意&emsp;&emsp;有 $n$ 个布尔变量 $x_1,\\cdots,x_n$，在一组约束下恰好有三种赋值方式。&emsp;&emsp;约束是形如 $x_i \\to x_j$ 这样，$x_i$ 可以是 $!x_i$，$x_j$ 可以是 $!x_j$。&emsp;&emsp;现给出这三种赋值方式，请构造出一组约束。 &emsp;&emsp;$n \\leq 50$，你构造的约束数量 $\\leq 500$","text":"题目大意&emsp;&emsp;有 $n$ 个布尔变量 $x_1,\\cdots,x_n$，在一组约束下恰好有三种赋值方式。&emsp;&emsp;约束是形如 $x_i \\to x_j$ 这样，$x_i$ 可以是 $!x_i$，$x_j$ 可以是 $!x_j$。&emsp;&emsp;现给出这三种赋值方式，请构造出一组约束。 &emsp;&emsp;$n \\leq 50$，你构造的约束数量 $\\leq 500$ \\\\ \\\\ \\\\题解&emsp;&emsp;纪念一下已经傻掉的自己 &emsp;&emsp;因为这个题目模型很 2-sat，所以上来就在想 tarjan，没想到最后居然是这么 sb 的做法。。 &emsp;&emsp;首先，如果一个变量在三次赋值中都是相同的，那它是常值变量，可以一条约束直接解决掉。（若 $x_i \\equiv 0$，则 $!x_i \\to x_i$；若 $x_i \\equiv 1$，则 $x_i \\to !x_i$）&emsp;&emsp;然后，合并本质相同的变量。即，若 $x_i$ 与 $x_j$ 取值完全相同或完全相反，都可以用两条约束解决掉。 &emsp;&emsp;那么，最后一定只能剩下两个变量。&emsp;&emsp;这是因为，由于合并了本质相同的变量，因此本质不同的情况最多只有 4 种，而其中有一种是常值的情况，因此最多只有 3 种。但是如果有 3 种的话，是无解的，因此最多 2 种。而合法的数据又不会只有 1 种，因此只能是 2 种。 &emsp;&emsp;剩下的这两个变量可以一条约束解决掉。 &emsp;&emsp;所以最后在 $2n$ 条约束下就解决了。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;bits/stdc++.h&gt;#define fo(i,a,b) for(int i=a;i&lt;=b;i++)using namespace std;typedef long long LL;const int maxn=1e5+5;int n,a[maxn][4],m;pair&lt;pair&lt;int,int&gt;,pair&lt;int,int&gt;&gt; ans[maxn];int main()&#123; scanf(&quot;%d&quot;,&amp;n); fo(j,1,3) fo(i,1,n) scanf(&quot;%d&quot;,&amp;a[i][j]); int cnt=0, w1, w2; fo(i,1,n) if (a[i][1]==a[i][2] &amp;&amp; a[i][1]==a[i][3]) &#123; ans[++m]=make_pair(make_pair(i,a[i][1]),make_pair(i,a[i][1]^1)); &#125; else &#123; bool idp=1; fo(j,1,i-1) if (a[i][1]==a[j][1] &amp;&amp; a[i][2]==a[j][2] &amp;&amp; a[i][3]==a[j][3]) &#123; idp=0; ans[++m]=make_pair(make_pair(j,0),make_pair(i,0)); ans[++m]=make_pair(make_pair(j,1),make_pair(i,1)); break; &#125; else if (a[i][1]!=a[j][1] &amp;&amp; a[i][2]!=a[j][2] &amp;&amp; a[i][3]!=a[j][3]) &#123; idp=0; ans[++m]=make_pair(make_pair(j,0),make_pair(i,1)); ans[++m]=make_pair(make_pair(j,1),make_pair(i,0)); break; &#125; if (idp) &#123; ++cnt; if (cnt==1) w1=i; else w2=i; &#125; &#125; if (cnt!=2) puts(&quot;-1&quot;); else &#123; int df; if (a[w1][1]!=a[w1][2] &amp;&amp; a[w1][1]!=a[w1][3]) df=1; else if (a[w1][2]!=a[w1][1] &amp;&amp; a[w1][2]!=a[w1][3]) df=2; else df=3; ans[++m]=make_pair(make_pair(w1,a[w1][df]^1),make_pair(w2,a[w2][df]^1)); printf(&quot;%d\\n&quot;,m); fo(i,1,m) &#123; if (ans[i].first.second) putchar(&#x27;!&#x27;); printf(&quot;x%d -&gt; &quot;,ans[i].first.first); if (ans[i].second.second) putchar(&#x27;!&#x27;); printf(&quot;x%d\\n&quot;,ans[i].second.first); &#125; &#125;&#125;","categories":[{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[{"name":"算法_构造题","slug":"算法-构造题","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E6%9E%84%E9%80%A0%E9%A2%98/"},{"name":"算法_2-SAT","slug":"算法-2-SAT","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-2-SAT/"}]},{"title":"【CF1209G1+G2】Into Blocks (easy+hard) 题解","slug":"【CF1209G】Into Blocks (easy+hard) 题解","date":"2019-10-16T16:00:00.000Z","updated":"2024-04-24T03:59:22.834Z","comments":true,"path":"【CF1209G】Into Blocks (easy+hard) 题解/","link":"","permalink":"http://kqp.world/%E3%80%90CF1209G%E3%80%91Into%20Blocks%20(easy+hard)%20%E9%A2%98%E8%A7%A3/","excerpt":"题目大意&emsp;&emsp;一个序列是好的，当且仅当，若两个元素相等，则它们之间的所有元素都相等，比如 $[3,3,3,4,1,1]$。&emsp;&emsp;现在有一个初始序列 $a_1,\\cdots,a_n$，你要把它修改成好的。如果你把一个值为 $x$ 的元素改成 $y$，那么所有值为 $x$ 的元素都要改成 $y$。求最少需要修改多少个位置。&emsp;&emsp;在 hard version 中，还有 $q$ 次单点修改，每次修改都要回答一次。（在 easy version 中，$q=0$） &emsp;&emsp;$1 \\leq n,a_i \\leq 2 \\times 10^5,~0 \\leq q \\leq 2 \\times 10^5$&emsp;&emsp;5s","text":"题目大意&emsp;&emsp;一个序列是好的，当且仅当，若两个元素相等，则它们之间的所有元素都相等，比如 $[3,3,3,4,1,1]$。&emsp;&emsp;现在有一个初始序列 $a_1,\\cdots,a_n$，你要把它修改成好的。如果你把一个值为 $x$ 的元素改成 $y$，那么所有值为 $x$ 的元素都要改成 $y$。求最少需要修改多少个位置。&emsp;&emsp;在 hard version 中，还有 $q$ 次单点修改，每次修改都要回答一次。（在 easy version 中，$q=0$） &emsp;&emsp;$1 \\leq n,a_i \\leq 2 \\times 10^5,~0 \\leq q \\leq 2 \\times 10^5$&emsp;&emsp;5s \\\\ \\\\ \\\\easy version&emsp;&emsp;设数字 $x$ 最早出现在 $l$，最晚出现在 $r$，那么最终 $[l,r]$ 全部都要相同。&emsp;&emsp;那么每个数字相当于给出一个区间，这些区间形成了若干个不相交的区间并，每个区间并内全部要相同。&emsp;&emsp;那么最优的肯定是每个区间并内选择众数保留。答案就是 $n$ 减去各众数的出现次数和。 &emsp;&emsp;用个栈+并查集就可以求出来了。 hard version&emsp;&emsp;感谢大佬的博客让我读懂了题解 qaq &emsp;&emsp;现在是要想办法维护这个区间并，以及区间并内的众数。 &emsp;&emsp;一个非常好的办法是，对于数字 $x$，假设它的出现区间是 $[l,r]$，给 $[l,r-1]$ 全体加 $1$，那么 $0$ 就是区间并的分界点。 &emsp;&emsp;因此用一个线段树维护区间并的情况。每个区间记录最小值、最小值的最左位置 $l$、最小值的最右位置 $r$、$[l+1,r]$ 的各众数的出现次数和 $sum$（去掉开头和结尾的连续段是为了方便合并），记为 $\\{minval,l,r,sum\\}$。如果最小值为 $0$，那么 $sum$ 就是要求的东西了。&emsp;&emsp;合并两个区间的话，首先是取最小值较小的那一边（因为如果最小值不同那么大的那边肯定没有 $0$），如果两边最小值相同，则是 $\\{minval,l_{lson},r_{rson},sum_{lson}+sum_{rson}+s(r_{lson}+1,l_{rson})\\}$，其中 $s(l,r)$ 表示 $[l,r]$ 的众数的出现次数。 &emsp;&emsp;所以接下来的问题就是 $s(l,r)$ 怎么求。普通的求区间众数是很难做的，但是这题有个性质，就是如果我问 $[l,r]$ 的区间众数，那么这个众数肯定全部落在 $[l,r]$ 之中，不会在区间外。因此，再开一棵线段树，在每个数 $x$ 的最左位置赋值为 $x$ 的出现次数，那么 $s(l,r)$ 实际上就是个区间最大值。 参考&emsp;&emsp;https://blog.csdn.net/qq_39972971/article/details/100884760 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134#include&lt;bits/stdc++.h&gt;#define fo(i,a,b) for(int i=a;i&lt;=b;i++)using namespace std;const int maxn=2e5+5;struct TR&#123; int sum,l0,r0,nmin;&#125;;int n,q,a[maxn],maxa;set&lt;int&gt; pos[maxn];int nmax[4*maxn];void nmax_xg(int k,int l,int r,int x,int z)&#123; if (l==r) &#123; nmax[k]+=z; return; &#125; int t=k&lt;&lt;1, mid=(l+r)&gt;&gt;1; if (x&lt;=mid) nmax_xg(t,l,mid,x,z); else nmax_xg(t+1,mid+1,r,x,z); nmax[k]=max(nmax[t],nmax[t+1]);&#125;int nmax_cx(int k,int l,int r,int x,int y)&#123; if (x&gt;y) return 0; if (x&lt;=l &amp;&amp; r&lt;=y) return nmax[k]; int t=k&lt;&lt;1, mid=(l+r)&gt;&gt;1, re=0; if (x&lt;=mid) re=max(re,nmax_cx(t,l,mid,x,y)); if (mid&lt;y) re=max(re,nmax_cx(t+1,mid+1,r,x,y)); return re;&#125;TR tr[4*maxn];int bz[4*maxn];void update(int k,int t)&#123; tr[t].nmin+=bz[k], tr[t+1].nmin+=bz[k]; bz[t]+=bz[k], bz[t+1]+=bz[k]; bz[k]=0;&#125;TR merge(const TR &amp;a,const TR &amp;b)&#123; if (a.nmin&lt;b.nmin) return a; else if (a.nmin&gt;b.nmin) return b; else return (TR)&#123;a.sum+b.sum+nmax_cx(1,1,n,a.r0+1,b.l0),a.l0,b.r0,a.nmin&#125;;&#125;void tr_js(int k,int l,int r)&#123; if (l==r) &#123; tr[k].l0=tr[k].r0=l; return; &#125; int t=k&lt;&lt;1, mid=(l+r)&gt;&gt;1; tr_js(t,l,mid), tr_js(t+1,mid+1,r); tr[k]=merge(tr[t],tr[t+1]);&#125;void tr_xg_sing(int k,int l,int r,int x,int z)&#123; if (l==r) &#123; nmax_xg(1,1,n,x,z); return; &#125; int t=k&lt;&lt;1, mid=(l+r)&gt;&gt;1; update(k,t); if (x&lt;=mid) tr_xg_sing(t,l,mid,x,z); else tr_xg_sing(t+1,mid+1,r,x,z); tr[k]=merge(tr[t],tr[t+1]);&#125;void tr_xg_q(int k,int l,int r,int x,int y,int z)&#123; if (x&gt;y) return; if (x&lt;=l &amp;&amp; r&lt;=y) &#123; tr[k].nmin+=z; bz[k]+=z; return; &#125; int t=k&lt;&lt;1, mid=(l+r)&gt;&gt;1; update(k,t); if (x&lt;=mid) tr_xg_q(t,l,mid,x,y,z); if (mid&lt;y) tr_xg_q(t+1,mid+1,r,x,y,z); tr[k]=merge(tr[t],tr[t+1]);&#125;void modify(int x,int sig)&#123; if (pos[x].empty()) return; tr_xg_sing(1,0,n,*pos[x].begin(),sig*pos[x].size()); set&lt;int&gt;::iterator it=pos[x].end(); it--; tr_xg_q(1,0,n,*pos[x].begin(),*it-1,sig);&#125;void calc_ans()&#123; int ans=n-tr[1].sum-nmax_cx(1,1,n,1,tr[1].l0)-nmax_cx(1,1,n,tr[1].r0+1,n); printf(&quot;%d\\n&quot;,ans);&#125;int main()&#123; scanf(&quot;%d %d&quot;,&amp;n,&amp;q); fo(i,1,n) &#123; scanf(&quot;%d&quot;,&amp;a[i]); maxa=max(maxa,a[i]); pos[a[i]].insert(i); &#125; tr_js(1,0,n); fo(i,1,maxa) modify(i,1); calc_ans(); while (q--) &#123; int x,y; scanf(&quot;%d %d&quot;,&amp;x,&amp;y); modify(a[x],-1); pos[a[x]].erase(x); modify(a[x],1); modify(y,-1); pos[y].insert(x); modify(y,1); a[x]=y; calc_ans(); &#125;&#125;","categories":[{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[{"name":"算法_神奇的脑洞","slug":"算法-神奇的脑洞","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E7%A5%9E%E5%A5%87%E7%9A%84%E8%84%91%E6%B4%9E/"},{"name":"算法_线段树","slug":"算法-线段树","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E7%BA%BF%E6%AE%B5%E6%A0%91/"}]},{"title":"2019CCPC哈尔滨背锅记","slug":"2019_CCPC_harbin","date":"2019-10-13T13:33:12.000Z","updated":"2024-04-24T03:59:22.770Z","comments":true,"path":"2019_CCPC_harbin/","link":"","permalink":"http://kqp.world/2019_CCPC_harbin/","excerpt":"&emsp;&emsp;赛季才刚开始，不能说太多伤心的话，简单写写记记就好了吧","text":"&emsp;&emsp;赛季才刚开始，不能说太多伤心的话，简单写写记记就好了吧 暑假以来&emsp;&emsp;在学校打模拟赛打得挺崩的。&emsp;&emsp;暑假的时候是多校+毛营，一开始还能在校内排 rk2，然后逐渐往下掉，掉到 rk6 都有，开学以后是网络赛，日常 rk50~100，校排基本 rk5，非常自闭。&emsp;&emsp;真的很怀疑人生，又练了一年了，我到底有没有进步，怎么校选和组队都萎成这个样子。 &emsp;&emsp;偶尔打些 14 年 15 年的 regional 能打到校排 rk1，打个秦皇岛复现也能捧杯，能恢复一点自信。但是那些远古真题用处不大，很多姿势（比如模任意质数 FFT）都是后来推广的，现在的队伍来打没出线才不正常。 &emsp;&emsp;开学以后前 2 周忙出题，后面基本能稳定每周补 3 个中档及以上的题，这一点是比较满意的。一定要把事情做起来，哪怕刷水题都好，不能迷茫不能颓。 出发&emsp;&emsp;出发前腿拉伤，又因为赞助的事跟郭老对线，心情一般。 &emsp;&emsp;听说是第一命题组的残骸在出题，然后几乎所有强队都会去哈尔滨，已经做好了当场去世的觉悟。&emsp;&emsp;赛前的这一周基本上是在看 claris 的课件 ，妄图摸一摸出题人的题风，飞机上还能切掉一两个题，主要是学到了一点东西。 &emsp;&emsp;周六快乐试机，队友冲上来过了 A 和 B，我冲上来写 C 还卡壳了，最后被帮助了才写完了 C。然后 D 是个原题，可惜队友已经不会了，想抄博客被我们摁住了，结果自闭到最后弃疗了。但是因为前三题过得快，排名甚至苟进了前 10。该做的测试不会做，比如测 1s 跑多少亿、栈空间、行末空格行尾回车，照猫画虎随便测测就溜了。&emsp;&emsp;试机猛如虎。 &emsp;&emsp;晚上快乐面基，看起来大家都混得不错啊，我这个练 acm 练得最专业的，还会不会是最菜的呢？ 开始了&emsp;&emsp;深吸一口气，不紧张，冷静分析，干他一场。 &emsp;&emsp;开场我冲上来过了 J，看样例猜结论又过了 K，然后就换队友来写 F。&emsp;&emsp;过了 F 以后，我发现 I 是个递推，于是冲上去过了 I。&emsp;&emsp;共计 40 min 签完 4 个签到题，零罚时荣登 rk4。&emsp;&emsp;签到猛如虎。 &emsp;&emsp;接下来一段时间在快乐读题。把剩下的题都读了，大概判断了一些不可做的题。&emsp;&emsp;L 题看了一下多组数据总范围，没细想觉得暴力不对，就跟 ctlchild 说 L 应该不是暴力。B 题应该是搞清楚题目东西到底是啥就能做了，然后 E 看上去就很启发式合并。A 没看题但听见队友在讨论网络流，因为 ctlchild 是个建图高手就觉得很安心，就没管他们了。 &emsp;&emsp;此时 4 题大排队形成，我们依然苟在 rk4。 &emsp;&emsp;然后大家开始自闭 E。我觉得每个点无论如何要维护个 set，于是就在脑补 DAG 轻重剖分之类的东西。另外两个人似乎在想一些我不理解的做法。过了很久我觉得不行然后我就滚去搞 B 了，他们继续自闭。 &emsp;&emsp;此时 5 题大排队形成，我们不在首页了。 &emsp;&emsp;大约在 2h 左右邓老板脑补了一个二分中位数的做法。然后花了半个小时 E 过了。&emsp;&emsp;然后我搞出了 B 的 dp，但是状态表示很蠢（一个区间一个区间地转移）导致我要花一吨时间处理位运算细节。中途 ctlchild 跟邓老板讨论 A 和 L，ctlchild 说 A 应该是流或者线性规划，L 应该不是暴力，于是他们得出结论 A 要流或者线性规划冲一发，L 要大力平衡树。&emsp;&emsp;然后我一直写一直 wa 搞到封榜，邓老板开始快乐平衡树。最后我和邓老板交替写，我发现我漏了 case 要改状态于是放弃了机位，然后他也没写完。 &emsp;&emsp;评委宣布结束，5 题打银滚粗。 开始背锅&emsp;&emsp;开始了精彩的吹水讨论环节。 &emsp;&emsp;一讨论，大家 L 都是暴力冲过去了。我们为什么没冲暴力呢？因为一开始我看错了范围并且没细想，忽悠 ctlchild 说这可能不是暴力，然后 ctlchild 也没细想就忽悠邓老板说这应该不是暴力，然后他们开始快乐平衡树，成功 T 了。&emsp;&emsp;一讨论，大家 A 都说模板题。我因为没看题于是我看了一下题，尼玛，这不就是个差分约束带二分吗，我人傻了。我是真没想到队友讨论半天的网络流题居然会是…差分约束板子题！！！&emsp;&emsp;一讨论，大家的 E 都随便 $O(n)$，仔细交流发现，我读成了每次合并都要输出答案。我人没了。&emsp;&emsp;一讨论，才意识到 B 可以一个数一个数地转移，我用一段一段地转移至少花了 1h 在搞恶心的位运算。 &emsp;&emsp;于是，ABEL 我全都有锅了。&emsp;&emsp;从一开始签到猛如虎，一下子成了千古罪人。 &emsp;&emsp;一开始发个说说，说自己中期题全背锅了。又想了想，这四个题，可能连中期题都不大算吧，只要三个人随便一个不抽风都不至于这幅光景。。能把简单题硬生生做成神仙题我们也是超强的。 回家了&emsp;&emsp;其实主要是这个故事真的是太有趣了想把它记下来，好像写得有点长了。 &emsp;&emsp;首战失败，队伍存在很多问题。比如沟通交流，这次接连发生错题意、没看题导致亏题的情况。至于我 B 题写得慢写得丑，跟我思维差些还是很有关系的。&emsp;&emsp;接下来队伍要狂练中期题了。 &emsp;&emsp;虽然这次心态很崩，但是赛季才刚刚开始，这还只是个没啥用的 ccpc。&emsp;&emsp;离我们的最后一个 icpc 还有 5 周，5 周努力的话还是可以发生一些事情的吧。还是不要在一开始就说丧气话为好。&emsp;&emsp;SYSU_FateBlueBird Never Give Up !&emsp;&emsp;算了算了还是不要这样说了感觉 RNG 跟我们一样下饭 &emsp;&emsp;忽然很想停课集训，但我已经是大学生了。。。","categories":[{"name":"总结与游记","slug":"总结与游记","permalink":"http://kqp.world/categories/%E6%80%BB%E7%BB%93%E4%B8%8E%E6%B8%B8%E8%AE%B0/"},{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[]},{"title":"【XIV Open Cup E.V. Pankratiev. GP of SPb. H】Reachability 题解","slug":"【XIV Open Cup E.V. Pankratiev. GP of SPb. H】Reachability 题解","date":"2019-10-05T12:48:35.000Z","updated":"2024-04-24T03:59:22.870Z","comments":true,"path":"【XIV Open Cup E.V. Pankratiev. GP of SPb. H】Reachability 题解/","link":"","permalink":"http://kqp.world/%E3%80%90XIV%20Open%20Cup%20E.V.%20Pankratiev.%20GP%20of%20SPb.%20H%E3%80%91Reachability%20%E9%A2%98%E8%A7%A3/","excerpt":"题目大意&emsp;&emsp;一幅有向图有 $n$ 个结点，初始没有边。&emsp;&emsp;有 $q$ 个操作，四种类型： $+\\ o\\ v\\ k\\ a_1\\ \\cdots\\ a_k$：加入边 $(v,a_1),\\cdots,(v,a_k)$ $+\\ i\\ v\\ k\\ a_1\\ \\cdots\\ a_k$：加入边 $(a_1,v),\\cdots,(a_k,v)$ $-\\ o\\ v\\ k\\ a_1\\ \\cdots\\ a_k$：删除边 $(v,a_1),\\cdots,(v,a_k)$ $-\\ i\\ v\\ k\\ a_1\\ \\cdots\\ a_k$：删除边 $(a_1,v),\\cdots,(a_k,v)$ &emsp;&emsp;加边之前会保证原来没有这条边，删边之前会保证原来有这条边。&emsp;&emsp;每次操作后，可以得到一个连通性矩阵 $a$（$a_{i,j}=1$ 表示 $i$ 能到 $j$），输出 \\bigg(\\sum_{i,j=1}^n a_{i,j}A^{i-1}B^{j-1}\\bigg)\\ \\text{mod}\\ 2^{32}&emsp;&emsp;$1 \\leq n \\leq 400,\\ 1 \\leq q \\leq 800,\\ 1 \\leq A,B \\leq 10^9$&emsp;&emsp;3s","text":"题目大意&emsp;&emsp;一幅有向图有 $n$ 个结点，初始没有边。&emsp;&emsp;有 $q$ 个操作，四种类型： $+\\ o\\ v\\ k\\ a_1\\ \\cdots\\ a_k$：加入边 $(v,a_1),\\cdots,(v,a_k)$ $+\\ i\\ v\\ k\\ a_1\\ \\cdots\\ a_k$：加入边 $(a_1,v),\\cdots,(a_k,v)$ $-\\ o\\ v\\ k\\ a_1\\ \\cdots\\ a_k$：删除边 $(v,a_1),\\cdots,(v,a_k)$ $-\\ i\\ v\\ k\\ a_1\\ \\cdots\\ a_k$：删除边 $(a_1,v),\\cdots,(a_k,v)$ &emsp;&emsp;加边之前会保证原来没有这条边，删边之前会保证原来有这条边。&emsp;&emsp;每次操作后，可以得到一个连通性矩阵 $a$（$a_{i,j}=1$ 表示 $i$ 能到 $j$），输出 \\bigg(\\sum_{i,j=1}^n a_{i,j}A^{i-1}B^{j-1}\\bigg)\\ \\text{mod}\\ 2^{32}&emsp;&emsp;$1 \\leq n \\leq 400,\\ 1 \\leq q \\leq 800,\\ 1 \\leq A,B \\leq 10^9$&emsp;&emsp;3s \\\\ \\\\ \\\\解法1&emsp;&emsp;每个点维护一个 bitset 表示它能到哪些点。&emsp;&emsp;每次操作时，暴力重构 $v$ 的 bitset，然后 bfs 一下把能到 $v$ 的点找出来，按拓扑序更新它们的 bitset。维护 bitset 时顺便维护答案。&emsp;&emsp;对于加边操作的更新，是 $bitset_i = bitset_i \\vee bitset_v$。这个的时间主要在于图的遍历，边表是 $O(n^2)$ 的，因此时间是 $O\\big(q(n^2+n\\frac n{64})\\big)=O(qn^2)$。&emsp;&emsp;对于删边操作的更新，是 $bitset_i = \\bigvee_{x \\in \\text{out}(i)}bitset_x$（$\\text{out}(i)$ 表示 $i$ 的出点），由于之前是或操作不可撤销，因此这个要对于 $i$ 枚举它的出点重新算，因此是 $O\\big(q(n^2+n^2\\frac n{64})\\big)=O(\\frac{qn^3}{64})$。 &emsp;&emsp;因此总的时间是 $O(\\frac{qn^3}{64})$，算出来 8 亿但是跑过去了。 解法2&emsp;&emsp;上面的解法，加边很优秀，但是删边不太行，这是因为删边的时候由于维护的是“是否连通”，所以无法快速撤销一个出点的影响。 &emsp;&emsp;那什么可以撤销呢？方案数就可以撤销！ &emsp;&emsp;记 $f_{i,j}$ 表示 $i$ 走到 $j$ 的方案数，给它模个 $10^9+7$ 啥的（不放心就多模几个）。&emsp;&emsp;每次操作时，暴力重算 $f_{v,\\cdot}$ 或者 $f_{\\cdot,v}$，然后对于所有 $(i,j)$，先 $f_{i,j}-=$原来的$f_{i,v}+f_{v,j}$，再 $+=$新的$f_{i,v}+f_{v,j}$。 &emsp;&emsp;这样就是 $O(qn^2)$ 的了。 代码// 解法1123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#include&lt;bits/stdc++.h&gt;#define fo(i,a,b) for(int i=a;i&lt;=b;i++)using namespace std;typedef unsigned int uint;const int maxn=405;int n,q,len,x[maxn];uint A[maxn],B[maxn];bool mp[maxn][maxn];bitset&lt;maxn&gt; a[maxn];void ReadChar(char &amp;ch)&#123; ch=getchar(); while (ch!=&#x27;+&#x27; &amp;&amp; ch!=&#x27;-&#x27; &amp;&amp; ch!=&#x27;o&#x27; &amp;&amp; ch!=&#x27;i&#x27;) ch=getchar();&#125;bool bz[maxn];void dfs1(int k,int v)&#123; if (v!=k) a[v][k]=1; bz[k]=1; fo(i,1,n) if (mp[k][i] &amp;&amp; !bz[i]) dfs1(i,v);&#125;int d[3*maxn],dg[maxn];void topo(int v,char ty)&#123; fo(i,1,n) bz[i]=0, dg[i]=0; int j=0; if (ty==&#x27;o&#x27;) d[j=1]=v; else fo(i,1,len) d[++j]=x[i]; for(int i=1; i&lt;=j; i++) &#123; fo(go,1,n) if (mp[go][d[i]]) &#123; dg[go]++; if (!bz[go]) bz[ d[++j]=go ]=1; &#125; &#125;&#125;uint ans,Ans[maxn];void Redo(int v)&#123; ans-=Ans[v]; Ans[v]=0; fo(i,1,n) if (a[v][i]) Ans[v]+=A[v-1]*B[i-1]; ans+=Ans[v];&#125;int main()&#123; freopen(&quot;reachability.in&quot;,&quot;r&quot;,stdin); freopen(&quot;reachability.out&quot;,&quot;w&quot;,stdout); scanf(&quot;%d %d %u %u&quot;,&amp;n,&amp;q,&amp;A[1],&amp;B[1]); A[0]=B[0]=1; fo(i,2,n) A[i]=A[i-1]*A[1], B[i]=B[i-1]*B[1]; while (q--) &#123; char ch1,ch2; int v; ReadChar(ch1), ReadChar(ch2); scanf(&quot;%d %d&quot;,&amp;v,&amp;len); fo(i,1,len) &#123; scanf(&quot;%d&quot;,&amp;x[i]); if (ch2==&#x27;o&#x27;) mp[v][x[i]]^=1; else mp[x[i]][v]^=1; &#125; if (ch2==&#x27;o&#x27;) &#123; a[v].reset(); fo(i,1,n) bz[i]=0; dfs1(v,v); Redo(v); &#125; topo(v,ch2); if (ch1==&#x27;+&#x27;) &#123; int j=0; if (ch2==&#x27;o&#x27;) d[j=1]=v; else fo(i,1,len) d[++j]=x[i]; for(int i=1; i&lt;=j; i++) &#123; a[d[i]]|=a[v]; if (d[i]!=v) a[d[i]][v]=1; Redo(d[i]); fo(go,1,n) if (mp[go][d[i]]) &#123; if (--dg[go]==0) d[++j]=go; &#125; &#125; &#125; else &#123; int j=0; if (ch2==&#x27;o&#x27;) d[j=1]=v; else fo(i,1,len) d[++j]=x[i]; for(int i=1; i&lt;=j; i++) &#123; a[d[i]].reset(); fo(go,1,n) if (mp[d[i]][go]) a[d[i]]|=a[go], a[d[i]][go]=1; Redo(d[i]); fo(go,1,n) if (mp[go][d[i]]) &#123; if (--dg[go]==0) d[++j]=go; &#125; &#125; &#125; printf(&quot;%u\\n&quot;,ans); &#125;&#125;","categories":[{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[{"name":"算法_DP","slug":"算法-DP","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-DP/"},{"name":"算法_位运算","slug":"算法-位运算","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/"}]},{"title":"【2019 Multi-University 4 I】Linear Functions 题解","slug":"【2019 Multi-University 4 I】Linear Functions 题解","date":"2019-10-01T15:21:18.000Z","updated":"2024-04-24T03:59:22.809Z","comments":true,"path":"【2019 Multi-University 4 I】Linear Functions 题解/","link":"","permalink":"http://kqp.world/%E3%80%902019%20Multi-University%204%20I%E3%80%91Linear%20Functions%20%E9%A2%98%E8%A7%A3/","excerpt":"题目大意&emsp;&emsp;有 $n$ 个元素，第 $i$ 个元素在初始 $0$ 时刻时值为 $a_i$，此后每个时刻增加 $b_i$ 并模 $p_i$，即在 $t$ 时刻时值为 $(a_i+b_i\\cdot t) \\bmod p_i$，其中 $t$ 为整数。&emsp;&emsp;求 \\max_{t=0}^T \\{\\sum_{i=1}^n (a_i+b_i\\cdot t) \\bmod p_i \\}&emsp;&emsp;输出这个最大值，及其对应的最早的时刻。 &emsp;&emsp;$1 \\leq n,T \\leq 10^5,\\ \\ 0 \\leq a_i,b_i &lt; p_i,\\ \\ 5\\times10^8 &lt; p_i &lt; 10^9$&emsp;&emsp;多测，$\\sum n \\leq 10^6$，80% 数据保证 $n \\leq 1000$&emsp;&emsp;保证 $p_i$ 为质数；&emsp;&emsp;$a_i,b_i$ 在 $[0,p_i)$ 范围内随机生成；&emsp;&emsp;5s","text":"题目大意&emsp;&emsp;有 $n$ 个元素，第 $i$ 个元素在初始 $0$ 时刻时值为 $a_i$，此后每个时刻增加 $b_i$ 并模 $p_i$，即在 $t$ 时刻时值为 $(a_i+b_i\\cdot t) \\bmod p_i$，其中 $t$ 为整数。&emsp;&emsp;求 \\max_{t=0}^T \\{\\sum_{i=1}^n (a_i+b_i\\cdot t) \\bmod p_i \\}&emsp;&emsp;输出这个最大值，及其对应的最早的时刻。 &emsp;&emsp;$1 \\leq n,T \\leq 10^5,\\ \\ 0 \\leq a_i,b_i &lt; p_i,\\ \\ 5\\times10^8 &lt; p_i &lt; 10^9$&emsp;&emsp;多测，$\\sum n \\leq 10^6$，80% 数据保证 $n \\leq 1000$&emsp;&emsp;保证 $p_i$ 为质数；&emsp;&emsp;$a_i,b_i$ 在 $[0,p_i)$ 范围内随机生成；&emsp;&emsp;5s \\\\ \\\\ \\\\题解&emsp;&emsp;鉴于目前这题只有两篇不讲人话的题解（官方题解和 Zayin 的博客），我决定补掉这题并写一篇世人能看得懂的题解 &emsp;&emsp;首先思考一些比较暴力的做法，一开始令 $ans=\\sum_{i=1}^n a_i$，然后每往后走一个时刻默认给 $ans$ 加上 $\\sum_{i=1}^n b_i$，然后我们对于每个 $i$ 事先标记出哪些时刻要让 $ans-=p_i$，这样就可以算出答案了。&emsp;&emsp;这样乍一看是 $O(nT)$ 的，但写准确一点应该是 $O(n\\lfloor\\frac{b_iT}{p_i}\\rfloor)$ 的，因为 $-p_i$ 的标记只有 $\\lfloor\\frac{a_i+b_iT}{p_i}\\rfloor$ 个，因此单个 $i$ 的预处理是 $O(\\lfloor\\frac{b_iT}{p_i}\\rfloor)$ 的。&emsp;&emsp;这在 $b_i$ 小的时候很好，在 $b_i$ 大的时候（接近 $p_i$ 的时候）就变成 $O(nT)$ 了。 &emsp;&emsp;所以接下来要用一些姿势，使得 $b_i$ 能够变小。 &emsp;&emsp;举个例子观察一下，比如 $b_i=4,~p_i=11$，那么 $(b_i\\cdot t)~\\text{mod}~p_i$ 会长这个样子： 4,8,1,5,9,2,6,10,3,7,0,4,\\cdots&emsp;&emsp;记 $G=\\lfloor \\sqrt n \\rfloor$，比如我们假设 $G=4$，那么观察前 $4$ 个数，记 $stp$ 表示这前 $G$ 个数的最小值，$g$ 表示最小值在第几个取到。（这个例子中 $stp=1,~g=3$）&emsp;&emsp;把时间 $t$ 按模 $g$ 分组，则可以发现，这个数列分成了 $g$ 组，每组起始值不同，间隔都是 $stp$，并且 $stp$ 比较小。 &emsp;&emsp;$stp$ 有多小呢？在 $b_i$ 随机的情况下是 $O(\\frac{p_i}{G})$ 的。这里引用一下 Zayin 的粗略证明： &emsp;&emsp;粗略证明（其实严格的我也不会….)&emsp;&emsp;当 $a$ 很大（比如 $a&gt;\\frac pk$）时，$a,2a\\%p,3a\\%p\\cdots ka\\%p$ 这个数列几乎可以认为是随机的，而在 $[0,p)$ 中随机选 $k$ 个数的最小值的期望是 $\\frac P{k+1}$&emsp;&emsp;当 $a$ 很小（比如 $a&lt;\\frac pk$）时，$a,2a\\%p,3a\\%p\\cdots ka\\%p$ 等价于 $a,2a,3a\\cdots ka$（因为 $a$ 很小），所以最小值的期望是 $a$，而此时 $a$ 的期望则是 $\\frac p{2k}$。&emsp;&emsp;所以 $a,2a\\%p,3a\\%p\\cdots ka\\%p$ 是 $\\frac pk$ 这个量级的。&emsp;&emsp;而根据程序验证，最小值大都处于 $[\\frac pk,\\frac {2p}k]$ 之间，相对来说比较符合。 &emsp;&emsp;那么现在尝试用 $stp$ 代替 $b_i$ 来压时间。就是说现在有了一个 $g$ 和 $stp$，那么把时间按模 $g$ 分组，每组独立做。原来的时候，第 $i$ 个元素在 $t$ 时刻的贡献为 $a_i+b_i \\cdot t-\\lfloor \\frac{a_i+b_i \\cdot t}{p_i} \\rfloor p_i$，现在相当于把 $a_i$ 换成了相应的初值，把 $b_i$ 换成了 $stp$，$t$ 压缩成从 $0$ 到 $\\frac T{g}$。&emsp;&emsp;然后每组还是按照一开始那个暴力做法来做，即每个时刻默认加 $stp$，然后用 $O(\\lfloor \\frac{stp \\cdot \\frac T{g}}{p_i} \\rfloor)$ 的时间来打 $-p_i$ 标记预处理。 &emsp;&emsp;这样一来，单个 $i$ 的打标记复杂度变成 $O(g\\lfloor \\frac{stp\\cdot \\frac Tg}{p_i} \\rfloor)=O(g\\lfloor \\frac{\\frac{p_i}{\\sqrt n}\\cdot \\frac T{g}}{p_i} \\rfloor)=O(\\frac T{\\sqrt n})$，因此 $n$ 个元素打标记总复杂度为 $O(T\\sqrt n)$。&emsp;&emsp;然后扫一遍时间算答案的这部分，$g$ 相同的元素可以放一起扫，只有 $\\sqrt n$ 种不同的 $g$，因此这部分总时间为 $O(\\sqrt n \\cdot g \\frac Tg)=O(T\\sqrt n)$。&emsp;&emsp;因此总时间是 $O(T \\sqrt n)$。 &emsp;&emsp;UPD：然后这题要卡常。&emsp;&emsp;这题主要的卡常姿势是：在上面我们是正着走的，即 $stp=(b_i \\cdot t)~\\text{mod}~p_i$，我们再加上个倒着走，即 $stp=-(p_i-b_i) \\cdot t~\\text{mod}~p_i$ 也拿来比较一下。这样可以优化掉一半的时间。&emsp;&emsp;然后注意把 long long 换成 int。 参考&emsp;&emsp;Zayin 的博客：https://blog.csdn.net/Zayin___/article/details/100529778 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include&lt;bits/stdc++.h&gt;#define fo(i,a,b) for(int i=a;i&lt;=b;i++)using namespace std;typedef long long LL;const int maxn=1e5+5, maxsqrtn=500;int n,T,a[maxn],b[maxn],p[maxn],sqrtn,stp[maxn],sig[maxn];LL Ans[maxn];void ReadInt(int &amp;data)&#123; data=0; char ch=getchar(); while (ch&lt;&#x27;0&#x27; || ch&gt;&#x27;9&#x27;) ch=getchar(); do&#123; data=(data&lt;&lt;3)+(data&lt;&lt;1)+ch-&#x27;0&#x27;; ch=getchar(); &#125; while (ch&gt;=&#x27;0&#x27; &amp;&amp; ch&lt;=&#x27;9&#x27;);&#125;inline void add(int &amp;now,const int &amp;b,const int &amp;p)&#123; now+=b; now=(now&gt;=p) ?now-p :now;&#125;vector&lt;int&gt; v[maxsqrtn];LL tag[maxn];int main()&#123; while (scanf(&quot;%d %d&quot;,&amp;n,&amp;T)!=EOF) &#123; fo(i,1,n) ReadInt(a[i]); fo(i,1,n) ReadInt(b[i]); fo(i,1,n) ReadInt(p[i]); fo(i,0,T) Ans[i]=0; sqrtn=sqrt(n); fo(i,1,sqrtn) v[i].clear(); fo(i,1,n) &#123; stp[i]=p[i]+5; int now=0, g; fo(j,1,sqrtn) &#123; add(now,b[i],p[i]); if (now&lt;stp[i]) stp[i]=now, g=j, sig[i]=1; //正着走 if (p[i]-now&lt;stp[i]) stp[i]=p[i]-now, g=j, sig[i]=-1; //倒着走 &#125; v[g].push_back(i); &#125; fo(g,1,sqrtn) &#123; fo(i,0,T) tag[i]=0; LL sumstp=0; for(int i:v[g]) &#123; sumstp+=stp[i]*sig[i]; for(int j=0, st=a[i]; j&lt;g; j++, add(st,b[i],p[i])) &#123; tag[j]+=st; if (stp[i]==0) continue; for(int now=st, t=j, tmp, nextt; ; t=nextt) &#123; tmp=(sig[i]==1) ?(p[i]-1-now)/stp[i]+1 :now/stp[i]+1 ; if (t+(LL)tmp*g&gt;T) break; nextt=t+tmp*g; tag[nextt]-=p[i]*sig[i]; now+=(tmp*stp[i]-p[i])*sig[i]; &#125; &#125; &#125; fo(i,g,T) tag[i]+=tag[i-g]+sumstp; fo(i,0,T) Ans[i]+=tag[i]; &#125; int w=0; fo(i,1,T) if (Ans[i]&gt;Ans[w]) w=i; printf(&quot;%lld %d\\n&quot;,Ans[w],w); &#125;&#125;","categories":[{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[{"name":"算法_神奇的脑洞","slug":"算法-神奇的脑洞","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E7%A5%9E%E5%A5%87%E7%9A%84%E8%84%91%E6%B4%9E/"},{"name":"算法_随机大法","slug":"算法-随机大法","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E9%9A%8F%E6%9C%BA%E5%A4%A7%E6%B3%95/"},{"name":"算法_根号平衡","slug":"算法-根号平衡","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E6%A0%B9%E5%8F%B7%E5%B9%B3%E8%A1%A1/"}]},{"title":"【2019 Multi-University 6 A】Salty Fish 题解","slug":"【2019 Multi-University 6 A】Salty Fish 题解","date":"2019-09-27T03:17:17.000Z","updated":"2024-04-24T03:59:22.809Z","comments":true,"path":"【2019 Multi-University 6 A】Salty Fish 题解/","link":"","permalink":"http://kqp.world/%E3%80%902019%20Multi-University%206%20A%E3%80%91Salty%20Fish%20%E9%A2%98%E8%A7%A3/","excerpt":"题目大意&emsp;&emsp;有一棵 $n$ 个结点的树，第 $i$ 个结点有 $a_i$ 的收益。&emsp;&emsp;还有 $m$ 个摄像头，第 $i$ 个摄像头在 $x_i$ 这个结点上，能监测它子树里所有与 $x_i$ 距离不超过 $k_i$ 的结点（距离按边算），黑掉这个摄像头的代价是 $c_i$。一个结点被任何摄像头监测着它就不能获得收益。&emsp;&emsp;求最大获益。 &emsp;&emsp;$1 \\leq n,m \\leq 3 \\times 10^5,~1 \\leq a_i,c_i \\leq 10^9$&emsp;&emsp;多测，$\\sum n \\leq 10^6,~\\sum m \\leq 10^6$&emsp;&emsp;4s","text":"题目大意&emsp;&emsp;有一棵 $n$ 个结点的树，第 $i$ 个结点有 $a_i$ 的收益。&emsp;&emsp;还有 $m$ 个摄像头，第 $i$ 个摄像头在 $x_i$ 这个结点上，能监测它子树里所有与 $x_i$ 距离不超过 $k_i$ 的结点（距离按边算），黑掉这个摄像头的代价是 $c_i$。一个结点被任何摄像头监测着它就不能获得收益。&emsp;&emsp;求最大获益。 &emsp;&emsp;$1 \\leq n,m \\leq 3 \\times 10^5,~1 \\leq a_i,c_i \\leq 10^9$&emsp;&emsp;多测，$\\sum n \\leq 10^6,~\\sum m \\leq 10^6$&emsp;&emsp;4s \\\\ \\\\ \\\\题解&emsp;&emsp;首先这是个“最大获利”（学名 最大权闭合图），可以快速建出模型：左边 $m$ 个点表示摄像头，与源点相连，容量为 $c_i$；右边 $n$ 个点表示树上结点，与汇点相连，容量为 $a_i$，然后每个摄像头与它监控的所有结点连边，容量为 $+\\infty$。跑最小割即是答案。 &emsp;&emsp;然后这个图太大了，所以要考虑用贪心模拟网络流。 &emsp;&emsp;对于每个点上的摄像头，它的最优方案肯定是先找深度最大的结点来流。因此可以每个点维护一个 set，存这棵子树下每个深度的剩余流量。然后摄像头就贪心地在 set 里找深度最大的去流。 &emsp;&emsp;然后 set 里的内容是以深度为下标的，因此用长链剖分来合并，这样就是 $O(n \\log n)$ 的了。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123#include&lt;bits/stdc++.h&gt;#define fo(i,a,b) for(int i=a;i&lt;=b;i++)#define fi first#define se secondusing namespace std;typedef long long LL;typedef pair&lt;int,LL&gt; spr;const int maxn=3e5+5;const LL inf=1e18;int n,m,a[maxn];vector&lt;int&gt; e[maxn];vector&lt;pair&lt;int,int&gt;&gt; q[maxn];int maxdeep[maxn],Lson[maxn],deep[maxn];void dfs_pre(int k,int last)&#123; Lson[k]=0; maxdeep[k]=deep[k]=deep[last]+1; for(int go:e[k]) &#123; dfs_pre(go,k); if (maxdeep[go]&gt;maxdeep[Lson[k]]) Lson[k]=go; &#125;&#125;LL ans;set&lt;spr&gt; S[maxn];int id[maxn];void merge(int a,int b)&#123; for(spr pr:S[b]) &#123; set&lt;spr&gt;::iterator it=S[a].upper_bound(make_pair(pr.fi,inf)); if (it==S[a].begin()) continue; it--; if (it-&gt;fi==pr.fi) &#123; spr now=*it; S[a].erase(now); now.se+=pr.se; S[a].insert(now); &#125; else S[a].insert(pr); &#125; S[b].clear();&#125;void calc(int k)&#123; for(pair&lt;int,int&gt; qi:q[k]) &#123; while (qi.se&gt;0) &#123; set&lt;spr&gt;::iterator it=S[id[k]].upper_bound(make_pair(qi.fi+deep[k],inf)); if (it==S[id[k]].begin()) break; it--; spr now=*it; S[id[k]].erase(now); LL nmin=min(now.se,1ll*qi.se); ans-=nmin; qi.se-=nmin; now.se-=nmin; if (now.se&gt;0) S[id[k]].insert(now); &#125; &#125;&#125;void dfs(int k)&#123; if (!Lson[k]) &#123; S[k].insert(make_pair(deep[k],a[k])); calc(k); return; &#125; dfs(Lson[k]); id[k]=id[Lson[k]]; S[id[k]].insert(make_pair(deep[k],a[k])); for(int go:e[k]) if (go!=Lson[k]) &#123; dfs(go); merge(id[k],id[go]); &#125; calc(k);&#125;void Clear()&#123; fo(i,1,n) &#123; e[i].clear(), q[i].clear(), S[i].clear(); id[i]=i; &#125; ans=0;&#125;int T;int main()&#123; scanf(&quot;%d&quot;,&amp;T); while (T--) &#123; scanf(&quot;%d %d&quot;,&amp;n,&amp;m); Clear(); fo(i,2,n) &#123; int x; scanf(&quot;%d&quot;,&amp;x); e[x].push_back(i); &#125; fo(i,1,n) scanf(&quot;%d&quot;,&amp;a[i]), ans+=a[i]; fo(i,1,m) &#123; int x,k,c; scanf(&quot;%d %d %d&quot;,&amp;x,&amp;k,&amp;c); q[x].push_back(make_pair(k,c)); &#125; dfs_pre(1,0); dfs(1); printf(&quot;%lld\\n&quot;,ans); &#125;&#125;","categories":[{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[{"name":"算法_网络流/匹配","slug":"算法-网络流-匹配","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E7%BD%91%E7%BB%9C%E6%B5%81-%E5%8C%B9%E9%85%8D/"},{"name":"算法_贪心","slug":"算法-贪心","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E8%B4%AA%E5%BF%83/"},{"name":"算法_树链剖分","slug":"算法-树链剖分","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/"}]},{"title":"【Petrozavodsk WC 2018d2 ITMO U 1 Contest E】Enumeration of Tournaments 题解","slug":"【Petrozavodsk WC 2018d2 ITMO U 1 Contest E】Enumeration of Tournaments 题解","date":"2019-09-26T01:38:57.000Z","updated":"2024-04-24T03:59:22.863Z","comments":true,"path":"【Petrozavodsk WC 2018d2 ITMO U 1 Contest E】Enumeration of Tournaments 题解/","link":"","permalink":"http://kqp.world/%E3%80%90Petrozavodsk%20WC%202018d2%20ITMO%20U%201%20Contest%20E%E3%80%91Enumeration%20of%20Tournaments%20%E9%A2%98%E8%A7%A3/","excerpt":"题目大意&emsp;&emsp;有 $n$ 个人玩淘汰赛。&emsp;&emsp;每一轮，假设当前还剩 $k$ 人，则他们随机分成 $\\lfloor \\frac k2 \\rfloor$ 组（$k$ 为奇数时有一人轮空），最后晋级 $\\lceil \\frac k2 \\rceil$ 人。每个人能力互不相同，两人对打时一定是能力强者获胜。&emsp;&emsp;求所有可能的局面数，答案对 $2^{64}$ 取模。 &emsp;&emsp;$1 \\leq n \\leq 10^{18}$ &emsp;&emsp;注意题面坑：Two tournaments are called different if there is a game (between two participants) in one of the tournaments that doesn’t occur in the other tournament. 这句话是错的！","text":"题目大意&emsp;&emsp;有 $n$ 个人玩淘汰赛。&emsp;&emsp;每一轮，假设当前还剩 $k$ 人，则他们随机分成 $\\lfloor \\frac k2 \\rfloor$ 组（$k$ 为奇数时有一人轮空），最后晋级 $\\lceil \\frac k2 \\rceil$ 人。每个人能力互不相同，两人对打时一定是能力强者获胜。&emsp;&emsp;求所有可能的局面数，答案对 $2^{64}$ 取模。 &emsp;&emsp;$1 \\leq n \\leq 10^{18}$ &emsp;&emsp;注意题面坑：Two tournaments are called different if there is a game (between two participants) in one of the tournaments that doesn’t occur in the other tournament. 这句话是错的！ \\\\ \\\\ \\\\题解&emsp;&emsp;这题的难点在于揣摩出题人的正确题意&emsp;&emsp;题意演我 3 个小时出题人今晚买菜必涨价 &emsp;&emsp;考虑递推。设 $f(n)$ 为 $n$ 个人时的方案数。&emsp;&emsp;当 $n$ 为奇数时，设 $m=\\lfloor \\frac n2 \\rfloor$，轮空一个人有 $n$ 种情况，分组有 $\\frac{(2m)!}{2^m m!}$ 种情况（给 $2m$ 个人标号 $1$~$2m$，$i$ 和 $m+i$ 一组，然后去重），晋级的 $m+1$ 个人打接下来的比赛有 $f(m+1)$ 种情况，故 f(n)=n\\cdot \\frac{(2m)!}{2^m m!} \\cdot f(m+1)=n!!\\cdot f(\\lceil \\frac n2 \\rceil)&emsp;&emsp;偶数同理，得到 f(n)=\\frac{(2m)!}{2^m m!} \\cdot f(m)=(n-1)!!\\cdot f(\\frac n2)&emsp;&emsp;如何求 $n!!~\\text{mod}~2^{64}$ 呢？这个技巧还是不错的。&emsp;&emsp;首先这个 $n$ 是个奇数，设 $P_k(x)=\\prod_{i=1}^k(2x+2i-1)=(2x+1)(2x+3)\\cdots(2x+2k-1)$，而这个 $P_k(0)$ 就是要求的值。&emsp;&emsp;$P_k(x)$ 是关于 $x$ 的多项式，而这个多项式对于 $x^{64}$ 及以上的项，系数都含有 $2^{64}$，模意义下为 $0$，因此这个多项式只用考虑前 64 项（$x^0$ 至 $x^{63}$）。因此这个多项式的普通乘法是 $O(64\\cdot 64)$ 的。&emsp;&emsp;考虑倍增求这个多项式，假设已知 $P_k(x)$，那么 $P_{2k}(x)=P_k(x)P_k(x+k)$，具体实现就先用 $O(64\\cdot 64)$ 的时间求出 $P_k(x+k)$，然后再用 $O(64\\cdot 64)$ 的乘法求出 $P_{2k}(x)$。通过 $P_{2k}(x)$ 求 $P_{2k+1}(x)$ 同理。 题面的题意&emsp;&emsp;如果按照题面的题意要怎么做呢？ &emsp;&emsp;其实差别就是，比如 $n=3$ 的时候，3 先跟 1 打再跟 2 打，与 3 先跟 2 打再跟 1 打是等价的。&emsp;&emsp;我们给要对打的两个人连边，它形成了一棵树，所以不同的局面数就是合法的生成树的个数。&emsp;&emsp;有标号生成树计数，考虑 prufer 序。 &emsp;&emsp;然后不会了 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include&lt;bits/stdc++.h&gt;#define fo(i,a,b) for(int i=a;i&lt;=b;i++)using namespace std;typedef long long LL;typedef unsigned long long ULL;const int maxw=130;struct P&#123; ULL a[maxw]; LL k;&#125; zero,re;LL n;ULL C[70][70];void C_Pre(int n)&#123; fo(i,0,n) &#123; C[i][0]=1; fo(j,1,i) C[i][j]=C[i-1][j-1]+C[i-1][j]; &#125;&#125;P mul1(const P &amp;x,P y)&#123; fo(i,0,63) &#123; ULL kpow=x.k; for(int j=i-1; j&gt;=0; j--, kpow*=x.k) y.a[j]+=C[i][i-j]*kpow*y.a[i]; &#125; re.k=x.k+y.k; fo(i,0,63) re.a[i]=0; fo(i,0,63) fo(j,0,63) re.a[i+j]+=x.a[i]*y.a[j]; return re;&#125;P mul2(const P &amp;x,const P &amp;y)&#123; fo(i,0,63) re.a[i]=0; fo(i,0,63) fo(j,0,63) re.a[i+j]+=x.a[i]*y.a[j]; return re;&#125;P fac(LL n)&#123; P re=zero, x=zero; re.a[0]=1, x.k=1, x.a[0]=1, x.a[1]=2; for(n=(n+1)&gt;&gt;1; n; n&gt;&gt;=1, x=mul1(x,x)) if (n&amp;1) re=mul1(re,x); return re;&#125;P dfs(LL n)&#123; if (n&lt;=2) &#123; re=zero; re.a[0]=1; return re; &#125; return (n&amp;1) ?mul2(dfs(n-(n&gt;&gt;1)),fac(n)) :mul2(dfs(n&gt;&gt;1),fac(n-1)) ;&#125;int main()&#123; C_Pre(65); scanf(&quot;%lld&quot;,&amp;n); P ans=dfs(n); printf(&quot;%llu\\n&quot;,ans.a[0]);&#125;","categories":[{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[{"name":"算法_多项式/生成函数","slug":"算法-多项式-生成函数","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E5%A4%9A%E9%A1%B9%E5%BC%8F-%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/"}]},{"title":"【Petrozavodsk WC 2018d2 ITMO U 1 Contest I】Is It a p-drome? 题解","slug":"【Petrozavodsk WC 2018d2 ITMO U 1 Contest I】Is It a p-drome! 题解","date":"2019-09-24T15:16:51.000Z","updated":"2024-04-24T03:59:22.863Z","comments":true,"path":"【Petrozavodsk WC 2018d2 ITMO U 1 Contest I】Is It a p-drome! 题解/","link":"","permalink":"http://kqp.world/%E3%80%90Petrozavodsk%20WC%202018d2%20ITMO%20U%201%20Contest%20I%E3%80%91Is%20It%20a%20p-drome!%20%E9%A2%98%E8%A7%A3/","excerpt":"题目大意&emsp;&emsp;给定一个长度为 $n$ 的排列 $p_1\\cdots p_n$，以及一个长度为 $m$ 的数组 $s[1..m]$。&emsp;&emsp;对于长度为 $n$ 的数组 $t$，如果满足 $\\forall i \\in [1,n],t_i=t_{p_i}$，则称 $t$ 是 p-drome。&emsp;&emsp;求 $s$ 每个长度为 $n$ 的子串是不是 p-drome。 &emsp;&emsp;$1 \\leq n \\leq m \\leq 5 \\times 10^5,~1 \\leq s_i \\leq 5 \\times 10^5$&emsp;&emsp;6s","text":"题目大意&emsp;&emsp;给定一个长度为 $n$ 的排列 $p_1\\cdots p_n$，以及一个长度为 $m$ 的数组 $s[1..m]$。&emsp;&emsp;对于长度为 $n$ 的数组 $t$，如果满足 $\\forall i \\in [1,n],t_i=t_{p_i}$，则称 $t$ 是 p-drome。&emsp;&emsp;求 $s$ 每个长度为 $n$ 的子串是不是 p-drome。 &emsp;&emsp;$1 \\leq n \\leq m \\leq 5 \\times 10^5,~1 \\leq s_i \\leq 5 \\times 10^5$&emsp;&emsp;6s \\\\ \\\\ \\\\这真是个有趣的题目 题解&emsp;&emsp;$t_i=t_{p_i}$ 不好判断，用 $t_i \\cdot y + t_{p_i} \\cdot (-y) =0$ 来代替。 &emsp;&emsp;于是我们弄一个 $a$ 数组，初始全 $0$，对于每个 $i \\in [1,n]$，随机一个 $y_i$，给 $a_i$ 加上 $y_i$，给 $a_{p_i}$ 减去 $y_i$。&emsp;&emsp;那么如果 $\\sum_{i=1}^n t_ia_i=0$，那就代表这个子串合法了。 &emsp;&emsp;然后你发现这其实是个卷积。&emsp;&emsp;读入的 $s$ 数组反序，跟 $a$ 做 NTT，把所有结果为 $0$ 的位标出来就行了。 代码// 来自队友123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;bits/stdc++.h&gt;#define rep(i,l,r) for (int i=l;i&lt;=r;i++)using namespace std;const int N=1048576,K=19;int n,m,c,a[N+10],b[N+10],A[N+10],B[N+10];int P=998244353,G=3,g[K+10],ng[K+10],inv[N+10],inv2;int Pow(int x,int y)&#123; int ans=1; while (y)&#123; if (y&amp;1) ans=1ll*ans*x%P; x=1ll*x*x%P; y&gt;&gt;=1; &#125; return ans;&#125;void NTT(int a[],int n,int t)&#123; for (int i=1,j=0;i&lt;n-1;i++)&#123; for (int s=n;j^=s&gt;&gt;=1,~j&amp;s;); if (i&lt;j) swap(a[i],a[j]); &#125; for (int d=0;(1&lt;&lt;d)&lt;n;d++)&#123; int m=1&lt;&lt;d,m2=m&lt;&lt;1,_w=t==1?g[d]:ng[d]; for (int i=0;i&lt;n;i+=m2) for (int w=1,j=0;j&lt;m;j++)&#123; int &amp;A=a[i+j+m],&amp;B=a[i+j],t=1ll*w*A%P; A=B-t; if (A&lt;0) A+=P; B=B+t; if (B&gt;=P) B-=P; w=1ll*w*_w%P; &#125; &#125; if (t==-1) for (int i=0,j=inv[n];i&lt;n;i++) a[i]=1ll*a[i]*j%P;&#125;int main()&#123; int i; for (g[K]=Pow(G,(P-1)/N),ng[K]=Pow(g[K],P-2),i=K-1;~i;i--)&#123; g[i]=1ll*g[i+1]*g[i+1]%P,ng[i]=1ll*ng[i+1]*ng[i+1]%P; &#125; for (inv[0]=inv[1]=1,i=2;i&lt;=N;i++) inv[i]=1ll*(P-inv[P%i])*(P/i)%P;inv2=inv[2]; scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;c); int p1=4999999,now1=1,p2=786433,now2=1,x; rep(i,0,n-1)&#123; now1=1ll*now1*p1%P; now2=1ll*now2*p2%P; scanf(&quot;%d&quot;,&amp;x); x--; a[i]=(a[i]+now1)%P; a[x]=(a[x]+P-now1)%P; A[i]=(A[i]+now2)%P; A[x]=(A[x]+P-now2)%P; &#125; rep(i,0,m-1) scanf(&quot;%d&quot;,&amp;b[i]); reverse(b,b+m); NTT(a,N,1); NTT(b,N,1); NTT(A,N,1); for (int i=0;i&lt;N;i++) &#123; a[i]=1ll*a[i]*b[i]%P; A[i]=1ll*A[i]*b[i]%P; &#125; NTT(a,N,-1); NTT(A,N,-1); for (int i=m-1;i&gt;=n-1;i--) &#123; if (a[i]==0&amp;&amp;A[i]==0) printf(&quot;1&quot;); else printf(&quot;0&quot;); &#125; return 0;&#125;","categories":[{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[{"name":"算法_神奇的脑洞","slug":"算法-神奇的脑洞","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E7%A5%9E%E5%A5%87%E7%9A%84%E8%84%91%E6%B4%9E/"},{"name":"算法_随机大法","slug":"算法-随机大法","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E9%9A%8F%E6%9C%BA%E5%A4%A7%E6%B3%95/"},{"name":"算法_FFT/NTT","slug":"算法-FFT-NTT","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-FFT-NTT/"}]},{"title":"【计蒜之道2019初赛1 BCD】【计蒜客39263】商汤AI园区的n个路口 题解","slug":"【计蒜之道2019初赛1 BCD】【计蒜客39263】商汤AI园区的n个路口 题解","date":"2019-09-19T15:25:04.000Z","updated":"2024-04-24T03:59:22.881Z","comments":true,"path":"【计蒜之道2019初赛1 BCD】【计蒜客39263】商汤AI园区的n个路口 题解/","link":"","permalink":"http://kqp.world/%E3%80%90%E8%AE%A1%E8%92%9C%E4%B9%8B%E9%81%932019%E5%88%9D%E8%B5%9B1%20BCD%E3%80%91%E3%80%90%E8%AE%A1%E8%92%9C%E5%AE%A239263%E3%80%91%E5%95%86%E6%B1%A4AI%E5%9B%AD%E5%8C%BA%E7%9A%84n%E4%B8%AA%E8%B7%AF%E5%8F%A3%20%E9%A2%98%E8%A7%A3/","excerpt":"题目大意&emsp;&emsp;有一棵 $n$ 个点的树，每条边有边权，边权互不相同，范围为 $[1,m]$。&emsp;&emsp;现在你要给每个点定一个点权，点权范围也是 $[1,m]$。&emsp;&emsp;假设一条边连着 $a$ 和 $b$，边权为 $w$，那么点权 $v_a$ 和 $v_b$ 要满足 $\\gcd(v_a,v_b)\\not = w$。&emsp;&emsp;求方案数。 &emsp;&emsp;medium：&emsp;&emsp;$1 \\leq n \\leq m \\leq 1000$&emsp;&emsp;hard：&emsp;&emsp;$1 \\leq n \\leq m \\leq 10^5$","text":"题目大意&emsp;&emsp;有一棵 $n$ 个点的树，每条边有边权，边权互不相同，范围为 $[1,m]$。&emsp;&emsp;现在你要给每个点定一个点权，点权范围也是 $[1,m]$。&emsp;&emsp;假设一条边连着 $a$ 和 $b$，边权为 $w$，那么点权 $v_a$ 和 $v_b$ 要满足 $\\gcd(v_a,v_b)\\not = w$。&emsp;&emsp;求方案数。 &emsp;&emsp;medium：&emsp;&emsp;$1 \\leq n \\leq m \\leq 1000$&emsp;&emsp;hard：&emsp;&emsp;$1 \\leq n \\leq m \\leq 10^5$ \\\\ \\\\ \\\\&emsp;&emsp;这个题挺有趣的。 medium&emsp;&emsp;首先列出一个 dp：设 $f_{i,j}$ 表示第 $i$ 个点，点权为 $j$ 的方案数，记 $s_i=\\sum_{j=1}^m f_{i,j}$，那么转移很简单： \\begin{aligned} f_{i,j}&=\\prod_{son}\\sum_{k=1}^m [\\gcd(j,k)\\not=w]f_{son,k} \\\\ &=\\prod_{son}(s_{son}-\\sum_{k=1}^m [\\gcd(j,k)=w]f_{son,k}) \\end{aligned}&emsp;&emsp;计算减去 $[\\gcd(j,k)=w]f_{son,k}$ 这一部分的时候，实际上 $j$ 和 $k$ 都是 $w$ 的倍数。由于边权互不相同，因此时间最多为 \\begin{aligned} &\\sum_{w=1}^m \\lfloor \\frac mw \\rfloor^2 \\\\ \\leq &\\bigg(\\sum_{w=1}^m \\lfloor \\frac mw \\rfloor \\bigg)^2 \\\\ \\leq &(m\\ln m)^2 \\end{aligned}&emsp;&emsp;因此总的时间为 $O(nm+m^2\\ln^2 m)$，这就可以过掉 medium 了。 hard&emsp;&emsp;考虑优化这个 dp。可以发现，大部分的 $f_{i,j}$ 都等于 $\\prod_{son}s_{son}$，只有 $m \\ln m$ 个 $f_{i,j}$ 是特殊的。所以只要快速计算出这些特殊位置就行了。&emsp;&emsp;即，对于 $i$ 的儿子 $son$（连过去的边的边权为 $w$），当 $j$ 为 $w$ 的倍数时，快速得到 illegal_j=\\sum_{k=1}^m [\\gcd(j,k)=w]f_{son,k}&emsp;&emsp;莫比乌斯反演一下： \\begin{aligned} &\\sum_{k=1}^m [\\gcd(j,k)=w]f_{son,k} \\\\ =& \\sum_{k=1}^{\\lfloor \\frac mw \\rfloor} [\\gcd(\\frac jw,k)=1] f_{son,kw} \\\\ =& \\sum_{d|\\frac jw} \\mu(d) \\sum_{k=1}^{\\lfloor \\frac{m}{wd} \\rfloor} f_{son,kwd} \\end{aligned}&emsp;&emsp;对于 $son$，枚举 $d$，然后枚举 $k$ 算出 $\\mu(d) \\sum_{k=1}^{\\lfloor \\frac{m}{wd} \\rfloor} f_{son,kwd}$，最后枚举 $j$ 把这个 $d$ 的贡献加到那个 $j$ 里就好了。 &emsp;&emsp;来算一下复杂度。$d$ 的范围是 $[1,\\lfloor \\frac mw \\rfloor]$，在枚举了 $d$ 以后枚举 $k$ 的时间就是 \\sum_{d=1}^{\\lfloor \\frac mw \\rfloor} \\lfloor \\frac{m}{wd} \\rfloor=O(\\frac mw \\ln \\frac mw)&emsp;&emsp;枚举 $j$ 同理，算上全部的 $w$ 的话就是 \\begin{aligned} &\\sum_{w=1}^m O(\\frac mw \\ln \\frac mw) \\\\ =& O(\\ln m) \\cdot \\sum_{w=1}^m O(\\frac mw) \\\\ =& O(\\ln m) \\cdot O(m \\ln m) \\\\ =& O(m \\ln^2 m) \\end{aligned}&emsp;&emsp;因此总时间是 $O(n+m\\ln^2m)$ 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include&lt;bits/stdc++.h&gt;#define fo(i,a,b) for(int i=a;i&lt;=b;i++)using namespace std;typedef long long LL;const int maxn=1e5+5;const LL mo=1e9+7;int n,m;int p0,p[maxn],mu[maxn];bool bz[maxn];void Pre(int n)&#123; mu[1]=1; fo(i,2,n) &#123; if (!bz[i]) p[++p0]=i, mu[i]=-1; fo(j,1,p0) &#123; if ((LL)i*p[j]&gt;n) break; bz[i*p[j]]=1; if (i%p[j]==0) break; else mu[i*p[j]]=-mu[i]; &#125; &#125;&#125;int tot,go[2*maxn],val[2*maxn],nxt[2*maxn],f1[maxn];void ins(int x,int y,int z)&#123; go[++tot]=y; val[tot]=z; nxt[tot]=f1[x]; f1[x]=tot;&#125;LL mi(LL x,LL y)&#123; LL re=1; for(; y; y&gt;&gt;=1, x=x*x%mo) if (y&amp;1) re=re*x%mo; return re;&#125;map&lt;int,LL&gt; f[maxn];LL s[maxn],ilg[maxn];LL findF(int k,int j) &#123; return (f[k].count(j)) ?f[k][j] :f[k][0] ; &#125;void dfs(int k,int last)&#123; LL pro=1; for(int p=f1[k]; p; p=nxt[p]) if (go[p]!=last) &#123; dfs(go[p],k); (pro*=s[go[p]])%=mo; for(int d=val[p], di=1; d&lt;=m; d+=val[p], di++) &#123; LL sum=0; for(int y=d; y&lt;=m; y+=d) (sum+=mu[di]*findF(go[p],y))%=mo; for(int x=d; x&lt;=m; x+=d) (ilg[x/val[p]]+=sum)%=mo; &#125; LL ny=mi(s[go[p]],mo-2); for(int j=val[p]; j&lt;=m; j+=val[p]) if (f[k].count(j)) (f[k][j]*=(s[go[p]]-ilg[j/val[p]])*ny%mo)%=mo; else f[k][j]=(s[go[p]]-ilg[j/val[p]])*ny%mo; fo(j,1,m/val[p]) ilg[j]=0; &#125; s[k]=pro*m%mo; for(auto p:f[k]) &#123; int j=p.first; (f[k][j]*=pro)%=mo; s[k]=(s[k]-pro+f[k][j])%mo; &#125; f[k][0]=pro;&#125;int main()&#123; Pre(maxn-5); scanf(&quot;%d %d&quot;,&amp;n,&amp;m); fo(i,1,n-1) &#123; int x,y,w; scanf(&quot;%d %d %d&quot;,&amp;x,&amp;y,&amp;w); ins(x,y,w), ins(y,x,w); &#125; dfs(1,0); printf(&quot;%lld\\n&quot;,(s[1]+mo)%mo);&#125;","categories":[{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[{"name":"算法_数论","slug":"算法-数论","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E6%95%B0%E8%AE%BA/"},{"name":"算法_DP","slug":"算法-DP","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-DP/"}]},{"title":"【AtCoder Grand 035D】Add and Remove 题解","slug":"【AtCoder Grand 035D】Add and Remove 题解","date":"2019-09-18T15:37:14.000Z","updated":"2024-04-24T03:59:22.826Z","comments":true,"path":"【AtCoder Grand 035D】Add and Remove 题解/","link":"","permalink":"http://kqp.world/%E3%80%90AtCoder%20Grand%20035D%E3%80%91Add%20and%20Remove%20%E9%A2%98%E8%A7%A3/","excerpt":"题目大意&emsp;&emsp;有 $n$ 张牌，写有数字 $a_1,\\cdots,a_n$。&emsp;&emsp;每一轮操作，选择连续的三张牌，吃掉中间那张，然后把中间那张的数字加到其余两张上。&emsp;&emsp;直到只剩两张牌为止。&emsp;&emsp;目标是使得最后剩下的两张牌的数字和最小，输出最小的和。 &emsp;&emsp;$2 \\leq n \\leq 18,~0 \\leq a_i \\leq 10^9$&emsp;&emsp;时限 2s","text":"题目大意&emsp;&emsp;有 $n$ 张牌，写有数字 $a_1,\\cdots,a_n$。&emsp;&emsp;每一轮操作，选择连续的三张牌，吃掉中间那张，然后把中间那张的数字加到其余两张上。&emsp;&emsp;直到只剩两张牌为止。&emsp;&emsp;目标是使得最后剩下的两张牌的数字和最小，输出最小的和。 &emsp;&emsp;$2 \\leq n \\leq 18,~0 \\leq a_i \\leq 10^9$&emsp;&emsp;时限 2s \\\\ \\\\ \\\\题解&emsp;&emsp;最近 atcoder 的模型怎么都这么。。。 &emsp;&emsp;要考虑每张牌的贡献，实际上就是想要知道每张牌被算了多少次。 &emsp;&emsp;然后发现算这个贼麻烦，它对左右都有贡献，还跟顺序有关。。。 &emsp;&emsp;所以题解又给了个好办法。 &emsp;&emsp;一开始，最左和最右这两张牌都是贡献 $1$ 次的。&emsp;&emsp;对于当前区间 $[l,r]$，枚举最后被吃掉的是哪张牌，假设是 $i$，那么 $i$ 这张牌的贡献次数就是 $l$ 的次数加上 $r$ 的次数。&emsp;&emsp;设 $f_{l,r,x,y}$ 表示当前 $[l,r]$ 这个区间，$l$ 被贡献了 $x$ 次，$r$ 被贡献了 $y$ 次，所能达到的最小代价和。于是就枚举 $i$ 然后 dp 下去了。 &emsp;&emsp;分析一波复杂度。首先是状态数，$l,r$ 总共是 $O(n^2)$，至于 $x,y$，它与 dp 时选择哪个 $i$ 无关，每往下走一层会产生两种新的状态，因此总量是 $O(2^n)$ 的。因此状态数是 $O(2^nn^2)$ 的，加上转移后时间就是 $O(2^nn^3)$ 跑不满。 &emsp;&emsp;用记忆化搜索实现，代码贼短。 代码123456789101112131415161718192021222324252627282930#include&lt;bits/stdc++.h&gt;#define fo(i,a,b) for(int i=a;i&lt;=b;i++)using namespace std;typedef long long LL;typedef pair&lt;pair&lt;int,int&gt;,pair&lt;LL,LL&gt;&gt; pr;const int maxn=20;int n;LL a[maxn];map&lt;pr,LL&gt; f;LL dfs(int l,int r,LL x,LL y)&#123; if (l+1&gt;=r) return 0; pr now=make_pair(make_pair(l,r),make_pair(x,y)); if (f.count(now)) return f[now]; LL re=5e18; fo(i,l+1,r-1) re=min(re,dfs(l,i,x,x+y)+dfs(i,r,x+y,y)+a[i]*(x+y)); return f[now]=re;&#125;int main()&#123; scanf(&quot;%d&quot;,&amp;n); fo(i,1,n) scanf(&quot;%lld&quot;,&amp;a[i]); printf(&quot;%lld\\n&quot;,dfs(1,n,1,1)+a[1]+a[n]);&#125;","categories":[{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[{"name":"算法_神奇的脑洞","slug":"算法-神奇的脑洞","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E7%A5%9E%E5%A5%87%E7%9A%84%E8%84%91%E6%B4%9E/"},{"name":"算法_DP","slug":"算法-DP","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-DP/"}]},{"title":"【CF1214G】Feeling Good 题解","slug":"【CF1214G】Feeling Good 题解","date":"2019-09-13T03:03:30.000Z","updated":"2024-04-24T03:59:22.835Z","comments":true,"path":"【CF1214G】Feeling Good 题解/","link":"","permalink":"http://kqp.world/%E3%80%90CF1214G%E3%80%91Feeling%20Good%20%E9%A2%98%E8%A7%A3/","excerpt":"题目大意&emsp;&emsp;有一个 $n\\times m$ 的黑白棋盘，初始时候每个格子都是白色。&emsp;&emsp;接下来 $q$ 次操作，每次把第 $a_i$ 行的 $[l_i,r_i]$ 这个区间反色。&emsp;&emsp;每次操作结束就会问你，是否存在 $x_1,y_1,x_2,y_2$，满足 $1 \\leq x_1 &lt; x_2 \\leq n$ $1 \\leq y_1 &lt; y_2 \\leq m$ $(x_1,y_1)$ 与 $(x_2,y_2)$ 同色 $(x_1,y_2)$ 与 $(x_2,y_1)$ 同色 $(x_1,y_1)$ 与 $(x_2,y_1)$ 异色（即：对于矩形的四个角，对角同色，同侧异色） &emsp;&emsp;若存在，则输出其中一组解。 &emsp;&emsp;$n,m \\leq 2000,~q \\leq 5\\times 10^5$","text":"题目大意&emsp;&emsp;有一个 $n\\times m$ 的黑白棋盘，初始时候每个格子都是白色。&emsp;&emsp;接下来 $q$ 次操作，每次把第 $a_i$ 行的 $[l_i,r_i]$ 这个区间反色。&emsp;&emsp;每次操作结束就会问你，是否存在 $x_1,y_1,x_2,y_2$，满足 $1 \\leq x_1 &lt; x_2 \\leq n$ $1 \\leq y_1 &lt; y_2 \\leq m$ $(x_1,y_1)$ 与 $(x_2,y_2)$ 同色 $(x_1,y_2)$ 与 $(x_2,y_1)$ 同色 $(x_1,y_1)$ 与 $(x_2,y_1)$ 异色（即：对于矩形的四个角，对角同色，同侧异色） &emsp;&emsp;若存在，则输出其中一组解。 &emsp;&emsp;$n,m \\leq 2000,~q \\leq 5\\times 10^5$ \\\\ \\\\ \\\\题解&emsp;&emsp;为什么我想到每一列建一个 bitset 然后搞不出来，结果最后是每一行建一个 bitset 就特 tm 方便 &emsp;&emsp;给每一行维护一个 bitset，表示这一行的染色情况。&emsp;&emsp;维护很好维护，每次就第 $a_i$ 行异或一段全 $1$ 的东西就好了。 &emsp;&emsp;然后看怎么找答案。如果某两行的 bitset 不是互相包含的关系（假设是第 $x_1$ 行和第 $x_2$ 行），那么存在 $y_1$，它在 $x_1$ 那里为 $1$ 而在 $x_2$ 那里为 $0$，也存在 $y_2$，它在 $x_1$ 那里为 $0$ 而在 $x_2$ 那里为 $1$。那这个 $(x_1,y_1,x_2,y_2)$ 就是答案。 &emsp;&emsp;所以现在是要判断是否存在两行，它们不是互相包含的关系。然后题解给了一个很 nice 的方法，把所有的 bitset 按 size 排序，那么只需判断相邻的是否全都是包含关系即可。若相邻的全是包含关系，则任选两个都是包含关系（因为这形成了一条链），就会无解，否则把不是包含关系的那个相邻对拿出来算答案就行了。&emsp;&emsp;这个就用两个 set 维护一下，一个维护排序的 bitset，一个维护答案。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include&lt;bits/stdc++.h&gt;#define fo(i,a,b) for(int i=a;i&lt;=b;i++)using namespace std;const int maxn=2005;struct BST&#123; int i,cnt;&#125;;bool operator &lt; (const BST &amp;a,const BST &amp;b) &#123;return a.cnt&lt;b.cnt || a.cnt==b.cnt &amp;&amp; a.i&lt;b.i;&#125;int n,m,q;bitset&lt;maxn&gt; B[maxn],flp[maxn];set&lt;BST&gt; S;set&lt;pair&lt;int,int&gt;&gt; Ans;bitset&lt;maxn&gt; common;bool cmp(int x,int y)&#123; common=B[x]&amp;B[y]; return (common!=B[x] &amp;&amp; common!=B[y]);&#125;void modify(int i,int cnt,int ty)&#123; set&lt;BST&gt;::iterator it=S.find((BST)&#123;i,cnt&#125;), mae, tsugi=it; // 最近好像学日语学疯了 tsugi++; if (it!=S.begin()) &#123; mae=it; mae--; int x=mae-&gt;i, y=it-&gt;i; if (ty==-1) Ans.erase(make_pair(x,y)); else if (cmp(x,y)) Ans.insert(make_pair(x,y)); &#125; if (tsugi!=S.end()) &#123; int x=it-&gt;i, y=tsugi-&gt;i; if (ty==-1) Ans.erase(make_pair(x,y)); else if (cmp(x,y)) Ans.insert(make_pair(x,y)); &#125; if (it!=S.begin() &amp;&amp; tsugi!=S.end()) &#123; int x=mae-&gt;i, y=tsugi-&gt;i; if (ty==1) Ans.erase(make_pair(x,y)); else if (cmp(x,y)) Ans.insert(make_pair(x,y)); &#125;&#125;bitset&lt;maxn&gt; b1,b2;int main()&#123; scanf(&quot;%d %d %d&quot;,&amp;n,&amp;m,&amp;q); fo(i,1,n) S.insert((BST)&#123;i,0&#125;); fo(i,1,m) flp[i]=flp[i-1], flp[i][i]=1; while (q--) &#123; int a,l,r; scanf(&quot;%d %d %d&quot;,&amp;a,&amp;l,&amp;r); int cnt=B[a].count(); modify(a,cnt,-1); S.erase((BST)&#123;a,cnt&#125;); B[a]^=((flp[r]&gt;&gt;l)&lt;&lt;l); cnt=B[a].count(); S.insert((BST)&#123;a,cnt&#125;); modify(a,cnt,1); if (Ans.empty()) puts(&quot;-1&quot;); else &#123; set&lt;pair&lt;int,int&gt;&gt;::iterator it=Ans.begin(); int x1=it-&gt;first, x2=it-&gt;second; common=B[x1]&amp;B[x2]; b1=B[x1]^common, b2=B[x2]^common; int y1=b1._Find_first(), y2=b2._Find_first(); if (x1&gt;x2) swap(x1,x2); if (y1&gt;y2) swap(y1,y2); printf(&quot;%d %d %d %d\\n&quot;,x1,y1,x2,y2); &#125; &#125;&#125;","categories":[{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[{"name":"算法_位运算","slug":"算法-位运算","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/"}]},{"title":"【2019 Multi-University 9 K】Rikka with Segment Tree 题解","slug":"【2019 Multi-University 9 K】Rikka with Segment Tree 题解","date":"2019-08-23T03:11:16.000Z","updated":"2024-04-24T03:59:22.810Z","comments":true,"path":"【2019 Multi-University 9 K】Rikka with Segment Tree 题解/","link":"","permalink":"http://kqp.world/%E3%80%902019%20Multi-University%209%20K%E3%80%91Rikka%20with%20Segment%20Tree%20%E9%A2%98%E8%A7%A3/","excerpt":"题目大意&emsp;&emsp;规定线段树上 $[l,r]$ 这个区间往下分会分到 $[l,\\lfloor \\frac{l+r}2 \\rfloor]$、$[\\lfloor \\frac{l+r}2 \\rfloor+1,r]$，直到区间长度为 $1$ 为止。&emsp;&emsp;设 $f(i,n)$ 为 $[i,i]$ 这个区间在有 $n$ 个叶子的线段树上的深度（根节点深度为 $1$），求： \\sum_{n=L}^R \\sum_{i=1}^n f(i,n) \\times i&emsp;&emsp;$L,R \\leq 5 \\times 10^{17}$","text":"题目大意&emsp;&emsp;规定线段树上 $[l,r]$ 这个区间往下分会分到 $[l,\\lfloor \\frac{l+r}2 \\rfloor]$、$[\\lfloor \\frac{l+r}2 \\rfloor+1,r]$，直到区间长度为 $1$ 为止。&emsp;&emsp;设 $f(i,n)$ 为 $[i,i]$ 这个区间在有 $n$ 个叶子的线段树上的深度（根节点深度为 $1$），求： \\sum_{n=L}^R \\sum_{i=1}^n f(i,n) \\times i&emsp;&emsp;$L,R \\leq 5 \\times 10^{17}$ \\\\ \\\\ \\\\题解&emsp;&emsp;设 $f_n$ 表示有 $n$ 个叶子的线段树的叶子深度和，$g_n$ 表示 叶子深度乘叶子 id 的和，$h_n$ 表示 叶子深度乘 $n$ 的和，设 $F_n$、$G_n$、$H_n$ 分别为它们的前缀和。 &emsp;&emsp;答案就是 $G_R-G_{L-1}$，$F$ 和 $H$ 算是辅助函数。 &emsp;&emsp;考虑怎么递推求 $F_n$，这里一共是 $n$ 棵线段树，每一棵都分一半，分成这样： \\begin{aligned} [1,1]&:~~[1,1] \\\\ [1,2]&:~~[1,1]+[2,2] \\\\ [1,3]&:~~[1,2]+[3,3] \\\\ [1,4]&:~~[1,2]+[3,4] \\\\ [1,5]&:~~[1,3]+[4,5] \\\\ [1,6]&:~~[1,3]+[4,6] \\\\ [1,7]&:~~[1,4]+[5,7] \\\\ &\\vdots \\end{aligned}&emsp;&emsp;这是 $n$ 为奇数的情况，可以发现，左边分为了两组前缀和：$F_{\\lfloor \\frac n2 \\rfloor}$ 和 $F_{\\lceil \\frac n2 \\rceil}$（偶数下标对应第一组，奇数下标对应第二组，每一组的区间长度恰好是 $1,2,3,\\cdots$，所以是分成两组前缀和），右边也分为了两组前缀和：都是 $F_{\\lfloor \\frac n2 \\rfloor}$（偶数下标对应第一组，奇数下标对应第二组）。&emsp;&emsp;然后还要考虑左右子树拼起来之后，除第一棵树外所有叶子的深度都加了 $1$，因此 $n$ 棵树增加的深度和就是 $2+3+\\cdots+n=\\frac{n(n+1)}{2}-1$。&emsp;&emsp;因此 $n$ 为奇数时的 $F$ 的递推式出来了： F_n=3 \\cdot F_{\\lfloor \\frac n2 \\rfloor}+F_{\\lceil \\frac n2 \\rceil}+\\frac{n(n+1)}{2}-1~~~~~~,n~is~odd&emsp;&emsp;$n$ 为偶数是类似的，左边分成的两组都是 $F_{\\frac n2}$，右边的两组分别为 $F_{\\frac n2}$ 和 $F_{\\frac n2 -1}$： F_n=3 \\cdot F_{\\frac n2}+F_{\\frac n2 -1}+\\frac{n(n+1)}{2}-1~~~~~~,n~is~even&emsp;&emsp;接下来推 $H_n$，也是同样的思路，左边右边各分成两组。以 $n$ 为奇数时左边两组为例，因为 $h_i=\\sum deep_x \\cdot i$，先考虑把 $i$ 变对，那么其中一组是要把 $i$ 变成 $2i-1$，另一组要把 $i$ 变成 $2i$，因此对应的分别是 $2H_{\\lceil \\frac n2 \\rceil}-F_{\\lceil \\frac n2 \\rceil}$ 和 $2H_{\\lfloor \\frac n2 \\rfloor}$。&emsp;&emsp;然后考虑左右子树拼起来后增加的深度的贡献，区间长度为 $i$ 的树有 $i$ 个叶子，每个叶子贡献增加 $i$，那么是 $2^2+3^2+4^2+\\cdots+n^2=\\frac{n(n+1)(2n+1)}6-1$。&emsp;&emsp;因此递推式为： H_n=(2H_{\\lceil \\frac n2 \\rceil}-F_{\\lceil \\frac n2 \\rceil})+(2H_{\\lfloor \\frac n2 \\rfloor})+(2H_{\\lfloor \\frac n2 \\rfloor}+F_{\\lfloor \\frac n2 \\rfloor})+(2H_{\\lfloor \\frac n2 \\rfloor})+\\frac{n(n+1)(2n+1)}6-1~~~~~~,n~is~odd \\\\&emsp;&emsp;偶数就不写了。 &emsp;&emsp;接下来推 $G_N$，还是一样的，要考虑的就是右子树的起始下标被左子树抬上去了，所以这部分是用 $H$ 函数来做贡献： G_n=G_{\\lceil \\frac n2 \\rceil}+G_{\\lfloor \\frac n2 \\rfloor}+(G_{\\lfloor \\frac n2 \\rfloor}+H_{\\lfloor \\frac n2 \\rfloor})+(G_{\\lfloor \\frac n2 \\rfloor}+H_{\\lfloor \\frac n2 \\rfloor}+F_{\\lfloor \\frac n2 \\rfloor})+\\sum_{i=2}^n \\frac{i(i+1)}{2}~~~~~~,n~is~odd&emsp;&emsp;偶数就不写了。 &emsp;&emsp;最后来分析时间复杂度，$n$ 为奇数时递归到 $\\lceil \\frac n2 \\rceil$ 和 $\\lfloor \\frac n2 \\rfloor$，$n$ 为偶数时递归到 $\\frac n2$ 和 $\\frac n2 -1$，可以观察到，每往下走一层都是一段连续的区间，比如 $n=32$，往下走到 $15$ 和 $16$，再往下走到 $7,8,9$，再往下走到 $3,4,5$……&emsp;&emsp;因为同一层相邻的两个数，往下走是会交的，因此每一层最多比上一层多一个数，因此总量是 $O(\\log^2 n)$ 的。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include&lt;bits/stdc++.h&gt;#define fo(i,a,b) for(int i=a;i&lt;=b;i++)using namespace std;typedef long long LL;const LL mo=998244353;LL L,R,inv2,inv6;LL mi(LL x,LL y)&#123; LL re=1; for(; y; y&gt;&gt;=1, x=x*x%mo) if (y&amp;1) re=re*x%mo; return re;&#125;map&lt;LL,LL&gt; f,g,h; // f = sum of deep, g = sum of deep*id, h = sum of deep*nLL sum(LL n) // 1+2+3+..+n&#123; n%=mo; return n*(n+1)%mo*inv2%mo;&#125;LL sum2(LL n) // 1+4+9+...+n^2&#123; n%=mo; return n*(n+1)%mo*(2*n+1)%mo*inv6%mo;&#125;LL sums(LL n) // 1+3+6+10+...+n(n+1)/2&#123; return (sum2(n)+sum(n))%mo*inv2%mo;&#125;void dfs(LL n)&#123; if (f.count(n)) return; if (n&lt;=1) &#123; f[n]=g[n]=h[n]=n; return; &#125; if (n&amp;1) &#123; LL l=(n+1)&gt;&gt;1, r=n&gt;&gt;1; dfs(l), dfs(r); f[n]=(f[l]+f[r]*3+sum(n)-1+mo)%mo; g[n]=(g[l]+g[r]+(g[r]+h[r])+(g[r]+h[r]+f[r])+mo+sums(n)-1+mo)%mo; h[n]=(h[l]*2-f[l]+h[r]*2+h[r]*2+f[r]+h[r]*2+sum2(n)-1+mo)%mo; &#125; else &#123; LL l=n&gt;&gt;1, r=l-1; dfs(l), dfs(r); f[n]=(f[l]*3+f[r]+sum(n)-1+mo)%mo; g[n]=(g[l]*2+(g[l]+h[l])+(g[r]+h[r]+f[r])+mo+sums(n)-1+mo)%mo; h[n]=(h[l]*2-f[l]+h[l]*2+h[l]*2+h[r]*2+f[r]+sum2(n)-1+mo)%mo; &#125;&#125;LL calc(LL n)&#123; dfs(n); return g[n];&#125;int T;int main()&#123; inv2=mi(2,mo-2); inv6=mi(6,mo-2); scanf(&quot;%d&quot;,&amp;T); while (T--) &#123; scanf(&quot;%lld %lld&quot;,&amp;L,&amp;R); printf(&quot;%lld\\n&quot;,(calc(R)-calc(L-1)+mo*2)%mo); &#125;&#125;","categories":[{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[]},{"title":"【2019GDCPC F】【hdu6537】Neko and function 题解","slug":"【2019GDCPC F】【hdu6537】Neko and function 题解","date":"2019-08-15T12:27:27.000Z","updated":"2024-04-24T03:59:22.811Z","comments":true,"path":"【2019GDCPC F】【hdu6537】Neko and function 题解/","link":"","permalink":"http://kqp.world/%E3%80%902019GDCPC%20F%E3%80%91%E3%80%90hdu6537%E3%80%91Neko%20and%20function%20%E9%A2%98%E8%A7%A3/","excerpt":"题目大意&emsp;&emsp;定义 $f(n,k)$ 为，把 $n$ 表示成 $k$ 个大于 $1$ 的数的积的方案数。&emsp;&emsp;（注意 $6=2 \\times 3$ 和 $6=3 \\times 2$ 是两种不同的方案）&emsp;&emsp;给定 $n$、$k$，求 $\\sum_{i=1}^n f(i,k)$。 &emsp;&emsp;$1 \\leq n \\leq 2^{30},~1 \\leq k \\leq 30$&emsp;&emsp;注意 hdu 上是有多测的但是题目没写","text":"题目大意&emsp;&emsp;定义 $f(n,k)$ 为，把 $n$ 表示成 $k$ 个大于 $1$ 的数的积的方案数。&emsp;&emsp;（注意 $6=2 \\times 3$ 和 $6=3 \\times 2$ 是两种不同的方案）&emsp;&emsp;给定 $n$、$k$，求 $\\sum_{i=1}^n f(i,k)$。 &emsp;&emsp;$1 \\leq n \\leq 2^{30},~1 \\leq k \\leq 30$&emsp;&emsp;注意 hdu 上是有多测的但是题目没写 \\\\ \\\\ \\\\题解&emsp;&emsp;拆成的数必须大于 $1$，这个限制不好做，于是容斥，设 $g(n,k)$ 表示把 $n$ 表示成 $k$ 个数（允许为 $1$）的积的方案数： ans=\\sum_{i=0}^{k-1} (-1)^i \\cdot \\binom{k}{i} \\cdot g(n,k-i)&emsp;&emsp;这个 $g$ 肯定是个积性函数了。 解法1&emsp;&emsp;用递推去考虑，考虑第 $k$ 位放什么： g(n,k)=\\sum_{d|n}g(d,k-1)&emsp;&emsp;即 g(k)=g(k-1)*1&emsp;&emsp;其中 $*$ 表示狄利克雷卷积，$1$ 表示全 $1$ 函数，即 $1(n)=1$。那么有： g(k)*\\mu=g(k-1)&emsp;&emsp;于是就可以愉快地杜教筛啦~ \\\\&emsp;&emsp;然后发现杜教筛好慢，主要是预处理，预处理好写一点就 $O(nk \\log n)$，要快一点可以套线性筛做到 $O(nk)$，总之就是预处理得越多，前面就越慢；预处理得越少，后面就越慢。&emsp;&emsp;我写这个做法 T 了，没去卡常，没去卡预处理，毕竟不是标算没前途~ 解法2&emsp;&emsp;既然 $g$ 都是积性函数了，为什么不大力 min25 一发呢？ &emsp;&emsp;$p$ 为质数时，$g(p,k)=k$，$g(p^c,k)=\\binom{c+k-1}{k-1}$，这就体现出 min25 的优势了，预处理只用进行一次，筛出 $n$ 以内的质数个数就行了。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include&lt;bits/stdc++.h&gt;#define fo(i,a,b) for(int i=a;i&lt;=b;i++)using namespace std;typedef long long LL;const int maxsqrtn=1e6+5, maxk=105;const LL mo=1e9+7;LL n;int sqrtn,k;int p0,p[maxsqrtn],Np[maxsqrtn];bool bz[maxsqrtn];void Pre(int n)&#123; fo(i,2,n) &#123; if (!bz[i]) p[++p0]=i, Np[i]=1; fo(j,1,p0) &#123; if ((LL)i*p[j]&gt;n) break; bz[i*p[j]]=1; if (i%p[j]==0) break; &#125; &#125; fo(i,2,n) Np[i]+=Np[i-1];&#125;LL C[maxk][maxk];void C_Pre(int n)&#123; fo(i,0,n) &#123; C[i][0]=1; fo(j,1,i) C[i][j]=(C[i-1][j-1]+C[i-1][j])%mo; &#125;&#125;LL mw[maxsqrtn],g[maxsqrtn],id1[maxsqrtn],id2[maxsqrtn];int w0;LL min25_g(LL n)&#123; w0=0; for(LL i=1, j; i&lt;=n; i=j+1) &#123; j=n/(n/i); mw[++w0]=n/i; if (mw[w0]&lt;=sqrtn) id1[mw[w0]]=w0; else id2[j]=w0; g[w0]=mw[w0]-1; &#125; fo(j,1,Np[sqrtn]) for(int i=1; i&lt;=w0 &amp;&amp; (LL)p[j]*p[j]&lt;=mw[i]; i++) &#123; int id=(mw[i]/p[j]&lt;=sqrtn) ?id1[mw[i]/p[j]] :id2[n/(mw[i]/p[j])]; (g[i]-=g[id]-(j-1))%=mo; &#125;&#125;LL min25_S(LL x,int j,int k)&#123; if (x&lt;=1 || p[j]&gt;x) return 0; int id=(x&lt;=sqrtn) ?id1[x] :id2[n/x]; LL re=(g[id]-(j-1))*k; for(int i=j; i&lt;=Np[sqrtn] &amp;&amp; (LL)p[i]*p[i]&lt;=x; i++) &#123; LL pe=p[i]; for(int e=1; pe*p[i]&lt;=x; e++, pe*=p[i]) (re+=min25_S(x/pe,i+1,k)*C[e+k-1][k-1]+C[e+k][k-1])%=mo; &#125; return re;&#125;int main()&#123; Pre(maxsqrtn-5); C_Pre(100); while (scanf(&quot;%lld %d&quot;,&amp;n,&amp;k)!=EOF) &#123; sqrtn=sqrt(n); min25_g(n); LL ans=0; for(int i=0, fu1=1; i&lt;k; i++, fu1*=(-1)) (ans+=min25_S(n,1,k-i)*fu1*C[k][i])%=mo; printf(&quot;%lld\\n&quot;,(ans+mo)%mo); &#125;&#125;","categories":[{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[{"name":"算法_数论","slug":"算法-数论","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E6%95%B0%E8%AE%BA/"}]},{"title":"【2019 Multi-University 3 E】Easy Math Problem 题解","slug":"【2019 Multi-University 3 E】Easy Math Problem 题解","date":"2019-08-14T13:43:39.000Z","updated":"2024-04-24T03:59:22.809Z","comments":true,"path":"【2019 Multi-University 3 E】Easy Math Problem 题解/","link":"","permalink":"http://kqp.world/%E3%80%902019%20Multi-University%203%20E%E3%80%91Easy%20Math%20Problem%20%E9%A2%98%E8%A7%A3/","excerpt":"题目大意&emsp;&emsp;求： \\sum_{i=1}^n \\sum_{j=1}^n \\gcd(i,j)^k lcm(i,j) [\\gcd\\ is\\ prime]&emsp;&emsp;$1 \\leq n \\leq 10^{10},~1 \\leq k \\leq 100$&emsp;&emsp;多测，$T \\leq 5$，时限 10s","text":"题目大意&emsp;&emsp;求： \\sum_{i=1}^n \\sum_{j=1}^n \\gcd(i,j)^k lcm(i,j) [\\gcd\\ is\\ prime]&emsp;&emsp;$1 \\leq n \\leq 10^{10},~1 \\leq k \\leq 100$&emsp;&emsp;多测，$T \\leq 5$，时限 10s \\\\ \\\\ \\\\题解 \\sum_{i=1}^n \\sum_{j=1}^n \\gcd(i,j)^k lcm(i,j) ~[\\gcd~is~prime] \\\\ =\\sum_{d=1}^n d^{k+1}[d~is~prime] \\sum_{i'=1}^{\\lfloor \\frac nd \\rfloor} \\sum_{j'=1}^{\\lfloor \\frac nd \\rfloor} i'j'[\\gcd(i,j)=1] \\\\&emsp;&emsp;后面那玩意儿是个经典转换： \\begin{aligned} & \\sum_{i=1}^m \\sum_{j=1}^m ij[\\gcd(i,j)=1] \\\\ =& \\bigg( 2 \\times \\sum_{i=2}^m i \\sum_{j=1}^{i-1} j[\\gcd(i,j)=1] \\bigg) + \\bigg( \\sum_{i=1}^m i^2[\\gcd(i,i)=1] \\bigg)\\\\ =& \\bigg( 2 \\times \\sum_{i=2}^m i \\frac{i \\phi(i)}2 \\bigg) +1 \\\\ =& \\sum_{i=1}^m i^2 \\phi(i) \\end{aligned}&emsp;&emsp;因此原式等于 \\sum_{d=1}^n d^{k+1} [d~is~prime] \\sum_{i=1}^{\\lfloor \\frac nd \\rfloor} i^2 \\phi(i)&emsp;&emsp;于是对 $\\lfloor \\frac nd \\rfloor$ 分块，前面求质数幂和用洲阁筛或 min25，后面求 $\\sum i^2\\phi(i)$ 用杜教筛或 min25。 扯淡&emsp;&emsp;symbol 推法（可参考 WC2016 第二课堂课件）居然不是万能的。。。 \\begin{aligned} &\\sum_{i=1}^n \\sum_{j=1}^n \\gcd(i,j)^k lcm(i,j) ~[\\gcd~is~prime] \\\\ =&\\sum_{d=1}^n d^{k+1}[d~is~prime] \\sum_{i'=1}^{\\lfloor \\frac nd \\rfloor} \\sum_{j'=1}^{\\lfloor \\frac nd \\rfloor} i'j'[\\gcd(i,j)=1] \\\\ =&\\sum_{d=1}^n d^{k+1}[d~is~prime] \\sum_{D=1}^{\\lfloor \\frac nd \\rfloor} \\mu(D)D^2\\frac{(1+\\lfloor \\frac n{dD} \\rfloor)^2 (\\lfloor \\frac n{dD} \\rfloor)^2}4 \\\\ =&\\sum_{T=1}^n \\frac{(1+\\lfloor \\frac nT \\rfloor)^2 (\\lfloor \\frac nT \\rfloor)^2}4 T \\sum_{d|T,~d~is~prime} d^{k-1}\\mu(\\frac Td) \\end{aligned}&emsp;&emsp;以前是觉得，这种变量前移的推法能通杀一切，即便跟标准做法不一样，但最后会推出来相同的东西，或者我这样推也是能做的（甚至更快）。做这题之前，这个想法都是对的。&emsp;&emsp;直到遇见了这题。。。后面那坨居然不能预处理又不能筛？？ 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160#include&lt;bits/stdc++.h&gt;#define fo(i,a,b) for(int i=a;i&lt;=b;i++)using namespace std;typedef long long LL;const int maxsqrtn=2e6+5, maxk=105;const LL mo=1e9+7;LL n;int sqrtn,k;LL mi(LL x,LL y)&#123; LL re=1; for(; y; y&gt;&gt;=1, x=x*x%mo) if (y&amp;1) re=re*x%mo; return re;&#125;LL phi[maxsqrtn],Sp[maxsqrtn],inv[maxsqrtn];int p0,p[maxsqrtn],Np[maxsqrtn];bool bz[maxsqrtn];void Pre(int n)&#123; p0=0; memset(bz,0,sizeof(bz)); memset(Np,0,sizeof(Np)); phi[1]=1; fo(i,2,n) &#123; if (!bz[i]) &#123; p[++p0]=i; phi[i]=i-1; Np[i]=1; Sp[p0]=(Sp[p0-1]+mi(i,k))%mo; &#125; fo(j,1,p0) &#123; if ((LL)i*p[j]&gt;n) break; bz[i*p[j]]=1; if (i%p[j]==0) &#123; phi[i*p[j]]=phi[i]*p[j]; break; &#125; else phi[i*p[j]]=phi[i]*(p[j]-1); &#125; &#125; inv[1]=1; fo(i,2,n) &#123; phi[i]=(phi[i-1]+phi[i]*i%mo*i%mo)%mo; Np[i]+=Np[i-1]; inv[i]=(-(mo/i)*inv[mo%i])%mo; &#125;&#125;LL x[maxk],y[maxk],w[maxk],invw[maxk];void lagrange_add(int n)&#123; fo(i,1,n-1) (w[i]*=(x[i]-x[n]))%=mo; w[n]=1; fo(i,1,n-1) (w[n]*=(x[n]-x[i]))%=mo;&#125;LL lagrange_get(int n,LL nx)&#123; if (nx&lt;=n) return y[nx]; nx%=mo; LL sum=0, l=1; fo(i,1,n) &#123; (l*=(nx-x[i]))%=mo; (sum+=y[i]*invw[i]%mo*(nx-x[i]&lt;=maxsqrtn-5 ?inv[nx-x[i]] :mi(nx-x[i],mo-2)))%=mo; &#125; return l*sum%mo;&#125;LL mw[maxsqrtn],g[maxsqrtn],id1[maxsqrtn],id2[maxsqrtn];int w0;LL min25_g(LL n)&#123; w0=0; for(LL i=1, j; i&lt;=n; i=j+1) &#123; j=n/(n/i); mw[++w0]=n/i; if (mw[w0]&lt;=sqrtn) id1[mw[w0]]=w0; else id2[j]=w0; g[w0]=lagrange_get(k+2,mw[w0])-1; &#125; fo(j,1,Np[sqrtn]) for(int i=1; i&lt;=w0 &amp;&amp; (LL)p[j]*p[j]&lt;=mw[i]; i++) &#123; int id=(mw[i]/p[j]&lt;=sqrtn) ?id1[mw[i]/p[j]] :id2[n/(mw[i]/p[j])]; (g[i]-=(Sp[j]-Sp[j-1])*(g[id]-Sp[j-1]))%=mo; &#125;&#125;unordered_map&lt;LL,LL&gt; f;LL inv2,inv6;LL sum(LL n,int id)&#123; n%=mo; if (id==2) return n*(n+1)%mo*inv6%mo*(2*n+1)%mo; else if (id==3) &#123; LL t=n*(n+1)%mo*inv2%mo; return t*t%mo; &#125;&#125;LL Sphi(LL x,int id)&#123; if (x&lt;=maxsqrtn-5) return phi[x]; if (f.count(x)) return f[x]; LL re=sum(x,id+1); for(LL i=2, j; i&lt;=x; i=j+1) &#123; j=x/(x/i); (re-=(sum(j,id)-sum(i-1,id)+mo)%mo*Sphi(x/i,id)%mo)%=mo; &#125; (re+=mo)%=mo; return f[x]=re;&#125;int T;int main()&#123; inv2=mi(2,mo-2); inv6=mi(6,mo-2); scanf(&quot;%d&quot;,&amp;T); while (T--) &#123; scanf(&quot;%lld %d&quot;,&amp;n,&amp;k); k++; sqrtn=sqrt(n); Pre(maxsqrtn-5); fo(i,1,k+2) &#123; x[i]=i, y[i]=(y[i-1]+mi(i,k))%mo; lagrange_add(i); &#125; fo(i,1,k+2) invw[i]=mi(w[i],mo-2); min25_g(n); LL ans=0; for(LL i=1, j; i&lt;=n; i=j+1) &#123; j=n/(n/i); int idi=((i-1)&lt;=sqrtn) ?id1[(i-1)] :id2[n/(i-1)] ; int idj=(j&lt;=sqrtn) ?id1[j] :id2[n/j] ; (ans+=(g[idj]-g[idi]+mo)%mo*Sphi(n/i,2))%=mo; &#125; printf(&quot;%lld\\n&quot;,(ans+mo)%mo); &#125;&#125;","categories":[{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[{"name":"算法_数论","slug":"算法-数论","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E6%95%B0%E8%AE%BA/"}]},{"title":"【2019 Multi-University 1 L】Sequence 题解","slug":"【2019 Multi-University 1 L】Sequence 题解","date":"2019-07-26T12:40:14.000Z","updated":"2024-04-24T03:59:22.808Z","comments":true,"path":"【2019 Multi-University 1 L】Sequence 题解/","link":"","permalink":"http://kqp.world/%E3%80%902019%20Multi-University%201%20L%E3%80%91Sequence%20%E9%A2%98%E8%A7%A3/","excerpt":"题目大意&emsp;&emsp;有一个长度为 $n$ 的数列 $a_1$~$a_n$，进行 $m$ 次操作，每次操作给定一个整数 $k$（$1 \\leq k \\leq 3$），将 $a$ 数列变成 $b$ 数列： b_i=\\sum_{1 \\leq i-kj \\leq i} a_{i-kj}&emsp;&emsp;求最终的数列。 &emsp;&emsp;$1 \\leq n \\leq 10^5,\\ \\ 1 \\leq m \\leq 10^6,\\ \\ 1 \\leq a_i \\leq 10^9$","text":"题目大意&emsp;&emsp;有一个长度为 $n$ 的数列 $a_1$~$a_n$，进行 $m$ 次操作，每次操作给定一个整数 $k$（$1 \\leq k \\leq 3$），将 $a$ 数列变成 $b$ 数列： b_i=\\sum_{1 \\leq i-kj \\leq i} a_{i-kj}&emsp;&emsp;求最终的数列。 &emsp;&emsp;$1 \\leq n \\leq 10^5,\\ \\ 1 \\leq m \\leq 10^6,\\ \\ 1 \\leq a_i \\leq 10^9$ \\\\ \\\\ \\\\题解&emsp;&emsp;您好，您的多项式能力为 0，请做题 &emsp;&emsp;先是有一个经典的转换：设 $a$ 数列的生成函数为 $A=\\sum a_ix^i$，考虑 $a$ 数列经过一次 $k$ 操作变成 $b$ 数列，那么它们的生成函数是这样的： B=\\sum b_ix^i=(\\sum a_ix^i)(\\sum x^{ik})=A\\sum x^{ik}&emsp;&emsp;一次操作相当于给 $A$ 乘一个多项式，那么操作顺序是不要紧的，因此三种操作分别对应三个多项式：$(\\sum x^i)^{m_1}$、$(\\sum x^{2i})^{m_2}$、$(\\sum x^{3i})^{m_3}$。&emsp;&emsp;然后这三个多项式都可以先算出来（系数都是组合数），那么对于原序列就是 3 次 NTT 的事儿。 &emsp;&emsp;时间 $O(n \\log n)$","categories":[{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[{"name":"算法_多项式/生成函数","slug":"算法-多项式-生成函数","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E5%A4%9A%E9%A1%B9%E5%BC%8F-%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/"},{"name":"算法_FFT/NTT","slug":"算法-FFT-NTT","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-FFT-NTT/"}]},{"title":"新的开始","slug":"New_Starting","date":"2019-07-25T08:27:46.000Z","updated":"2024-04-24T03:59:22.783Z","comments":true,"path":"New_Starting/","link":"","permalink":"http://kqp.world/New_Starting/","excerpt":"&emsp;&emsp;不知不觉大一就过完了。这一年混杂着学习、acm，好多感想。&emsp;&emsp;想想还是觉得要简单写写吧。","text":"&emsp;&emsp;不知不觉大一就过完了。这一年混杂着学习、acm，好多感想。&emsp;&emsp;想想还是觉得要简单写写吧。 新的队伍&emsp;&emsp;去年北京赛区结束，我们莫得出线，SYSU_Ass♂We♂Can 这支队就 end 了。当时计划再来一年，用一年的时间潜心修炼，大二打完退役。fanvree：你怎么还在沉迷竞赛，赶紧给我学文化课准备考研找导师进实验室去 &emsp;&emsp;闲来无事拉了两个人打毛营选拔赛，结果没进。回去肝期末考了。&emsp;&emsp;过了一段时间，郭老突然说，你跟 Dama、ctlchild 组一支队去毛营。&emsp;&emsp;我：？？？ &emsp;&emsp;于是就有了一支新的队伍——沈阳亚军选手 Dama，NanoApe 的好基友 ctlchild，菜鸡 kqp。&emsp;&emsp;ctlchild 是个杏树病患，于是我们队就有两个拉拉人了，队名就选自 LLSS 第二季最终曲 Wonderful Stories 里的这段：&emsp;&emsp;队名 命运的青鸟 FateBlueBird 是 Fate 的新作呢，队歌 Wonderful Stories，队群头&emsp;&emsp;希望站在颁奖台的时候，心中会响起这首歌作为 BGM。&emsp;&emsp;她们在追寻梦想，我们不也是吗？ 目前&emsp;&emsp;我们队暂时没有后期题选手，但是前中期还行，拿了校赛第四，省赛第六。&emsp;&emsp;补了 2018 焦作，好像用了一半时间就金了，剩下时间囤题数打爆了去年一队，但最终没写完，落得最后 2h 像弃疗了一样。&emsp;&emsp;暑假集训是校内前排队，多数总题数第一，但是多久写完的这些题我们心里清楚，跟一队还是有很大差距。 &emsp;&emsp;总之目前我们的战绩都挺好，但是有一队在这，加之今年形势严峻，恐怕路不好走。 &emsp;&emsp;于我自己而言，是在退步，吃老本的时间多过学新东西的时间，不断被人超越，在重演中学的仲永惨剧。 &emsp;&emsp;校选我和 ctlchild 都打崩了，可能过多几周这个队直接就散了也说不定~&emsp;&emsp;那么邓大佬就不用被我们拖累了 &emsp;&emsp;我必须更大程度地提升自己，不要成为队伍短板。 大一&emsp;&emsp;再来说文化课。 &emsp;&emsp;这学期有计划地加大了竞赛训练量，结果就是文化课大退步。上学期 rk10-，这学期恐怕 rk30+ 了。&emsp;&emsp;高中时物理不好，但是没想过会在大学迎来期中考挂科。。整套卷子考下来本来没多少及格的，一波调分之后大概就剩我不及格了。。数分期中考也考不好，也是改卷过松被我胡过去几十分。。 &emsp;&emsp;颓废与懒惰是大学以来的最严重的问题。比上个学期有进步了，至少这个学期有了自主的规划，该干啥活都干起来了。但是问题还是老问题，很容易开始腐败，时间是花出去了，事情可真的没做多少。每周四早上给自己定的数分习题课，到头来连书本习题都做不完，更不用说上个学期规划的要在期末考前做掉 thu 的习题课了。给自己定的每周多少时间肝竞赛，连题都补不完，一年下来博客就多了几个水题。&emsp;&emsp;以为是环境问题，于是这学期都不在宿舍学习了，去图书馆学习，去集训室学习，却惊人地发现我依然在大把大把地浪费时间，连良好的学习氛围都救不了我吗？&emsp;&emsp;与高二时肝 oi 的热情、高三时肝高考的冲劲，形成鲜明的对比。那时候随手翻翻书写写题是很自然的事情，现在很刻意。 &emsp;&emsp;还要继续努力，找回高二高三时的学习状态。 &emsp;&emsp;至少，找回了当年对竞赛的热爱。&emsp;&emsp;去年真的是很迷茫的状态，又想打又想退役学文化课，结果训练的时候很容易怀疑人生。现在是又感受到了高二时的那种感觉（心里很向往，但是手还是在颓废），刷题的乐趣回来了。&emsp;&emsp;同时也明白了，高中时候许多人说自己热爱竞赛，都是假的。大多还是盯着签协议，进了大学校就肝别的东西去了。真正的热爱竞赛，像 sysu 这里，这帮人坚定地要一路打下去，哪怕大三大四了，进过 final 了，还要继续打，甘愿本科出来工作，这种热爱到有点偏狂的状态，这才是喜欢竞赛吧。从他们身上，真的看到了很纯的热爱。 &emsp;&emsp;总结起来，大一这年，没有活出该有的样子。心中总是很压抑很焦虑，这多半是源自于自己总是在颓废，没有去扎实地提升自己。同时也因为一些迷茫，耽误了很久。 これから&emsp;&emsp;今后，还是努力做一个善于管理时间的人吧。高二高三时说自己热爱学习，并且是真的做到了，大学不要自己砸自己招牌。 &emsp;&emsp;希望大二开始，生活还是要变得充实，想学的专业课去学，想写的题想学的知识不要总是拖着，想补的番及时去补，想读的书要读下去，高中积累起来的诗词之爱不要荒废。 &emsp;&emsp;附上这张图时刻警醒自己","categories":[{"name":"总结与游记","slug":"总结与游记","permalink":"http://kqp.world/categories/%E6%80%BB%E7%BB%93%E4%B8%8E%E6%B8%B8%E8%AE%B0/"},{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[]},{"title":"【2019 Multi-University 1 B】Operation 题解","slug":"【2019 Multi-University 1 B】Operation 题解","date":"2019-07-25T04:13:36.000Z","updated":"2024-04-24T03:59:22.808Z","comments":true,"path":"【2019 Multi-University 1 B】Operation 题解/","link":"","permalink":"http://kqp.world/%E3%80%902019%20Multi-University%201%20B%E3%80%91Operation%20%E9%A2%98%E8%A7%A3/","excerpt":"题目大意&emsp;&emsp;有一个长度为 $n$ 的序列 $a_1\\cdots a_n$，有 $m$ 个操作，操作有两种：&emsp;&emsp;$0~l~r$：选择 $a_l\\cdots a_r$ 的一个子序列，使得其异或和最大，求该异或和；&emsp;&emsp;$1~x$：a[++n]=x;&emsp;&emsp;强制在线。 &emsp;&emsp;数据组数 $T \\leq 10$，时限 4s&emsp;&emsp;$n,m \\leq 5\\times 10^5,\\ \\ (\\sum n),(\\sum m) \\leq 10^6,\\ \\ 0 \\leq x,a_i \\leq 2^{30}$","text":"题目大意&emsp;&emsp;有一个长度为 $n$ 的序列 $a_1\\cdots a_n$，有 $m$ 个操作，操作有两种：&emsp;&emsp;$0~l~r$：选择 $a_l\\cdots a_r$ 的一个子序列，使得其异或和最大，求该异或和；&emsp;&emsp;$1~x$：a[++n]=x;&emsp;&emsp;强制在线。 &emsp;&emsp;数据组数 $T \\leq 10$，时限 4s&emsp;&emsp;$n,m \\leq 5\\times 10^5,\\ \\ (\\sum n),(\\sum m) \\leq 10^6,\\ \\ 0 \\leq x,a_i \\leq 2^{30}$ \\\\ \\\\ \\\\题解&emsp;&emsp;吹爆优秀的队友想出了优秀的 $O(n \\log a_i)$ 做法！ &emsp;&emsp;子序列最大异或和肯定是线性基了，直接线段树维护区间线性基有 3 个 $\\log$ 就会 T 掉。 &emsp;&emsp;于是考虑每个点 $i$ 维护 $1$~$i$ 的线性基。对于点 $i$，首先它要继承 $i-1$ 的线性基，然后把 $a_i$ 加进去，但不是普通的加，而是更新式地加。假设 $a_i$ 的最高位是 $w$，若线性基里 $w$ 这个位为空，则直接加进去；若这个位放了一个数 $y_w$，并且它比较旧（在原序列中的下标比 $i$ 小），则把 $y_w$ 替换成 $a_i$，然后 $y_w$ 当作一个新来的数继续插入线性基。&emsp;&emsp;这样一来，相当于我所用的基元都是最新的，最靠近 $i$ 的。&emsp;&emsp;那么询问 $[l,r]$ 的时候，就看 $r$ 的线性基，先把 $l$ 之前的基元去掉，然后剩下的基元求最大异或和就行了。 &emsp;&emsp;这样的时间就是 $O(n \\log a_i)$ 的了。 代码//来自队友12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;stdio.h&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;cstring&gt;#define cint const int &amp;using namespace std;typedef long long ll;#define rep(i,l,r) for (int i=l;i&lt;=r;i++) int n,m,tt,a[1005000],pos[1005000][32],val[1005000][32];void insert(int x,int xval)&#123; rep(i,0,30) &#123; pos[x][i]=pos[x-1][i]; val[x][i]=val[x-1][i]; &#125; int tmp=x; for (int i=30;i&gt;=0;i--) if (xval&amp;(1&lt;&lt;i))&#123; if (!val[x][i]) &#123; pos[x][i]=tmp; val[x][i]=xval; break; &#125; else &#123; if (pos[x][i]&lt;tmp)&#123; swap(pos[x][i],tmp); swap(val[x][i],xval); &#125; xval^=val[x][i]; &#125; &#125;&#125;int main() &#123;// freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin); scanf(&quot;%d&quot;,&amp;tt); while (tt--)&#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); rep(i,1,n) &#123; scanf(&quot;%d&quot;,&amp;a[i]); insert(i,a[i]); &#125; int ans=0; rep(i,1,m)&#123; int op; scanf(&quot;%d&quot;,&amp;op); if (op==1)&#123; int x; scanf(&quot;%d&quot;,&amp;x); x^=ans; ++n; insert(n,x); &#125; else &#123; int l,r; scanf(&quot;%d%d&quot;,&amp;l,&amp;r); l=(l^ans)%n+1; r=(r^ans)%n+1; if (l&gt;r) swap(l,r); ans=0; for (int j=30;j&gt;=0;j--)&#123; if (pos[r][j]&gt;=l&amp;&amp;val[r][j]) ans=max(ans,ans^val[r][j]); &#125; printf(&quot;%d\\n&quot;,ans); &#125; &#125; rep(i,0,n) rep(j,0,30) val[i][j]=pos[i][j]=0; &#125;&#125;","categories":[{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[{"name":"算法_位运算","slug":"算法-位运算","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/"}]},{"title":"【AtCoder Grand 036B】Do Not Duplicate 题解","slug":"【AtCoder Grand 036B】Do Not Duplicate 题解","date":"2019-07-22T13:12:24.000Z","updated":"2024-04-24T03:59:22.827Z","comments":true,"path":"【AtCoder Grand 036B】Do Not Duplicate 题解/","link":"","permalink":"http://kqp.world/%E3%80%90AtCoder%20Grand%20036B%E3%80%91Do%20Not%20Duplicate%20%E9%A2%98%E8%A7%A3/","excerpt":"题目大意&emsp;&emsp;有一个长度为 $n$ 的数组 $a_0,\\cdots,a_{n-1}$，把它拼 $k$ 次，得到 $a_0,\\cdots,a_{nk-1}$。&emsp;&emsp;有一个初始为空的数组 $X$，对于 $0 \\leq i &lt; nk$，依次进行下面的操作： 若 $X$ 不含 $a_i$，则把 $a_i$ 加到 $X$ 的末尾； 若 $X$ 含有 $a_i$，则一直删除 $X$ 的末尾直至 $X$ 不含 $a_i$。 &emsp;&emsp;求最终的 $X$ 数组。 &emsp;&emsp;$n,a_i \\leq 2\\times10^5,\\ \\ k \\leq 10^{12}$","text":"题目大意&emsp;&emsp;有一个长度为 $n$ 的数组 $a_0,\\cdots,a_{n-1}$，把它拼 $k$ 次，得到 $a_0,\\cdots,a_{nk-1}$。&emsp;&emsp;有一个初始为空的数组 $X$，对于 $0 \\leq i &lt; nk$，依次进行下面的操作： 若 $X$ 不含 $a_i$，则把 $a_i$ 加到 $X$ 的末尾； 若 $X$ 含有 $a_i$，则一直删除 $X$ 的末尾直至 $X$ 不含 $a_i$。 &emsp;&emsp;求最终的 $X$ 数组。 &emsp;&emsp;$n,a_i \\leq 2\\times10^5,\\ \\ k \\leq 10^{12}$ \\\\ \\\\ \\\\题解&emsp;&emsp;把 $a_{ik},\\cdots,a_{ik+n-1}$ 叫做第 $i$ 层。 &emsp;&emsp;假设 $a_0,\\cdots,a_{n-1}$ 是个循环数组，每个 $a_i$ 找到它下一个跟他相同的元素，假设是 $a_j$，那么 $i$ 向 $(j+1)\\mod n$ 连边，边权为这条边跨过了几层。比如： &emsp;&emsp;由于每个点都有一条出边，那么这回是一棵环套树，也即有循环节。 &emsp;&emsp;$O(n)$ 找到循环节，然后通过循环节快速走到最后一层，再暴力最后一层。 &emsp;&emsp;题解没有找循环节，而是用倍增来求每个点走 $2^k$ 层之后到哪。萌新第一次艹标算好紧张啊。。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;bits/stdc++.h&gt;#define fo(i,a,b) for(int i=a;i&lt;=b;i++)#define fd(i,a,b) for(int i=a;i&gt;=b;i--)using namespace std;typedef long long LL;struct D&#123; int i; LL k;&#125;;const int maxn=2e5+5;int n,a[maxn],occur[maxn],d0;LL k;D p[maxn],d[maxn];bool bz[maxn];int ans0,ans[maxn];void Last(int x)&#123; memset(bz,0,sizeof(bz)); fo(i,x,n) if (!bz[a[i]]) &#123; ans[++ans0]=a[i]; bz[a[i]]=1; &#125; else &#123; while (bz[a[i]]) bz[ans[ans0--]]=0; &#125; fo(i,1,ans0) printf(&quot;%d &quot;,ans[i]);&#125;int main()&#123; scanf(&quot;%d %lld&quot;,&amp;n,&amp;k); fo(i,1,n) scanf(&quot;%d&quot;,&amp;a[i]); fd(i,n,1) &#123; if (occur[a[i]]) &#123; if (occur[a[i]]==n) p[i]=(D)&#123;1,1ll&#125;; else p[i]=(D)&#123;occur[a[i]]+1,0ll&#125;; &#125; occur[a[i]]=i; &#125; memset(occur,0,sizeof(occur)); fo(i,1,n) &#123; if (!occur[a[i]]) occur[a[i]]=i; if (!p[i].i) &#123; if (occur[a[i]]==n) p[i]=(D)&#123;1,2ll&#125;; else p[i]=(D)&#123;occur[a[i]]+1,1ll&#125;; &#125; &#125; D i=(D)&#123;1,1&#125;; memset(occur,0,sizeof(occur)); for(; i.k&lt;k; i.k+=p[i.i].k, i.i=p[i.i].i) &#123; d[++d0]=i; if (occur[i.i]) break; else occur[i.i]=d0; &#125; if (i.k==k) &#123;Last(i.i); return 0;&#125; LL cir=d[d0].k-d[occur[d[d0].i]].k; i.k=d[occur[d[d0].i]].k+(k-d[occur[d[d0].i]].k)/cir*cir; for(; i.k&lt;k; i.k+=p[i.i].k, i.i=p[i.i].i); Last(i.i);&#125;","categories":[{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[]},{"title":"【程设大作业】mydeque","slug":"programming_mydeque","date":"2019-07-19T12:39:27.000Z","updated":"2024-04-24T03:59:22.788Z","comments":true,"path":"programming_mydeque/","link":"","permalink":"http://kqp.world/programming_mydeque/","excerpt":"&emsp;&emsp;记录下，那段，与 STL 斗智斗勇的岁月~ Task&emsp;&emsp;一句话，实现 deque&lt;int&gt; 及相应的 iterator。","text":"&emsp;&emsp;记录下，那段，与 STL 斗智斗勇的岁月~ Task&emsp;&emsp;一句话，实现 deque&lt;int&gt; 及相应的 iterator。&emsp;&emsp;具体来说，你需要实现 mydeque、myIterator、myrIterator 三个类（不允许使用 STL），需要完成的功能如下：12345678910111213141516171819202122232425262728293031323334353637383940414243class mydeque &#123; public: mydeque(); ~mydeque(); // Add element at the end void push_back(int num); // Add element at the front void push_front(int num); // Insert elements at pos void insert(myIterator&amp; pos, int num); // Erase elements void earse(myIterator&amp; pos); // Clear content void clear(); // Access element int&amp; operator[](int pos); // Access first element int&amp; front(); // Access last element int&amp; back(); // Return size int size(); // Return iterator to beginning myIterator begin(); // Return iterator to end myIterator end(); // Return reverse iterator to reverse beginning myrIterator rbegin(); // Return reverse iterator to reverse end myrIterator rend();&#125;;class myIterator &#123; public: myIterator&amp; operator= (const myIterator &amp;iter); bool operator!= (const myIterator &amp;iter); bool operator== (const myIterator &amp;iter); myIterator&amp; operator++ (); myIterator operator++ (int); myIterator operator+ (int num);&#125;;class myrIterator &#123; //与 myIterator 同理&#125;; &emsp;&emsp;可自行增加需要的函数、变量。 &emsp;&emsp;使用 Linux 下的 benchmark 评分。评分标准为跟 STL 比速度，共 18 个测试项（具体看后面的 main.cpp），每个测试项满分为 6 分，总分最终不超过 100 分。（基准实验指 class mydeque : public stl::deque&lt;int&gt; &#123;&#125;） 程序正确运行,没有崩溃,内存泄露等错误(3.6分) 程序运行效率达到基准实验的60%(4.2分) 程序运行效率达到基准实验的70%(6.8分) 程序运行效率达到基准实验的80%(5.4分) 程序运行效率达到基准实验的100%(6分) &emsp;&emsp;STL 效率如下：&emsp;&emsp;Iteration 我猜是一个自适应的迭代次数，就是如果你跑得快，就可以多跑一些，跑得慢就会少跑一些，最终用自己的 Iteration 除以 STL 的 Iteration 就可以直到效率比了。 Sol&emsp;&emsp;deque 的特性是，$O(1)$ 前端后端插入、随机访问，$O(n)$ 中间插入、删除。要做到这样，最方便的是使用一个长长的一维数组，但是这样的话迁移的效率又不是很高，而且对内存要求苛刻，因此折中一下使用块状链表，有一个大数组 map，里面的每一个元素都指向一个小数组，即双层数组结构。&emsp;&emsp;然后它的 iterator 比较复杂，要记录两层数组的下标、所在第二层数组的开头、结尾，具体参考《STL源码剖析》。 \\\\&emsp;&emsp;然而，要深知，照着 STL 的写法来写一遍，是会有 debuff 的，是永远也别想跟它比效率的。&emsp;&emsp;比如，就 for (auto it = deq.begin(); it != deq.end(); it++) &#123;&#125; 这句话，如果在 it++ 里执行了大于等于两个操作，你甚至可能要跑 STL 的几倍到十几倍时间。。。&emsp;&emsp;要想艹 STL 得高分，就必须使尽浑身解数，斗智斗勇。 \\\\&emsp;&emsp;首先简化一下我需要记录的东西： 1234struct MapType &#123; int *a,num;&#125; *map;int head,tail,l,r,maxsize,totsize; &emsp;&emsp;map[i].a[j] 就是一个双层数组结构，用于存放东西，用一个常数 alen 表示每个 map.a[] 的定长，maxsize 表示第一层也就是 map[] 的长度（这个是要不断倍长、迁移的）。STL 的写法中记录了一头一尾两个 iterator，在这里我用 head 和 l 表示头的两个下标，tail 和 r 表示尾的两个下标。 &emsp;&emsp;做法很简单，push_back() 和 push_front() 就直接往两边放，第二层不够了就新开第二层，第一层不够了就整体倍长迁移（像 vector 那样）。insert() 就直接找到那个位置，然后把它右边的元素全部往后推一位，erase() 同理。由于第二层数组是定长的，因此简单算个数就能使用 [] 访问了。 &emsp;&emsp;一些优化：&emsp;&emsp;比如说，myIterator 里就只放一个下标，表示它是从左往右数第几个数。毕竟测试项里没有通过 iterator 访问元素这一项，那我就牺牲这个的复杂度（把它转成通过 [] 来访问），换取一个飞快的 for (auto it = deq.begin(); it != deq.end(); it++) &#123;&#125;。&emsp;&emsp;insert() 和 erase() 在 STL 里都用 iterator 来写，那么我就直接 for 循环，避免过多的调用。&emsp;&emsp;能用 memcpy 就不要用 for 循环，要始终坚信它写的东西就是比你的快。&emsp;&emsp;一个重要的优化是，insert() 不要鲁莽地全部往右推，判断一下它是在整个结构的左半边还是右半边，如果在左半边就左边的往左推，如果在右半边就往右推。简单分析一下效率，如果一味往右推，单次操作期望次数 $\\frac{n^2}{2}$，优化以后单次操作期望次数 $2\\times\\frac{(\\frac n2)^2}{2}=\\frac{n^2}{4}$，能优化掉一半的时间。erase() 同理。&emsp;&emsp;块大小 alen 可以调调参，理论上当它取 $\\sqrt n$ 的时候效率是最优的（学分块学疯了），但是 $n$ 在实际中是未知的，而且恰好取到 $\\sqrt n$ 的时候其实挺慢的，STL 其实也取得很小。&emsp;&emsp;写时复制。这个我没加，但是对于这个题来说（详见 main.cpp，构造了一个 deque 之后传来传去的）显然是一个十分有用的优化。写了的人说十分有用。&emsp;&emsp;自己写内存分配，不要用 new 和 free。这两个贼慢，详见 舍友的博客。 &emsp;&emsp;放一波效率图，可以看到效率其实还是很烂，毕竟 STL 自带了很多 buff。 有趣的故事&emsp;&emsp;我的队友老哥，想写平衡树艹它，于是写了个无旋 treap。&emsp;&emsp;一开始的时候，main.cpp 里的那些关于暂停的注释是没有的，也就是说，构造 deque 是不计时间的。&emsp;&emsp;这位老哥的 treap 很优秀，各操作时间很平衡，于是艹爆了 STL 的 $O(n)$ 操作。但是他复制这个 treap 的时间有点慢。&emsp;&emsp;万万没想到让这个 benchmark 的测评方法给栽跟头了。由于他跑太快了，于是他要跑很多次，跑很多次的话，他的复制的时间就爆掉了。&emsp;&emsp;于是就出现了“我跑得太快了，所以我超时了”。 &emsp;&emsp;后来可怜的助教就把注释加上了，构造 deque 也计时间，于是他的平衡树就被打爆了，不得不写标准版。 代码// main.cpp// 这是下发的不可修改的文件// 程序最后可看到 18 个测试项，括号里的数字代表数据规模123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139#include &lt;benchmark/benchmark.h&gt;#include &lt;algorithm&gt;#include &lt;random&gt;#include &quot;mydeque.hpp&quot;long getRandom(long from=0, long to=65536) &#123; return (rand() % (to-from+1)) + from;&#125;mydeque constructRandomDeque(long num) &#123; mydeque deq; for (long i = 0; i &lt; num; i++) &#123; deq.push_back(i); &#125; return deq;&#125;static void BM_deqempty(benchmark::State&amp; state) &#123; for (auto _ : state) &#123; mydeque deq; &#125;&#125;static void BM_deqPushBack(benchmark::State&amp; state) &#123; for (auto _ : state) &#123; mydeque deq; for (long i = 0; i &lt; state.range(0); i++) &#123; deq.push_back(i); &#125; &#125;&#125;static void BM_deqPushfront(benchmark::State&amp; state) &#123; for (auto _ : state) &#123; mydeque deq; for (long i = 0; i &lt; state.range(0); i++) &#123; deq.push_front(i); &#125; &#125;&#125;static void BM_deqTraverse(benchmark::State&amp; state) &#123; for (auto _ : state) &#123; mydeque deq; // state.PauseTiming(); deq = constructRandomDeque(state.range(0)); // state.ResumeTiming(); for (auto it = deq.begin(); it != deq.end(); it++) &#123;&#125; &#125;&#125;static void BM_deqRtraverse(benchmark::State&amp; state) &#123; for (auto _ : state) &#123; mydeque deq; // state.PauseTiming(); deq = constructRandomDeque(state.range(0)); // state.ResumeTiming(); for (auto it = deq.rbegin(); it != deq.rend(); it++) &#123;&#125; &#125;&#125;static void BM_deqInsert(benchmark::State&amp; state) &#123; for (auto _ : state) &#123; mydeque deq; // state.PauseTiming(); deq = constructRandomDeque(state.range(0)); // state.ResumeTiming(); for (int j = 0; j &lt; state.range(1); ++j) deq.insert(deq.begin()+getRandom(0, deq.size()-1), getRandom()); &#125;&#125;static void BM_deqErase(benchmark::State&amp; state) &#123; for (auto _ : state) &#123; mydeque deq; state.PauseTiming(); deq = constructRandomDeque(state.range(0)); int max = state.range(0) &gt; state.range(1) ? state.range(0) : state.range(1); state.ResumeTiming(); for (long j = 0; j &lt; state.range(1); ++j) &#123; if (deq.size()==0) break; deq.erase(deq.begin()+getRandom(0, max-1-j)); &#125; &#125;&#125;static void BM_deqAt(benchmark::State&amp; state) &#123; for (auto _ : state) &#123; mydeque deq; // state.PauseTiming(); deq = constructRandomDeque(state.range(0)); // state.ResumeTiming(); for (long j = 0; j &lt; state.range(1); ++j) deq[getRandom(0, state.range(0)-1)]; &#125;&#125;// static void BM_deqSort(benchmark::State&amp; state) &#123;// mydeque deq;// for (auto _ : state) &#123;// state.PauseTiming();// deq = constructRandomDeque(state.range(0));// state.ResumeTiming();// std::sort(deq.begin(),deq.end());// &#125;// &#125;// static void BM_deqShuffle(benchmark::State&amp; state) &#123;// mydeque deq;// for (auto _ : state) &#123;// state.PauseTiming();// deq = constructRandomDeque(state.range(0));// state.ResumeTiming();// std::random_shuffle(deq.begin(),deq.end());// &#125;// &#125;// Register the function as a benchmarkBENCHMARK(BM_deqempty);BENCHMARK(BM_deqPushBack)-&gt;Arg(32)-&gt;Arg(65536)-&gt;Arg(1L&lt;&lt;22);//BENCHMARK(BM_deqPushfront)-&gt;Arg(32)-&gt;Arg(65536)-&gt;Arg(1L&lt;&lt;22);BENCHMARK(BM_deqTraverse)-&gt;Arg(32)-&gt;Arg(65536)-&gt;Arg(1L&lt;&lt;22);BENCHMARK(BM_deqRtraverse)-&gt;Arg(32)-&gt;Arg(65536)-&gt;Arg(1L&lt;&lt;22);BENCHMARK(BM_deqInsert)-&gt;Args(&#123;32, 512&#125;)-&gt;Args(&#123;65536, 512&#125;)-&gt;Args(&#123;1L&lt;&lt;22, 512&#125;);BENCHMARK(BM_deqErase)-&gt;Args(&#123;512, 512&#125;)-&gt;Args(&#123;65536, 512&#125;)-&gt;Args(&#123;1L&lt;&lt;22, 512&#125;);BENCHMARK(BM_deqAt)-&gt;Args(&#123;32, 128&#125;)-&gt;Args(&#123;65536, 128&#125;);// BENCHMARK(BM_deqPushfront)-&gt;RangeMultiplier(32)-&gt;Range(8L, 8L&lt;&lt;20);// BENCHMARK(BM_deqTraverse)-&gt;RangeMultiplier(32)-&gt;Range(8L, 8L&lt;&lt;20);// BENCHMARK(BM_deqRtraverse)-&gt;RangeMultiplier(32)-&gt;Range(8L, 8L&lt;&lt;20);// BENCHMARK(BM_deqInsert)-&gt;Ranges(&#123;&#123;32L, 8L&lt;&lt;22&#125;, &#123;128, 512&#125;&#125;);// BENCHMARK(BM_deqErase)-&gt;Ranges(&#123;&#123;32L, 8L&lt;&lt;22&#125;, &#123;128, 512&#125;&#125;);// BENCHMARK(BM_deqAt)-&gt;Ranges(&#123;&#123;32L, 8L&lt;&lt;22&#125;, &#123;128, 512&#125;&#125;);// BENCHMARK(BM_deqSort)-&gt;RangeMultiplier(32)-&gt;Range(8L, 8L&lt;&lt;20);// BENCHMARK(BM_deqShuffle)-&gt;RangeMultiplier(32)-&gt;Range(8L, 8L&lt;&lt;22);BENCHMARK_MAIN();// mydeque.hpp123456789101112131415161718192021222324252627282930313233343536373839#ifndef MYDEQUE_HPP#define MYDEQUE_HPP#include&quot;myIterator.hpp&quot;class mydeque &#123; public: struct MapType &#123; int *a,num; &#125; *map; int head,tail,l,r,maxsize,totsize; void NewMapType(MapType &amp;x); void ChangeMap(); inline void Release(); inline void init(); mydeque(); ~mydeque(); mydeque&amp; operator = (const mydeque &amp;deq); void push_back(const int &amp;val); void push_front(const int &amp;val); void insert(myIterator pos,int val); void erase(const myIterator &amp;pos); void clear(); int&amp; operator [] (int i); int&amp; front(); int&amp; back(); int size(); myIterator begin(); myIterator end(); myrIterator rbegin(); myrIterator rend();&#125;;#endif// myIterator.hpp12345678910111213141516171819202122232425262728293031323334#ifndef MYITERATOR_HPP#define MYITERATOR_HPPconst int alen=130;class myIterator &#123; public: int pos; myIterator(int x=0); bool operator != (const myIterator &amp;iter); bool operator == (const myIterator &amp;iter); myIterator&amp; operator ++ (); myIterator&amp; operator -- (); myIterator operator ++ (int); myIterator operator + (int num);&#125;;class myrIterator &#123; public: int pos; myrIterator(int x=0); bool operator != (const myrIterator &amp;iter); bool operator == (const myrIterator &amp;iter); myrIterator&amp; operator ++ (); myrIterator&amp; operator -- (); myrIterator operator ++ (int); myrIterator operator + (int num);&#125;;#endif// mydeque.cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183#include&lt;cstring&gt;#include&quot;mydeque.hpp&quot;#define fo(i,a,b) for(int i=a;i&lt;=b;i++)#define fd(i,a,b) for(int i=a;i&gt;=b;i--)using namespace std;inline void mydeque::NewMapType(mydeque::MapType &amp;x)&#123; x.a=new int[alen+2]; x.num=0;&#125;void mydeque::ChangeMap()&#123; int len=maxsize, half=len&gt;&gt;1; maxsize&lt;&lt;=1; MapType *newmap=new MapType[maxsize+2]; memcpy(newmap+half,map,len*sizeof(MapType)); delete[] map; map=newmap; head+=half, tail+=half;&#125;inline void mydeque::Release()&#123; fo(i,head,tail) delete[] map[i].a; delete[] map;&#125;inline void mydeque::init()&#123; maxsize=2; map=new MapType[maxsize+2]; NewMapType(map[1]); head=tail=1; l=1, r=0; totsize=0;&#125;mydeque::mydeque()&#123; init();&#125;mydeque::~mydeque()&#123; Release();&#125;mydeque&amp; mydeque::operator = (const mydeque &amp;deq)&#123; Release(); maxsize=deq.maxsize; head=deq.head, tail=deq.tail; l=deq.l, r=deq.r; totsize=deq.totsize; map=new MapType[maxsize+2]; fo(i,head,tail) &#123; map[i].num=deq.map[i].num; map[i].a=new int[alen+2]; memcpy(map[i].a,deq.map[i].a,sizeof(map[i].a)); &#125;&#125;void mydeque::push_back(const int &amp;val)&#123; if (r==alen) &#123; if (tail==maxsize-1) ChangeMap(); NewMapType(map[++tail]); r=0; &#125; map[tail].num++; map[tail].a[++r]=val; totsize++;&#125;void mydeque::push_front(const int &amp;val)&#123; if (l==1) &#123; if (head==0) ChangeMap(); NewMapType(map[--head]); l=alen+1; &#125; map[head].num++; map[head].a[--l]=val; totsize++;&#125;void mydeque::insert(myIterator pos,int val)&#123; if (pos.pos&gt;=(totsize&gt;&gt;1)) &#123; push_back(0); for(int i=tail, cnt=totsize-1; cnt!=pos.pos; --i) for(int j=(i==tail ?r :alen); j&gt;=1 &amp;&amp; cnt!=pos.pos; --j, --cnt) map[i].a[j]=(j==1) ?map[i-1].a[alen] :map[i].a[j-1] ; &#125; else &#123; push_front(0); for(int i=head, cnt=0; cnt!=pos.pos; ++i) for(int j=(i==head ?l :1); j&lt;=alen &amp;&amp; cnt!=pos.pos; ++j, ++cnt) map[i].a[j]=(j==alen) ?map[i+1].a[1] :map[i].a[j+1] ; &#125; (*this)[pos.pos]=val;&#125;void mydeque::erase(const myIterator &amp;pos)&#123; if (pos.pos&gt;=(totsize&gt;&gt;1)) &#123; for(int i=tail, cnt=totsize-1, last=map[i].a[(i==tail ?r :alen)], t, *p; cnt!=pos.pos; --i) for(int j=(i==tail ?r :alen); j&gt;=1 &amp;&amp; cnt!=pos.pos; --j, --cnt) &#123; p=(j==1) ?&amp;(map[i-1].a[alen]) :&amp;(map[i].a[j-1]) ; t=*p, *p=last, last=t; &#125; map[tail].num--; if (--r==0) &#123;delete[] map[tail--].a; r=alen;&#125; &#125; else &#123; for(int i=head, cnt=0, last=map[i].a[(i==head ?l :1)], t, *p; cnt!=pos.pos; ++i) for(int j=(i==head ?l :1); j&lt;=alen &amp;&amp; cnt!=pos.pos; ++j, ++cnt) &#123; p=(j==alen) ?&amp;(map[i+1].a[1]) :&amp;(map[i].a[j+1]) ; t=*p, *p=last, last=t; &#125; map[head].num--; if (++l&gt;alen) &#123;delete[] map[head++].a; l=1;&#125; &#125; totsize--;&#125;void mydeque::clear()&#123; Release(); init();&#125;int&amp; mydeque::operator [] (int i)&#123; if (i&lt;map[head].num) return map[head].a[l+i]; i-=map[head].num; int index=i/alen; return map[head+index+1].a[i-index*alen+1];&#125;int&amp; mydeque::front()&#123; return map[head].a[l];&#125;int&amp; mydeque::back()&#123; return map[tail].a[r];&#125;int mydeque::size()&#123; return totsize;&#125;myIterator mydeque::begin()&#123; return myIterator(0);&#125;myIterator mydeque::end()&#123; return myIterator(totsize);&#125;myrIterator mydeque::rbegin()&#123; return myrIterator(totsize-1);&#125;myrIterator mydeque::rend()&#123; return myrIterator(-1);&#125;// myIterator.cpp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include&quot;myIterator.hpp&quot;//myIteratorbool myIterator::operator != (const myIterator &amp;iter)&#123; return (this-&gt;pos!=iter.pos);&#125;bool myIterator::operator == (const myIterator &amp;iter)&#123; return (this-&gt;pos==iter.pos);&#125;myIterator::myIterator(int x)&#123; pos=x;&#125;myIterator&amp; myIterator::operator ++ ()&#123; ++pos; return *this;&#125;myIterator&amp; myIterator::operator -- ()&#123; --pos; return *this;&#125;myIterator myIterator::operator ++ (int)&#123; myIterator re=*this; ++pos; return re;&#125;myIterator myIterator::operator + (int num)&#123; return myIterator(this-&gt;pos+num);&#125;//myrIteratorbool myrIterator::operator != (const myrIterator &amp;iter)&#123; return (this-&gt;pos!=iter.pos);&#125;bool myrIterator::operator == (const myrIterator &amp;iter)&#123; return (this-&gt;pos==iter.pos);&#125;myrIterator::myrIterator(int x)&#123; pos=x;&#125;myrIterator&amp; myrIterator::operator ++ ()&#123; --pos; return *this;&#125;myrIterator&amp; myrIterator::operator -- ()&#123; ++pos; return *this;&#125;myrIterator myrIterator::operator ++ (int)&#123; myrIterator re=*this; --pos; return re;&#125;myrIterator myrIterator::operator + (int num)&#123; return myrIterator(this-&gt;pos-num);&#125;","categories":[{"name":"project","slug":"project","permalink":"http://kqp.world/categories/project/"}],"tags":[{"name":"程设","slug":"程设","permalink":"http://kqp.world/tags/%E7%A8%8B%E8%AE%BE/"}]},{"title":"【长更】一句话题解（各大oj）","slug":"short_sol_oj","date":"2019-06-26T14:57:28.000Z","updated":"2024-08-11T09:33:34.281Z","comments":true,"path":"short_sol_oj/","link":"","permalink":"http://kqp.world/short_sol_oj/","excerpt":"&emsp;&emsp;太简单的题，但是又要记录下来做过哪些东西，就写在这里啦~&emsp;&emsp;早搞不搞，等到快退役了才来搞 &emsp;&emsp;标 * 的为有价值的题，标 ^ 的为欺诈题，标 - 的为知识点待填坑，标 ? 的表示看别人是这样做的但是没懂为什么&emsp;&emsp;组队训练的题，如果是队友过的板刷题，题面又很长，就会标个“队友说是沙雕题”","text":"&emsp;&emsp;太简单的题，但是又要记录下来做过哪些东西，就写在这里啦~&emsp;&emsp;早搞不搞，等到快退役了才来搞 &emsp;&emsp;标 * 的为有价值的题，标 ^ 的为欺诈题，标 - 的为知识点待填坑，标 ? 的表示看别人是这样做的但是没懂为什么&emsp;&emsp;组队训练的题，如果是队友过的板刷题，题面又很长，就会标个“队友说是沙雕题” AtCoderAtCoder Grand Contest 028&emsp;&emsp;A：若有解，则 $lcm(n,m)$ 就是最小解&emsp;&emsp;B：对每个 $i$ 考虑删 $a_j$ 时 $a_i$ 造成的贡献，即 $\\frac{n!}{|i-j|+1}a_i$&emsp;&emsp;*C：每条边拆成 $a_i$、$b_j$ 两条边，还是找最小圈。那么有三种情况：每个点只贡献 $a_i$、每个点只贡献 $b_i$、其他。对于第三种情况，枚举一个 $i$ 表示它贡献了 $a_i+b_i$，那么剩下的就是选 $a_1,\\cdots,a_n,b_1,\\cdots,b_n$ 里去掉 $a_i$ 和 $b_i$ 的最小的 $n-2$ 个&emsp;&emsp;*D：设 $f_{i,j}$ 表示最小元素为 $i$、最大元素为 $j$ 的连通块数，通过容斥转移&emsp;&emsp;**E：贪心按位考虑，根据题目性质可以化为一个类似于 LIS 的 dp&emsp;&emsp;&emsp;&emsp;看大题解 AtCoder Grand Contest 029&emsp;&emsp;A：略&emsp;&emsp;B：lowbit 相同的分一组，每组从大到小贪心&emsp;&emsp;C：二分，当 $a_i &lt; a_{i-1}$ 的时候就把 $a_i$ 抬升一位，$a_i$ 抬满了就抬 $a_i-1$，注意一些细节&emsp;&emsp;D：两个人的最优策略都是能走就走（先手肯定不能停否则后手一停就结束了；后手尽早走到下一列不会劣于晚些走到下一列）&emsp;&emsp;E：把 $1$ 视为根，那么每个节点需要预处理它的子树“只走权值不超过它爷爷到根的最大权值，能走多少”，记为 $sz_i$，答案就是这个点的儿子的 $sz$ 和加上它到根路径上的其他儿子的 $sz$ 和。这个 $sz$ 的预处理可以简单粗暴数据结构 $O(n \\log n)$ 也可以精细地 $O(n)$。&emsp;&emsp;*F：建一个二分图，左边 $1,\\cdots,n$ 表示点，右边 $E_1,\\cdots,E_{n-1}$ 表示边，左边去掉根以后要存在完美匹配，且从根开始沿”非匹配边-匹配边-非匹配边-……“做 BFS 能遍历所有点&emsp;&emsp;&emsp;&emsp;看大题解 AtCoder Grand Contest 030&emsp;&emsp;A：$b+\\min(a+b+1,c)$&emsp;&emsp;B：先做出间隔序列（与起点相邻的间隔在序列两端），答案等价于序列上找一个位置叉掉，其中一侧乘上系数 $1,3,5,7,\\cdots$，另一侧乘上系数 $2,4,6,8,\\cdots$。预处理前缀后缀阶梯，枚举叉掉的位置。&emsp;&emsp;*C：首先找一个偶数的 $n$，奇数行放 $(r+c) \\bmod n$，偶数行放 $(r+c) \\bmod n+n$，这样会得到 $k=2n$ 的解，如果多了就把最大的 $k+n$ 变回 $k$&emsp;&emsp;D：设 $dp_{i,j}$ 表示一个小的数初始在 $i$、一个大的数初始在 $j$，最终造成的贡献总和，按操作倒序 dp，每次转移是 $O(n)$ 的。最后 $\\sum_{i,j | a_i &lt; a_j} dp_{i,j}$ 即是答案&emsp;&emsp;*E：$0 \\to 1$ 视为红线，$1 \\to 0$ 视为蓝线，那么反转一位相当于线移动一位，答案相当于线的匹配，$O(n)$ 枚举起点的匹配再 $O(n)$ check 即可&emsp;&emsp;&emsp;&emsp;看大题解&emsp;&emsp;F：数字从大到小 dp，看成左右括号匹配，设 $dp_{i,j,k}$ 表示考虑了前 $i$ 个数，有 $j$ 个空余左括号，其中 $k$ 个是给定数字作为左括号，的方案数 AtCoder Grand Contest 035&emsp;&emsp;A：必定是 $a_1\\ a_2\\ a_3\\ a_1\\ a_2\\ a_3 \\cdots $ 这样循环，分类讨论共 3 种情况&emsp;&emsp;*B：做一棵 dfs 树，非树边随便定向，树边从下往上定向，判断根是否合法&emsp;&emsp;*C：如图：$n$ 为奇数就大风车，$n$ 为偶数就另外加上 $n$，$n$ 为 $2$ 的幂无解&emsp;&emsp;**D：考虑每张牌的贡献次数，设 $f_{l,r,x,y}$ 表示 $[l,r]$ 这个区间，$l$ 贡献 $x$ 次，$r$ 贡献 $y$ 次，的最小代价和。枚举最后吃的那张，发现它的贡献是 $x+y$，就 dp 下去了&emsp;&emsp;&emsp;&emsp;看大题解 AtCoder Grand Contest 036&emsp;&emsp;^A：考虑 $(0,0),(10^9,1),(x,y)$，则 $10^9y-x=S$，令 $y=\\lceil \\frac{S}{10^9} \\rceil$&emsp;&emsp;B：考场做法：每个元素向它走到的下一个元素连边，找循环节，暴力跑最后一层&emsp;&emsp;&emsp;&emsp;题解做法：连边，然后倍增求每个点走 $2^k$ 层到哪&emsp;&emsp;&emsp;&emsp;看大题解&emsp;&emsp;*C：符合条件的序列满足和为 $3M$、单个元素不超过 $2M$、奇数个数不超过 $M$，用组合数和容斥算方案数&emsp;&emsp;*D：设 $p_i$ 为 $0$ 到各点的最短路，dp $p$ 序列的负差分&emsp;&emsp;E：大讨论 AtCoder Grand Contest 034&emsp;&emsp;A：若为 $C&lt;D$ 则先让 $B$ 走到 $D$ 再让 $A$ 走到 $C$，两人分别判断；若为 $D&lt;C$ 则让 $A$ 尽早超越 $B$ 然后分别判断&emsp;&emsp;B：相当于 BC 是障碍物，A 要跳过障碍物到最远的地方去&emsp;&emsp;C：二分，然后推式子发现最多只有一科不是满分，枚举那一科然后剩下的贪心选 AtCoder Grand Contest 037&emsp;&emsp;A：略&emsp;&emsp;B：显然贪心可得最优答案。然后计数，每个第三色有多少种第二色选择，每个第二色有多少种第一色选择，全部乘起来，再乘个 $n!$&emsp;&emsp;*C：倒过来做，如果 $b_i&gt;a_i$ 且 $b_i&gt;b_{i-1}+b_{i+1}$ 那么这个 $b_i$ 必然要被操作，用一个堆找最大的 $b_i$ 来做&emsp;&emsp;*D：问题转化为第一步使得每列包含每行的元素恰好一个。一列一列地确定，每列是一个完美匹配&emsp;&emsp;&emsp;&emsp;看大题解&emsp;&emsp;E：第一步找到倒序字典序最小的，然后接下来每次操作可以把结尾的最小字符连续段长度翻倍&emsp;&emsp;*F：按数值从小到大处理连续段（计算连续段的贡献并产生数值 $+1$ 的新连续段），可以把模型改成“如果一个区间合法那么贡献为 $L_i \\times R_j$”，在处理连续段时修改 $L,R$ 的值 DISCO Presents Discovery Channel Code Contest 2020 Qual&emsp;&emsp;A：略&emsp;&emsp;B：枚举分界点，答案是左右两边的差的绝对值&emsp;&emsp;C：同一行的草莓先把这行划分掉，然后如果有一行没草莓就复制它上面或下面的分法&emsp;&emsp;*D：解法一：暴力。每个数字是有循环节的（即使用多少个这个数字可以得到它自己），把循环节消掉了就是暴力&emsp;&emsp;&emsp;&emsp;解法二：顺序是不影响的，那么考虑把每个数字全部拆成 1，因此进位的影响就是 $\\lfloor \\frac{数位和-1}{9} \\rfloor$&emsp;&emsp;*E：先二分一个位置 $i$ 使得 $[i,i+n-1]$ 和 $[i+1,i+n]$ 的回答是不同的，那么 $i$ 和 $i+n$ 的颜色就确定了，并且 $[i+1,i+n-1]$ 这段区间是两种颜色相同的。剩下的都可以利用 $[i+1,i+n-1]$ 来完成 AtCoder Grand Contest 043&emsp;&emsp;我为什么要交题&emsp;&emsp;A：答案等于从 $(1,1)$ 走到 $(n,m)$ 所经过的最少的连续 $1$ 的段数，$O(n^2)$ dp&emsp;&emsp;*B：先判断答案是奇数还是偶数（看成异或，Lucas 定理算每个数被贡献了多少次），若为奇数则答案为 $1$，否则若原序列有 $1$ 则答案为 $0$，否则把 $2$ 当成 $1$ 再判奇偶 AtCoder Grand Contest 044NOMURA Programming Competition 2020&emsp;&emsp;AB：略&emsp;&emsp;C：从顶层到底层，逐层确定每层能选多少个点，$O(n)$&emsp;&emsp;*D：图是环套树森林，答案等于 $(n-1)^k-(每种方案下的连通块数)$，而连通块数等于环数，因此要算出每种方案下的环数之和，每个环单独贡献，$O(n^2)$ 求多项式 $\\prod(1+size_i)$&emsp;&emsp;F：一个方案合法的充要条件是，对于每一位的第一个 $1$ 和最后一个 $0$，这之间的数在以后的位上都要完全相同。于是 $O(nm)$ dp 一下&emsp;&emsp;E： ACL Contest 1&emsp;&emsp;*A：思路是每个元素向其左边能到的点连边。但实际上只要做出左边开始的下降序列，那么每个元素只需要在这个序列上连一个区间就行了，可以精细实现为 $O(n\\alpha(n))$ AtCoder Regular Contest 107&emsp;&emsp;AB：略&emsp;&emsp;C：行列独立，任意两行如果能换就连一条边，每个连通块大小的阶乘的积就是行的答案，列同理&emsp;&emsp;*D：dp，设 $dp_{x,y}$ 表示当前层有 $x$ 个数、已确定计入答案的有 $y$ 个数，的方案数。同层转移，即 $dp_{x,y}$ 转移到 $dp_{x-1,y+1}$ 和 $dp_{2x,y}$&emsp;&emsp;E：$\\forall i,j \\ge 4,\\ a_{i+1,j+1}=a_{i,j}$，因此只要算前四行和前四列即可&emsp;&emsp;F： AtCoder Grand Contest 049&emsp;&emsp;A：每个点产生贡献当且仅当它是它及其前驱中最早被选的点，假设它及它前驱共有 $cnt_i$ 个点，可以发现这个概率是 $\\frac{1}{cnt_i}$&emsp;&emsp;B：相当于每次可以选择一个 $1$ 前移一位，如果两个 $1$ 撞上了可以一起消掉。因此直接 two pointers 匹配&emsp;&emsp;CDEF： AtCoder Regular Contest 119&emsp;&emsp;A：枚举 $b$&emsp;&emsp;B：相当于每个字符串的 $0$ 的要按顺序依次匹配&emsp;&emsp;C：观察可得一段序列合法当且仅当奇数位的和等于偶数位的和&emsp;&emsp;*D：建出二分图，每个连通块可用其生成树代替，所有的树要么都保留一个左边点，要么都保留一个右边点&emsp;&emsp;&emsp;&emsp;看大题解&emsp;&emsp;*E：只有 $a_{l-1} \\le a_l$ 且 $a_r \\le a_{r+1}$ 或 $a_{l-1} \\ge a_l$ 且 $a_r \\ge a_{r+1}$ 的交换才会使答案更优，答案的改变量等于区间 $[a_{l-1},a_l]$ 与 $[a_r,a_{r+1}]$ 的交的两倍，因此问题转化成求最大区间交。&emsp;&emsp;&emsp;&emsp;看大题解&emsp;&emsp;F： AtCoder Regular Contest 141&emsp;&emsp;A：枚举周期长度，取最高位的那一段或其减 $1$ 作为周期。并且考虑 $999\\cdots9$（位数比 $N$ 少 $1$）&emsp;&emsp;B：$A_i$ 的二进制最高位必须递增，除最高位以外任选。搬 dreamoon 的 codeforces round 631(div. 1) B 被抓包&emsp;&emsp;*C：考虑“给定括号字符串如何求字典序最小的排列”，那么两个排列分别都可以确定很多的位置，以及留出一些不能确定的连续段，最后这些连续段贪心地做成“()()()…”即可&emsp;&emsp;*D：每个数表示成 $2^c \\cdot d$，按 $d$ 归类，则每个类恰好选一个数。求出每个类选的数的上限和下限，则夹在上下限之间的都是可行的&emsp;&emsp;&emsp;&emsp;看大题解&emsp;&emsp;EF： AtCoder Regular Contest 147&emsp;&emsp;A：用堆模拟即可&emsp;&emsp;B：先用类似于括号序的顺序将“奇数位上的偶数”和“偶数位上的奇数”换过来，再将奇数位和偶数位分别排序&emsp;&emsp;C：考场解法：大力猜测存在一个中心点，所有人都尽量往中心点靠。这个中心点的选择只能是线段端点，因此扫描线即可求出答案&emsp;&emsp;&emsp;&emsp;题解解法：一顿猛推得到答案为 $\\sum_{i=1}^n \\max(0,L_i-R_i) \\times (n-2i-1)$&emsp;&emsp;^D：$n^m \\cdot m^{n-1}$&emsp;&emsp;EF： AtCoder Grand Contest 059&emsp;&emsp;^A：把子串首尾拼接成环，统计相邻异色的 pair 数，这东西每次最多消除 $2$，所以除以 $2$ 上取整就是答案&emsp;&emsp;B：把数字按出现次数从大到小排序，相同数字之间相当于一个空位可以消除一个答案&emsp;&emsp;CDEF： AtCoder Regular Contest 156&emsp;&emsp;A：必要条件是 $1$ 的数量是偶数，注意 corner case，比如 $n \\le 4$ 且 $1$ 的数量为 $2$&emsp;&emsp;C：以直径中点为根（如果中间没有点就建一个虚点），所有深度的点轮换一位&emsp;&emsp;D：假设每个数的出现次数是 $c_i$，则只考虑 $\\frac{k!}{\\prod_{i=1}^n c_i!}$ 是奇数的情况，相当于 $c_i$ 只能是 $k$ 二进制下的 $1$ 的组合，dp 一下&emsp;&emsp;BEF： AtCoder Regular Contest 159&emsp;&emsp;被疯狂 corner case 杀&emsp;&emsp;A：显然 $\\bmod n$ 相同的点是可以合并考虑的，特殊考虑 $s \\equiv t \\pmod n$ 但 $s \\neq t$ 的情况&emsp;&emsp;*B：不妨设 $a \\le b$，那么每次等价于 $a$ 和 $b-a$ 在操作，但只有 $a$ 会减小。把 $a$ 看成 $a’ \\cdot \\gcd$，每次操作相当于 $a’$ 减 $1$，所以就看 $a’$ 什么时候减到下一个质因子的倍数&emsp;&emsp;*C：充分条件是 $n|\\sum a_i$（因为每两次操作可以使一人相对 $+1$，一人相对 $-1$），且这在 $n$ 为奇数时是必要的，$n$ 为偶数且操作数是偶数时也是必要的，$n$ 为偶数且操作数为奇数相当于一开始随便加上一个 $1,\\cdots,n$ 就转化成操作数为偶数的情况了&emsp;&emsp;D：观察可得最优情况下进入一个区间一定是从头开始进入，记 $dp_i$ 表示进入了区间 $i$ 并停在其头部的最长长度，则 $dp_i = \\max_{j &lt; i} ( dp_j + \\min(r_j + 1, l_i) - l_j)$，树状数组维护一下即可&emsp;&emsp;EF： CodeforcesCodeforces Round #559 Div.1&emsp;&emsp;A：首先让全部数字都是每行的 $\\min$ 值，然后找 $m-1$ 个最大值和 $1$ 个次大值替换成列的 $\\max$ 值。&emsp;&emsp;*C：考场解法：想办法做出拓扑图就能得到最终序列了，于是线段树优化连边得到拓扑图，时间 $O(n \\log n)$。&emsp;&emsp;&emsp;&emsp;题解解法：先判掉 $i&lt;j&lt;next_i&lt;next_j$ 的情况，然后 $i$ 向 $next_i$ 连边，构成一棵树，跑 dfs 序再倒过来。$O(n)$。&emsp;&emsp;**E：先用 $4\\log$ 的时间确定每个点的层（类似于整体二分，同一二分层的奇数段一起做，偶数段一起做），再用 $3\\log$ 的时间为每个点找父亲（逐二进制位确定每个点父亲，模 $3$ 相同的层一起做）。 Educational Codeforces Round 67&emsp;&emsp;没 AK，丢人~&emsp;&emsp;AB：略&emsp;&emsp;C：要单调不降的区间就全都平着，其他都下降&emsp;&emsp;D：区间排序等价于不断交换相邻两个，因此 $a$ 数组必须包含 $b$ 数组的所有逆序对。随便维护&emsp;&emsp;E：dp，换根&emsp;&emsp;*F：考场解法：设 $f_{i,j,k}$ 表示到了第 $i$ 个元素，结尾为 $j$，共 $k$ 段，的方案数。$k$ 用 AGC019E 的思想优化成 $0\\sim 2$，$j$ 扔线段树上，那么转移就是区间乘和加（矩阵）。代码过长，常数过大，请勿模仿&emsp;&emsp;G：费用流直接上。因为最大流只有 50，因此相当于跑 50 次最短路，这是不会 T 的。但还是把你吓得半死甚至丢了一血 Codeforces Round #572 Div.1+Div.2&emsp;&emsp;ABC：略&emsp;&emsp;D1：判是否存在度数为 2 的点，因为度数为 2 的点两边一定是一样的&emsp;&emsp;*D2：选一个叶子为根，从下往上一条边一条边确定&emsp;&emsp;^E：史上最大诈胡题 两边同乘 $(a_i-a_j)$，平方差公式&emsp;&emsp;^*F：设 $f_{i,j,x}$ 表示到了第 $i$ 个数，选了 $j$ 个，最小间隔为 $x$ 的方案数。后两维的有用状态总和为 $O(k \\cdot \\frac ak)=O(a)$ Codeforces Round #580 Div.1Codeforces Round #583&emsp;&emsp;A：全买 1$ 和 5€，暴力枚举买了多少个 1$&emsp;&emsp;B：$n+1-\\max(0,n-b)-\\max(0,n-g)$&emsp;&emsp;C：要么原串合法，要么把最后一个左括号放到开头，要么把第一个右括号放到结尾&emsp;&emsp;D：答案最多为 $2$（封住左上角），因此判断是否存在割点或者左上右下不连通&emsp;&emsp;E：$d_i$ 从大到小做，最长的作为主链，然后贪心填满主链，其他随便挂在主链上&emsp;&emsp;*F：一定能从某个地方割开成链然后从左到右贪心匹配。因此先假设是 $1$ 到 $m$ 的链，每个点的坐标要么是正贡献要么是负贡献，看它前面的 $a$ 和 $b$ 的数量。然后每次把开头的人丢到结尾，可以快速计算对答案的影响。&emsp;&emsp;*G：每行开一个 bitset，若某两行的 bitset 不是包含关系则有解。判断是否存在两行不互相包含只需按 size 从小到大排序然后依次检查相邻两个，用 set 维护&emsp;&emsp;&emsp;&emsp;看大题解&emsp;&emsp;H：若直径小于 $k$ 则任意染；若 $k=2$ 则黑白染色；否则直径按 $1$ 到 $k$ 循环染，剩下的枝都有长度限制，在长度限制以内方案是唯一的，超过长度限制则无解 Codeforces Round #584&emsp;&emsp;A：贪心&emsp;&emsp;B：模拟 $10^5$ 次&emsp;&emsp;C：枚举分界的数字，小于它的染 1 色，大于它的染 2 色，这个数字单独判断&emsp;&emsp;D：看成连边，然后答案为 $n$ 减生成森林的边数&emsp;&emsp;E1E2：只有 $\\min(n,m)$ 列是有用的，随便状压一下&emsp;&emsp;F：做出最短路图，按拓扑序处理每一个点，这个点相当于选择一条入边然后更新 trie。选择哪条入边更优秀那就看谁是 lca 的小的儿子&emsp;&emsp;G1：设一个数字最左出现在 $l$，最右出现在 $r$，那么 $[l,r]$ 要全部同色。栈+并查集维护一下就好了&emsp;&emsp;**G2：维护这个区间并。给 $[l,r-1]$ 全体加 $1$，那么 $0$ 就是区间并的分界点。用线段树维护这个，然后求区间众数的话再开一棵线段树，每个数的出现次数赋值到最早出现的位置，那么就是个区间最大值&emsp;&emsp;&emsp;&emsp;看大题解 Codeforces Round #594 (Div. 1)&emsp;&emsp;A：若第一行存在相邻同色格子，那么后面的行的方案是唯一的；否则等价于第一列的方案数。都是一个递推过去&emsp;&emsp;*B：先把原串循环移位成一个合法括号序（若不存在则答案为 0），然后只有最外层和次外层的匹配括号对才能交换，贡献可以用栈来算&emsp;&emsp;C：大模拟&emsp;&emsp;D：有向图 tarjan 缩环，找到一个没有出度的强连通分量即可作为 jury，其余作为猫&emsp;&emsp;E：一定是第一行从小到大，第二行从大到小，于是最大路径只能是走边界的两条之一。因此问题变成，从小到大排序，前两个数放左上和右下，后 $2n-2$ 个数平分成两个集合，使得最大和最小。$O(n^3\\max a)$ dp Codeforces Round #602 (Div. 1)&emsp;&emsp;*A：任意括号序都是可以被构造的，当前这位不合你意就在后面找一个换&emsp;&emsp;B1B2：询问离线，把元素以大小为第一关键字、位置为第二关键字排序，依次激活，线段树二分查询第 $pos$ 个。&emsp;&emsp;C：二分，用二维前缀和判断&emsp;&emsp;*D1D2：题分为 $h_i=h_{i+1}$（无论如何选都贡献 0）和 $h_i\\not=h_{i+1}$（可贡献 1、-1、0）两种，由对称性，正贡献的方案数等于负贡献的方案数，所以非零贡献的方案数除以 2 就是答案 Codeforces Round #614 (Div. 1)&emsp;&emsp;AB：略&emsp;&emsp;C：只有经过 $0$ 的路径是有用的，且必然是在一条路径上放 $0$ ~ $len-1$。类似于区间 dp，设 $f_{u,v}$ 表示 $u$ 到 $v$ 这条路径的答案。&emsp;&emsp;D：集合点一定在某个关键点上，预处理一些东西后任意两个关键点之间的距离可以 $O(1)$ 算。那么就枚举集合点，然后暴力算距离，$O(k^2)$。注意 $k=0$。 Hello 2020&emsp;&emsp;AB：略&emsp;&emsp;C：算每个连续段的贡献&emsp;&emsp;D：按一边的区间排序，set 维护另一边的开始结束时间，判断这边相交的是否有另一边没交，再反过来做一次&emsp;&emsp;E：枚举中心点，剩下的三点只要不在该点的同一侧即可，于是极角排序+two pointers&emsp;&emsp;FG： Codeforces Round #625 (Div. 1)&emsp;&emsp;A：移项得到 $i-b_i$ 相同的组一队&emsp;&emsp;B：终点出发求最短路图，每个 $p_i$ 依照最短路图的出边进行讨论递推&emsp;&emsp;C：二维偏序随便搞搞&emsp;&emsp;D：一个串的最小表示是：(开头可能有奇数个 1)+(若干个0)+(奇数个1)+(若干个0)+(奇数个1)+…+(结尾一堆1)，把这个形状 hash 起来，线段树维护区间 hash&emsp;&emsp;EF： Codeforces Round #621 (Div. 1+Div. 2)&emsp;&emsp;A：贪心&emsp;&emsp;B：若有步长等于 $x$，则可以一步到位；否则等于 $\\lceil \\frac {x}{最长步长} \\rceil$&emsp;&emsp;C：长度只能为 1 或 2&emsp;&emsp;D：从起点跑一次 bfs，从终点跑一次 bfs，再找 bfs 序相邻的两个关键点连边&emsp;&emsp;*E：枚举分界线（即枚举左集合的最右牛），每种 $f$ 的牛独立算贡献&emsp;&emsp;FG： Ozon Tech Challenge 2020 (Div.1 + Div.2)&emsp;&emsp;A：两个数组都从小到大排序&emsp;&emsp;B：贪心&emsp;&emsp;^C：考场解法：把所有数按 $\\bmod~m$ 分类，先假设都是正贡献算答案，再在原数组求要乘多少个 $-1$&emsp;&emsp;&emsp;&emsp;正常解法：$n&gt;m$ 时答案必为 $0$，所以直接暴力&emsp;&emsp;*D：每次询问一个三元组（设 $a-b-c$，则询问 $a,c$），就可以去掉两棵子树&emsp;&emsp;*E：上界就是 $1\\cdots n$，第 $i$ 个数最多贡献 $\\lfloor \\frac{i-1}2\\rfloor$。所以先找到最大的 $n’$ 使得 $1\\cdots n’$ 的贡献恰好小于等于 $m$，再凑后面的。&emsp;&emsp;*F：答案上限是奇数个数，并且随机选一个数，$O(n)$ 判断 $a_i,a_i+1,a_i-1$ 的质因子，至少 $\\frac n2$ 的概率是正确的，随机判断 20 个即可&emsp;&emsp;&emsp;&emsp;看大题解&emsp;&emsp;*G：加一个 $a_i=0$ 的点，每条边 $(u,v)$ 赋权值 $a_u+a_v$，答案等价于最大生成树减去点权和。用 Boruvka 求最大生成树，每个点连出去的边用权值的高维前缀和来求&emsp;&emsp;H： Codeforces Round #626 (Div. 1)&emsp;&emsp;A：前缀和为 $0$ 的位置作为分界点，把序列分成若干段，有问题的段重排&emsp;&emsp;B：按位考虑，每一位相当于要求两个数的和在两个区间内，two pointers&emsp;&emsp;*C：右边的点按照邻集分类，同类求和，不同类求 $\\gcd$&emsp;&emsp;*D：dp，设 $f_{i,j,k}$ 表示倒着枚举到了第 $i$ 个数，数字大小为 $j$，有 $k$ 个数字，的最优答案。复杂度分析同那种看起来是 $O(n^3)$ 实际是 $O(n^2)$ 的树形 dp&emsp;&emsp;EF： Codeforces Round #631 (Div. 1)&emsp;&emsp;A：从左往右放，每个 $l_i$ 放在 $\\max(i,\\sum_{j=i}^n l_j)$&emsp;&emsp;B：$a_i$ 的二进制最高位必须是递增的，因此最多 30 来个，随便 dp&emsp;&emsp;C：每次贪心找最大的可删除的结点&emsp;&emsp;DE： Codeforces Round #633 (Div. 1)&emsp;&emsp;A：填平 $\\max_{i &lt; j,\\ a_i &gt; a_j} a_i-a_j$ 即可&emsp;&emsp;B：最小：若所有叶子的深度的奇偶性相同就是 1，否则是 3；最大：初值为 $n-1$，每当有 $x$ 个叶子父亲相同就减去 $x-1$&emsp;&emsp;C：打表找规律&emsp;&emsp;D：树形 dp，设 $f_{i,0/1}$ 表示以 $i$ 为根的子树，$i$ 选或不选，的最优答案。$f_{i,0}=儿子数量-1+\\max\\{f_{son,0},f_{son,1}\\}$，$f_{i,1}=\\max\\{f_{son,0}\\}+1$，旋根 dp&emsp;&emsp;E： 2020 ECNU Campus Online Invitational Contest&emsp;&emsp;AI：略&emsp;&emsp;C：cdq 模板题&emsp;&emsp;^D：若存在 $0$ 权或所有结点权值均 $\\ge 2$ 则直接找一个最小权点即可；否则先找到最长的 $1$ 构成的直径，然后再考虑是否有两条最长的 $1$ 直径用一个 $2$ 连起来，后者用旋根 dp 预处理每个 $1$ 最长能延伸到多少。&emsp;&emsp;F：SA 搞一搞，注意坑点，比如 / 和 . 互换&emsp;&emsp;BEGH： Educational Codeforces Round 89&emsp;&emsp;BC：略&emsp;&emsp;A：设两种原材料分别有 $a,b$ 个，最终合成了 $x$ 个物品，则有 $a-x+b-x\\ge x$，即 $a+b \\ge 3x$，因此输出 $\\min\\{a,b,\\lfloor \\frac{a+b}{3} \\rfloor\\}$&emsp;&emsp;D：找到 $a_i$ 最小的质因子 $p$，则 $d_1=p$，$d_2=a_i$ 除以 $p$ 除到不能除为止，若 $d_2=1$ 表示无解&emsp;&emsp;E：相邻两段的分界线是造成方案不唯一的原因，预处理后缀最小值然后随便搞搞&emsp;&emsp;*G：类似于 LCS 一样 dp，预处理第一个串 $len_i$ 表示从 $s_i$ 出发第一次到达空串需要多长。&emsp;&emsp;F： 2020 Ateneo de Manila University DISCS PrO HS Division&emsp;&emsp;ABCDEFG：略&emsp;&emsp;H：设 $M=p_1^{c_1}p_2^{c_2}\\cdots p_k^{c_k}$，$N=p_1^{d_1}p_2^{d_2}\\cdots p_k^{d_k}$，那么会有 $d_i\\prod_{j=1}^k(1+d_j)=2c_i$，枚举 $\\gcd(c_1,c_2,\\cdots,c_k)$ 的约数作为 $\\prod (1+d_j)$ 判断一下合不合法就行了&emsp;&emsp;I：问题转化为问每一个三角形内部包含了多少点。预处理出每条线段下方有多少点即可，注意线段垂直的情况 Codeforces Round #664 (Div. 1)&emsp;&emsp;A：枚举选多少个 $&gt;w$ 的 $a_i$&emsp;&emsp;B：每条边记作 $(i,j)$ 表示它所属的出边集大小为 $i$、它排名为 $j$，而每个点必须恰好选一条入边，因此可以得到所有 $(i,j)$ 之间的互斥关系，然后 $O(k!)$ 枚举&emsp;&emsp;*C：二分，check 的时候求出答案点横坐标、纵坐标、横纵坐标差的合法区间&emsp;&emsp;&emsp;&emsp;看大题解&emsp;&emsp;D：简单树形 dp，设 $f_{i,0/1}$ 表示 $i$ 为根的子树，$i$ 往上走是上升还是下降，的最小代价&emsp;&emsp;E： Codeforces Round #706 (Div. 1)&emsp;&emsp;A：按 $x^2$ 和 $y^2$ 排序&emsp;&emsp;B：出生点必须在顶峰，而且必须在唯一的最长单调段的顶峰，然后讨论一下这个顶峰的较短单调段&emsp;&emsp;*C：$3$ 的倍数的行全染掉，最后一行讨论一下&emsp;&emsp;DEF： Codeforces Round #707 (Div. 1)&emsp;&emsp;^A：差分序列如果有不相邻的相同值就一定是 yes，因此序列最长为 $O(\\sqrt{a})$，取原序列前 $3000$ 个数用 $O(n^2)$ 的方法判断即可&emsp;&emsp;B：二分，枚举每种颜色计算相撞的天数&emsp;&emsp;CDEF： Codeforces Round #709 (Div. 1)&emsp;&emsp;A：每天优先选第一个人，然后如果发现有人超了，就把选他的天进行调整，调整完行就行，不行就不行&emsp;&emsp;B：提神醒脑小链表&emsp;&emsp;C：单调栈优化dp&emsp;&emsp;*D：先 flyod 求出任意两点最短路，然后反向 floyd 求出任意两点间的最松限制&emsp;&emsp;EF： Codeforces Round #745 (Div. 1)&emsp;&emsp;A：精细地实现 $O(n^3)$&emsp;&emsp;*B：题目的条件等价于“笛卡尔树深度为 $m$ 的节点恰有 $k$ 个”，大力 $O(n^5)$ dp 冲过去&emsp;&emsp;C：$x+y \\le \\sqrt m$ 的用一个周期表记录下来，$x+y &gt; \\sqrt m$ 的暴力&emsp;&emsp;**E：最短路图上入度为 $1$ 的点是关键点。无修是按最短路排序，每个关键点取前面 $w$ 的最小值或次小值。带修用两个 set 分别维护最小值相同的段和次小值相同的段，以及需要用最小值或次小值的关键点数量。&emsp;&emsp;&emsp;&emsp;看大题解&emsp;&emsp;DF： Codeforces Round #749 (Div. 1 + Div. 2)&emsp;&emsp;濒临紫名了。。。危&emsp;&emsp;^A：傻瓜解法：范围这么小这不直接冲 dp？&emsp;&emsp;&emsp;&emsp;聪明解法：要么总和是合数，否则一定能减去一个奇数变成合数&emsp;&emsp;B：一定有点没作为 $b$ 被限制过，以它为中心做个大菊花&emsp;&emsp;C：NO 当且仅当存在一个 X 它的右上也是 X&emsp;&emsp;D：先用 $n-1$ 步求出 $a_n$（依次假设 $a_n=1,2,\\cdots,n-1$，用前面的 $n$ 与它遥相呼应），然后用 $n-1$ 步求出其他所有数&emsp;&emsp;*E：YES 当且仅当每个点的询问度数是偶数（想象在询问点对间连边，会构成欧拉图），输出方案只要在生成树上走即可&emsp;&emsp;FGHI： Codeforces Round #773 (Div. 1)&emsp;&emsp;A：贪心从小到大匹配&emsp;&emsp;B：每次找到第一个与 $a_1$ 相同的 $a_i$，然后在 $a_i$ 后面构建 $a_1,\\cdots,a_{i-1}$。提神醒脑大模拟&emsp;&emsp;C：回答 NO 当且仅当它被 0 染色覆盖；回答 YES 当且仅当它没被 0 染色覆盖且有一个 1 染色除了这个位置其他都是 0。用并查集+链表维护 0 染色情况、每个元素左边右边第一个非 0 位置，用线段树看左端点在 $(l_x,x]$ 的 1 染色的右端点最小值是否 $&lt;r_x$ 即可&emsp;&emsp;DEF： Codeforces Round #831 (Div. 1 + Div. 2)&emsp;&emsp;A：奇数 $+3$，偶数 $+2$&emsp;&emsp;B：令 $a_i \\le b_i$，则答案为 $2(\\sum a_i + \\max b_i)$&emsp;&emsp;C：大胆猜测，一定是排好序后划分成连续的三段，然后 1 3 2 或 2 1 3 这样排。前者 1 肯定是单独一个数，只需枚举 2 3 分界点即可；后者 3 是单独一个数，枚举 1 2 分界点&emsp;&emsp;D：如果一张卡片能放出来，且放出来之后去掉起始点和目标点外仍然有一个空位，那就一定能通过若干步华容道把任意一张卡移到终点&emsp;&emsp;E：简单树形 dp，设 $dp_{i,0/1}$ 表示以 $i$ 为根的子树，$i$ 这个点是否计入贡献，的最大收益&emsp;&emsp;FGHI： 计蒜客计蒜之道2019初赛第1场&emsp;&emsp;A：略&emsp;&emsp;*BCD：莫比乌斯反演优化 dp&emsp;&emsp;&emsp;&emsp;看大题解 计蒜之道2019复赛&emsp;&emsp;A：用线段树求每个数往左的最长下降序列长度及方案数，以及往右的最长上升序列长度及方案数。&emsp;&emsp;B：暴力模拟，当然太暴力是不能过的。&emsp;&emsp;**C：观察得出 $SG(x)$ 等于 $x$ 二进制下末尾 $0$ 的个数。于是先求出 $cnt[i]$ 表示 $SG$ 值为 $i$ 的 $x$ 有多少个，然后像快速幂一样自己 FWT 自己，共 $\\log$ 次 FWT。&emsp;&emsp;D：贪心。由于每次要求最大值的区间是往右滑窗的，所以可以用单调队列。&emsp;&emsp;E：贪心。 JZOJ2019.08.04【NOIP提高组】模拟 A 组&emsp;&emsp;t1：递推&emsp;&emsp;*t2：化成 $x^m \\equiv x~(\\mod n)$，每个质因子下暴力解，再把解数乘起来&emsp;&emsp;*t3：解法一：LCT&emsp;&emsp;&emsp;&emsp;解法二：用两个倍增数组，一个存链上最小值（忽略方向，启发式合并），一个存方向 2017.11.09【NOIP提高组】冲刺A组&emsp;&emsp;*t1：NOI2015寿司晚宴（每个数最多含有 8 个小质因子和 1 个大质因子（以 $\\sqrt n$ 分大小），按大质因子分类，状压小质因子 dp）&emsp;&emsp;t2：边双缩起来得到一棵树，把直径连起来&emsp;&emsp;t3：保留初始 mst 的 $O(n)$ 条边，以后每次 add 直接重建 mst HNOI2018&emsp;&emsp;*D1t3(5657)：11 条非树边 22 个关键点，建虚树，虚树上儿子对父亲的贡献系数可以预处理，然后 $O(2^{11})$ 枚举每条非树边的下点选不选，在虚树上做 dp&emsp;&emsp;d2t1(5658)：预处理每个点只往左和只往右最远能到达哪里，然后从左往右每个点暴力扩展（要一段一段地跳），是线性的&emsp;&emsp;*D2t2(5659)：转化成树的问题，每个点是一个权值序列，每次找平均权值最小的序列，并到父亲的末尾去，用堆+dsu 实现 NOI2020全国统一省选&emsp;&emsp;*D2t3(6741)：矩阵树定理，把每条边视为 $1+wx$，那么 $\\det$ 就是生成树的边权和。$\\gcd$ 利用 $\\varphi * 1=id$ 拆掉 散装&emsp;&emsp;4703：物品做背包，钱袋子 meet in the middle，注意折成 $20+10$ 复杂度最优&emsp;&emsp;4829：蚂蚁问题，每次询问二分&emsp;&emsp;*4847：若 $x$ 到 $y$ 的路上经过奇环，则一定可以，否则看路径长度的奇偶性。用广义圆方树&emsp;&emsp;*4939：左端点从左往右移，线段树维护右端点。每次左端点右移就相当于结算一些段&emsp;&emsp;&emsp;&emsp;看大题解&emsp;&emsp;5001：状压 dp，设 $f_s$ 表示 $s$ 这个集合的字符串的 trie 大小，肯定先把这个集合的公共字母全部提取出来，然后枚举一个分割来转移&emsp;&emsp;100003：树边从深度小的连向深度大的，返祖边从深度大的连向深度小的，最大费用循环流 BZOJ&emsp;&emsp;^3083：换根是吓人的，实际上根据 $id$ 和 $root$ 的关系可以把询问拆成至多两个 dfs 序区间，用链剖+线段树维护区间最小值&emsp;&emsp;*5016：每个询问 $(l_1,r_1,l_2,r_2)$ 可以拆成 4 个前缀询问 $(r_1,r_2)-(l_1-1,r_2)-(l_2-1,r_1)+(l_1-1,l_2-1)$，然后莫队 Ynoi&emsp;&emsp;4810：莫队，加法和减法用 bitset 解决，乘法暴力枚举 $x$ 的因数判断&emsp;&emsp;*4811：链剖，线段树维护每个区间从左到右、从右到左、全 0 进入、全 1 进入得到的结果，询问按位贪心&emsp;&emsp;*4939：莫队求每个区间的 bitset，需要一些技巧&emsp;&emsp;&emsp;&emsp;看大题解&emsp;&emsp;4940：bzoj3083+bzoj5016 UOJGoodbye Jihai&emsp;&emsp;t1：按价格排序，那肯定是买便宜的然后白嫖贵的，所以前面做背包，枚举最后一个买的之后后面的按质量贪心选&emsp;&emsp;**t3：最优一定是从一个点出发左右扩展，且一个点往一边扩最多有 $\\log$ 段，因此有用的区间最多 $O(n \\log n)$ 个，在这些上面做区间 dp&emsp;&emsp;&emsp;&emsp;看大题解 UOJ Easy Round #9&emsp;&emsp;A：正常情况下以起点为中心极角排序转一圈就好了，但是有可能所有点在起点的同一半平面上，但这可以从一侧开始走，走到 $n$ 时递归成子问题&emsp;&emsp;*B：每个颜色块做 bfs 到达其他所有点的最短距离，用 bitset 求出对于其他每个点，有多少该颜色的点能沿最短路图到达它，能的点到它的距离就是最短距离，否则是最短距离 $+1$&emsp;&emsp;C： Goodbye Xinchou&emsp;&emsp;*A：解法一：特殊讨论答案为 1 或 2 的，然后 dfs 求答案为 3 的，剩下的就是答案为 4 的。&emsp;&emsp;&emsp;&emsp;解法二：特殊讨论答案为 1 或 2 或 3 的，剩下的就是答案为 4 的。但是在赛场上 FST 率极高。&emsp;&emsp;B：给胜者向负者连边，这样形成了一棵树状数组那样的树，且奇数层填正号，偶数层填负号。那么贪心填就好了，找找规律，最后是 $O(n)$ 实现。&emsp;&emsp;CDE： LOJ&emsp;&emsp;*2509：转化成树的问题，每个点是一个权值序列，每次找平均权值最小的序列，并到父亲的末尾去，用堆+dsu 实现&emsp;&emsp;*2978：“每个数包含奇数个哪些质数”可以看成 01 向量，做成线性基。区间太长时每个小质数都是基&emsp;&emsp;&emsp;&emsp;看大题解&emsp;&emsp;*2980：每个位置是一个向量 $[A_i,B_i,C_i,1]$，操作都是矩阵乘法，用线段树维护。&emsp;&emsp;&emsp;&emsp;看大题解 CometOJ2019 Wannafly Winter Camp Day5Comet OJ Contest #6&emsp;&emsp;A：略&emsp;&emsp;B：$O(n^3)$ 暴力 dp。&emsp;&emsp;C：考场解法：扫描右端点，用线段树维护左端点的答案。其实就是要维护左端点到当前右端点之间，一共有多少个度数不为 $0$ 的点。时间 $O(n \\log n)$。&emsp;&emsp;&emsp;&emsp;$O(n)$ 做法：求所有区间的连通块数和，转化成计算每个点的贡献。让一个连通块在它的 LCA 处被统计，那么就是说：一个点，它的父亲边被砍掉了，它的儿子边至少有一条。 Comet OJ Contest #8&emsp;&emsp;AB：略&emsp;&emsp;C：不管什么顺序都是 $\\sum_{i=1}^{n-1} b_ia_{i+1}$，再枚举一个区间乘 $k$&emsp;&emsp;D：枚举右端点，线段树维护左端点答案&emsp;&emsp;E：枚举 $f$ 的值为 $i$，那就是求 $\\lfloor \\frac{n}{i^2} \\rfloor$ 以内有多少个数没有平方因子，容斥反演一套打下去 Comet OJ Contest #13&emsp;&emsp;AB：略&emsp;&emsp;C：维护一个 $1$ 的并查集，每行再用一个并查集维护每个元素最右边的 $0$ 在哪里&emsp;&emsp;D：递推（设 $f_{i,0/1}$ 表示到了第 $i$ 个元素，$\\sqrt a$ 选了奇数个还是偶数个，的贡献），矩阵乘法加速&emsp;&emsp;E：枚举一条边经过的一个点，然后得到其余每个点在什么斜率下会被覆盖&emsp;&emsp;*F：大力分块 HDU2021CCPC华为云挑战赛&emsp;&emsp;A：按 $a_i$ 从大到小贪心放&emsp;&emsp;B：数据随机，枚举 2000 个 $k$，只判断序列前 20 个元素即可&emsp;&emsp;C：多重背包&emsp;&emsp;DEFG： 牛客东华大学2020年程序设计竞赛&emsp;&emsp;ABC：略&emsp;&emsp;D：PreFinals 2020 Day3 F 从小到大一段一段地合并，行就行，不行就不行&emsp;&emsp;F：最后结论是，若存在一个串里面 1 的个数是奇数，则先手必胜，否则先手必败&emsp;&emsp;G：dp，设 $f_i$ 表示考虑了前 $i$ 个数的最优答案。转移只需考虑最后一个 $0$ 和最后一个 $-1$&emsp;&emsp;H：建主席树，表示每个点到根路径上的值域线段树，每次询问二分。强行卡常不可取&emsp;&emsp;K：暴力（先 bfs 求出所有的 country，然后每个 country 边界点暴力往四周遍历，碰到别的 country 点就 break）复杂度是对的（隐约感觉，交了能过，还不会证&emsp;&emsp;EIJ： 2020牛客多校（第一场）&emsp;&emsp;一吨 paper 题加一两个用脚造数据的题&emsp;&emsp;F：队友说是沙雕题&emsp;&emsp;A：考场解法：（队友搞的）令 $a_i=s_i \\oplus s_{i+1}$，对 $a$ 数组求 SA，然后再怎么排个序&emsp;&emsp;&emsp;&emsp;题解解法：令 $c_i=\\min\\{j-i\\ |\\ j&gt;i,\\ s_i=s_j\\}$，对 $c$ 数组求 SA 就是答案&emsp;&emsp;*B：CF Round 614 Div1 D 评论区粉兔 先求出第一步往哪棵子树走，走过去之后，这棵子树就只有素数间隔那么多个元素了，建虚树找重心&emsp;&emsp;D：KKT 条件&emsp;&emsp;H：先假设容量为 $1$，不断 SPFA 单路增广求出从源点到汇点的第 $i$ 个流量所需的费用。每次询问等比例放大，相当于每 $u_i$ 个流量为一种费用，问前 $v_i$ 个流量总共需要多少费用，$O(1)$ 回答&emsp;&emsp;*I：带花树，每个点拆成 $d_i$ 个点，每条边也多拆两个点出来，答案等于 $最大匹配-边数$&emsp;&emsp;J：β 函数&emsp;&emsp;CEG： 2020牛客多校（第二场）&emsp;&emsp;D：略&emsp;&emsp;^C：解法一：找到重心，然后叶子按 dfs 序排序，头尾匹配&emsp;&emsp;&emsp;&emsp;解法二：任找一个非叶节点作根，然后叶子按 dfs 序排序，假设有 $s$ 个叶子，那么 $l_i$ 跟 $l_{i+\\frac s2}$ 匹配&emsp;&emsp;*E：答案可以表示成 $选18个数以内得到的答案+若干个“选18个数以内组成0”$，先做 18 次 FWT 算出任选 19 个数以内的所有情况，然后后面的 dp 上去&emsp;&emsp;F：单调队列求滑窗最大值。注意线性预处理 $\\gcd$，这里至少有两种方法&emsp;&emsp;G：大力 bitset 冲过去&emsp;&emsp;*H：两种情况，若 $x$ 是最大值，那么找 $x$ 的两个前驱；若 $x$ 不是最大值，则找一个 $a[i]&gt;x$ 使得 $a[i]-a[i-1]$ 最小。用平衡树维护&emsp;&emsp;I：看作在网格图上从 $(1,n)$ 不能走到主对角线，那么就是 bzoj 狼抓兔子，最小割用最短路实现&emsp;&emsp;J：对于输入的每个环长 $r$，把这个环“拉大” $k \\bmod r$ 倍即可，$k$ 是质数会保证操作一定可行&emsp;&emsp;K：枚举第二个圆上的点，推出积分式子，然后辛普森&emsp;&emsp;AB： 2020牛客多校（第三场）&emsp;&emsp;AL：略&emsp;&emsp;B：队友说是沙雕题&emsp;&emsp;C：先找到长度为 $9$ 的边，然后看比它的前驱后继哪个长，结合叉积判方向&emsp;&emsp;D：分两种情况讨论，若 $n$ 大 $m$ 小，则左边下边铺一个 $L$ 型，剩下的点从左下角往右上角拓展；若 $m$ 大 $n$ 小，则做一条直线+若干散点&emsp;&emsp;*E：把两个匹配的边都连上，会发现构成若干个大小为偶数且大于等于 $4$ 的环，于是就可以 dp&emsp;&emsp;F：若 $a,b$ 能约分则随便构造；否则若 $b=1$ 或 $b$ 只有一种质因子则无解；否则 exgcd&emsp;&emsp;*H：按位考虑，假设当前要排序的区间是 $[l,r]$，取一个最高位的修改操作使得它会把这个区间劈成两半，然后递归下去&emsp;&emsp;GIJK： 2020牛客多校（第四场）&emsp;&emsp;*A：从小到大枚举最大距离 $x$，算出这个距离最少需要多少关键点（每次找深度最深的点，它的 $x$ 级祖先为根的子树删掉，用线段树实现，关键点数量是 $O(\\frac nx)$ 的），然后 two pointers 求答案&emsp;&emsp;B：队友说是沙雕题&emsp;&emsp;*C：倒着插入字符，维护前缀最大值，会发现形成了一个 trie（大小不超过 $10n$），于是 trie 上建 sam&emsp;&emsp;*D：三种情况：1、一位一位来，发现答案 $\\le 9$；2、首段不超过 $30$，dp；3、首段超过 $30$，发现划分方案是唯一的&emsp;&emsp;*E：从小到大枚举当前的 $x$，比 $x$ 小的记作 $0$，比 $x$ 大的记作 $1$，那么就是问 $x$ 的左右两边是否能消成特定数字；暴力的话可以从左往右用栈贪心，那么快一点就用线段树维护一下某段对栈的影响&emsp;&emsp;F：可以判断 C、D 分别在 AB 中垂线的左边还是右边，然后讨论&emsp;&emsp;H：倒序考虑所有质因子的倍数，没匹配过的按其最小质因子从大到小贪心匹配&emsp;&emsp;**J：类似 Kruskal，并查集维护每个连通块的大小、相邻连通块的大小之和，其中相邻连通块的大小之和用启发式合并邻居表+根号平衡&emsp;&emsp;&emsp;&emsp;看大题解&emsp;&emsp;G： 2020牛客多校（第五场）&emsp;&emsp;F：略&emsp;&emsp;D：队友说是沙雕题&emsp;&emsp;A：一定有一个传送门是随身带着的，因此 $O(n^3)$ dp&emsp;&emsp;B：任选一个点作根，每个点求出它到根的异或和 $s_i$，会发现任意两个点之间连边的话权值一定是 $s_i \\oplus s_j$，那么就是个最小异或生成树&emsp;&emsp;*C：二维生成函数推一推&emsp;&emsp;E：等价于 $[1,2,\\cdots,n]$ 经过这个置换会得到多少不同的排列，因此是所有环长的 $lcm$，要高精度&emsp;&emsp;*H：每个右端点有 $O(\\log a)$ 个有效左端点，总共 $O(n \\log a)$ 个有效区间（看作平面上的点，点权为 $1$），如果两个区间 $[l_1,r_1]$ 和 $[l_2,r_2]$ 满足 $l1 \\le l_2 \\le r_1 \\le r_2$，那么新增一个区间 $[l_1,r_2]$，点权 $-1$，每个询问树套树二维数点&emsp;&emsp;I：$ans=\\frac 23$，方法为按对角线划分，连着两条对角线放 H，然后一条对角线交替放 E 和 G，边界点如果不合法就不放了，不影响极限&emsp;&emsp;K：队友说是大模拟&emsp;&emsp;GJ： 2020牛客多校（第六场）&emsp;&emsp;排列题大作战。。。&emsp;&emsp;*A：大胆猜想可以证明每次选一个环来操作是最优的，因此设 $f(n)$ 表示环大小为 $n$ 的操作期望，推一下式子发现很简单&emsp;&emsp;*B：解法一：看样例找规律，大胆猜想大胆写，要么怂B要么一血&emsp;&emsp;&emsp;&emsp;解法二：每个向量加进来的时候都不属于之前的空间，因此概率为 $\\prod_{i=0}^{n-1} \\frac{2^n-2^i}{2^n}$，化简一下可以递推&emsp;&emsp;C：队友说是沙雕题&emsp;&emsp;E：若 $n$ 为奇数，则 $k=0,ans=[1,n-1,2,n-2,\\cdots,n]$；否则 $k=\\frac n2,ans=[n,\\frac n2,1,n-1,2,n-2,\\cdots]$&emsp;&emsp;G：从左上到右下的副对角线、每条副对角线从右上到左下进行染色，且显然下标为偶数的副对角线，再染下标为奇数的副对角线&emsp;&emsp;H：数位 dp，设 $f_{i,sx-sy,0/1,0/1}$ 表示从高到低到了第 $i$ 位、$a$ 数位和减去 $b$ 数位和为 $sx-sy$、$a$ 是否小于 $b$、$b$ 是否小于 $n$，的方案数&emsp;&emsp;J：预处理出每一轮剩下的数字里要选第几个，然后线段树求出置换&emsp;&emsp;K：随便 dp 一下&emsp;&emsp;DFI： 2020牛客多校（第七场）&emsp;&emsp;^A：搞一个会 T 的 dp，比如设 $f_{i,x,y,sx,sy}$ 表示现在到了 $(x,y)$ 的位置，放了 $i$ 个点，之前的点横坐标和为 $sx$，纵坐标和为 $sy$，的最优答案。然后打表&emsp;&emsp;B：队友说是沙雕题&emsp;&emsp;*C：第一个操作看成全体 $+w$ 然后把 $x$ 丢进一个 multiset 里；第三个操作看成询问某个点到 multiset 里所有点的距离和，链剖解决；第二个操作看成单点询问和单点加法&emsp;&emsp;D：打表发现只有 $1$ 和 $24$ 是合法的&emsp;&emsp;**E：设 $dp_{i,(j,pj)}$ 表示目标树的第 $i$ 个结点，匹配模板里的结点 $j$，$i$ 连向父亲的边匹配 $j$ 连向 $pj$ 的边，的最小代价。转移是个 KM，用最短路快速退流&emsp;&emsp;&emsp;&emsp;看大题解&emsp;&emsp;*G：先 dp 出一个普通矩形的拓扑序数量，然后第一个矩形倒着 dp，设 $f_{i,j}$ 表示第一个矩形上排从右到左到了 $i$、下排从右到左到了 $j$ 的方案数，普通的转移是个挡板，$f_{i,i-1} \\to f_{i-1,i-1} \\to f_{i-1,i-2}$ 特殊地 $O(n)$ 转移一下（这样的情况只有 $n$ 次，不会 T）&emsp;&emsp;H：必有 $n=xk$ 或 $n=xk+1$，而 $x$ 和 $k$ 必有其一是 $\\le 10^6$ 的，枚举这一个算另外一个&emsp;&emsp;*I：答案为一个点的贡献 $\\times n$，枚举一个点的度数，用 prufer 序 dp 出方案数&emsp;&emsp;J：想办法连个图出来，跑足够多次传递闭包&emsp;&emsp;F： 2020牛客多校（第八场）&emsp;&emsp;*A：等价于求连通块个数，大力 LCT&emsp;&emsp;*D：$n \\bmod p$ 的部分分布在 $a_1,\\cdots,a_{p-1}$，方案为整数拆分；其余部分考虑分在 $a_1$ 和 $a_p$。&emsp;&emsp;&emsp;&emsp;看大题解&emsp;&emsp;E：枚举 $m\\cdot a_1$（枚举总量是 $O(n \\ln n)$），这会对 $[ma_1+3,ma_1+2m-3]$ 这一段的 $n$ 产生一个类似于等差数列的贡献，那么打上差分标记，再求个前缀和，就得到答案了&emsp;&emsp;G：大力打牌题&emsp;&emsp;I：视为 $a_i$ 与 $b_i$ 连边，每个连通块如果有环那么每个点都能选上，否则恰有一个点不能选&emsp;&emsp;K：第一问就是 $b_1$，第二问贪心选最大的前缀和&emsp;&emsp;BCFHJ： 2020牛客多校（第九场）&emsp;&emsp;A：队友说是沙雕题&emsp;&emsp;B：树形 dp，收益$\\ge$代价的按代价从小到大做，收益$&lt;$代价的按收益从大到小做&emsp;&emsp;*C：求“长度平方”即考虑点对的贡献，右点往右移，用线段树维护左点的贡献，这是个区间 $\\times 2$ 和区间求和&emsp;&emsp;^E：推推式子，for 一遍的事 把你骗去写类欧了&emsp;&emsp;F：简单的滑窗处理&emsp;&emsp;*G：考场想法：大力树链剖分，没写完不知道行不行&emsp;&emsp;&emsp;&emsp;题解解法：时间分治+可撤销并查集+维护一个连通块的相邻连通块大小之和，相当于连通块在树上的“儿子”之和 + “父亲”&emsp;&emsp;*H：每个间隔都是形如 $\\frac{1}{1-cx}$ 的多项式。分治算出分母，然后多项式求逆&emsp;&emsp;I：找最小的非 $0$ 数作为其中一个乘数，剩下的作为另一个乘数&emsp;&emsp;J：$O(n^3)$ 随便搞搞&emsp;&emsp;K：枚举终点&emsp;&emsp;GL： 2020牛客多校（第十场）&emsp;&emsp;*A：$\\times 2$ 关系会形成很多个环，一个环 $\\times 3$ 会通向另一个环，因此可以直接贪心 $\\times 2$，不行就 $\\times 3$&emsp;&emsp;D：&emsp;&emsp;E：倒着维护一个单调递增的栈&emsp;&emsp;J：day7E 弱化 树形 dp 用 KM 转移&emsp;&emsp;BCFGHI： 2021牛客多校（第十场）&emsp;&emsp;A：给字符串排序建 trie，trie 上要合并掉单链&emsp;&emsp;*D：通过直径中心往外加叶子的顺序进行 dp&emsp;&emsp;*E：六合一很好玩吗 king、Rook 是平凡的，Knight 只需记录离边界的距离，Queen、Bishop 维护 $cnt_{i,j}$ 表示有 $j$ 侧是 $\\ge i$ 的维数。&emsp;&emsp;F：队友说是沙雕题&emsp;&emsp;G：如果选定一群人最后或者的话，概率是可以列个式子的，然后再推个容斥系数&emsp;&emsp;H：按 1 的奇偶性染色&emsp;&emsp;*J：每个点能照亮的是一段区间，所以是环形线段覆盖，破环为链然后倍增&emsp;&emsp;*K：枚举竖直方向步数把两维独立，然后每一维用暴力+对称容斥进行根号平衡&emsp;&emsp;BCI： 2021牛客多校（第四场）&emsp;&emsp;*A：每个子树的生成函数是儿子的积加上 $\\frac{1}{1-x^{a_i}}$ 再减去前 $c_i$ 项&emsp;&emsp;*B：设 $a_i$ 表示序列长度大于 $i$ 的概率，则 $a_i$ 的生成函数为 $\\prod_{i=1}^n \\frac{1}{1-p_ix}$&emsp;&emsp;C：假设 $a$ 最小，先让三个串开头都是 ‘a’，问题归约成 $$，让 $s_1$ 剩下的全放 ‘b’、$s_2$ 剩下的全放 ‘c’、$s_3$ 根据限制放 ‘b’’c’’d’ 即可&emsp;&emsp;*D：地方撒&emsp;&emsp;E：以 1 为根，产生 $n$ 个限制，每个限制形如 $x \\oplus w_i \\in [l_i,r_i]$，这对 $x$ 来说有 $\\log$ 个合法区间，所有这些区间覆盖在数轴上，被覆盖 $n$ 次的位置就是合法的 $x$ 取值&emsp;&emsp;^F：无论如何操作对于“点数+边数”都是减少奇数个，因此判断 $n+m$ 奇偶性即可&emsp;&emsp;*G：考虑组合意义，转化成给 $D+nk$ 个有标号球染色，每种颜色至少 $k$ 个，的方案数，容斥 dp&emsp;&emsp;*H：枚举 $\\gcd(j,k)$ 推式子&emsp;&emsp;IJ：队友说是沙雕题 2021牛客多校（第二场）&emsp;&emsp;CDFIK：队友说是沙雕题&emsp;&emsp;*B：列出式子来，组合数求前缀和用递推&emsp;&emsp;*G：如果区间 $A$ 包含了区间 $B$，那么区间 $A$ 要么自成一组，要么与 $B$ 同一组（相当于扔掉），因此没有包含关系的区间就是滑窗的，排序，dp&emsp;&emsp;J：每个质数的贡献单独考虑，是 $p^{\\sum_{c}\\binom{p^c的倍数的数量}{c}}$，过程类似埃式筛，要用欧拉降幂&emsp;&emsp;L：按度数是否 $&gt;\\sqrt{2m}$ 分为大点和小点，小点更新时将更新信息推送给邻居，每个点询问的时候从小邻居获得更新信息（什么时候超过了自己），从大邻居的预处理中获得什么时候超过了自己&emsp;&emsp;AEH： AstarAstar 2019 复赛&emsp;&emsp;1001：显然每个节点要么选 $l_i$，要么选 $r_i$&emsp;&emsp;1002：假设 $c \\leq a \\leq b \\leq d$，那么 $\\frac{a-c}{b-a}$、$\\frac{d-b}{b-a}$ 必须是整数，且两者二进制下的 $1$ 恰好错开&emsp;&emsp;1003：中序遍历，若根最小且左右 $size$ 不同，则谁 $size$ 小谁先走，否则谁含有标号最小的点谁就先走&emsp;&emsp;*1004：设 $f_{i,q}$ 表示第 $i$ 个数，值选在 $q([l,r])$ 这个区间时，每一种选法的方案数。区间数量总共是 $O(n)$ 的 Astar 2020 初赛（第一场）&emsp;&emsp;1001 1002 1003 1004：略&emsp;&emsp;1005：每个黑格子都可以独立算贡献，最终推式子得到答案为 $\\frac{a_1+a_n}{4}$&emsp;&emsp;1006：二分第 $k$ 小的权值，然后算小于等于这个权值的点的权值和，再减去多的&emsp;&emsp;*1007：二分时间 $t$，于是所有格子按照“能到达哪些窗户”分为 $2^k$ 类，算出每一类的数量，网络流判一下&emsp;&emsp;*1008：powerful number&emsp;&emsp;&emsp;&emsp;看大题解 Astar 2020 复赛&emsp;&emsp;1001：$m-(\\frac{100m}{p}-1)\\frac{q}{100}$&emsp;&emsp;1002：+1 只能用一次，枚举用来 +1 的前缀&emsp;&emsp;1003：最大值：每 $l$ 个数，最后的 $k$ 位倒序放最大的。最小值同理&emsp;&emsp;*1005：解法一：Alice 的 $m$ 次攻击视作 $m$ 个挡板，那么每个间隙都是一个生成函数。最后要泰勒展开，不能上多项式板子&emsp;&emsp;&emsp;&emsp;解法二：dp 推一推，是个简单的组合数计数&emsp;&emsp;&emsp;&emsp;看大题解&emsp;&emsp;1004 1006： Code+Code+第七届其他学军信友队趣味网络邀请赛&emsp;&emsp;A：&emsp;&emsp;B：方法一：点分&emsp;&emsp;&emsp;&emsp;方法二：直接每个点找一个离它最远的点（在直径上）算答案即可&emsp;&emsp;*C：区间 dp，先用完全背包算出 $d_x$ 表示走 $x$ 距离的最小花费，然后 dp 时一个区间的转移必然要转移到这个区间被划分开，因此有用的区间一定是一个段的前缀或后缀，因此有用的区间是 $O(n)$ 的&emsp;&emsp;D：$h_m=$最大的 $2^k$ 使得 $2^k|m$。枚举 $2^k$ 算贡献，转化成求 $[1,n]$ 每个数的约数个数和，分块+卡常 第三届上海理工大学程序设计竞赛&emsp;&emsp;ABC：队友说是沙雕题&emsp;&emsp;^D：一条边 $(x,y)$ 的权值等价于 $\\text{make_pair}(\\max(x,y),\\min(x,y))$，因此 MST 也是唯一的&emsp;&emsp;E：Dijkstra 求出排列 $[1,2,\\cdots,8]$ 到其他排列的最短路，然后对于原序列，枚举一种置换，算答案&emsp;&emsp;*F：构造 $k=1$ 的时候 $(2,2\\times3,5,3\\times 5)$，$k&gt;1$ 的时候把这个东西复制 $k$ 份，然后修正，即每组的 $2\\times3$ 不能抢后面的 $5$、每组的 $3\\times5$ 不能抢后面的 $2$。&emsp;&emsp;G：单调栈&emsp;&emsp;H：每个格子的贡献取决于最后一次修剪&emsp;&emsp;*I：prufer 序 dp，初始连通块缩起来当一个点考虑&emsp;&emsp;&emsp;&emsp;看大题解&emsp;&emsp;*J：询问所有的 $2\\times2$、$2\\times3$、$3\\times2$ 即可知道任意一对相邻格子是否相等&emsp;&emsp;*K：$k=2$ 时，维护奇数位一棵 treap 和偶数位一棵 treap，操作一个区间相当于两棵 treap 互换子树；$k=3$ 时同理，维护 6 棵 treap 即可&emsp;&emsp;L：只需最后两位是 4 的倍数即可。注意 corner case&emsp;&emsp;M：插头 dp，一个格子有 4 种状态（石头、水、没水的甘蔗、有水的甘蔗） 福州大学第十七届程序设计竞赛&emsp;&emsp;ABCDEF：略&emsp;&emsp;I：先挖掉一种颜色，剩余两种颜色合并连续段，则只有 $O(n)$ 种情况，然后组合数算一下方案数&emsp;&emsp;*J：可删除线性基求交&emsp;&emsp;&emsp;&emsp;看大题解&emsp;&emsp;GH：","categories":[{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[]},{"title":"【2019 Wannafly Winter Camp Day5 C】Division 题解","slug":"【2019 Wannafly Winter Camp Day5 C】Division 题解","date":"2019-06-26T14:51:22.000Z","updated":"2024-04-24T03:59:22.811Z","comments":true,"path":"【2019 Wannafly Winter Camp Day5 C】Division 题解/","link":"","permalink":"http://kqp.world/%E3%80%902019%20Wannafly%20Winter%20Camp%20Day5%20C%E3%80%91Division%20%E9%A2%98%E8%A7%A3/","excerpt":"题目大意&emsp;&emsp;你有一个数列 $a_1,a_2,\\cdots,a_n$。你可以进行这样的一次操作，每次选择数列中其中一个数然后将其除 $2$ 下取整，也就是选择一个数 $a_i$，变成 $\\lfloor \\frac{a_i}{2} \\rfloor$。&emsp;&emsp;一共有 $q$ 个询问，每次你考虑数列中 $[l,r]$ 这段数，即 $a_l,a_{l+1},a_{l+2},\\cdots,a_r$，对这些数字进行不超过 $k$ 次操作，这些数字的总和最小值可能是多少。 &emsp;&emsp;$1 \\leq n \\leq 10^5,\\ 1 \\leq q \\leq 5*10^5$&emsp;&emsp;$1 \\leq a_i \\leq 10^9,\\ 0 \\leq k \\leq 10^9$&emsp;&emsp;5000 ms，256 MB","text":"题目大意&emsp;&emsp;你有一个数列 $a_1,a_2,\\cdots,a_n$。你可以进行这样的一次操作，每次选择数列中其中一个数然后将其除 $2$ 下取整，也就是选择一个数 $a_i$，变成 $\\lfloor \\frac{a_i}{2} \\rfloor$。&emsp;&emsp;一共有 $q$ 个询问，每次你考虑数列中 $[l,r]$ 这段数，即 $a_l,a_{l+1},a_{l+2},\\cdots,a_r$，对这些数字进行不超过 $k$ 次操作，这些数字的总和最小值可能是多少。 &emsp;&emsp;$1 \\leq n \\leq 10^5,\\ 1 \\leq q \\leq 5*10^5$&emsp;&emsp;$1 \\leq a_i \\leq 10^9,\\ 0 \\leq k \\leq 10^9$&emsp;&emsp;5000 ms，256 MB \\\\ \\\\ \\\\题解&emsp;&emsp;首先一个数字最多除 $\\log$ 次，$\\log$ 次以后就变成 $0$ 了。&emsp;&emsp;然后 $a_i$ 每除一次 $2$，就相当于减去一个 $\\lceil \\frac{a_i}{2} \\rceil$。这样的话就可以把每个 $a_i$ 拆成 $\\log$ 个数字之和。&emsp;&emsp;那么就相当于有 $n$ 个物品，每个物品可以拆成 $\\log$ 个小物品，每个小物品有一个收益。然后每次询问一个区间，取 $k$ 个小物品，能获得的最大收益是多少。 &emsp;&emsp;没啥特殊情况的话那就是区间前 $k$ 大和，主席树一下就行了。 &emsp;&emsp;然后发现空间只有 256 MB 各凭本事卡内存——杜老师 &emsp;&emsp;题解的卡内存的姿势还是有丶巧妙的。 &emsp;&emsp;题解的姿势就是，把这个主席树拆开来，拆成若干个小一点的主席树。&emsp;&emsp;怎么拆呢？就是把小物品按其价值的二进制位数分层，分成 $\\log$ 层，每个大物品在每一层只会有一个小物品（每除一次有一个）。这样的话，每一层就只有 $n$ 个物品了，那么每一层的主席树就只有 $O(n \\log a)$ 那么大了。&emsp;&emsp;然后求区间前 $k$ 大和，倒着枚举层（从高位到低位），每个询问只会在某一层处跑线段树二分，因此时间也还是 $O(q \\log a)$ 的。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include&lt;bits/stdc++.h&gt;#define fo(i,a,b) for(int i=a;i&lt;=b;i++)#define fd(i,a,b) for(int i=a;i&gt;=b;i--)using namespace std;typedef long long LL;const int maxn=1e5+5, maxq=5e5+5, MX=31;int n,q,maxw,maxx,l[maxq],r[maxq],c[maxq];LL s[maxn];vector&lt;pair&lt;int,int&gt;&gt; v[MX+5];int root[maxn],tot,son[maxn*40][2],num[maxn*40];LL sum[maxn*40];int New()&#123; tot++; num[tot]=sum[tot]=son[tot][0]=son[tot][1]=0; return tot;&#125;int tr_xg(int k,int last,int l,int r,int x)&#123; while (l&lt;r) &#123; sum[k]=sum[last]+x, num[k]=num[last]+1; int t1=(l+r)&gt;&gt;1; if (x&lt;=t1) &#123; son[k][0]=New(); son[k][1]=son[last][1]; k=son[k][0], last=son[last][0], r=t1; &#125; else &#123; son[k][0]=son[last][0]; son[k][1]=New(); k=son[k][1], last=son[last][1], l=t1+1; &#125; &#125; sum[k]=sum[last]+x, num[k]=num[last]+1;&#125;LL tr_cx(int k,int last,int l,int r,int x)&#123; LL re=0; while (l&lt;r) &#123; int t1=(l+r)&gt;&gt;1; if (num[son[k][1]]-num[son[last][1]]&gt;=x) k=son[k][1], last=son[last][1], l=t1+1; else &#123; re+=sum[son[k][1]]-sum[son[last][1]]; x-=num[son[k][1]]-num[son[last][1]]; k=son[k][0], last=son[last][0], r=t1; &#125; &#125; return (x) ?re+(sum[k]-sum[last])/(num[k]-num[last])*x :re ;&#125;LL ans[maxq];int main()&#123; scanf(&quot;%d %d&quot;,&amp;n,&amp;q); fo(i,1,n) &#123; scanf(&quot;%lld&quot;,&amp;s[i]); maxx=(s[i]&gt;maxx) ?s[i] :maxx ; int w=0; for(int x=s[i]; x; x&gt;&gt;=1) w++; maxw=max(maxw,w-1); for(int cnt=w-1, x=s[i]; x; cnt--, x&gt;&gt;=1) v[cnt].push_back(make_pair(i,x-(x&gt;&gt;1))); s[i]+=s[i-1]; &#125; fo(i,1,q) &#123; scanf(&quot;%d %d %d&quot;,&amp;l[i],&amp;r[i],&amp;c[i]); ans[i]=s[r[i]]-s[l[i]-1]; &#125; fd(i,maxw,0) &#123; tot=-1; int last=New(); memset(root,0,sizeof(root)); for(auto p:v[i]) &#123; tr_xg(root[p.first]=New(),last,1,maxx,p.second); last=root[p.first]; &#125; fo(i,1,n) if (!root[i]) root[i]=root[i-1]; fo(j,1,q) if (c[j]) &#123; int cnt=num[root[r[j]]]-num[root[l[j]-1]]; if (cnt&gt;=c[j]) &#123; ans[j]-=tr_cx(root[r[j]],root[l[j]-1],1,maxx,c[j]); c[j]=0; &#125; else &#123; c[j]-=cnt; ans[j]-=sum[root[r[j]]]-sum[root[l[j]-1]]; &#125; &#125; &#125; fo(i,1,q) printf(&quot;%lld\\n&quot;,ans[i]);&#125;","categories":[{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[{"name":"算法_线段树","slug":"算法-线段树","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E7%BA%BF%E6%AE%B5%E6%A0%91/"}]},{"title":"常系数线性递推的线性代数推导","slug":"LRCC_algebra","date":"2019-06-05T12:03:07.000Z","updated":"2024-04-24T03:59:22.783Z","comments":true,"path":"LRCC_algebra/","link":"","permalink":"http://kqp.world/LRCC_algebra/","excerpt":"&emsp;&emsp;// 这不是竞赛里那个多项式取模的东西，是离散课本里的特征根法&emsp;&emsp;抱着在离散课装逼的心态挖了这个坑，填了两个星期","text":"&emsp;&emsp;// 这不是竞赛里那个多项式取模的东西，是离散课本里的特征根法&emsp;&emsp;抱着在离散课装逼的心态挖了这个坑，填了两个星期 &emsp;&emsp;“推导”和“证明”这两个概念是有区别的，后者只是证明了这些结论是对的，而前者则是要说明它们的来源。但是到了“无重根”的部分，似乎我也无法完成“推导”而只能转向“证明”了。如果有 dalao 不吝赐教，我将不胜感激。 1. 递推中的线代1.1 递推的本质&emsp;&emsp;考虑斐波那契数列 $f_n=f_{n-1}+f_{n-2}$，我们构造一个向量 $\\vec v=\\begin{bmatrix}f_{n-1} \\\\ f_{n-2}\\end{bmatrix}$，把它乘一个矩阵 $A=\\begin{bmatrix}1&amp;1 \\\\ 1&amp;0\\end{bmatrix}$，会得到什么呢？ A\\vec v=\\begin{bmatrix}1&1 \\\\ 1&0\\end{bmatrix}\\begin{bmatrix}f_{n-1} \\\\ f_{n-2}\\end{bmatrix}=\\begin{bmatrix}f_{n-1}+f_{n-2} \\\\ f_{n-1}\\end{bmatrix}=\\begin{bmatrix}f_n \\\\ f_{n-1}\\end{bmatrix} \\tag 1&emsp;&emsp;会发现 $f$ 的下标往前推进了一位！这就产生了递推。 &emsp;&emsp;事实上，对于递推关系 $f_n=\\sum_{i=1}^k a_if_{n-i}$，都可以这样写： A\\vec v= \\begin{bmatrix} a_1 & a_2 & \\cdots & a_{k-1} & a_k \\\\ 1 & 0 & \\cdots & 0 & 0 \\\\ 0 & 1 & \\cdots & 0 & 0 \\\\ \\vdots & \\vdots & \\ddots & \\vdots & \\vdots \\\\ 0 & 0 & \\cdots & 1 & 0 \\end{bmatrix} \\begin{bmatrix}f_{n-1} \\\\ f_{n-2} \\\\ f_{n-3}\\\\ \\vdots \\\\ f_{n-k}\\end{bmatrix} =\\begin{bmatrix}\\sum_{i=1}^k a_if_{n-i} \\\\ f_{n-1} \\\\ f_{n-2}\\\\ \\vdots \\\\ f_{n-k+1}\\end{bmatrix} =\\begin{bmatrix}f_{n} \\\\ f_{n-1} \\\\ f_{n-2}\\\\ \\vdots \\\\ f_{n-k+1}\\end{bmatrix} \\tag 2&emsp;&emsp;这个 $A$ 矩阵叫做转移矩阵。如果给定了前 $k$ 项的值 $f_0$~$f_{k-1}$，则可以构造初始向量 $\\vec{v_0}=\\begin{bmatrix}f_{k-1} \\\\ f_{k-2} \\\\ \\vdots \\\\ f_0\\end{bmatrix}$，那么 $A\\vec{v_0}$ 就可以得到 $\\begin{bmatrix}f_{k} \\\\ f_{k-1} \\\\ \\vdots \\\\ f_1\\end{bmatrix}$，$A^n\\vec{v_0}$ 就可以得到 $\\begin{bmatrix}f_{n+k-1} \\\\ f_{n+k-2} \\\\ \\vdots \\\\ f_n\\end{bmatrix}$。也就是说，如果我们要求 $f_n$，只需要求 $A^n\\vec{v_0}$，然后拿最底下那个元素就可以了。 1.2 解的线性性与解空间&emsp;&emsp;若数列 $\\{f_n\\}$ 满足递推关系 $f_n=\\sum_{i=1}^k a_if_{n-i}$，则称数列 $\\{f_n\\}$ 为该递推的一个解。显然，有如下性质： 若 $\\{f_n\\}$ 为一个解，则对任意常数 $c$，$\\{cf_n\\}$ 也是一个解； 若 $\\{f_n\\},\\{g_n\\}$ 都是解，那么 $\\{f_n+g_n\\}$ 也是一个解。 &emsp;&emsp;因此，满足该递推关系的解具有线性性。 &emsp;&emsp;只有递推关系的话解有无穷多个。但如果给出了初始向量，那么就可以递推出每一项，解也就唯一确定了，因此解是由初始向量决定的，并且是 one-to-one 的，可以表示为 $\\{f_n\\}=T(\\vec{v_0})$。 &emsp;&emsp;那么只要证明了以下两点，就可以证明这个 $T$ 是线性变换了： $\\forall c \\in \\mathbb{R},~\\{cf_n\\}=T(c\\vec{v_0})$ 对于两组初始向量 $\\vec{u_0},\\vec{v_0}$，有 $T(\\vec{u_0})+T(\\vec{v_0})=T(\\vec{u_0}+\\vec{v_0})$ &emsp;&emsp;这两点都可以根据递推关系对 $f_n$ 进行归纳而证得。因此，该变换 $\\{f_n\\}=T(\\vec{v_0})$ 是线性变换。 &emsp;&emsp;而由于 $T$ 是双射的，因此 $\\dim(\\{f_n\\})=\\dim(\\vec{v_0})=k$，即解空间是 $k$ 维的。 2. 齐次2.1 特征方程与特征向量&emsp;&emsp;考虑齐次递推关系 $f_n=\\sum_{i=1}^k a_if_{n-i}$，前面说过这等价于求 $A^n\\vec{v_0}$。我们来特征一波： \\det(A-\\lambda I)= \\begin{vmatrix} a_1-\\lambda & a_2 & \\cdots & a_{k-1} & a_k \\\\ 1 & -\\lambda & \\cdots & 0 & 0 \\\\ 0 & 1 & \\cdots & 0 & 0 \\\\ \\vdots & \\vdots & \\ddots & \\vdots & \\vdots \\\\ 0 & 0 & \\cdots & 1 & -\\lambda \\end{vmatrix} \\tag 3&emsp;&emsp;按第一行展开，得： \\begin{aligned} \\det(A-\\lambda I)&=(a_1-\\lambda)(-\\lambda)^{k-1}-a_2(-\\lambda)^{k-2}+a_3(-\\lambda)^{k-3}+\\cdots+a_k \\\\ &=(-1)^k[\\lambda^k-\\sum_{i=1}^k a_i\\lambda^{k-i}] \\end{aligned} \\tag 4&emsp;&emsp;因此特征方程为： \\lambda^k-\\sum_{i=1}^k a_i\\lambda^{k-i}=0 \\tag 5&emsp;&emsp;这就是递推的特征方程的由来。 &emsp;&emsp;有了特征方程就可以解出特征根，然后就看特征向量，即解 $(A-\\lambda I)\\vec v=0$。我们给 $A-\\lambda I$ （$(3)$ 式）做高斯消元，第 1 行减去第 2 行的 $a_1-\\lambda$ 倍，得： \\begin{bmatrix} 0 & -\\lambda^2+a_1\\lambda+a_2 & \\cdots & a_{k-1} & a_k \\\\ 1 & -\\lambda & \\cdots & 0 & 0 \\\\ 0 & 1 & \\cdots & 0 & 0 \\\\ \\vdots & \\vdots & \\ddots & \\vdots & \\vdots \\\\ 0 & 0 & \\cdots & 1 & -\\lambda \\end{bmatrix}&emsp;&emsp;再用第 1 行减去第 3 行的 $-\\lambda^2+a_1\\lambda+a_2$ 倍，重复下去，最终会得到： \\begin{bmatrix} 0 & 0 & \\cdots & 0 & \\lambda^k-\\sum_{i=1}^k a_i\\lambda^{k-i} \\\\ 1 & -\\lambda & \\cdots & 0 & 0 \\\\ 0 & 1 & \\cdots & 0 & 0 \\\\ \\vdots & \\vdots & \\ddots & \\vdots & \\vdots \\\\ 0 & 0 & \\cdots & 1 & -\\lambda \\end{bmatrix}&emsp;&emsp;代入具体的特征根 $\\lambda_i$，第 1 行就全都是 $0$ 了，因此解为 $\\vec{x}=c\\begin{bmatrix}\\lambda^{k-1} \\\\ \\vdots \\\\ \\lambda^2 \\\\ \\lambda \\\\ 1 \\end{bmatrix}$。取 $c=1$ 作为特征向量 $\\vec{v_i}$。 2.2 无重根&emsp;&emsp;现在假设特征方程 $(5)$ 有 $k$ 个不同的实数解 $\\lambda_1,\\cdots,\\lambda_k$，那么就会有对应的 $k$ 个线性无关的特征向量 $\\vec{v_1},\\cdots,\\vec{v_k}$，那么就可以将初始向量表示成特征向量的线性组合： \\vec{v_0}=\\sum_{i=1}^k\\beta_i\\vec{v_i} \\tag 6&emsp;&emsp;因此： \\begin{aligned} A^n\\vec{v_0} &=A^n\\sum_{i=1}^k\\beta_i\\vec{v_i} \\\\ &=\\sum_{i=1}^k\\beta_iA^n\\vec{v_i} \\\\ &=\\sum_{i=1}^k\\beta_i\\lambda_i^n\\vec{v_i} \\end{aligned} \\tag 7&emsp;&emsp;若只看向量的最底下的元素在这个式子中的计算，$A^n\\vec{v_0}$ 的最底下的元素是 $f_n$，$\\vec{v_i}$ 的最底下的元素是 $1$，可以得出： f_n=\\sum_{i=1}^k\\beta_i\\lambda_i^n \\tag 8&emsp;&emsp;这就得出了齐次线性递推的计算公式。 &emsp;&emsp;如果 $\\vec{v_0}$ 是给定的，即给出了初值 $f_0$~$f_{k-1}$，那么可以解线性方程组 $(6)$： \\begin{cases} f_0 &= \\beta_1+\\beta_2+\\cdots+\\beta_k \\\\ f_1 &= \\beta_1\\lambda_1+\\beta_2\\lambda_2+\\cdots+\\beta_k\\lambda_k \\\\ \\vdots \\\\ f_{k-1} &= \\beta_1\\lambda_1^{k-1}+\\beta_2\\lambda_2^{k-1}+\\cdots+\\beta_k\\lambda_k^{k-1} \\end{cases} \\tag 9&emsp;&emsp;得到待定系数的 $\\beta$ 值。 &emsp;&emsp;如果 $\\vec{v_0}$ 不是给定的，那么可以注意到，$\\sum_{i=1}^k\\beta_i\\vec{v_i}$ 实际上表示了任意 $\\vec{v_0}$，因为这些特征向量可以线性组合出任意 $k$ 维向量。因此，$(8)$ 式表示了一般解。 &emsp;&emsp;由此又可以得出，$\\{f_n|f_n=\\lambda_1^n\\}$、$\\{f_n|f_n=\\lambda_2^n\\}$、……、$\\{f_n|f_n=\\lambda_k^n\\}$ 都是解，并且是线性无关的，因此是一组基。这就印证了“解空间是 $k$ 维的”这个结论。 2.3 有重根&emsp;&emsp;有重根的话，就是说特征向量的个数不够 $k$ 个了，不能直接组合出初始向量了。但是解空间依然是 $k$ 维的，因此如果能构造出 $k$ 个线性无关的解，那么就仍然能够推出公式来。 &emsp;&emsp;特征方程 $(5)$ 可以改写为如下特征多项式： \\begin{align} p(\\lambda)&=\\sum_{i=0}^kd_i\\lambda^{k-i} \\tag{10} \\\\ &=\\prod_i(\\lambda-\\lambda_i)^{m_i} \\tag{11} \\end{align}&emsp;&emsp;其中 $d_0=1,~d_i=-c_i(i&gt;1)$。对 $(11)$ 式求导可得下面这个性质： Lemma 1：若 $\\lambda_0$ 为重根，重数为 $m$，则特征多项式 $p(\\lambda)=\\sum_{i=0}^kd_i\\lambda^{k-i}$ 在 $\\lambda_0$ 处的 $1$ 至 $m$ 阶导都为 $0$，且 $m+1$ 阶导不为 $0$。 &emsp;&emsp;根据递推关系 $f_n=\\sum_{i=1}^k a_if_{n-i}$ 变形可得，数列 $\\{f_n\\}$ 为一个解当且仅当 \\sum_{i=0}^k d_if_{n-i}=0 \\tag{12}&emsp;&emsp;现假设有特征根 $\\lambda$，且为二重根，那么 $\\{f_n|f_n=\\lambda^n\\}$ 是递推关系的一个解。那么有 \\begin{align} &&\\sum_{i=0}^k d_i\\lambda^{n-i}&=0 \\tag{13} \\\\ \\therefore&& \\lambda^{n-k}\\sum_{i=0}^k d_i\\lambda^{k-i}&=0 \\\\ \\therefore&& \\lambda^{n-k}p(\\lambda)&=0 \\\\ \\therefore&& \\lambda^{n-k+1}p(\\lambda)&=0 \\tag{14} \\end{align}&emsp;&emsp;根据 Lemma 1，这个东西求导还是 $0$，那我给它逐项求导，得 \\sum_{i=0}^k d_i(n-i+1)\\lambda^{n-i}=0 \\tag{15}&emsp;&emsp;$(15)$ 式减 $(13)$ 式便得 \\sum_{i=0}^k d_i(n-i)\\lambda^{n-i}=0 \\tag{16}&emsp;&emsp;即可得到 $\\{f_n|f_n=n\\lambda^n\\}$ 为一个解。 &emsp;&emsp;如果 $\\lambda$ 为三重根，那么可以对 $(16)$ 式做同样操作（两边乘 $\\lambda$，求导，然后减去 $(16)$ 式），即可得到 $\\{f_n|f_n=n^2\\lambda^n\\}$ 也是解。如此下去，若 $\\lambda$ 为 $m$ 重根，则 $\\{f_n|f_n=n^j\\lambda^n\\}~(0 \\leq j &lt; m)$ 都是解。 &emsp;&emsp;也就是说，$m$ 重的特征根可以弄出 $m$ 个解，总共就有 $k$ 个解。这些解的形式是关于 $n$ 的多项式，因此它们仍然是线性无关的。那我们的这组基就做出来了，也就能得到那个解的公式了： f_n=\\sum_i(\\beta_{i0}+\\beta_{i1}n+\\cdots+\\beta_{i(m_i-1)}n^{m_i-1})\\lambda_i^n \\tag{17}3. 非齐次&emsp;&emsp;现在是递推关系 $f_n=\\sum_{i=1}^k a_if_{n-i}+P(n)s^n$，其中 $P(n)$ 为关于 $n$ 的多项式，设 $P(n)=\\sum_{i=0}^t p_in^i$。 &emsp;&emsp;根据解的线性性，解的形式应当是通解加特解。具体来说，先根据 $(12)$ 式变形有如下性质： Lemma 2：数列 $\\{f_n\\}$ 为 $f_n=\\sum_{i=1}^k a_if_{n-i}+P(n)s^n$ 的一个解，等价于 $\\forall n \\geq 0,~\\vec v=\\begin{bmatrix}f_{n+k} \\\\ f_{n+k-1} \\\\ \\vdots \\\\ f_n\\end{bmatrix}$ 满足 $\\vec{d}\\cdot\\vec{v}=P(n)s^n$，其中 $\\vec d=\\begin{bmatrix}d_k \\\\ d_{k-1} \\\\ \\vdots \\\\ d_0\\end{bmatrix}$ &emsp;&emsp;假设解出了 $f_n=\\sum_{i=1}^k a_if_{n-i}$ 的通解 $\\{f_n^{(h)}\\}$，以及 $f_n=\\sum_{i=1}^k a_if_{n-i}+P(n)s^n$ 的特解 $\\{f_n^{(p)}\\}$，对于 $\\forall n \\geq 0$，按 Lemma 2 的写法分别写成向量 $\\vec{v^{(h)}}$ 和 $\\vec{v^{(p)}}$，那么有 \\begin{align} &&\\vec{d}\\cdot\\vec{v^{(h)}}&=0 \\\\ &&\\vec{d}\\cdot\\vec{v^{(p)}}&=P(n)s^n \\\\ \\therefore&&\\vec{d}\\cdot(\\vec{v^{(h)}}+\\vec{v^{(p)}})&=P(n)s^n \\tag{18} \\end{align}&emsp;&emsp;因此解的形式为通解加特解。 &emsp;&emsp;通解的解法已经有了，剩下的就是要构造一组特解，满足 $f_n=\\sum_{i=1}^k a_if_{n-i}+P(n)s^n$。 &emsp;&emsp;最好的方法，就是跟着它的形式：令 $f_n=Q(n)s^n$，其中 $Q(n)$ 是与 $P(n)$ 同次数的多项式，即 $Q(n)=\\sum_{i=0}^t q_in^i$。然后代入递推式解出 $q$值： Q(n)s^n=\\sum_{i=1}^ka_iQ(n-i)s^{n-i}+P(n)s^n \\tag{19}&emsp;&emsp;但如果 $s$ 是特征根的话，会出现一些问题：设 $s$ 为 $m$ 重根，根据 2.3，会有 $\\sum_{i=0}^k d_i(n-i)^j\\lambda^{n-i}=0$ 对于 $\\forall j\\in[0,m)$ 成立，那么会出现 $q_0$~$q_{m-1}$ 被完全消掉了，方程 $(19)$ 变成 $s^kp_tn^t+S(n)=0$（$S(n)$ 表示次数小于 $t$ 的多项式），这显然是不成立的。 &emsp;&emsp;解决方法就是，给 $f_n$ 再乘多些 $n$，变成 $f_n=n^mQ(n)s^n$，把 $n$ 的次数顶上去，顶到 $n^m$ 就相当于 $\\sum_{i=0}^k d_i(n-i)^{j+m}\\lambda^{n-i}$，这就不会等于 $0$，就不会有系数被消掉了。 4. 参考资料[1]第二节 常系数线性齐次递推关系 https://wenku.baidu.com/view/50c3348b856a561253d36f43.html","categories":[{"name":"随手academy","slug":"随手academy","permalink":"http://kqp.world/categories/%E9%9A%8F%E6%89%8Bacademy/"}],"tags":[]},{"title":"【AtCoder Grand 024E】Sequence Growing Hard 题解","slug":"【AtCoder Grand 024E】Sequence Growing Hard 题解","date":"2019-05-23T13:12:04.000Z","updated":"2024-04-24T03:59:22.823Z","comments":true,"path":"【AtCoder Grand 024E】Sequence Growing Hard 题解/","link":"","permalink":"http://kqp.world/%E3%80%90AtCoder%20Grand%20024E%E3%80%91Sequence%20Growing%20Hard%20%E9%A2%98%E8%A7%A3/","excerpt":"题目大意&emsp;&emsp;求满足以下条件的序列集合 $\\{A_0,A_1,…,A_N\\}$ 的个数，模 $M$： $A_i$ 长度为 $i$，其中每个元素都是 $[1,K]$ 内的一个正整数。 对于 $i \\geq 1$，$A_i$ 是由 $A_{i-1}$ 在某个位置插入一个数得到的。 对于 $i \\geq 1$，$A_i$ 字典序大于 $A_{i-1}$ &emsp;&emsp;$N,K \\leq 300,~M \\leq 10^9$","text":"题目大意&emsp;&emsp;求满足以下条件的序列集合 $\\{A_0,A_1,…,A_N\\}$ 的个数，模 $M$： $A_i$ 长度为 $i$，其中每个元素都是 $[1,K]$ 内的一个正整数。 对于 $i \\geq 1$，$A_i$ 是由 $A_{i-1}$ 在某个位置插入一个数得到的。 对于 $i \\geq 1$，$A_i$ 字典序大于 $A_{i-1}$ &emsp;&emsp;$N,K \\leq 300,~M \\leq 10^9$ \\\\ \\\\ \\\\GG做法&emsp;&emsp;假设现在有了一个最终的序列 $A_N$，考虑有多少种生成到它的序列集合。&emsp;&emsp;相当于每次删掉一个数。由于删掉之后字典序要变小，所以对于删的数，要么它右边比它小，要么它右边跟它相等，且一路过去最终比它小，但是为了避免计重，相等的这种情况不用理会。也就是说，对于单调不降的子段，它必须从后往前删。因此，如果把这个最终序列 $A_N$ 分解成若干个单调不降的极长子段，每段长 $len_i$，那么它的方案数就是 \\frac{N!}{\\prod len_i !}&emsp;&emsp;这样就可以 dp 这个 $A_N$ 了。设 $f_{i,j}$ 表示长度为 $i$ 的序列，最后一个元素为 $j$，的方案数。转移就是枚举最后一个极长子段，长度为 $len$，因此转移为 f_{i,j}=\\sum_{len=1}^N \\sum_{j'=2}^{k+1} f_{i-len,j'} \\cdot \\frac{G_{len,j'-1,j}}{len!}&emsp;&emsp;$G_{len,s,t}$ 是指长度为 $len$，开头小于等于$s$，结尾为 $t$ 的单调不降的序列个数，这个就是个挡板，可以预处理。这个各种优化之后就是 $O(n^2k)$ 的啦！ &emsp;&emsp;一切就绪，编辑器，启动！ &emsp;&emsp;。。。&emsp;&emsp;。。。&emsp;&emsp;（一段时间之后。。。 &emsp;&emsp;woc 模数是他给的，不是质数就没有逆元了？？？？？ 题解&emsp;&emsp;所以要搞个不用除法的 dp。。。 &emsp;&emsp;此处搬一下题解。&emsp;&emsp;就考虑给一个序列插入一个数，同理，它只能插在一个比它小的数的左边。为了方便，假设一开始序列不为空，而是一个 $0$。&emsp;&emsp;假设把 $x$ 插在 $y$ 左边，那么就在树上把 $y$ 设为 $x$ 的父亲。&emsp;&emsp;设 $id_x$ 表示 $x$ 这个节点是第几个插入的，$v_x$ 表示它的值。那么这棵树满足儿子的 $id$ 和 $v$ 都比父亲大。&emsp;&emsp;不同的树与不同的序列集合一一对应，因此就是要求有多少棵树，使得任意儿子的两个权值都比父亲大。&emsp;&emsp;设 $f_{i,j}$ 表示这棵树大小为 $i$，点的 $id$ 为 $1$~$i$，根节点的 $v$ 值为 $j$，的方案数。显然 $id=1$ 的点一定是根节点，它一定有一个儿子是 $id=2$，因此转移就是枚举 $id=2$ 的这棵子树： f_{i,j}=\\sum_{size=1}^{i-1} \\sum_{j'=j+1}^{k} f_{i-size,j} \\cdot f_{size,j'} \\cdot \\binom{i-2}{size-1}&emsp;&emsp;这个 $j’$ 的枚举搞个后缀和去掉，因此时间是 $O(n^2k)$。 代码123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;bits/stdc++.h&gt;#define fo(i,a,b) for(int i=a;i&lt;=b;i++)#define fd(i,a,b) for(int i=a;i&gt;=b;i--)using namespace std;typedef long long LL;const int maxn=305;int n,k;LL mo;LL C[maxn][maxn];void Pre(int n)&#123; fo(i,0,n) &#123; C[i][0]=1; fo(j,1,i) C[i][j]=(C[i-1][j-1]+C[i-1][j])%mo; &#125;&#125;LL f[maxn][maxn],sf[maxn][maxn];int main()&#123; scanf(&quot;%d %d %lld&quot;,&amp;n,&amp;k,&amp;mo); Pre(n); fo(j,0,k) f[1][j]=1, sf[1][j]=k-j+1; fo(i,2,n+1) &#123; fo(j,0,k) &#123; fo(sz,1,i-1) (f[i][j]+=f[i-sz][j]*sf[sz][j+1]%mo*C[i-2][sz-1])%=mo; &#125; sf[i][k]=f[i][k]; fd(j,k-1,1) sf[i][j]=(sf[i][j+1]+f[i][j])%mo; &#125; printf(&quot;%lld\\n&quot;,f[n+1][0]);&#125;","categories":[{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[{"name":"算法_DP","slug":"算法-DP","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-DP/"}]},{"title":"【bzoj3864】Hero meet devil 题解","slug":"【bzoj3864】Hero meet devil 题解","date":"2019-04-25T15:04:29.000Z","updated":"2024-04-24T03:59:22.831Z","comments":true,"path":"【bzoj3864】Hero meet devil 题解/","link":"","permalink":"http://kqp.world/%E3%80%90bzoj3864%E3%80%91Hero%20meet%20devil%20%E9%A2%98%E8%A7%A3/","excerpt":"题目大意&emsp;&emsp;给你一个只由 AGCT 组成的字符串 $S$，对于每个 $0 \\leq i \\leq |S|$，问有多少个只由 AGCT 组成的长度为 $m$ 的字符串 $T$，使得 $LCS(S,T)=i$。 &emsp;&emsp;$|S| \\leq 15,~m \\leq 1000$","text":"题目大意&emsp;&emsp;给你一个只由 AGCT 组成的字符串 $S$，对于每个 $0 \\leq i \\leq |S|$，问有多少个只由 AGCT 组成的长度为 $m$ 的字符串 $T$，使得 $LCS(S,T)=i$。 &emsp;&emsp;$|S| \\leq 15,~m \\leq 1000$ \\\\ \\\\ \\\\题解&emsp;&emsp;直到大学了才初见 dp 套 dp 呢。。这该是有多菜呢？ &emsp;&emsp;假设已经拥有了一个 $T$，则可以 $O(nm)$ 求出 $LCS$： LCS_{i,j}=\\max\\{LCS_{i-1,j},~LCS_{i,j-1},~LCS_{i-1,j-1}+1(S_i==T_j)\\}&emsp;&emsp;并且，对于 $T$ 的某一位（假设第 $j$ 位）的 dp，相邻的两个 $i$ 所对应的 $LCS_{i,j}$ 最多相差 $1$。也就是说，对于某一位 $j$，由 $LCS_{1,j},~LCS_{2,j},~…~,~LCS_{n,j}$ 构成的 dp 状态最多 $2^{15}$ 种。 &emsp;&emsp;现在没有 $T$，则 dp 这个 T。设 $f_{j,s}$ 表示到了 $T$ 的第 $j$ 位，dp 状态为 $s$，的方案数。预处理各方案的转移 $T_{s,k}$（$k\\in\\{A,T,C,G\\}$），就可以 $O(m\\cdot2^{|S|})$ dp 了。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;bits/stdc++.h&gt;#define fo(i,a,b) for(int i=a;i&lt;=b;i++)#define fd(i,a,b) for(int i=a;i&gt;=b;i--)using namespace std;typedef long long LL;const int maxm=1005, maxN=32800;const LL mo=1e9+7;int n,m,N,er[20];char S[20];LL f[2][maxN];int Q,fn[maxm][2],T[maxN][4],cnt[maxN];char tb[4]=&#123;&#x27;A&#x27;,&#x27;G&#x27;,&#x27;C&#x27;,&#x27;T&#x27;&#125;;int main()&#123; fo(i,0,14) er[i]=1&lt;&lt;i; scanf(&quot;%d&quot;,&amp;Q); while (Q--) &#123; scanf(&quot;%s&quot;,S+1); n=strlen(S+1); scanf(&quot;%d&quot;,&amp;m); N=(1&lt;&lt;n)-1; fo(s,0,N) &#123; fo(k,0,3) &#123; fo(i,1,n) fn[i][0]=fn[i-1][0]+((s&amp;er[n-i])&gt;0); fo(i,1,n) fn[i][1]=max(max(fn[i-1][1],fn[i][0]),(S[i]==tb[k])?fn[i-1][0]+1:0); int news=0; fd(i,n,1) fn[i][1]-=fn[i-1][1], news|=(fn[i][1]&lt;&lt;(n-i)); T[s][k]=news; cnt[s]=fn[n][0]; &#125; &#125; memset(f,0,sizeof(f)); f[0][0]=1; int now=0; fo(i,0,m-1) &#123; memset(f[now^1],0,sizeof(f[now^1])); fo(s,0,N) fo(k,0,3) &#123; LL *p=&amp;f[now^1][T[s][k]]; *p+=f[now][s]; *p=(*p&gt;=mo) ?*p-mo :*p ; &#125; now^=1; &#125; fo(i,0,n) &#123; LL ans=0; fo(s,0,N) if (cnt[s]==i) (ans+=f[now][s])%=mo; printf(&quot;%lld\\n&quot;,ans); &#125; &#125;&#125;","categories":[{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[{"name":"算法_DP","slug":"算法-DP","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-DP/"}]},{"title":"【2018icpc Regional Dhaka G】Techland 题解","slug":"【2018icpc Regional Dhaka G】Techland 题解","date":"2019-04-25T12:34:11.000Z","updated":"2024-04-24T03:59:22.805Z","comments":true,"path":"【2018icpc Regional Dhaka G】Techland 题解/","link":"","permalink":"http://kqp.world/%E3%80%902018icpc%20Regional%20Dhaka%20G%E3%80%91Techland%20%E9%A2%98%E8%A7%A3/","excerpt":"题目大意&emsp;&emsp;有一棵 $n$ 个点的树，点编号 $1,\\cdots,n$。有 $Q$ 次操作，操作有三种类型：&emsp;&emsp;$1\\ X\\ L\\ R$：公司 $X$ 在编号属于 $[L,R]$ 的点上各开一家商店。如果该公司曾经有过商店，则它以前的商店全部清除，只算这次的。&emsp;&emsp;$2\\ X$：公司 $X$ 的商店全部清除。&emsp;&emsp;$3\\ C\\ M\\ P_1\\ P_2\\ …\\ P_M$：有个人在 $C$ 号点，他指定了他喜欢的公司为 $P_1,\\cdots,P_M$，你要找到一个离 $C$ 最近的点，使得这个点有他喜欢的公司开的商店。求这个距离。 &emsp;&emsp;单组数据：$n \\leq 50000,\\ Q \\leq 10^5,\\ \\sum m \\leq 10^5$&emsp;&emsp;10 组数据共 10s。","text":"题目大意&emsp;&emsp;有一棵 $n$ 个点的树，点编号 $1,\\cdots,n$。有 $Q$ 次操作，操作有三种类型：&emsp;&emsp;$1\\ X\\ L\\ R$：公司 $X$ 在编号属于 $[L,R]$ 的点上各开一家商店。如果该公司曾经有过商店，则它以前的商店全部清除，只算这次的。&emsp;&emsp;$2\\ X$：公司 $X$ 的商店全部清除。&emsp;&emsp;$3\\ C\\ M\\ P_1\\ P_2\\ …\\ P_M$：有个人在 $C$ 号点，他指定了他喜欢的公司为 $P_1,\\cdots,P_M$，你要找到一个离 $C$ 最近的点，使得这个点有他喜欢的公司开的商店。求这个距离。 &emsp;&emsp;单组数据：$n \\leq 50000,\\ Q \\leq 10^5,\\ \\sum m \\leq 10^5$&emsp;&emsp;10 组数据共 10s。 \\\\ \\\\ \\\\题解 对了..上次那个 G 题，我后来想了想发现是个点分水题.——liyang21 &emsp;&emsp;由于 $\\sum m \\leq 10^5$，只需要对于每个 $P_i$，求 $C$ 点到相应的 $[L_i,R_i]$ 这些点的最短距离就好了。 &emsp;&emsp;你想，要是每个点 $x$ 有一棵线段树，记录着 $x$ 到所有点的最短距离，那就好了，就可以对于每个询问直接区间查询 $[L_i,R_i]$ 的最小值了。 &emsp;&emsp;但这样太大了。想办法以时间换空间，我查询多一些东西，让这个线段树总量少些。 &emsp;&emsp;由于最近点是经典点分题，于是想到了点分 &emsp;&emsp;考虑点分树，对于每个点，只记录它的子树上的所有点到它的最短距离。你可以给点重新编号，或者用主席树，使得这个线段树总大小为 $O(n \\log n)$。&emsp;&emsp;这样一来，点 $x$ 到终点 $z$ 的路径就被分为了两部分，第一部分是 $x$ 到它点分树上的祖先 $y$，第二部分是 $y$ 到 $z$。&emsp;&emsp;因此查询的话，就从点分树的根一直查到那个点。比如上面说的我查询点 $x$，现在考虑它点分树上的祖先 $y$，那么就是 $dis_{x,y}+\\min\\{dis_{y,z}|z\\in[L_i,R_i]\\}$，这就是线段树区间查询了。点分树树高为 $\\log n$，线段树查询有一个 $\\log n$，因此复杂度为 $O(m \\log^2 n)$。","categories":[{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[{"name":"算法_线段树","slug":"算法-线段树","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"name":"算法_点分治","slug":"算法-点分治","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E7%82%B9%E5%88%86%E6%B2%BB/"}]},{"title":"【codejam2019 Round1A】Golf Gophers 题解","slug":"【codejam2019 Round1A】Golf Gophers 题解","date":"2019-04-13T15:46:30.000Z","updated":"2024-04-24T03:59:22.839Z","comments":true,"path":"【codejam2019 Round1A】Golf Gophers 题解/","link":"","permalink":"http://kqp.world/%E3%80%90codejam2019%20Round1A%E3%80%91Golf%20Gophers%20%E9%A2%98%E8%A7%A3/","excerpt":"题目大意&emsp;&emsp;这是一道交互题。&emsp;&emsp;现在有若干只地鼠，你只知道地鼠数量 $\\leq M$，你要把这个数量猜出来。&emsp;&emsp;你有 18 个风扇。每天初始，你给每个风扇设定它的叶片数 $b_i$（2 到 18 之间，从 0 开始标号），然后都让 0 号叶片指向正下。接着，每只地鼠独立地、等概率地选择一个风扇，把它的叶片往前拨一位（即原来是 $j$ 号叶片向下的现在变成 $(j+1)\\bmod b_i$ 号叶片向下）。&emsp;&emsp;你告诉电脑 $b$ 序列，它告诉你这天结束时各风扇指向正下的叶片编号。&emsp;&emsp;你要在至多 $N$ 天之内猜出来。 &emsp;&emsp;$Task1: N=365,\\ \\ M=100$&emsp;&emsp;$Task2: N=7,\\ \\ M=10^6$","text":"题目大意&emsp;&emsp;这是一道交互题。&emsp;&emsp;现在有若干只地鼠，你只知道地鼠数量 $\\leq M$，你要把这个数量猜出来。&emsp;&emsp;你有 18 个风扇。每天初始，你给每个风扇设定它的叶片数 $b_i$（2 到 18 之间，从 0 开始标号），然后都让 0 号叶片指向正下。接着，每只地鼠独立地、等概率地选择一个风扇，把它的叶片往前拨一位（即原来是 $j$ 号叶片向下的现在变成 $(j+1)\\bmod b_i$ 号叶片向下）。&emsp;&emsp;你告诉电脑 $b$ 序列，它告诉你这天结束时各风扇指向正下的叶片编号。&emsp;&emsp;你要在至多 $N$ 天之内猜出来。 &emsp;&emsp;$Task1: N=365,\\ \\ M=100$&emsp;&emsp;$Task2: N=7,\\ \\ M=10^6$ \\\\ \\\\ \\\\题解&emsp;&emsp;Task1：&emsp;&emsp;没想出来。。。 &emsp;&emsp;Task2： 看到 $N=7$，马上想到 $18$ 以内恰好只有 $7$ 个质数，用这 $7$ 个质数做模数，然后解中国剩余定理！！——Zayin &emsp;&emsp;他从看完题到想出这一串东西总共用了 10s &emsp;&emsp;对于每一天，所有的风扇叶片数都取同一个模数 $p$，那么这一天你把最终状态加起来，就知道了地鼠数量$\\mod p$ 的值。&emsp;&emsp;7 天就把 $2、3、5、7、11、13、17$ 全部试一遍，这就有了 7 个同余方程。然后跑 CRT 就行了。&emsp;&emsp;根据 CRT，这个方程组在 $235…17=510510$ 内有唯一解。 &emsp;&emsp;好像不够大？那把 $2$ 换成 $16$、$3$ 换成 $9$ 就可以啦！ 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;bits/stdc++.h&gt;#define fo(i,a,b) for(int i=a;i&lt;=b;i++)#define fd(i,a,b) for(int i=a;i&gt;=b;i--)using namespace std;typedef long long LL;const int maxs=50005, maxlen=55;int n,m,p[7]=&#123;5,7,11,13,17,16,9&#125;;LL ny(LL x,int pi)&#123; fo(i,1,p[pi]-1) if (x*i%p[pi]==1) return i;&#125;int T;int main()&#123; LL P=1; fo(i,0,6) P*=p[i]; scanf(&quot;%d%d%d&quot;,&amp;T,&amp;n,&amp;m); fo(ti,1,T) &#123; LL ans=0; fo(i,0,6) &#123; LL a=0; fo(j,1,18) printf(&quot;%d &quot;,p[i]); puts(&quot;&quot;); fflush(stdout); fo(j,1,18) &#123; int x; scanf(&quot;%d&quot;,&amp;x); (a+=x)%=p[i]; &#125; (ans+=a*(P/p[i])%P*ny(P/p[i],i))%=P; &#125; printf(&quot;%lld\\n&quot;,ans); fflush(stdout); int res; scanf(&quot;%d&quot;,&amp;res); &#125;&#125;","categories":[{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[{"name":"算法_神奇的脑洞","slug":"算法-神奇的脑洞","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E7%A5%9E%E5%A5%87%E7%9A%84%E8%84%91%E6%B4%9E/"},{"name":"算法_数论","slug":"算法-数论","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E6%95%B0%E8%AE%BA/"}]},{"title":"【AtCoder Grand 031C】Differ by 1 Bit 题解","slug":"【AtCoder Grand 031C】Differ by 1 Bit 题解","date":"2019-03-20T03:35:51.000Z","updated":"2024-04-24T03:59:22.825Z","comments":true,"path":"【AtCoder Grand 031C】Differ by 1 Bit 题解/","link":"","permalink":"http://kqp.world/%E3%80%90AtCoder%20Grand%20031C%E3%80%91Differ%20by%201%20Bit%20%E9%A2%98%E8%A7%A3/","excerpt":"题目大意&emsp;&emsp;给出 $N,A,B$，要求构造一个长度为 $2^N$ 的排列 $P_0,…,P_{2^N-1}$，使得 $P_0=A$，$P_{2^N-1}=B$，且相邻两个元素二进制下只有一位不同。若不存在则输出 NO。&emsp;&emsp;$N \\leq 17$","text":"题目大意&emsp;&emsp;给出 $N,A,B$，要求构造一个长度为 $2^N$ 的排列 $P_0,…,P_{2^N-1}$，使得 $P_0=A$，$P_{2^N-1}=B$，且相邻两个元素二进制下只有一位不同。若不存在则输出 NO。&emsp;&emsp;$N \\leq 17$ \\\\ \\\\ \\\\学艺不精&emsp;&emsp;正好不久前数电课学了格雷码，这题又恰好是长度为 $2$ 的幂的排列且相邻两个元素只有一位不同，就自然想到了用格雷码来构造。&emsp;&emsp;用格雷码的话，相当于构造一个从 $0$ 到 $A \\oplus B$ 的格雷码序列，最后再全部异或 $A$。当然，要调整一下二进制位谁先谁后。 &emsp;&emsp;结果 WA 到死。。。 &emsp;&emsp;用格雷码的本质错误在于，格雷码是要求循环的，但是这个题所要的排列是不循环的，所以 “$A$ 和 $B$ 只有一位不同” 这个有解判断是错的。 题解&emsp;&emsp;先从有解判断开始。因为每次改一个二进制位，因此最后 $A$ 和 $B$ 二进制下必须有奇数个位不同。这个是必要条件。&emsp;&emsp;然后通过构造方法能证明充分性。假设 $A$ 和 $B$ 在第 $x$ 位不同，那么大家都去掉第 $x$ 位，变成 $A’$ 和 $B’$，这样它们就有偶数位不同了。任意把 $A’$ 再改一位变成 $mid$，这样 $A’$ 和 $mid$、$mid$ 和 $B’$ 都有奇数位不同了。递归构造 $(A’,mid)$ 和 $(mid,B’)$，得出两个序列拼起来，再把第 $x$ 位补上，前面的序列第 $x$ 位跟 $A$ 相同，后面的序列第 $x$ 位跟 $B$ 相同。 &emsp;&emsp;这位大佬的几何解释更加直观：https://www.cnblogs.com/zhoushuyu/p/10548483.html 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;bits/stdc++.h&gt;#define fo(i,a,b) for(int i=a;i&lt;=b;i++)#define fd(i,a,b) for(int i=a;i&gt;=b;i--)using namespace std;typedef long long LL;const int maxn=2e5+5;int n,a,b,N,er[30],c[maxn];int lowbit(int x) &#123;return x&amp;(-x);&#125;bool bz[30];void dfs(int k,int a,int b)&#123; if (k==1) &#123; printf(&quot;%d %d &quot;,a,b); return; &#125; fo(i,0,n-1) if (((a&gt;&gt;i)&amp;1)^((b&gt;&gt;i)&amp;1)) &#123; bz[i]=1; int mid=a; fo(j,0,n-1) if (!bz[j]) &#123; mid^=er[j]; break; &#125; dfs(k-1,a,mid); dfs(k-1,mid^er[i],b); bz[i]=0; break; &#125;&#125;int main()&#123; scanf(&quot;%d %d %d&quot;,&amp;n,&amp;a,&amp;b); N=(1&lt;&lt;n)-1; fo(i,0,N) for(int x=i; x; x-=lowbit(x)) c[i]++; fo(i,0,n-1) er[i]=1&lt;&lt;i; if ((c[a]&amp;1)==(c[b]&amp;1)) puts(&quot;NO&quot;); else &#123; puts(&quot;YES&quot;); dfs(n,a,b); &#125;&#125;","categories":[{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[{"name":"算法_构造题","slug":"算法-构造题","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E6%9E%84%E9%80%A0%E9%A2%98/"}]},{"title":"【CF1137D】Cooperative Game 题解","slug":"【CF1137D】Cooperative Game 题解","date":"2019-03-14T12:56:40.000Z","updated":"2024-04-24T03:59:22.834Z","comments":true,"path":"【CF1137D】Cooperative Game 题解/","link":"","permalink":"http://kqp.world/%E3%80%90CF1137D%E3%80%91Cooperative%20Game%20%E9%A2%98%E8%A7%A3/","excerpt":"题目大意&emsp;&emsp;这是一道交互题。&emsp;&emsp;有这样一个 $\\rho$ 型的有向图：&emsp;&emsp;但是 $t$ 和 $c$ 都是未知的。&emsp;&emsp;你有 10 个棋子一开始在起点（标了房子那个），你要把他们都走到终点（标了棋子的那个）。每一步，你可以任意指定一些棋子，让这些棋子都向前走一步。然后电脑会告诉你，哪些棋子是在同一个格子里的。当你认为你把所有棋子都放到终点了的时候，就可以 end 了。&emsp;&emsp;你的步数不能超过 $3(t+c)$。&emsp;&emsp;$t+c \\leq 1000$","text":"题目大意&emsp;&emsp;这是一道交互题。&emsp;&emsp;有这样一个 $\\rho$ 型的有向图：&emsp;&emsp;但是 $t$ 和 $c$ 都是未知的。&emsp;&emsp;你有 10 个棋子一开始在起点（标了房子那个），你要把他们都走到终点（标了棋子的那个）。每一步，你可以任意指定一些棋子，让这些棋子都向前走一步。然后电脑会告诉你，哪些棋子是在同一个格子里的。当你认为你把所有棋子都放到终点了的时候，就可以 end 了。&emsp;&emsp;你的步数不能超过 $3(t+c)$。&emsp;&emsp;$t+c \\leq 1000$ 题解&emsp;&emsp;这肯定是要用 Floyd 判圈了，有意思的是判完圈之后的小分析，这个分析有点妙。 &emsp;&emsp;一开始，一个人一次走两步，另一个人一次走一步，那么他们必在环中相遇。&emsp;&emsp;并且慢者在环上最多走一圈。因为如果慢者走了多于一圈，那么快者一定走了两圈了，因此就一定会超过他，不可能跟在他屁股后面转。 &emsp;&emsp;设他们相遇的地点离终点距离为 $x$，则慢者的路程为 $t+x$，快者的路程为 $t+kc+x$，$k$ 是快者走过的圈数。&emsp;&emsp;由快者速度是慢者两倍可得 $2(t+x)=t+kc+x$，即 $t+x=kc$，即 $t+x \\equiv 0 \\pmod{c}$ &emsp;&emsp;也就是说，他们相遇后再走 $t$ 步就到终点了。&emsp;&emsp;而剩下的在起点的 8 个人也是走 $t$ 步到终点！！！&emsp;&emsp;所以大家一起走，直到相遇，就行了。 &emsp;&emsp;第一个过程的步数，即为快者的步数，不超过 $2(t+c)$，第二个过程的步数恰好为 $t$，所以总步数在 $3(t+c)$ 范围内。","categories":[{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[{"name":"算法_神奇的脑洞","slug":"算法-神奇的脑洞","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E7%A5%9E%E5%A5%87%E7%9A%84%E8%84%91%E6%B4%9E/"}]},{"title":"【CF1137C】Museums Tour 题解","slug":"【CF1137C】Museums Tour 题解","date":"2019-03-13T15:31:24.000Z","updated":"2024-04-24T03:59:22.833Z","comments":true,"path":"【CF1137C】Museums Tour 题解/","link":"","permalink":"http://kqp.world/%E3%80%90CF1137C%E3%80%91Museums%20Tour%20%E9%A2%98%E8%A7%A3/","excerpt":"题目大意&emsp;&emsp;有一幅 $n$ 个点 $m$ 条边的有向图，每个点有一个博物馆，一周有 $d$ 天。每个博物馆在每一天的开闭状态是已知的（一个大的 01 矩阵）。&emsp;&emsp;一开始你在 $1$ 号点星期 $1$，每天如果当前所在的博物馆开馆，你就可以去访问它，当这一天结束时，你必须向前走一步或者结束行程。&emsp;&emsp;求你最多能访问多少个不同的博物馆。 &emsp;&emsp;$n,m \\leq 10^5,\\ d\\leq50$","text":"题目大意&emsp;&emsp;有一幅 $n$ 个点 $m$ 条边的有向图，每个点有一个博物馆，一周有 $d$ 天。每个博物馆在每一天的开闭状态是已知的（一个大的 01 矩阵）。&emsp;&emsp;一开始你在 $1$ 号点星期 $1$，每天如果当前所在的博物馆开馆，你就可以去访问它，当这一天结束时，你必须向前走一步或者结束行程。&emsp;&emsp;求你最多能访问多少个不同的博物馆。 &emsp;&emsp;$n,m \\leq 10^5,\\ d\\leq50$ \\\\ \\\\ \\\\题解&emsp;&emsp;首先想到要拆点，一个点拆成 $d$ 个，表示这个点星期几。然后现在就变成了一幅 $nd$ 个点 $md$ 条边的有向图。 &emsp;&emsp;一个强连通分量内部是互相可达的，于是想到缩起来变成一幅 DAG。 &emsp;&emsp;那现在有了这个 DAG 之后干啥呢？ &emsp;&emsp;一开始肯定想 dp 啊，设 $f_i$ 表示从第 $i$ 个强连通分量开始最多能访问多少博物馆。然后从它连出去的所有点里面找个最大的转移过来。 &emsp;&emsp;但是这样就会想到一个问题啊，后面的强连通分量包含了第 $i$ 个点星期 $j$，而现在的强连通分量包含第 $i$ 个点星期 $j’$，这不就计重了吗？甚至前面的强连通分量还会包含第 $i$ 个点星期 $j’’$ 呢！ &emsp;&emsp;于是傻逼如我就开始想用 set 来代替个数，这样就不会计重了。然后这样 dp 就成了启发式合并 set。&emsp;&emsp;但是这样依然有问题啊，第 $i$ 个点你得跟儿子合并了取 size 才知道这样转移的好坏，那合并 set 就还得撤销了啊！！而且这样转移，是有后效性的。&emsp;&emsp;然后我就崩了。 &emsp;&emsp;因此要想题解那样发现一个很强的性质——不存在计重的情况！！&emsp;&emsp;设 $i$ 号点星期 $x$ 可以走到 $i$ 号点星期 $y$，即存在路径 $(i,x) \\to (i,y)$。设 $\\Delta d=y-x$，那么这条路径还可以继续扩展： $(i,x) \\to (i,y) \\to (i,y+\\Delta d) \\to (i,y+2\\Delta d) \\to … \\to (i,y+(d-1)\\Delta d)$，这个就是 $(i,x)$ 了，也就是说 $(i,y)$ 也是能走回到 $(i,x)$ 的！&emsp;&emsp;也就是说，一个点拆出来的几个状态，如果能从一个到达另一个，那它们一定是在同一个强连通分量里的。&emsp;&emsp;这样 dp 就没有顾虑了，就直接 dp 了。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include&lt;bits/stdc++.h&gt;#define fo(i,a,b) for(int i=a;i&lt;=b;i++)#define fd(i,a,b) for(int i=a;i&gt;=b;i--)using namespace std;typedef long long LL;const int maxn=1e5+5, maxd=55, maxN=5e6+5, maxe=5e6+5;int n,m,d,num[maxN];int getid(int i,int j) &#123;return i+n*(j-1);&#125;int tot,go[maxe],nxt[maxe],f1[maxN];void ins(int x,int y)&#123; go[++tot]=y; nxt[tot]=f1[x]; f1[x]=tot;&#125;int tot2,go2[maxe],nxt2[maxe],f2[maxN],com[maxN];void ins2(int x,int y)&#123; go2[++tot2]=y; nxt2[tot2]=f2[x]; f2[x]=tot2; com[y]++;&#125;int sum,dfn[maxN],low[maxN],bz[maxN],z0,z[maxN],rt[maxN];void tarjan(int k)&#123; dfn[k]=low[k]=++sum; bz[k]=1; z[++z0]=k; for(int p=f1[k]; p; p=nxt[p]) &#123; if (!bz[go[p]]) &#123; tarjan(go[p]); low[k]=min(low[k],low[go[p]]); &#125; else if (bz[go[p]]==1) low[k]=min(low[k],dfn[go[p]]); &#125; if (dfn[k]==low[k]) &#123; do&#123; bz[z[z0]]=2; rt[z[z0]]=k; &#125; while (z[z0--]!=k); &#125;&#125;int f[maxN],q[maxN];void topo()&#123; int j=0; fo(i,1,n*d) if (rt[i]==i &amp;&amp; !com[i]) q[++j]=i; for(int i=1; i&lt;=j; i++) &#123; f[q[i]]+=num[q[i]]; for(int p=f2[q[i]]; p; p=nxt2[p]) &#123; f[go2[p]]=max(f[go2[p]],f[q[i]]); if (--com[go2[p]]==0) q[++j]=go2[p]; &#125; &#125;&#125;char s[maxd];int main()&#123; scanf(&quot;%d %d %d&quot;,&amp;n,&amp;m,&amp;d); fo(i,1,m) &#123; int x,y; scanf(&quot;%d %d&quot;,&amp;x,&amp;y); fo(j,1,d) ins(getid(x,j),getid(y,j%d+1)); &#125; tarjan(1); memset(bz,0,sizeof(bz)); fo(i,1,n) &#123; scanf(&quot;%s&quot;,s+1); fo(j,1,d) if (s[j]==&#x27;1&#x27;) &#123; int id=rt[getid(i,j)]; if (!bz[id]) bz[id]=1, num[id]++; &#125; fo(j,1,d) bz[rt[getid(i,j)]]=0; &#125; fo(i,1,n*d) for(int p=f1[i]; p; p=nxt[p]) if (rt[go[p]]!=rt[i] &amp;&amp; rt[go[p]] &amp;&amp; rt[i]) ins2(rt[go[p]],rt[i]); topo(); printf(&quot;%d\\n&quot;,f[1]);&#125;","categories":[{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[{"name":"算法_图论","slug":"算法-图论","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E5%9B%BE%E8%AE%BA/"},{"name":"算法_DP","slug":"算法-DP","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-DP/"}]},{"title":"【Moscow Workshop 2019 WinterCamp day3 divB L】LED-led Paths 题解","slug":"【Moscow Workshop 2019 WinterCamp day3 divB L】LED-led Paths 题解","date":"2019-02-20T03:23:06.000Z","updated":"2024-04-24T03:59:22.861Z","comments":true,"path":"【Moscow Workshop 2019 WinterCamp day3 divB L】LED-led Paths 题解/","link":"","permalink":"http://kqp.world/%E3%80%90Moscow%20Workshop%202019%20WinterCamp%20day3%20divB%20L%E3%80%91LED-led%20Paths%20%E9%A2%98%E8%A7%A3/","excerpt":"题目大意&emsp;&emsp;给定一幅 $n$ 个点 $m$ 条边的 DAG。你有三种颜色（红蓝绿），你要给每条边染色，使得不存在一条路径上连续 42 条边同色。&emsp;&emsp;$n \\leq 50000,\\ m \\leq 2 \\times 10^5$","text":"题目大意&emsp;&emsp;给定一幅 $n$ 个点 $m$ 条边的 DAG。你有三种颜色（红蓝绿），你要给每条边染色，使得不存在一条路径上连续 42 条边同色。&emsp;&emsp;$n \\leq 50000,\\ m \\leq 2 \\times 10^5$ \\\\ \\\\ \\\\naive想法1&emsp;&emsp;今天的主题是 random algorithm，于是下午的 contest 就变成了随机大战+乱搞大战。于是这题理所当然地首先想想随机。&emsp;&emsp;似乎直接给每条边随机一个颜色很优秀啊？你想想，一条路径连续 42 个同色的概率不是几乎为 0 吗？&emsp;&emsp;然而非常好叉，因为这不是随机图，只要让两个点之间重边非常多，那么在随机下每个点到另一个点什么颜色都有了，轻松 42 条同色。&emsp;&emsp;然后又脑洞了一下：给每个点随机一种颜色然后这个点的出边全都是这种颜色、按 bfs 序每15层全部同色轮换然后其他随机……全都 WA 了。然后发现，只要把点分层，每层 100 个，共 500 层，相邻两层之间完全相连，不同层之间再随便加些边扰动一下，那么在随机下每层到下一层也是什么颜色都有，依然轻松 42 条同色。 &emsp;&emsp;因此本质问题是，上面这种数据就是卡掉所有随机的。思考的方向不是让它如何更随机，因为越随机，这种数据越过不去。应该构造一种方案使得它在这种情况下不那么随机。&emsp;&emsp;因此这是一个构造题。 naive想法2&emsp;&emsp;需要构造一种方法，使得如果连续 42 条边同色的话，会有什么东西爆掉。比如让点的编号爆掉。&emsp;&emsp;有一种很 naive 的想法是，设 $x$ 的二进制最高位的 1 是从右往左数第 $w_x$ 位，比如 $i$ 连向 $j$，若 $i &lt; j$，且 $w_i &lt; w_j$，那么 $i$ 到 $j$ 连红边。这样的话，红边连续意味着二进制最高位的 1 一直向前推进，那么连续 42 次编号肯定爆了。然后比如当 $w_i &gt; w_j$ 时连绿边，那么连续 42 条绿边也爆了…… &emsp;&emsp;但是还有很多情况没考虑，比如 $w_i=w_j$ 怎么连……会发现三种颜色不太够，因此方法要改进一下。 &emsp;&emsp;基于这种思路就得出了一种构造方法。&emsp;&emsp;首先为了去掉 $i &gt; j$ 的情况，我们用拓扑序编号来做。对于 $i$ 连向 $j$，设它们的拓扑序编号分别为 $id_i$ 和 $id_j$，那么一定有 $id_i &lt; id_j$。&emsp;&emsp;然后我们不要讨论最高位的 1，而是讨论 $id_i$ 和 $id_j$ 二进制下第一个不同的位，即 $w_{id_i \\oplus id_j}$。由于 $n \\leq 50000$，因此 $id$ 二进制最多只有 16 位，那么我们对 $w_{id_i \\oplus id_j}$ 进行讨论：若为 $1$~$5$，连红边；若为 $6$~$10$，连绿边；若为 $11$~$16$，连蓝边。这样红边和绿边的连续转移都不超过 $2^5=32$ 次。蓝边因为有第 16 位，严格分析一下最大是 $48$ 次。 &emsp;&emsp;比赛时脑子抽了以为蓝边也是 32 次，于是勇敢地写了，然后过了。。。&emsp;&emsp;估计出题人也没想过我这种偏门的想法于是没有专门出数据去卡。。。&emsp;&emsp;直到写这个 blog 重新证明一次才发现被叉掉了 qaq&emsp;&emsp;不过这场本身也是乱搞大战，我乱搞过了这个题不也算是正解吗（大雾 &emsp;&emsp;（当然还是希望有 dalao 继续完善一下这个想法。 题解&emsp;&emsp;然后题解异常地简单，思路很直接。（其实是因为我想的太复杂了qaq &emsp;&emsp;先对点进行分组，分成 $42$ 个组，每组 $\\frac{n}{42}$ 个点。组与组之间的转移连红边。由于是 DAG，红边连续最多 41 次。&emsp;&emsp;对于每组内，再分 $42$ 个小组，每小组 $\\frac{n}{42 \\cdot 42}$ 个点。小组与小组之间转移连蓝边。同理，蓝边连续最多 41 次。&emsp;&emsp;由于小组内点数 $\\frac{n}{42 \\cdot 42} &lt; 42$，因此小组内转移连绿边。这样绿边连续也不超过 42 次了。 &emsp;&emsp;这个方法用的思想是 $42^3&gt;n$，因此连续分组两次就行了。 代码// naive想法2 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;bits/stdc++.h&gt;#define fo(i,a,b) for(int i=a;i&lt;=b;i++)using namespace std;const int maxn=5e4+5, maxm=2e5+5;int n,m;char clr[3]=&#123;&#x27;R&#x27;,&#x27;B&#x27;,&#x27;G&#x27;&#125;;int tot,go[maxm],fro[maxm],nxt[maxm],f1[maxn],com[maxn];void ins(int x,int y)&#123; go[++tot]=y; fro[tot]=x; nxt[tot]=f1[x]; f1[x]=tot; com[y]++;&#125;int d[maxn],dis[maxn];void topo()&#123; int j=0; fo(i,1,n) if (!com[i]) &#123; d[++j]=i; dis[i]=1; &#125; for(int i=1; i&lt;=j; i++) &#123; for(int p=f1[d[i]]; p; p=nxt[p]) &#123; dis[go[p]]=max(dis[go[p]],dis[d[i]]+1); if (--com[go[p]]==0) d[++j]=go[p]; &#125; &#125;&#125;int main()&#123; srand(time(0)); scanf(&quot;%d %d&quot;,&amp;n,&amp;m); fo(i,1,m) &#123; int x,y; scanf(&quot;%d %d&quot;,&amp;x,&amp;y); ins(x,y); &#125; topo(); fo(i,1,m) &#123; int w=0; for(int x=dis[fro[i]]^dis[go[i]]; x; x&gt;&gt;=1, w++); printf(&quot;%c\\n&quot;,clr[w%3]); &#125;&#125;","categories":[{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[{"name":"算法_构造题","slug":"算法-构造题","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E6%9E%84%E9%80%A0%E9%A2%98/"}]},{"title":"【2018icpc Regional Jakarta C】Smart Thief 题解","slug":"【2018icpc Regional Jakarta C】Smart Thief 题解","date":"2019-02-01T14:57:50.000Z","updated":"2024-04-24T03:59:22.807Z","comments":true,"path":"【2018icpc Regional Jakarta C】Smart Thief 题解/","link":"","permalink":"http://kqp.world/%E3%80%902018icpc%20Regional%20Jakarta%20C%E3%80%91Smart%20Thief%20%E9%A2%98%E8%A7%A3/","excerpt":"题目大意&emsp;&emsp;给出 $M$ 个个位数。现在你要用它们构造一个最短的数字串，使得这个串所有长度为 $N$ 的连续子串，至少有 $K$ 种。&emsp;&emsp;保证存在长度在 1e5 以内的答案。&emsp;&emsp;$N\\leq10^5,\\ M\\leq10,\\ K\\leq \\min(M^N,10^5)$ “这是我初二时的 GDOI 题。”——1队dalao","text":"题目大意&emsp;&emsp;给出 $M$ 个个位数。现在你要用它们构造一个最短的数字串，使得这个串所有长度为 $N$ 的连续子串，至少有 $K$ 种。&emsp;&emsp;保证存在长度在 1e5 以内的答案。&emsp;&emsp;$N\\leq10^5,\\ M\\leq10,\\ K\\leq \\min(M^N,10^5)$ “这是我初二时的 GDOI 题。”——1队dalao \\\\ \\\\ \\\\题解&emsp;&emsp;要想到，一个子串后面添加一个数字成为下一个子串，这个类似于点通过边来转移，因此用欧拉路径来建图。 &emsp;&emsp;考虑当 $N$ 很小的时候。&emsp;&emsp;把所有长度为 $N-1$ 的串视为点，表示子串的最后 $N-1$ 位。共有 $M^{N-1}$ 个点。那么点与点之间就可以连转移边了，连边表示状态转移，比如 $123$ 连一条权值为 $4$ 的边到 $234$ 去。&emsp;&emsp;对这个图跑一次欧拉路径，那么每个点加上它连出去的边，就是题目要求的一个子串，而且都是不同的，因此总的串就是最短的。 &emsp;&emsp;$N$ 很大的时候呢，&emsp;&emsp;找到最小的 $N’$，使得 $M^{N’}\\geq K$。那么对于所有长度为 $N$ 的子串，只看最后 $N’$ 位也足够满足 $K$ 的要求了，换句话说前 $N-N’$ 位是无关紧要的。因此把 $N$ 换成 $N’$ 按上面的做法做就行了。 代码// 这个代码在 opentrain 上能过，在 cf 上会神奇地 WA 样例，似乎是搞爆了它的 spj ？？12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include&lt;bits/stdc++.h&gt;#define fo(i,a,b) for(int i=a;i&lt;=b;i++)#define fd(i,a,b) for(int i=a;i&gt;=b;i--)using namespace std;typedef long long LL;const int maxtot=1e6+5, maxnp=30, maxn=1e5+5;const LL mo=1e9+7, px=998244353;int n,m,k,np,a[15];LL mm,powpx[maxnp];unordered_map&lt;LL,int&gt; M;int tot;vector&lt;pair&lt;int,int&gt;&gt; e[maxtot];void dfs1(int k,LL now)&#123; if (k==np) &#123; M[now]=++tot; return; &#125; fo(i,1,m) dfs1(k+1,(now*px+a[i])%mo);&#125;void dfs2(int k,LL now,int fir)&#123; if (k==np) &#123; int my=M[now]; fo(i,1,m) &#123; int go=M[((now*px+a[i]-fir*powpx[np-1])%mo+mo)%mo]; e[my].push_back(make_pair(go,a[i])); &#125; return; &#125; fo(i,1,m) dfs2(k+1,(now*px+a[i])%mo,(fir==-1)?a[i]:fir);&#125;int nowh[maxn],d0,st,d[maxn];void Euler(int k,int lim)&#123; int sz=e[k].size(); for(int i=nowh[k]; i&lt;sz; i=nowh[k]) &#123; nowh[k]=i+1; Euler(e[k][i].first,lim); if (d0==lim) return; d[++d0]=e[k][i].second; st=k; if (d0==lim) return; &#125;&#125;int rc[maxn];bool pd;void dfs3(int k,LL now)&#123; if (k==np) &#123; if (M[now]==st) &#123; fo(i,1,np-1) printf(&quot;%d&quot;,rc[i]); pd=1; &#125; return; &#125; fo(i,1,m) &#123; rc[k]=a[i]; dfs3(k+1,(now*px+a[i])%mo); if (pd) return; &#125;&#125;int main()&#123; scanf(&quot;%d %d %d&quot;,&amp;n,&amp;m,&amp;k); fo(i,1,m) scanf(&quot;%d&quot;,&amp;a[i]); for(np=1, mm=m; mm&lt;k; np++, mm*=m); powpx[0]=1; fo(i,1,np) powpx[i]=powpx[i-1]*px%mo; dfs1(1,0); dfs2(1,0,-1); Euler(1,k); fo(i,1,n-np) printf(&quot;%d&quot;,a[1]); dfs3(1,0); fd(i,d0,1) printf(&quot;%d&quot;,d[i]);&#125;","categories":[{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[{"name":"算法_神奇的脑洞","slug":"算法-神奇的脑洞","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E7%A5%9E%E5%A5%87%E7%9A%84%E8%84%91%E6%B4%9E/"},{"name":"算法_图论","slug":"算法-图论","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E5%9B%BE%E8%AE%BA/"},{"name":"算法_构造题","slug":"算法-构造题","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E6%9E%84%E9%80%A0%E9%A2%98/"}]},{"title":"【程设大作业】printf 的实现","slug":"programming_printf","date":"2019-01-31T15:23:29.000Z","updated":"2024-04-24T03:59:22.789Z","comments":true,"path":"programming_printf/","link":"","permalink":"http://kqp.world/programming_printf/","excerpt":"我决定挂(biao)一挂(biao)我们的这个程设大作业。（同样是大一，别人家的大作业是写一个 jumping game，怎么到你这就是个 printf 呢。。。 Task&emsp;&emsp;一句话，就是要手写 printf。&emsp;&emsp;具体来讲，你需要自己实现一个函数（C 语言），名叫 myprintf，其功能和 printf 一致——参数第一个是字符串format[]，后面是任意个参数，然后能把这些东西输出出来，返回值是一共输出了多少个字符。","text":"我决定挂(biao)一挂(biao)我们的这个程设大作业。（同样是大一，别人家的大作业是写一个 jumping game，怎么到你这就是个 printf 呢。。。 Task&emsp;&emsp;一句话，就是要手写 printf。&emsp;&emsp;具体来讲，你需要自己实现一个函数（C 语言），名叫 myprintf，其功能和 printf 一致——参数第一个是字符串format[]，后面是任意个参数，然后能把这些东西输出出来，返回值是一共输出了多少个字符。&emsp;&emsp;当然你不能在 myprintf 里内嵌 printf，只能用 putchar。&emsp;&emsp;为了简化问题，对于 % 后面的转换字符只作部分规定（见下表），其他如 %lld、%a 等视为未定义。下面是题目的部分pdf： 考点&emsp;&emsp;第一自然是可变参列表的使用了。&emsp;&emsp;第二就是对format这个字符串的处理。&emsp;&emsp;第三就是如何输出这些参数 &emsp;&emsp;隐藏的第四点是你要发现 printf 的所有隐藏鬼畜 sol可变参列表&emsp;&emsp;头文件是：1#include&lt;stdarg.h&gt; &emsp;&emsp;参数数量、类型是不定的，故曰可变参列表，用三个点来表示：123int myprintf(const char format[], ...)&#123;&#125;然后你要需要一个指向参数的指针：12va_list ap; // 定义指针apva_start(ap,format); // 初始化ap，将它指向format的末尾，这样它后面就是那个...列表了。接着就是通过指针ap提取列表里的参数，例如左到右依次是 int、char、double、字符串，那么可以这样：1234int a=va_arg(ap,int); // 执行完这个操作之后ap会自动往后跳，比如这里就会跳到这个int的末尾char b=va_arg(ap,int); // 因为char也是int。。。比较奇怪的设定。。double c=va_arg(ap,double);char *d=va_arg(ap,char*);用完了之后要把ap释放掉：1va_end(ap); 字符串处理&emsp;&emsp;这个瞎处理就好了，一位一位扫format，碰到 % 就后面接一堆判断和 switch，否则就直接输出。&emsp;&emsp;至于许多小朋友们担心的 \\n、\\t、\\233 等转义字符怎么办，其实 C 已经自动帮你转好的了，它们本身就只是一个字符而已。 输出参数&emsp;&emsp;有机智的小朋友说直接 _vsnprintf 就好啦。。。快去请卢来佛祖&emsp;&emsp;基本的思想都是把数字转化成数组，然后倒着输出。这个大家在学进制转换的时候天天玩的了。&emsp;&emsp;然后为了方便统计一共输出了多少字符，建议最后的输出统一用字符串进行。即把数组也再转换成字符串，丢到统一的输出函数里去。 &emsp;&emsp;麻烦的是实数，你不能把任何一个部分转成整数来处理，因为会爆 long long。然后你还要保持精度。&emsp;&emsp;所以要想个办法。可以先转成科学记数法，意思就是对于实数 $x$ 要先求出一个最大的 $10$ 的幂 $ep$ 使得 $\\frac{x}{ep}\\in[1,10)$，然后从高位开始一位一位除下去，存到数组里。当然，视不同的输出格式要做些调整，比如 %f 输出的时候无视 $ep&lt;1$ 的情况。&emsp;&emsp;另一个办法是 C 里有一个库函数可以直接把实数转成字符串。但是这个精度不好，输出 $2^{63}$ 的时候最后一位就被吞掉了。所以不推荐。&emsp;&emsp;注意四舍五入，这里会有一个类似于高精度的运算。（恶心吧。。 鬼畜区&emsp;&emsp;真正实现起来的时候，你会发现 printf 是有多么的鬼畜。。。 &emsp;&emsp;四舍五入对吧，好那我就四舍五入。诶为什么printf(&quot;%.f&quot;,3.5);输出 3 啊？？？&emsp;&emsp;诶为什么printf(&quot;%.f&quot;,3.55);就是 4 了啊？？？&emsp;&emsp;再输出一个printf(&quot;%.f&quot;,3.5000001);，懂了，这逼居然是恰好 0.5 的时候不进位，要严格大于 0.5 才进位。。。 &emsp;&emsp;好的现在肝完 %f 和 %e 来肝 %g 了。&emsp;&emsp;诶不对为啥 printf(&quot;%.6g&quot;,0.00001234);是 1.234e-005 啊？？不是说好了默认 6 位精度的吗？？诶为啥printf(&quot;%.4g&quot;,acos(-1));是 3.142 啊这个精度也不对啊？？&emsp;&emsp;输出研究了一通，%f 和 %e 的精度是指小数点后保留多少位，%g 的精度是指有效数字。。。 &emsp;&emsp;好的这些都只是小鬼畜。我们试着输出一发：123int haha=2147483647;double tst=3.6;printf(&quot;%yha %.yha %33.33ttttt %%..... %%d %hd\\n&quot;,haha,haha);&emsp;&emsp;诶这啥玩意？？？&emsp;&emsp;再来。。12double tst=3.6;printf(&quot;%...f %----10.f\\n&quot;,tst,tst);&emsp;&emsp;这。。。&emsp;&emsp;自动去掉重复的东西？？1printf(&quot;%.---3f\\n&quot;,tst);&emsp;&emsp;这。。。&emsp;&emsp;精度自动取绝对值，好像都能解释，没什么问题。。那大概就是这样了吧，验证下。。 1printf(&quot;%----10.....----10f\\n&quot;,tst); &emsp;&emsp;？？？？？？？？？？？？？？？？？ &emsp;&emsp;弃疗 代码先是 myprintf 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240#include&lt;math.h&gt;#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;stdarg.h&gt;#define fo(i,a,b) for(int i=a;i&lt;=b;i++)#define fd(i,a,b) for(int i=a;i&gt;=b;i--)#define maxlen 1000005typedef unsigned int uint;const double eps=1e-14;int max(int x,int y) &#123;return (x&gt;y) ?x :y ;&#125;int charnum,d0,d[maxlen],len,ali,width;char S[maxlen];void Put(char ch)&#123; putchar(ch); charnum++;&#125;void PutString(char *S,int limit)&#123; int len=strlen(S); if (limit&gt;-1 &amp;&amp; limit&lt;len) len=limit; if (ali) fo(i,1,width-len) Put(&#x27; &#x27;); fo(i,0,len-1) Put(S[i]); if (!ali) fo(i,1,width-len) Put(&#x27; &#x27;);&#125;void PutChar(char ch)&#123; S[0]=ch, S[1]=&#x27;\\000&#x27;; PutString(S,-1);&#125;void PutInt(int x,int limit)&#123; if (x&lt;0) &#123; S[len++]=&#x27;-&#x27;; x=-x; &#125; if (x==0) d[d0=1]=0; else for(d0=0; x; x/=10) d[++d0]=x%10; fo(i,1,limit-d0) S[len++]=&#x27;0&#x27;; fd(i,d0,1) S[len++]=d[i]+&#x27;0&#x27;; S[len++]=&#x27;\\000&#x27;; PutString(S,-1);&#125;void PutUInt(uint x,int ty,int cap,int limit)&#123; if (x==0) d[d0=1]=0; else for(d0=0; x; x/=ty) d[++d0]=x%ty; fo(i,1,limit-d0) S[len++]=&#x27;0&#x27;; fd(i,d0,1) S[len++]=(d[i]&lt;10) ?d[i]+&#x27;0&#x27; :d[i]-10+(cap?&#x27;A&#x27;:&#x27;a&#x27;); S[len++]=&#x27;\\000&#x27;; PutString(S,-1);&#125;void DigitToArray(double x,double ep,int len)&#123; d[d0=0]=0; fo(i,1,len) &#123; d[++d0]=fmod(x,ep*10)/ep; x-=d[d0]*ep; ep/=10; &#125; d[d0]+=(fmod(x,ep*10)/ep&gt;5+eps); for(int i=d0; d[i]&gt;9; i--) d[i]-=10, d[i-1]++;&#125;void PutFloat(double x,int acr)&#123; if (x&lt;0) &#123; S[len++]=&#x27;-&#x27;; x=-x; &#125; int w=1; double ep=1; for(double xx=x; xx+eps&gt;=10; xx/=10) w++, ep*=10; DigitToArray(x,ep,w+acr); int st=(d[0]==0); fo(i,st,w) S[len++]=d[i]+&#x27;0&#x27;; if (acr) &#123; S[len++]=&#x27;.&#x27;; fo(i,w+1,w+acr) S[len++]=d[i]+&#x27;0&#x27;; &#125; S[len++]=&#x27;\\000&#x27;; PutString(S,-1);&#125;void PutFloatE(double x,int acr,char cap)&#123; if (x&lt;0) &#123; S[len++]=&#x27;-&#x27;; x=-x; &#125; int index=0; double ep=1; for(double xx=x; xx+eps&gt;=10; xx/=10) index++, ep*=10; for(double xx=x; xx&gt;eps &amp;&amp; xx+eps&lt;1; xx*=10) index--, ep/=10; DigitToArray(x,ep,1+acr); index+=(d[0]&gt;0); int st=(d[0]==0); S[len++]=d[st]+&#x27;0&#x27;; if (acr) &#123; S[len++]=&#x27;.&#x27;; fo(i,st+1,st+acr) S[len++]=d[i]+&#x27;0&#x27;; &#125; S[len++]=cap; if (index&gt;=0) S[len++]=&#x27;+&#x27;; else S[len++]=&#x27;-&#x27;, index=-index; for(int i=100; i&gt;=1; i/=10) S[len++]=(index/i)%10+&#x27;0&#x27;; S[len]=&#x27;\\000&#x27;; PutString(S,-1);&#125;void PutFloatG(double x,int acr,char cap)&#123; if (x&lt;0) &#123; S[len++]=&#x27;-&#x27;; x=-x; &#125; int index=0; double ep=1; for(double xx=x; xx+eps&gt;=10; xx/=10) index++, ep*=10; for(double xx=x; xx&gt;eps &amp;&amp; xx+eps&lt;1; xx*=10) index--, ep/=10; DigitToArray(x,ep,acr); index+=(d[0]&gt;0); int st=(d[0]==0); if (index&lt;-4 || index&gt;=acr) &#123; while (st&lt;d0 &amp;&amp; d[d0]==0) d0--; S[len++]=d[st]+&#x27;0&#x27;; if (st&lt;d0) &#123; S[len++]=&#x27;.&#x27;; fo(i,st+1,d0) S[len++]=d[i]+&#x27;0&#x27;; &#125; S[len++]=cap; if (index&gt;=0) S[len++]=&#x27;+&#x27;; else S[len++]=&#x27;-&#x27;, index=-index; for(int i=100; i&gt;=1; i/=10) S[len++]=(index/i)%10+&#x27;0&#x27;; &#125; else &#123; int w=max(index+1,0); while (st+w-1&lt;d0 &amp;&amp; d[d0]==0) d0--; if (!w) S[len++]=&#x27;0&#x27;; else fo(i,st,st+w-1) S[len++]=d[i]+&#x27;0&#x27;; if (st+w-1&lt;d0) S[len++]=&#x27;.&#x27;; fo(i,1,-index-1) S[len++]=&#x27;0&#x27;; fo(i,st+w,d0) S[len++]=d[i]+&#x27;0&#x27;; &#125; S[len]=&#x27;\\000&#x27;; PutString(S,-1);&#125;int myprintf(const char format[],...)&#123; int n=strlen(format); charnum=0; va_list ap; va_start(ap,format); fo(i,0,n-1) if (format[i]==&#x27;%&#x27; &amp;&amp; i&lt;n-1) &#123; int now=i; ali=1, width=0; int acr=0, hasacr=0, h=0, l=0, get; while (format[i+1]==&#x27;-&#x27;) ali=0, i++; while (format[i+1]&gt;=&#x27;0&#x27; &amp;&amp; format[i+1]&lt;=&#x27;9&#x27;) width=width*10+format[++i]-&#x27;0&#x27;; if (format[i+1]==&#x27;.&#x27;) hasacr=1, i++; if (format[i+1]==&#x27;-&#x27;) i++; while (format[i+1]&gt;=&#x27;0&#x27; &amp;&amp; format[i+1]&lt;=&#x27;9&#x27;) acr=acr*10+format[++i]-&#x27;0&#x27;; if (format[i+1]==&#x27;h&#x27;) h=1, i++; if (format[i+1]==&#x27;l&#x27;) l=1, i++; len=0; switch (format[++i]) &#123; case &#x27;d&#x27;: case &#x27;i&#x27;: get= h ?(short)va_arg(ap,int) :va_arg(ap,int) ; PutInt(get,acr); break; case &#x27;o&#x27;: get= h ?(short)va_arg(ap,uint) :va_arg(ap,uint) ; PutUInt(get,8,0,acr); break; case &#x27;x&#x27;: case &#x27;X&#x27;: get= h ?(short)va_arg(ap,uint) :va_arg(ap,uint) ; PutUInt(get,16,(format[i]==&#x27;X&#x27;),acr); break; case &#x27;u&#x27;: get= h ?(short)va_arg(ap,uint) :va_arg(ap,uint) ; PutUInt(get,10,0,acr); break; case &#x27;c&#x27;: PutChar(va_arg(ap,int)); break; case &#x27;s&#x27;: PutString(va_arg(ap,char*),(hasacr)?acr:-1); break; case &#x27;f&#x27;: PutFloat(va_arg(ap,double),(hasacr)?acr:6); break; case &#x27;e&#x27;: case &#x27;E&#x27;: PutFloatE(va_arg(ap,double),(hasacr)?acr:6,format[i]); break; case &#x27;g&#x27;: case &#x27;G&#x27;: PutFloatG(va_arg(ap,double),(hasacr)?max(acr,1):6,format[i]-2); break; case &#x27;p&#x27;: PutUInt((uint)va_arg(ap,void*),16,0,8); break; case &#x27;%&#x27;: Put(&#x27;%&#x27;); break; default: fo(j,now,i) Put(format[j]); &#125; &#125; else Put(format[i]); va_end(ap); return charnum;&#125; 然后是一些测试 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&quot;myprintf.c&quot;int main()&#123; //freopen(&quot;main.out&quot;,&quot;w&quot;,stdout); long long ll=2147483647; ll++; ll=ll*ll; ll=ll-1+ll; printf(&quot;%e\\n&quot;,acos(-1)-3); myprintf(&quot;%e\\n&quot;,acos(-1)-3); printf(&quot;%f %f %f\\n&quot;,-acos(-1),(double)ll,1.0/22); myprintf(&quot;%f %f %f\\n&quot;,-acos(-1),(double)ll,1.0/22); puts(&quot;&quot;); int a=20, b=30, n; double c=10.5, d=100000000; char e=&#x27;m&#x27;; char s[9]=&quot;myprintf&quot;; myprintf(&quot;%d %d\\n&quot;,a,a+b); myprintf(&quot;%f %e\\n&quot;,c,d); n=myprintf(&quot;%c\\t%s\\n&quot;,e,s); myprintf(&quot;%d\\n&quot;,n); puts(&quot;&quot;); printf(&quot;%g %g %.2g %.2g\\n&quot;, 0.00001234,0.0001234,123.45,23.45); myprintf(&quot;%g %g %.2g %.2g\\n&quot;, 0.00001234,0.0001234,123.45,23.45); float x=654.321; double pi=acos(-1); printf(&quot;%f %e %g %.8f %.8e %.8g %.4g\\n&quot;,x,x,x,pi,pi,pi,pi); myprintf(&quot;%f %e %g %.8f %.8e %.8g %.4g\\n&quot;,x,x,x,pi,pi,pi,pi); printf(&quot;%g %.5g %.3g\\n&quot;,0.034,9999.99,0.0009999); myprintf(&quot;%g %.5g %.3g\\n&quot;,0.034,9999.99,0.0009999); puts(&quot;&quot;); int haha=2147483647; double tst=3.6; printf(&quot;%yha %.yha %33.33ttttt %%..... %%d %hd\\n&quot;,haha,haha); myprintf(&quot;%yha %.yha %33.33ttttt %t %..... %%d %hd\\n&quot;,haha,haha); printf(&quot;%33.33\\n&quot;); myprintf(&quot;%33.33\\n&quot;); printf(&quot;%----10.....----10f\\n&quot;,tst); myprintf(&quot;%----10.....----10f\\n&quot;,tst); printf(&quot;%-10..3f\\n&quot;,tst); myprintf(&quot;%-10..3f\\n&quot;,tst); printf(&quot;%...f %----10.f\\n&quot;,tst,tst); myprintf(&quot;%...f %----10.f\\n&quot;,tst,tst); printf(&quot;%.---3f\\n&quot;,tst); myprintf(&quot;%.---3f\\n&quot;,tst); printf(&quot;%d\\n&quot;,printf(&quot;\\0&quot;)); printf(&quot;%d\\n&quot;,myprintf(&quot;\\0&quot;));&#125;","categories":[{"name":"project","slug":"project","permalink":"http://kqp.world/categories/project/"}],"tags":[{"name":"程设","slug":"程设","permalink":"http://kqp.world/tags/%E7%A8%8B%E8%AE%BE/"}]},{"title":"【MIPT Workshop Open 1 K】Blocks 题解","slug":"【MIPT Workshop Open 1 K】Blocks 题解","date":"2018-11-27T02:40:17.000Z","updated":"2024-04-24T03:59:22.861Z","comments":true,"path":"【MIPT Workshop Open 1 K】Blocks 题解/","link":"","permalink":"http://kqp.world/%E3%80%90MIPT%20Workshop%20Open%201%20K%E3%80%91Blocks%20%E9%A2%98%E8%A7%A3/","excerpt":"题目大意&emsp;&emsp;有 $n$ 个柱子，高度构成 $1$~$n$ 的排列。现在你要把他们排在一行，使得从左边看能看到恰好 $l$ 根柱子，从右边看能看到恰好 $p$ 根柱子。求方案数。共 $m$ 组数据。&emsp;&emsp;$n \\leq 50000,\\ \\ l,p \\leq 100,\\ \\ m \\leq 10^5$","text":"题目大意&emsp;&emsp;有 $n$ 个柱子，高度构成 $1$~$n$ 的排列。现在你要把他们排在一行，使得从左边看能看到恰好 $l$ 根柱子，从右边看能看到恰好 $p$ 根柱子。求方案数。共 $m$ 组数据。&emsp;&emsp;$n \\leq 50000,\\ \\ l,p \\leq 100,\\ \\ m \\leq 10^5$ \\\\ \\\\ \\\\题解&emsp;&emsp;可以很自然地想到 dp，从大到小放柱子，那么放在边上的就可以被看到，放到中间的就看不到。 &emsp;&emsp;这里要注意的是不要把左边和右边分开考虑，就是说不要什么分别算左边和右边然后合并，或者 dp 式子里设左边和右边分别看到了多少柱子。我不会告诉你我就是这样被卡了 2h 多。这样子始终会有一个 $O(l*p)$ 的时间。 &emsp;&emsp;但是可以发现一个新的柱子放两边其实是本质相同的！&emsp;&emsp;所以设 $f_{i,j}$ 表示从大到小放了 $i$ 个柱子（方便起见，去掉最高的那个），两边可见的共有 $j$ 个，的方案数。新加进来一个柱子要么放两边使 $j$ 加一，要么放中间。&emsp;&emsp;最后询问的时候乘个 $C_{p+q-2}^{p-1}$ 就好啦。 &emsp;&emsp;这样就是 $O(np+m)$ 的了。 代码1234567891011121314151617181920212223242526272829303132333435#include&lt;bits/stdc++.h&gt;#define fo(i,a,b) for(int i=a;i&lt;=b;i++)using namespace std;typedef long long LL;const int maxn=5e4+5, maxp=205;const LL mo=1e9+7;int n,p,q;LL f[maxn][maxp],C[maxp][maxp];int m;int main()&#123; n=50000, p=200; f[0][0]=1; fo(i,1,n-1) fo(j,1,min(p,i)) f[i][j]=(f[i-1][j-1]+f[i-1][j]*(i-1))%mo; fo(i,0,p) &#123; C[i][0]=1; fo(j,1,i) C[i][j]=(C[i-1][j-1]+C[i-1][j])%mo; &#125; scanf(&quot;%d&quot;,&amp;m); while (m--) &#123; scanf(&quot;%d %d %d&quot;,&amp;n,&amp;p,&amp;q); LL ans=f[n-1][p+q-2]*C[p+q-2][p-1]%mo; printf(&quot;%lld\\n&quot;,ans); &#125;&#125;","categories":[{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[{"name":"算法_神奇的脑洞","slug":"算法-神奇的脑洞","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E7%A5%9E%E5%A5%87%E7%9A%84%E8%84%91%E6%B4%9E/"},{"name":"算法_DP","slug":"算法-DP","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-DP/"}]},{"title":"2018ICPC北京凉凉记","slug":"2018_ICPC_beijing","date":"2018-11-15T05:49:53.000Z","updated":"2024-04-24T03:59:22.769Z","comments":true,"path":"2018_ICPC_beijing/","link":"","permalink":"http://kqp.world/2018_ICPC_beijing/","excerpt":"三色的 ACM&emsp;&emsp;单赛季三场比赛全部结束了，又到了退役的时候。&emsp;&emsp;三场集齐了金银铜，三色的 ACM~（笑 &emsp;&emsp;这次北京凉了也宣告我们 EC 续命失败了，我们的队可能也要终了。可以水一发游记纪念一下了~","text":"三色的 ACM&emsp;&emsp;单赛季三场比赛全部结束了，又到了退役的时候。&emsp;&emsp;三场集齐了金银铜，三色的 ACM~（笑 &emsp;&emsp;这次北京凉了也宣告我们 EC 续命失败了，我们的队可能也要终了。可以水一发游记纪念一下了~ 游记day-1&emsp;&emsp; 8h 高铁，感觉十分不友好。&emsp;&emsp;高铁上一直在给新手培训做数论课件，没有做题，感觉要凉。不开开脑子后天怎么打比赛啊。。。 &emsp;&emsp;据说因为沈阳报销超了，要削减经费，于是安排了个街边小宾馆，坐在马桶上头会顶到墙的那种。&emsp;&emsp;旅游第一弹——晚上 8 个人去干了一通全聚德。 day0&emsp;&emsp;报到领一件白色毛外套感觉十分 nice。几个家伙轮流装教练，骗了一堆饭卡和晚宴邀请。。。&emsp;&emsp;又见到了久违的打洞饭卡，熟悉的pku校园，被秋天金色渲染过的未名湖格外好看。感觉时间回到了一年半前，只希望脑子不要再是那时的脑子。&emsp;&emsp;饭堂居然没有冰淇淋卖了。。北方的冬天这么怂的吗。。 &emsp;&emsp;然后就是试机了。&emsp;&emsp;一看，旁边是 thu，心态崩了。&emsp;&emsp;一看，这个队是洲阁、鏼鏼鏼，鏼鏼发抖。我要找他们签名！&emsp;&emsp;一看题，妈呀这不是去年的北京原题吗，周三刚补的题！天助我也，终于有机会摸一血气球了吗？于是立下大志——抢气球！&emsp;&emsp;王神迅速开始写 C，写完 C 之后回头一看 ABC 的气球全没了。（大雾&emsp;&emsp;于是我迅速开始写 D，场上明显还有几支队也是在抢气球。幸好印象还在，凭印象把所有细节全都写好了，结果连 WA 两发，气球没了。心态崩了。&emsp;&emsp;抢气球失败，最后心情沮丧地 ak 掉，然后试了该试的东西就溜了。 &emsp;&emsp;晚上跟 thu 的小朋友们面基。主要任务&emsp;&emsp;逛了一圈清华，超大学校，超漂亮风景，超高档住宅区，超宽宿舍，超豪华自习室，超神仙课程资料。&emsp;&emsp;打开了一扇通往知识殿堂的大门。 day1&emsp;&emsp;今天是很重要的比赛，赢了我们就有机会 ec 续命，输了大概就要解散了。但是不能给自己太多这样的心理暗示，放松心情好好肝吧露比！ &emsp;&emsp;饭卡钱用不完，早上特地多买了两瓶咖啡。原以为足够牛逼了，转头一看隔壁鏼桌，四罐红牛。。。输了输了。。。 &emsp;&emsp;开场，王神迅速过了 A，然后轮到我写 I。&emsp;&emsp;写之前没认真算时间复杂度，直接就写了一位一位枚举和高精度，T 了一发。然后超蠢地花了很长时间优化高精度，所以一直 T。&emsp;&emsp;期间任大爷上去写 D，王神发现 B 是大模拟，我发现 H 可以AC自动机dp，这样我们就期望 5 题了。隔壁鏼爷已经 5 个气球了&emsp;&emsp;D 过了以后我去掉了一位一位枚举，然后就调 WA 了，又过了 1h 才终于 A 了，此时 11 点多。被这破题搞了 2h+ 和 3 发罚时可真是菜啊。。。&emsp;&emsp;任大爷发现 C 是做过的题，但是忘记式子了，推了很久没推出东西，上来打了个表，我写完 H 了依然没有找到规律。于是拉上任大爷弃 C 想 F。&emsp;&emsp;然后王大爷开始写 B，细节巨多，坑也巨多，一直写到封榜后 20min。终于把屯的题清干净了，然而大家都 5 题了 QAQ，隔壁鏼爷也快要 AK 了。&emsp;&emsp;我们在 F 和 J 中游荡，最后因为紧张把 F 看错题了，直接弃了 F，最后一起脑补出了 J，只剩 20min 了，写到一半结束了。 &emsp;&emsp;然后愉快地看坦克，自己的坦克太菜了并不能入围。看着别人的蒙特卡洛、机器学习，再看看自己的爆搜+if。。。&emsp;&emsp;居然能在决赛目睹了二打一的存在。。。 &emsp;&emsp; 5 题人太多，从 rk5 到 rk25。我们离 au 线大概是 3 发罚时，卡 B I 卡到 ag 第 4。。。&emsp;&emsp;前面的队伍突然冒出一句话：“我们的抽奖券呢？这是我们最后翻盘的机会了。。”&emsp;&emsp;挺搞笑的，但是却很伤感。我们又何尝不是这样呢？最后中了个三等奖 &emsp;&emsp;晚上愉快商汤，然后第二天就滚粗了。 end&emsp;&emsp;结束了，意味着终于有大把时间学习文化课了，当初希望爆肝数学爆肝专业课的愿望要开始了。&emsp;&emsp;但是却没有当初期盼得到学习时间的那种释然，反而很沉重，很伤心，又一次体会到了退役的失落。&emsp;&emsp;为什么会这么矛盾呢？&emsp;&emsp;大概还是因为没有“把在做的每一件事做到最好”吧。 &emsp;&emsp;既然决定了打acm，就应该拼劲全力，像左神说的，“先把金牌拿了再说，先把 final 进了再说。”我做到了吗？大概是没有。&emsp;&emsp;总是在学习和竞赛之间犹豫不决，时间分配错乱；总是莫名其妙不知道把时间花到哪里去了。屯了一堆题没做，屯了一堆课件没学，这下好了，到了可以离开竞赛的时候，又离不开了。现在这个半吊子成绩，值得这段时间的花费吗？ &emsp;&emsp;此刻队友已是大二，再往上就要去科研了，没进 final 可能不会再来一次了，这就落下终身遗憾了。&emsp;&emsp;或许，我浪费了自己的时间，我还有大二可以再来一次。但是队友呢？因为我的怠惰，失去了最后的机会。 &emsp;&emsp;最后还是回到我身上。大二还来吗？ &emsp;&emsp;大学不似高中，高中的课停了，一个高三就可以追回来。大学的课，怕是停不起。最好的学竞赛的时光是中学，中学学明白了，大学就安安心心做学术。只不过，趁着大一，可以玩一场。 &emsp;&emsp;其实你说什么也补不回已经过去的这几个月了。大一上明明是最空闲的、最适合为 final 而冲刺的时光，现在没了。&emsp;&emsp;那么，承认自己的无能，往下掉一个段位，同大一基础不太好的同学一起，再来一次？&emsp;&emsp;毕竟，好不容易能在 sysu 这样一个机会多多的学校，能有机会冲 final，为什么不来一次呢？毕竟，就算是 thu / pku / sjtu / zju 这样的强校，也有很多大二大三的选手，他们能平衡竞赛和学习的时间，我也可以吧？毕竟，像左神、Q神、唐老师、cjb、claris这样的选手，前途不会比完全专心学术的人差（吧。&emsp;&emsp;当初一诺跟你说“我们争取进 final”的时候，你甚至在笑。现在你知道了什么是自己放弃自己，你知道了什么是以为自己时间很多。 先把 final 进了再说。——左老师 &emsp;&emsp;这一次，你可千万别再迷茫了。","categories":[{"name":"总结与游记","slug":"总结与游记","permalink":"http://kqp.world/categories/%E6%80%BB%E7%BB%93%E4%B8%8E%E6%B8%B8%E8%AE%B0/"},{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[]},{"title":"【2018icpc Regional 北京 F】【hihocoder1875】The Kth Largest Value","slug":"【2018icpc Regional 北京 F】【hihocoder1875】The Kth Largest Value","date":"2018-11-12T15:37:38.000Z","updated":"2024-04-24T03:59:22.807Z","comments":true,"path":"【2018icpc Regional 北京 F】【hihocoder1875】The Kth Largest Value/","link":"","permalink":"http://kqp.world/%E3%80%902018icpc%20Regional%20%E5%8C%97%E4%BA%AC%20F%E3%80%91%E3%80%90hihocoder1875%E3%80%91The%20Kth%20Largest%20Value/","excerpt":"题目大意&emsp;&emsp;给定一幅 $n$ 个点的有向图，若 $u$ 可达 $v$，则把 $u \\oplus v$ 加进一个可重集合里。有 $Q$ 个询问，每次询问求集合里的第 $k$ 大的数。&emsp;&emsp;$n \\le 50000,\\ k \\le 10^9,\\ Q \\le 10$","text":"题目大意&emsp;&emsp;给定一幅 $n$ 个点的有向图，若 $u$ 可达 $v$，则把 $u \\oplus v$ 加进一个可重集合里。有 $Q$ 个询问，每次询问求集合里的第 $k$ 大的数。&emsp;&emsp;$n \\le 50000,\\ k \\le 10^9,\\ Q \\le 10$ \\\\ \\\\ \\\\题解&emsp;&emsp;缩环后每个点 $u$ 可以用 bitset 得到一个 $v$ 的集合。 &emsp;&emsp;想象一下把每个点的贡献（各种 $u \\oplus v$）合起来构一棵 trie，那么答案就可以从高位到低位贪心了，能放 1 就放 1 否则放 0 那种。于是问题转化成问某个子树的标记数量。&emsp;&emsp;但是把 trie 建出来时间复杂度就不对了。贪心了答案的某一位后，我们想知道当前这个范围内的数量，就 $O(n)$ 扫每一个点单独统计。 &emsp;&emsp;对于每个点的询问相当于，给定一个区间，求这个点有多少个可达的点，标号在这个区间内。那就是 bitset 的 count 了。&emsp;&emsp;但是不能每个点 $O(\\frac{n}{32})$ 地询问，否则会 T。所以这个 bitset 要处理一下，比如手写 bitset，每 32 位作为一个单元，求出每个单元的 1 的个数，做前缀和。这样询问每个点的时候，就像分块一样只需要 $O(32)$ 了。","categories":[{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[{"name":"算法_莫队/分块","slug":"算法-莫队-分块","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E8%8E%AB%E9%98%9F-%E5%88%86%E5%9D%97/"},{"name":"算法_位运算","slug":"算法-位运算","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/"}]},{"title":"2018ICPC南京站观光记","slug":"2018_ICPC_nanjing","date":"2018-10-19T16:52:36.000Z","updated":"2024-04-24T03:59:22.770Z","comments":true,"path":"2018_ICPC_nanjing/","link":"","permalink":"http://kqp.world/2018_ICPC_nanjing/","excerpt":"海风吹过的夏天&emsp;&emsp;刚来到 sysu，打第一场选拔赛的时候，我的感受大概就是：这帮人是连点分都不会的吗？？ &emsp;&emsp;后来，一场一场选拔，一次一次组队练习，这帮人终于露出了面目狰狞的真面孔。这里有 GDOI 出题人，有 APIO Au，有 WC Au，有 WF 选手、cf 红名，区域赛金牌、前十、奖杯数不胜数，还有人肉 oeis 、LL万氪dalao……我第一次跟某 WC Au 组队，结果写挂的都是我的；第二次跟某 GDOI 出题人组队，不到三天就被赶了出来；第三次跟某双十和绍一 dalao 组队，才被收留了。 &emsp;&emsp;这里打 acm 的氛围很好。在 thu，大一就已经学业繁忙了，学生们都专心学习和舞会，而且名额基本上被那群人包了（什么 ioi rank 之和等于 6 的队啦（雾）），一本 dalao 根本都轮不上。sysu 这里没有 thu 那么巨，但是也会让你有很大压力，毕竟 sysu每年都会有几个远远超出sysu水平的人。——知乎","text":"海风吹过的夏天&emsp;&emsp;刚来到 sysu，打第一场选拔赛的时候，我的感受大概就是：这帮人是连点分都不会的吗？？ &emsp;&emsp;后来，一场一场选拔，一次一次组队练习，这帮人终于露出了面目狰狞的真面孔。这里有 GDOI 出题人，有 APIO Au，有 WC Au，有 WF 选手、cf 红名，区域赛金牌、前十、奖杯数不胜数，还有人肉 oeis 、LL万氪dalao……我第一次跟某 WC Au 组队，结果写挂的都是我的；第二次跟某 GDOI 出题人组队，不到三天就被赶了出来；第三次跟某双十和绍一 dalao 组队，才被收留了。 &emsp;&emsp;这里打 acm 的氛围很好。在 thu，大一就已经学业繁忙了，学生们都专心学习和舞会，而且名额基本上被那群人包了（什么 ioi rank 之和等于 6 的队啦（雾）），一本 dalao 根本都轮不上。sysu 这里没有 thu 那么巨，但是也会让你有很大压力，毕竟 sysu每年都会有几个远远超出sysu水平的人。——知乎 9月&emsp;&emsp;我们队自建队以来，只要我参与的训练，就没有总题数第一。。。 &emsp;&emsp;有时候做题做着做着会忽然怀疑人生，觉得现在还在写算法学算法失去了很多意义。同行都在玩耍或者进一步发展，我好像只是在重复过去。是因为没法再去获得中学时那样的荣誉了吗？可能是，对竞赛的热爱有点不纯了。&emsp;&emsp;我发现我变得咸鱼了，懒于改题，懒于写博客，中学时会过的现在不会了，没看完的课件也撇一边不看了，邮箱里存着的 tourist 的 agc 也没看了……每次总要屯到快把题目忘光了才来看看题解，然后憋好久憋出一篇质量十分水的题解。noi 之前的那股学习的冲劲呢？？呢？？呢？？&emsp;&emsp;来时想着这里可能学习比较水要自己补一点，结果也没补成，超前预习最终也被课程进度赶上了。&emsp;&emsp;大学时间是真的多，然而安排不好就比高中还少。 &emsp;&emsp;感觉真的是在吃老本了。 &emsp;&emsp;不行了我真的要发奋图强了。你说好的自学计划呢？？屯着的 oi 资料呢？？快 tmd 给我学啊！！ &emsp;&emsp;先补文化课还是先肝竞赛呢？犹豫一下，时间好像又过去了。。。 &emsp;&emsp;比赛终究来了。 观光记day-1&emsp;&emsp;飞机不给报销于是坐高铁，结果没有合适的时间于是买了 广州南-&gt;武汉-&gt;南京 的车，足足跑了一个等腰三角形的两条腰，最后据说比飞机还贵。。。&emsp;&emsp;在车上愉快地做题。从 JZ 的模拟赛里偷了一套题出来，结果总是做着做着就去做别的题了。。。 day0&emsp;&emsp;一大早起来肝英语比赛错过逛校园。 &emsp;&emsp;下午试机。&emsp;&emsp;woc 这个试机题怎么这么劝退啊，看了好久没一点思路。。。&emsp;&emsp;许久之后 wcy1122 和任大爷把 B 和 C 弄好了，我的 A 和 D 还没有想法。然后发现 D 看错题了，并不是累加而是替换，这样的话每个点最多一个标记了。结果对着个等差数列不知所措，总是在想维护一次函数，直到别的队来交流才意识到是个类欧。。。最后发现 A 也理解错了，而且好像是全场都理解成了海盗要跟着步子走，然后觉得是个神仙题，正好也没什么人过，于是没人提问。。。。&emsp;&emsp;我是个假数论讲师。&emsp;&emsp;心态崩了。 &emsp;&emsp;晚上复习，看着课件里的操作发现自己啥也不会，什么高级的博弈啦，牛逼一点的平衡树啦，还有一堆算法啦，中学时来不及学，暑假了立下 flag 要补，到现在还没补。总要等到考试了，才发现自己是个萌新。&emsp;&emsp;最终复习进度 1.2M / 2.2G。心态崩了。 day1&emsp;&emsp;早上遇见了 HbFS，他的队友长得超级像王劲松，三个人站一起真的像一支特种部队，超级帅~ &emsp;&emsp;比赛愉快地开始辣。&emsp;&emsp;开场板刷 A，我们一看这不是个 SG 裸题吗赶紧敲，敲完 WA 了，改了换行交上去又 WA，心态崩了。重新审题，终于发现看漏了连续，于是我赶紧口胡了个新算法，码完又 WA，这才发现报了个假算法，心态完全崩了。于是埋头找规律，终于在将近 30min 的时候猜对了 QaQ。。。罚时开始爆炸。&emsp;&emsp;然后很顺利地过了 J、I，志愿者小姐姐连续发错两次气球差评。任大爷以为 E 是个签到题结果 WA 了以后发现看错题了，于是去搞 G 了。wcy1122 认为 D 可以三分套三分套三分，于是写了一发又 WA 了。然后我发现 M 是个 Manacher 加匹配的套路题，写完发现不能 kmp 而且 exkmp 的板子错了。。。现在我们 3 题，排名千里之外，心态崩得不行。&emsp;&emsp;然后我们就交替写题，wcy1122 改 D 和 G，我改 exkmp，任大爷推 G。就这样交替了一万年，完全不敢开 board。终于在封榜前 1h 内肝出了结果，陆续过了 D G M。（场外的郭老被我们 20min 连过三题震惊了。。）&emsp;&emsp;然后突然灵感来了，想出了 K，于是赶紧写，写完过了，就封榜了。此时 rk13，罚时巨大，十分不稳。&emsp;&emsp;封榜之后能做的大概只有 B E L 了。苦思冥想，转化模型，最终还是咸鱼了 1h。于是比赛结束了。 &emsp;&emsp;开榜后 rk20，罚时巨大，幸好还在 Au 之内。sysu帅气小哥哥队大概是去掉铁牌打星后 rk3 还是 rk5 反正比较强。我们果然还是太咸鱼了。&emsp;&emsp;出场跟人讨论，发现 B 是凸优化，E 是最小表示。QAQ 我太菜了，以前把凸优化当水法不重视，现在被打了。 &emsp;&emsp;算是人生第一枚金牌啦，心情还算愉悦，晚上快乐吃饭饭、游南京、逛南大。 day2&emsp;&emsp;就回去了。&emsp;&emsp;列车上被某小孩大声哭闹吵到了，跟监护人理论时感受到了国人的素质。&emsp;&emsp;后来作业也没写多少。 总结&emsp;&emsp;我还是觉得总题数比较重要，罚时什么的，读错题就不可避免了。所以后面的训练还是思维为主。争取后面训练能有总题数第一。（flag）&emsp;&emsp;当然代码能力我们三个人都不算十分好，包括训练在内，我们总是写错好多。一开始还想我们加训要不就不要练签到题了，但想想还是不行，签到题炸罚时的确是我们的弱项。 ACM？&emsp;&emsp;这次比赛忽然发现了 acm 跟 oi 一个极大的不同：acm 几乎不重视对模板算法的理解。&emsp;&emsp;在 oi，你学了一个算法，还不够，得彻底理解，理解不了的得背下来，这才能在赛场上用。也因此赛场上常出现会做不会写的情况，在这里形成了区分度。&emsp;&emsp;而 acm 呢？你甚至都不用学算法，把它抄到模板上，纯粹就是个黑箱，你只要知道它是干什么的就行了。这次比赛中我忽然发现 exkmp 我不会原理了，这要是放在 oi 上是要出大事的，但是这次，我却可以直接把板子抄了，调一调，就行了。 &emsp;&emsp;是好事，也是忧患。万一养成了只重应用不重理解，那就成了比谁知道的算法更多，这样思维会有缺陷的。&emsp;&emsp;有心的人自会去学，无心的人却会坏了风气。 离题了&emsp;&emsp;好吧，这篇里的游记只占一半了。&emsp;&emsp;那就水到这里吧。 &emsp;&emsp;SYSU_Ass♂We♂Can","categories":[{"name":"总结与游记","slug":"总结与游记","permalink":"http://kqp.world/categories/%E6%80%BB%E7%BB%93%E4%B8%8E%E6%B8%B8%E8%AE%B0/"},{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[]},{"title":"【2017ccpc杭州L】【hdu6275】Mod, Xor and Everything 题解","slug":"【2017ccpc杭州L】【hdu6275】Mod, Xor and Everything 题解","date":"2018-10-17T16:12:36.000Z","updated":"2024-04-24T03:59:22.803Z","comments":true,"path":"【2017ccpc杭州L】【hdu6275】Mod, Xor and Everything 题解/","link":"","permalink":"http://kqp.world/%E3%80%902017ccpc%E6%9D%AD%E5%B7%9EL%E3%80%91%E3%80%90hdu6275%E3%80%91Mod,%20Xor%20and%20Everything%20%E9%A2%98%E8%A7%A3/","excerpt":"题目大意&emsp;&emsp;求 $(n \\bmod 1)\\oplus(n \\bmod 2)\\oplus \\cdots \\oplus(n \\bmod n)$&emsp;&emsp;$n \\leq 10^{12}$","text":"题目大意&emsp;&emsp;求 $(n \\bmod 1)\\oplus(n \\bmod 2)\\oplus \\cdots \\oplus(n \\bmod n)$&emsp;&emsp;$n \\leq 10^{12}$ \\\\ \\\\ \\\\题解&emsp;&emsp;此题跟超级绵羊异或异曲同工。 &emsp;&emsp;求异或和有一个思路是：求出每一位分别是什么。&emsp;&emsp;从低到高第 $k$ 位（从 $0$ 开始）的答案其实就是 \\begin{aligned} &\\sum_{i=1}^n\\lfloor\\frac{n~mod~i}{2^k}\\rfloor \\pmod{2} \\\\ =&\\sum_{i=1}^n\\lfloor\\frac{n-\\lfloor\\frac{n}{i}\\rfloor i}{2^k}\\rfloor \\pmod{2} \\end{aligned}&emsp;&emsp;注意到 $\\lfloor\\frac{n}{i}\\rfloor$ 是可分块的，于是把它分块，这就成类欧啦~ &emsp;&emsp;当然可能还需要卡卡常：比如调整循环顺序以剪枝，比如前 1e7 个直接暴力。。。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;bits/stdc++.h&gt;#define fo(i,a,b) for(int i=a;i&lt;=b;i++)using namespace std;typedef long long LL;LL n;bool f(LL a,LL b,LL c,LL n)&#123; if (!a) return (((n+1)&amp;(b/c))&amp;1)&gt;0; if (a&gt;=c || b&gt;=c) &#123; LL sqr=(n&amp;1) ?(n+1)/2*n :n/2*(n+1) ; return ((f(a%c,b%c,c,n)+(a/c)*sqr+(n+1)*(b/c))&amp;1)&gt;0; &#125; else &#123; LL m=(a*n+b)/c; return (((m*n)^f(c,c-b-1,a,m-1))&amp;1)&gt;0; &#125;&#125;int T;int main()&#123; scanf(&quot;%d&quot;,&amp;T); while (T--) &#123; scanf(&quot;%lld&quot;,&amp;n); LL ans=0,sqrtn=min(30000000ll,n); fo(i,1,sqrtn) ans^=n%i; for(LL i=sqrtn+1, j; i&lt;=n; i=j+1) &#123; j=n/(n/i); LL lim=n/i*(j-i)+n%j, ans1=0; for(LL k=1; k&lt;=lim; k&lt;&lt;=1) ans1+=f(n/i,n%j,k,j-i)*k; ans^=ans1; &#125; printf(&quot;%lld\\n&quot;,ans); &#125;&#125;","categories":[{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[{"name":"算法_数论","slug":"算法-数论","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E6%95%B0%E8%AE%BA/"}]},{"title":"【2018ccpc网络赛1008】【hdu6445】Search for Answer 题解","slug":"【2018ccpc网络赛1008】【hdu6445】Search for Answer 题解","date":"2018-09-21T16:45:50.000Z","updated":"2024-04-24T03:59:22.805Z","comments":true,"path":"【2018ccpc网络赛1008】【hdu6445】Search for Answer 题解/","link":"","permalink":"http://kqp.world/%E3%80%902018ccpc%E7%BD%91%E7%BB%9C%E8%B5%9B1008%E3%80%91%E3%80%90hdu6445%E3%80%91Search%20for%20Answer%20%E9%A2%98%E8%A7%A3/","excerpt":"题目大意&emsp;&emsp;有一幅竞赛图（n&lt;=200），其中一些边未定向（ $s[i][j]=1$ 且 $s[j][i]=0$ 表示一条边从 $i$ 到 $j$，$s[i][j]=s[j][i]=2$ 表示未定向）。现在你要把这些边定向，使得图的权值最大。权值用下面的算法来计算：","text":"题目大意&emsp;&emsp;有一幅竞赛图（n&lt;=200），其中一些边未定向（ $s[i][j]=1$ 且 $s[j][i]=0$ 表示一条边从 $i$ 到 $j$，$s[i][j]=s[j][i]=2$ 表示未定向）。现在你要把这些边定向，使得图的权值最大。权值用下面的算法来计算： \\\\ \\\\ \\\\题解&emsp;&emsp;据说你们都能很顺利地直接推出式子。。。果然是我太菜了吗 QAQ &emsp;&emsp;考虑容斥，首先先把所有四元环加一次（即 $A_n^4$），然后把不该加的去掉。不该加的环一定存在某个点连了两条出边，且如果这个环是 $Ans$ 不加不减的，那么它有且仅有一个这样的点；如果是 $Ans$ 要减的，那么它就会有两个这样的点。&emsp;&emsp;于是我们只要枚举一个点的两条出边，再枚举另一个点，这样来代表一个不该加的环，然后给 $Ans$ 减 8。如果这个环是 $Ans$ 不加不减的，那么它刚好被全部减掉；如果这个环是 $Ans$ 要减的，那么它就被减了两次，刚好成为负数。于是得出了下面的式子： Ans=A^4_n-\\sum_{i=1}^n \\binom{deg[i]}{2}*(n-3)*8&emsp;&emsp;（注：牛客上面的式子是错的） &emsp;&emsp;于是可以发现答案只跟点的出度有关，并且 $\\sum \\binom{deg[i]}{2}$ 越小越好。这个可以费用流，左边一排点表示未定向的边，右边两排点表示原图的点，右边的 $i$ 与 $i’$ 之间连若干条边，表示点 $i$ 每次度数 +1 的费用增量（类似于动态加边那样，但是不用动态加边也能过）。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define fo(i,a,b) for(int i=a;i&lt;=b;i++)using namespace std;typedef long long LL;const int maxn=205, maxp=20405, maxe=80205;int n,mp[maxn][maxn],dg[maxn],sum;int ReadDigit()&#123; char ch=getchar(); while (ch&lt;&#x27;0&#x27; || ch&gt;&#x27;9&#x27;) ch=getchar(); return ch-&#x27;0&#x27;;&#125;int tot,go[2*maxe],val[2*maxe],Cos[2*maxe],nxt[2*maxe],f1[maxp];void ins(int x,int y,int z,int c)&#123; go[++tot]=y; val[tot]=z; Cos[tot]=c; nxt[tot]=f1[x]; f1[x]=tot;&#125;LL ans;int d[10*maxp],dis[maxp],fro[maxp][2];bool bz[maxp];void McMf()&#123; while (1) &#123; memset(dis,127,sizeof(dis)), dis[0]=0; bz[ d[1]=0 ]=1; for(int i=1, j=1; i&lt;=j; i++) &#123; for(int p=f1[d[i]]; p; p=nxt[p]) if (val[p] &amp;&amp; dis[d[i]]+Cos[p]&lt;dis[go[p]]) &#123; dis[go[p]]=dis[d[i]]+Cos[p]; fro[go[p]][0]=d[i], fro[go[p]][1]=p; if (!bz[go[p]]) &#123; bz[ d[++j]=go[p] ]=1; if (dis[d[i+1]]&gt;dis[d[j]]) swap(d[i+1],d[j]); &#125; &#125; bz[d[i]]=0; &#125; if (dis[sum]==2139062143) break; for(int i=sum; i; i=fro[i][0]) &#123; int p=fro[i][1]; val[p]--, val[(p&amp;1) ?p+1 :p-1 ]++; ans+=Cos[p]; &#125; &#125;&#125;int T;int main()&#123; scanf(&quot;%d&quot;,&amp;T); while (T--) &#123; tot=0; memset(f1,0,sizeof(f1)); scanf(&quot;%d&quot;,&amp;n); memset(dg,0,sizeof(dg)); fo(i,1,n) fo(j,1,n) &#123; mp[i][j]=ReadDigit(); if (mp[i][j]==1) dg[i]++; &#125; fo(i,1,n) &#123; ins(0,i,n+5,0), ins(i,0,0,0); fo(j,dg[i]+1,n-1) ins(i,n+i,1,j*(j-1)/2-(j-1)*(j-2)/2), ins(n+i,i,0,0); &#125; sum=2*n; fo(i,1,n-1) fo(j,i+1,n) if (mp[i][j]==2) &#123; sum++; ins(n+i,sum,1,0), ins(sum,n+i,0,0); ins(n+j,sum,1,0), ins(sum,n+j,0,0); &#125; fo(i,2*n+1,sum) ins(i,sum+1,1,0), ins(sum+1,i,0,0); sum++; ans=0; fo(i,1,n) ans+=dg[i]*(dg[i]-1)/2; McMf(); ans=(LL)n*(n-1)*(n-2)*(n-3)-ans*(n-3)*8; printf(&quot;%I64d\\n&quot;,ans); &#125;&#125;","categories":[{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[{"name":"算法_网络流/匹配","slug":"算法-网络流-匹配","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E7%BD%91%E7%BB%9C%E6%B5%81-%E5%8C%B9%E9%85%8D/"}]},{"title":"【2017NEERC Moscow Subregional】Byteland Trip 题解","slug":"【2017NEERC Moscow Subregional】Byteland Trip 题解","date":"2018-07-25T15:54:27.000Z","updated":"2024-04-24T03:59:22.803Z","comments":true,"path":"【2017NEERC Moscow Subregional】Byteland Trip 题解/","link":"","permalink":"http://kqp.world/%E3%80%902017NEERC%20Moscow%20Subregional%E3%80%91Byteland%20Trip%20%E9%A2%98%E8%A7%A3/","excerpt":"题目大意&emsp;&emsp;$n$ 个点排成一排，每个点如果为 “&lt;” 则表示可以跳到它左边的一个位置，如果为 “&gt;” 则表示可以跳到它右边的一个位置。&emsp;&emsp;对每个点 $i$，求以 $i$ 为终点、经过每个点恰好一次的路径数。&emsp;&emsp;$n \\leq 5000$","text":"题目大意&emsp;&emsp;$n$ 个点排成一排，每个点如果为 “&lt;” 则表示可以跳到它左边的一个位置，如果为 “&gt;” 则表示可以跳到它右边的一个位置。&emsp;&emsp;对每个点 $i$，求以 $i$ 为终点、经过每个点恰好一次的路径数。&emsp;&emsp;$n \\leq 5000$ \\\\ \\\\ \\\\题解&emsp;&emsp;对于到达点 $i$ 的每一条路，有时在左边有时在右边，不好处理，我们应该想办法使左右两边分别处理然后合并。&emsp;&emsp;dp，设 $f_{i,j}$ 表示从左到右做到第 $i$ 个点、形成了 $j$ 个连通块（每个连通块是一段路径，并且最终指向右边）的方案数，再设 $g_{i,j}$ 表示从右到左做到第 $i$ 个点、形成了 $j$ 个连通块（每个连通块最终指向左边）的方案数。&emsp;&emsp;对于点 $i$，枚举 $j$ 将 $f_{i-1}$ 与 $g_{i+1}$ 合并即是答案。&emsp;&emsp;求这两个 dp 数组很简单，比如求 $f_i$，第 $i$ 个点如果是 “&lt;”，则要么成为某个连通块的开始，要么连接两个连通块；如果是 “&gt;”，则要么成为某个连通块的末尾，要么新建一个连通块。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define fo(i,a,b) for(int i=a;i&lt;=b;i++)#define fd(i,a,b) for(int i=a;i&gt;=b;i--)using namespace std;typedef long long LL;const int maxn=5010;const LL mo=1e9+7;int n;char S[maxn];LL f[maxn][maxn],g[maxn][maxn],fac[maxn];int main()&#123; fac[0]=1; fo(i,1,5005) fac[i]=fac[i-1]*i%mo; scanf(&quot;%s&quot;,S+1); n=strlen(S+1); if (n==1) &#123;printf(&quot;1\\n&quot;); return 0;&#125; f[0][0]=1; fo(i,1,n) fo(j,1,i) if (S[i]==&#x27;&lt;&#x27;) f[i][j]=(f[i-1][j]*j+f[i-1][j+1]*(j+1)%mo*j)%mo; else f[i][j]=(f[i-1][j-1]+f[i-1][j]*j)%mo; g[n+1][0]=1; fd(i,n,1) fo(j,1,n-i+1) if (S[i]==&#x27;&lt;&#x27;) g[i][j]=(g[i+1][j]*j+g[i+1][j-1])%mo; else g[i][j]=(g[i+1][j]*j+g[i+1][j+1]*(j+1)%mo*j)%mo; fo(i,1,n) &#123; LL ans=0; fo(j,0,i-1) &#123; if (j) (ans+=fac[j]*fac[j-1]%mo*f[i-1][j]%mo*g[i+1][j-1])%=mo; (ans+=fac[j]*fac[j]%mo*2%mo*f[i-1][j]%mo*g[i+1][j])%=mo; (ans+=fac[j]*fac[j+1]%mo*f[i-1][j]%mo*g[i+1][j+1])%=mo; &#125; printf(&quot;%I64d &quot;,ans); &#125;&#125;","categories":[{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[{"name":"算法_DP","slug":"算法-DP","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-DP/"}]},{"title":"复活","slug":"rebirth","date":"2018-06-30T05:05:15.000Z","updated":"2024-04-24T03:59:22.790Z","comments":true,"path":"rebirth/","link":"","permalink":"http://kqp.world/rebirth/","excerpt":"// 感谢各位在我不在的时候对我的支持！ 复活&emsp;&emsp;这么快又一年了，高中都读完了，要成为大学生了耶~ &emsp;&emsp;在一群神犇中成长，我算是比较菜的一个了。同组的人签完了各种协议，我却要拼高考；最后他们 thu / pku / zju / sjtu …… 只有我是野生的 sysu。 &emsp;&emsp;但是，高三学文化课的这一年给我带来了一个全新的世界。原以为机房才是通向世界的大门，走出机房才发现别有洞天。","text":"// 感谢各位在我不在的时候对我的支持！ 复活&emsp;&emsp;这么快又一年了，高中都读完了，要成为大学生了耶~ &emsp;&emsp;在一群神犇中成长，我算是比较菜的一个了。同组的人签完了各种协议，我却要拼高考；最后他们 thu / pku / zju / sjtu …… 只有我是野生的 sysu。 &emsp;&emsp;但是，高三学文化课的这一年给我带来了一个全新的世界。原以为机房才是通向世界的大门，走出机房才发现别有洞天。 高三8~10月&emsp;&emsp; 8 月刚回到教室还是处于情绪低落的阶段。不过斗志却很充足，毕竟是自己的出路，无论如何必须要奋斗的。&emsp;&emsp;然而啥都不会。。虽说完全停课的只有一个学期，但是已经把停课之前的都忘了。。。宛若新高一。&emsp;&emsp;不过也正因如此，高考题充满了挑战性的诱惑。数学啊物理啊同样可以刷新智商的。 &emsp;&emsp;班主任说，你是素质很高的学生啊，你至少要考到 zju！（奶×1） &emsp;&emsp;于是开始补课、刷题，渐渐沉迷学习无法自拔。发现好多原以为掌握透彻的基础概念因为时间太久的关系都出现了很大偏差，几乎所有东西都要重新学。别人复习，我们预习。所幸基础还是有的，学起来不是很困难。&emsp;&emsp;开学十几天第一次大考，rank 500+。考了停课组第一，有了一点信心。 &emsp;&emsp;渐渐地已经把过去的事忘得差不多了，学习也逐渐顺利起来了，周日下午的自由时间也用来学习是一件很快乐的事情不然我根本做不完作业。rank 逐渐恢复到 200+。 &emsp;&emsp;就在 oi 即将被遗忘的时候… noip2017&emsp;&emsp;说什么为期一年的休战协议。。。高三参加 noip 明明就是传统习俗，肯定要去玩啦~&emsp;&emsp;纯属裸考，权当旅游。 &emsp;&emsp;WTF！？今年考点在广州二中？偏远山区，说好的玩耍呢？这样只能玩电脑了啊！！ &emsp;&emsp;day0 复习，发现多数板子还记得，但是临近 noi 时学的先进技巧就不太会了（比如广附版短小精悍的线段树）。&emsp;&emsp;day1，t2 好像很水啊，t1 exgcd 可以暴力但应该能推式子吧，t3 不知道呢待会再说。t1 搞了一会儿没推出式子，突然发现可以打表，然后就打了个表，顺利找到了规律。然后写完了前两题。t3 还是想复杂了，老是想着把环缩起来然后怎样怎样，事实上只要按 k 分层然后 dp 就好了。。。我好菜啊.jpg&emsp;&emsp;day2，t1 签到题，t2 的话 n 这么小肯定是状压 dp 啦，t3 某种数据结构题。写着写着发现 t2 好像不太对啊怎么只能做到 70 分的呢？再来敲 t3，QAQ老年人已经不会做数据结构题了。。。然后出了考场被提醒，t2 我多枚举了一个东西（已经忘记是啥了），去掉就可以过了。 &emsp;&emsp;最后停课组参加了的全部 500+，我只有 400+。oi 的事算是结束了。 10月~高考&emsp;&emsp;这时候做题已经有点熟练了，但是知识点还不齐，于是一边学知识一边做题，就这样过了一段时间。。。&emsp;&emsp;布置的作业和自己的资料基本无法兼顾，原因还是自己效率太低了。认认真真做作业可以提高成绩，但无法顾我所需。然后就这样努力平衡两边。&emsp;&emsp;直到第二学期开始，知识点全部补完，rank 也终于到了 100+。&emsp;&emsp;然后就进入二轮复习，刷专题、套题。 &emsp;&emsp;我真的越来越有感悟，文化课带来的眼界一点不比待在机房小。我得庆幸回来做做数学物理，能学会很多分析题目的方法，重拾各种各样的思维；我得高兴回来学学化学生物，搞清楚基本概念不说，做的题目里面有各种各样的前沿科技背景；非常开心能读古诗古文、写写作文，还有各种阅读材料，让我真正明白什么叫做 “ 腹有诗书气自华 ”，不至于做一个只会看番打隔膜的宅；还有很厉害的同学，学不同科目的人真的思维都不一样，多接触一下真的很有趣。 &emsp;&emsp;然后就是一模二模三模，到后面每周一考。许多做题套路真正熟练也是从这时候开始，然而成绩却没怎么提高。学校给的卷子都很水，感觉根本不是全国卷难度，于是我们班单独找了很多很难的卷子来做。&emsp;&emsp;最后 100 天倒计时飞一样快（真的，noi 一个月倒计时都没有这么快），还没有完全准备好呢突然间就要考试了。别的同学都焦躁难忍，期盼放假，但我却真的不希望这么早结束，我希望留给我准备的时间越长越好。 &emsp;&emsp;跟 noi 一个感觉，抱着一堆没做完的题，一堆没证完的公式，仓促上阵。 &emsp;&emsp;woc 这真的是全国卷吗？意外的水啊。。。&emsp;&emsp;woc 不是水题吗怎么这题我不会啊？？？&emsp;&emsp;woc 怎么全场都切了就我没切！！？？？ &emsp;&emsp;凉了半截。。。 sysu&emsp;&emsp;然而无暇顾及高考结果，高考完就是自招了，sysu 要考机试，还只有一天时间准备。。。&emsp;&emsp;大半年过去了，大约已经不记得自己学过 oi 了。随便翻了翻我的博客，woc这是我写的吗？？不敢相信我曾经会过。。。&emsp;&emsp;一天时间：啊啊啊板子背不完了赶紧想个题吧恢复思维水平更重要——&gt;啊啊啊题目想不出来了赶紧背板子吧会写代码更重要——&gt;啊啊啊板子背不完了赶紧想个题吧恢复思维水平更重要…… &emsp;&emsp;然后就来到了可爱的 sysu。2.5h 4个题。&emsp;&emsp;嗯，t1 大约是推题目性质的题；t2 大约是简单线段树；t3 哇喜闻乐见的 2-sat，进考场之前还在讨论来着！t4 组合数题估计要推公式。于是赶紧码，码完 t1 t2，然后码 t4 的暴力，然后码 t3，时间太紧什么题都没拍，t3 想写 tarjan，然而写完缩环写不下去了。。。最后急中生智想起了 noi 的时候有人 random_shuffle 水的分贼高于是果断交了个水法结束。&emsp;&emsp;跟以前经受的 OI 毒打对比起来感受就是：这种题真的是可以出来选拔的吗？要是比赛有 4h 分分钟全场 AK 给你看啊？&emsp;&emsp;woc 我 t3 t4 都没写正解那我肯定进不了前七了。。。我觉得有人会 AK，即使不 AK 也可以接近 AK 了吧？ &emsp;&emsp;咦？我一本了？ &emsp;&emsp;第一个叫我名字？？那肯定从第七开始读的。 &emsp;&emsp;咦我真的是 rank1 哦？2-sat 被我水了80？？ zju&emsp;&emsp;复（wan）习（shua）了三四天之后就去考 zju 了。 &emsp;&emsp;好难啊啥都不会最后考挂了。 以后&emsp;&emsp;问——你身边的人都去 thu/pku 了，你会不会很心塞啊？&emsp;&emsp;答——会有一点吧。每个阶段都没做到最好，夏令营、noi、高考、自招……才导致了今天的位置。 &emsp;&emsp;不过大学还是可以发奋图强的嘛。。。 &emsp;&emsp;大学还要搞 acm 集训呢感觉会有点累。。。但总比做一条咸鱼要好了。 &emsp;&emsp;肝吧露比！","categories":[{"name":"总结与游记","slug":"总结与游记","permalink":"http://kqp.world/categories/%E6%80%BB%E7%BB%93%E4%B8%8E%E6%B8%B8%E8%AE%B0/"}],"tags":[]},{"title":"老年人OI回忆录&为期一年的休战协议","slug":"afo","date":"2017-07-24T17:56:41.000Z","updated":"2024-07-22T03:56:05.704Z","comments":true,"path":"afo/","link":"","permalink":"http://kqp.world/afo/","excerpt":"独上高楼，望尽天涯路&emsp;&emsp;终于也到了我要退役的时候了。","text":"独上高楼，望尽天涯路&emsp;&emsp;终于也到了我要退役的时候了。 &emsp;&emsp;和所有 OIer 一样，我会梦想成为神犇。然而直到结束的这一刻，我依然是过路人。 &emsp;&emsp;OI，没有为我带来金牌，也没有为我带来高校协议。但是与 OI 邂逅的这段故事，真的很有趣。 夜深忽梦少年事，梦啼妆泪红阑干开始的开始，我们都是孩子&emsp;&emsp;小学的时候我什么都学，学音乐，学奥数。我长期担任活动主持人、艺术节评委，长期文化课前排。我的那个班叫实验班，意思就是入学的时候每个人都要买一台手提电脑拿来玩摩尔庄园。五年级我们就在机房打计算机表演赛和 AI-RCJ。 &emsp;&emsp;五年级毕业的时候，信息老师突然叫了我们班几个同学到机房去。坐下来之后，她叫我们比赛金山打字。我就很快很快地打，打完之后她说，你们合格了，你们都是我观察很久的，成绩优秀数学很好的小朋友，来学编程吧。 &emsp;&emsp;我就是这样入坑的。 &emsp;&emsp;我们的启蒙老师是外面的一个私人教练，叫陈老师，他的口头禅是“清华大学教一个学期的东西，我两个小时就能讲完”。我大概就是这样，用 10 天入门了 pascal。 &emsp;&emsp;然后就被推荐到了纪中夏令营，由于有 10 天的基础，第一场比赛我拿了 rank4，然后就被认识了。。。&emsp;&emsp;开学以后就每个周末来纪中上课。我们住在一起的 4 个小伙伴轮流出车，路上打 UNO、看电影、谈题目、讲段子……那是极其欢乐的时光。 &emsp;&emsp;小学教的 OI 还是很入门的，我记得我小学毕业就把整个小学 OJ 刷完了。。。唯一把我卡住的是 4 月份学背包问题，6 年级我的智商并不兼容 DP。&emsp;&emsp;但是用这种智商参加市里的小学信息学邀请赛，可以拿到 rank4。 初一&emsp;&emsp;很不幸的是初中我遇到了一个很能布置作业的班主任，除了规定的 OI 训练，其他时间都要写作业。 &emsp;&emsp;初一做比赛其实没有比赛意识的，从不看部分分，从不计算时间复杂度，想到什么就打什么。&emsp;&emsp;毕竟还是小朋友，拿了普及 3= 觉得光宗耀祖。。。&emsp;&emsp;那时的 GDKOI 名额还非常少，分配到初一才只有 2 个，我是其中一个。那是我唯一一次超越了 philipsweng 感觉超棒的。 &emsp;&emsp;初一后期，可能是恶根的开始。 &emsp;&emsp;我同桌开始在做比赛的时候偷偷玩皇家守卫军。那时做比赛是自己选位置隔开坐，我和同桌两人每一场都往最后一排跑，4h 的比赛大概做 2h 就开始玩皇家守卫军。&emsp;&emsp;那时比赛简单，做 2h 也能 rank1。&emsp;&emsp;一发不可收拾，我学会了颓废。（用我们的话叫做腐败）&emsp;&emsp;从皇家守卫军，到口袋妖怪白金，到 MC……&emsp;&emsp;从我们俩，到整个机房…… &emsp;&emsp;所以升初二的暑假的时候，有一个人悄悄地，超越了我…… 初二&emsp;&emsp;升初二的暑假，也是新初一加入的时候。&emsp;&emsp;我们整个年级都染上了腐败的风气。暑假的模拟赛，我们被新初一吊打。 &emsp;&emsp;教练很严肃地 Diss 了我们，说我们不够努力。我们懵懵懂懂，大约明白了我们处境很危险。 &emsp;&emsp;初二上期中考之后，发生了大规模的劝退事件。初二这个 20 多人的团队，一下子只剩 10 个不到。留下来的我有一点点骄傲，又开始混日子了。 &emsp;&emsp;真正让我受到刺激的是这两件事：&emsp;&emsp;一是高中同学来给我们讲网络流，我们和初一同学一起听课。我们和初一同学一起听课！这让我感到羞愧，凭什么这么难的东西他们现在就能会啊！！&emsp;&emsp;二是上文提到的悄悄追上来的同学，他叫 fanvree，他跟高中一起训练了。 &emsp;&emsp;受到刺激的我决定加大时间投入，于是每天中午吃饭前的半小时我都来机房。&emsp;&emsp;然而，开始的几周我还能认真地写代码，后来渐渐地，这段时间还是被我用看世界杯、看 NBA…… &emsp;&emsp;凭着那可怜的一点水平，初二的市选我还是考到了市里的初中第三~~，也是非市队第一名~~，不过省选就划水了。 初三&emsp;&emsp;转眼就到了初三。 &emsp;&emsp;年级开始每天晚上搞小测，我们的官方训练时间变得越来越少。再加上我的班主任很能布置作业， 我投入 OI 的时间每周不超过 10h。再减去腐败的时间，所剩无几。 &emsp;&emsp;所以那时候基本上就是，周末做模拟赛，周一到周五都在改题（就是订正的意思），几乎没有额外学习什么知识。题目多了难了，我就养成了抄代码的习惯。那时我同桌是 jasonvictoryan，他由于不抄代码所以进步很快。 &emsp;&emsp;于是，我成为了文化课高手和 OI 弱渣。 &emsp;&emsp;初三这年，提高组初赛没过，整个赛季报销。省选又跟中考口语冲突，初三全员留守学校。 &emsp;&emsp;我就这样在机房划水了一年。我意识到我们急需大量地补知识点而不是整天做模拟赛，但是最终都没有跟教练说。教练叫我们研究树状数组，我们对着个 lowbit 研究一个星期还是马马虎虎最后只能背代码。 &emsp;&emsp;我只希望快点毕业上高中，一是因为高中竞赛班会有充裕的时间搞竞赛，二是高中机房风气好。我迫切地想要换一个环境重新发展。 高一&emsp;&emsp;总算是熬过初中三年，开始正式的竞赛生涯。 &emsp;&emsp;新高一暑假，有两次集训。&emsp;&emsp;第一次集训，除了 jasonvicotryan 和 fanvree 是省赛组，我们都是联赛组。我在联赛组考得很好，同时也在这个时候，我意识到了转 c++ 的必要。&emsp;&emsp;第二次集训，我们正式搬到了 403 机房。但是这次我做比赛做得很差，曾经落下的知识点开始一步步托我后腿。旁边的像 yxuanwkeith、ddddddpppppp 这些人已经从联赛组转到省赛组了，我却连刚学的斜率优化都做不出来被 D。&emsp;&emsp;中大学长回来嘲笑了我，小学被誉为最有希望的同学现在竟然还在做联赛题而且还做那么烂。我大概高中一直忘不掉他的这番嘲讽，这是我高中的第一份激励。&emsp;&emsp;这次集训最大的收获可能就是转了 c++。 &emsp;&emsp;高中正式开始了，的确在这个机房风气很不一样，学术变得很专业，而且非常幸运地有 fanvree 做同桌。我一点一点地补基础算法，学会了写博客、上网打比赛，但是腐败的恶习还是没改正。10 月 7 日下午，我学会了打 LOL，noip 停课集训的时候我天天下午打 LOL。 &emsp;&emsp;直到 noip，当头一棒，压线 1=。当时高一大部分同学都已经转到省赛组了，我因为联赛考差而依然在联赛组。虽然我在联赛组做得好多了，但是还是很腐，还因为这个跟 fanvree 吵过几次。 &emsp;&emsp;最后是我在校道上感慨我们这一届很弱，上有 philipsweng 下有 werkeytom，正伤感时 fanvree 说了一句：“你也知道，那你还这么腐。”&emsp;&emsp;这句话，第一次，正式地，让我有了戒腐决心。 &emsp;&emsp;省选专题训练很快开始了。我也跟着进度来，恶补了很多很多东西，其实有大量的知识是相当基础的。也是这时我深刻感受到了初中三年的划水使我浪费了大半个青春。 &emsp;&emsp;后来就到了省选停课集训了，我从这个时候正式加入省赛组。fanvree 自行组织高一同学补专题，我又一次迎来大补习的机会。从高一开始到现在，我的水平提升了很多个档次，我对省选有了信心。&emsp;&emsp;不过省选还是挂了。day1 两个签到题没弄出来，所幸 day2 和 day3 还算不错，我得以继续留在省赛组。 &emsp;&emsp;最后以 APIO Cu 结束高一。这是第一次参加需要坐飞机的 OI 比赛。 高二&emsp;&emsp;升高二暑假，我第一次领专题任务，讲 dp，这也是我准备得最认真的课件之一。最后讲得还算成功。&emsp;&emsp;这个暑假我做题找到了很多感觉，比以前成熟了。&emsp;&emsp;然后领了数论专题的任务，开始漫长的准备。 &emsp;&emsp;很快开始了专题训练和 noip 集训，新一轮恶补开始了。&emsp;&emsp;我学会了列计划，学会在走路、洗澡等时间思考题目，跟 fanvree 讨论思考方法的时候我也努力改造自己的思维。为了准备专题，我还找数竞同学借书，有时候午休我也在学课件。 &emsp;&emsp;多次在模拟赛 rank 排前，可以说这次来 noip 经过了充分的准备。然而，由于 v 和 n 打反等一系列原因，我只有 399 分。最后一个赛季了来这种东西，一度让我怀疑人生。 &emsp;&emsp;绝望过后是压线申请到 WC 的欢喜，各种各样的 WC 模拟赛使我感受到来自 OI 满满的恶意。轮到数论专题，本以为我能讲得叱诧风云，但是讲了才发现我掌握的很多只是皮毛，而且很不牢固，甚至闹出了“现学现卖”的笑话，成为最失败的专题讲课人。 &emsp;&emsp;在 philipsweng 的带领下机房十几人打了 hackerrank 的 university 1，排 rank2，甚至一度超越圣光机排到 rank1。然后 hackerrank 就发布了个大新闻说纪中是全球十大最适合学编程的高校之一。。然后我们就牛逼大了。。学校海报栏、pyq 瞬间都在吹我们是“全球第二”了。。。（然而学校的报道好像出了偏差，明明只是 philipsweng 误以为有 100$ 于是拼命拉我们打，不知怎么地被报道成“在学校领导的带领下”？？？） &emsp;&emsp;第二学期全程停课。GDKOI 考了 22 名，是我考得最好的一次。然后是出去 ZJ、JS 省选（又称周游列国），都没能过线。然后是省选集训，专题复习，我领了四边形不等式专题，这是我做的技术含量最高的课件了。fanvree 在快比赛时教会了我学专题要系统学习所有资料，那时的我还不是很能接受。&emsp;&emsp;最后四场省选全模拟，前三场我近乎垫底，最后一场幸运进队。&emsp;&emsp;省选来了。我考了 21 名，没进队，但也是历史最好成绩了。我真切感受到了我的付出。 &emsp;&emsp;省选刚结束就要去 CTSC 和 APIO。CTSC 被我捡了银牌，APIO 却因为太松懈而没牌。然后就是清北夏令营，怀着对 pku 的不好印象，中途跳去了 thu，结果 thu 又考炸了，做了五年的梦最终还是菜醒了。空手回家。 &emsp;&emsp;我幸运申到了 D 类，接着是一个月的 NOI 集训。最后的冲刺，改题、补知识、学课件。 &emsp;&emsp;最后的最后，NOI，两天犯下很多错误，铜牌，退役。 \\\\ \\\\&emsp;&emsp;故事就这样结束了。六年过得真快，如同躺在病床上死亡的老人，忽然回想起了他的一生，可是却什么都抓不到了。 欲说还休，却道天凉好个秋&emsp;&emsp;楼下的小学生刚刚穿上纪中校服，又来了一批五颜六色的小朋友。&emsp;&emsp;403 机房的物品堆了又清，清了又堆。rating 蹦蹦跳跳像个娃子。&emsp;&emsp;中山大学西苑宾馆历经风雨依然红茂，广州六中周围的店家日新月异。&emsp;&emsp;白云机场新航站楼日渐一日显露出恢宏之势。 &emsp;&emsp;沧海桑田，物是人非。 纯粹的竞赛&emsp;&emsp;最初，选择 OI 的理由是，老师说这个是聪明人玩的东西。&emsp;&emsp;初中，坚持 OI 的理由是，我不想把时间都花在文化课上。&emsp;&emsp;高中，专攻 OI 的理由是，我感受到了算法的艺术。 &emsp;&emsp;OI 是啥？竞赛是啥？&emsp;&emsp;我们教练 symbol 总会跟我们强调，我们学竞赛一定是纯粹的，不是为了考大学，靠功名利禄是学不下去的。&emsp;&emsp;我就是这样的，我学 OI 很纯粹，并没有刻意为了什么，就是觉得好玩，看起来很荒唐的理由。 &emsp;&emsp;“学 OI 就不要老想着它能给你带来什么。”这也是 symbol 说的。&emsp;&emsp;我最后是失败了，我伤心过，看着清北、上交等等一大批名校擦肩而过，看着金牌银牌擦肩而过，我哭过。我最终止住伤心，也是因为我不去思考 OI 到底能给我带来什么。 &emsp;&emsp;这或许就是竞赛了。竞赛很可能不给我们带来任何东西，但是我们拥有这段经历，我们去研究，去学喜欢的东西，去实现梦想。我们喜欢竞争的感觉，我们喜欢获得荣誉的欣喜，绝对不是为了高考走后门这种低贱的理由。还记得早年流传的《因为我们是 OIer》，这首诗写出了很真实很纯粹的梦想。 &emsp;&emsp;这才是真正的青春啊，为了深奥的算法而钻研，为了荣誉而拼搏，趁着现在有肝不完的精力，去熬夜打比赛，去跟别人竞争，去热血，去冲动，就是不服别人做到的自己做不到。凭着这些我能说，无竞赛，不青春。 欢乐的笑声&emsp;&emsp;因为 OI 我认识了很多可爱的小伙伴。早早退坑的也好，坚持到现在的也好。&emsp;&emsp;首先要谢谢你们给我带来的欢乐。我们在机房有很多奇妙的（黑）历史，有很多很多梗，还有外出经历。这些东西都是无价之宝，我不开心的时候就拿出来笑笑，真的很好笑。我真是挂了八辈子 noip 才会遇到你们这么可(zhi)爱(zhang)的小伙伴呢。 &emsp;&emsp;还有 403 机房，这个曾经在这里熬夜打比赛的地方。我都没有拍照。以后若有机会回来，柜子里的证书奖杯还塞得下吗？ &emsp;&emsp;愿大家都可以理想地发展吧。 谁道人生无再少，门前流水尚能西&emsp;&emsp;人毕竟不是咸鱼，OI 结束毕竟不是生命结束。 &emsp;&emsp;我的计算机历程并未终止，只是休战一年。一年之后，我将重新拾起键盘。&emsp;&emsp;我会努力考上个好学校的。大学，有计算机理论，有 acm，有智能体，还有各种各样的线上线下赛。我依然爱算法，喜欢捣鼓电脑。 &emsp;&emsp;这个 blog 要停更一年了。&emsp;&emsp;这个 blog 放的是我的总结，和我遇到的好题。大概有 80 多题，算是个小小题库了。不过相比大神来说，这肯定是弱逊水啦。。如果我所写的能给你带来帮助，那将是我感激不尽的。&emsp;&emsp;来立个 flag 吧，一年后，我的 blog 的访问量破 4w。 &emsp;&emsp;那就先走了。","categories":[{"name":"总结与游记","slug":"总结与游记","permalink":"http://kqp.world/categories/%E6%80%BB%E7%BB%93%E4%B8%8E%E6%B8%B8%E8%AE%B0/"},{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[]},{"title":"NOI2017 最后的失败","slug":"NOI2017","date":"2017-07-23T13:04:07.000Z","updated":"2024-04-24T03:59:22.785Z","comments":true,"path":"NOI2017/","link":"","permalink":"http://kqp.world/NOI2017/","excerpt":"前言&emsp;&emsp;CD类名单出了以后，机房的常驻人口就只有 9 个了（外加 HbFS 的话是 10 个）。我们带着“中山纪念中学”这个荣誉称号，来到 NOI。&emsp;&emsp;然而这次普遍大翻车，没人进队。 &emsp;&emsp;学校里宣传的“连续xx年有xx人入选集训队保送xxx”被我们 shutdown 了。 &emsp;&emsp;这也是我的最后一次 OI 比赛了，却不是什么好回忆，我只弄到了铜牌。&emsp;&emsp;最后这 9 个人里面也只有我没签协议。 &emsp;&emsp;想来想去也就这句话最合适：&emsp;&emsp;技不如人，甘拜下风。","text":"前言&emsp;&emsp;CD类名单出了以后，机房的常驻人口就只有 9 个了（外加 HbFS 的话是 10 个）。我们带着“中山纪念中学”这个荣誉称号，来到 NOI。&emsp;&emsp;然而这次普遍大翻车，没人进队。 &emsp;&emsp;学校里宣传的“连续xx年有xx人入选集训队保送xxx”被我们 shutdown 了。 &emsp;&emsp;这也是我的最后一次 OI 比赛了，却不是什么好回忆，我只弄到了铜牌。&emsp;&emsp;最后这 9 个人里面也只有我没签协议。 &emsp;&emsp;想来想去也就这句话最合适：&emsp;&emsp;技不如人，甘拜下风。 赛记一个多月的 NOI 模拟&emsp;&emsp;端午节后，从富榄五连测（又称山东集训）开始。然后陆陆续续地有 20 多场模拟赛 &emsp;&emsp;我做的分数都不高，经常垫底。知识点的缺失、脑袋的不灵光，轮着拖我排名。&emsp;&emsp;达成成就——每套题至少改完两题。这些模拟题隔三差五就有我没学的东西，然后我为了这个flag我就拼命去啃，一些码量很大别人都不改的题我也弄下来了。&emsp;&emsp;不甘做咸鱼的我，在这段时间补了大量的东西，包括各种各样的知识点和课件，也额外做了很多题。省选前列出的自己还不会的必备知识，几乎都在这段时间补了，不过大部分没来得及精补。有那么点累，但是学 OI 总是快乐的，所以我非常乐意地去做这些事情。&emsp;&emsp;打了 UNR#2，得益于大量高手不打 day2，我捞到个垫底银牌。 &emsp;&emsp;只不过，我感觉我的思维不那么灵光了，看课件的时候看一题不会一题。老年选手征兆。 &emsp;&emsp;后来去了学车中学，模拟赛也是日常挂分。在这里我列了个复习计划，头两天执行得很好，后来由于各种原因（强行听课等）都执行不顺利。 day0&emsp;&emsp;7 月 18 日。早上开幕式，下午笔试。&emsp;&emsp;身为地理 96 分的文科选手（雾），前一天我玩那个“背笔试的小程序”玩到 298/300，我觉得没什么问题了。 &emsp;&emsp;笔试完了以后，本来计划像 ctsc 那样打场 cf 练练手，结果发现没有外网。。。&emsp;&emsp;晚上背板。大概是有生以来背得最认真的一次了。 day1&emsp;&emsp;按照计划，7点50分准时喝咖啡（雾 &emsp;&emsp;然后就开始比赛了。t1 看上去大概是二进制 DS 题，t2 是比较啰嗦的字符串题，t3 不知道要干啥的概率题。&emsp;&emsp;开始刚 t1。先是实现了两个错误的方法，弄了 1h 多。然后脑中回想起“二进制不停地 +1，复杂度均摊 O(n)”这句话，突然就有种感觉好像暴力的复杂度是对的啊？那我每次加数字加完了以后把进位单独提取出来，再维护一些乱七八糟的东西好像就行了。我对着这个方法瞎分析了一通复杂度，觉得它是 1 个 log 的，但是写出来跑不了大样例。。。&emsp;&emsp;t2 是弄 t1 期间跳出来想的，于是弄 t2 的时候心思就不集中，虽然看到了 k 很小但是就没把复杂度往 k 上套，最终结果就是苦想无果打了 20 分暴力。&emsp;&emsp;t3 放到最后弄，打了个错的 dp 又耗了将近 40min，最后没办法打了 10 分。 &emsp;&emsp;最后 36+20+10。 &emsp;&emsp;讲题了才发现自己学的势能分析根本就是乱来的，很多带撤销的操作都是不能分析的，因此我最后打出来的依然是 n^2 算法。欣慰的是 t1 题解的后两种解法都用到了“二进制不停地 +1，复杂度均摊 O(n)”这个东西，但是后面的性质我都没发现，那么还是自己失了智。。。&emsp;&emsp;t2 亏出翔了，要是发现 k 很小然后把复杂度往 k 上弄的话，很容易想到标解啊。。哪怕以为它是 k^2 的那也有很高分啊。。。&emsp;&emsp;fanvree 出考场说 t3 900B 75分。。。那我也没办法了，这个题可能超出我智商范围了。 &emsp;&emsp;第一天就这么因为没有梦想挂掉了。稍微不咸鱼的同学们 t1 直接基于暴力上线段树、t2 果断 nk^2，都几乎是八九十分。。。我 t1 盯着 3kw 看了很久最终没有打线段树。。。打了太多模拟赛第一题都习惯直接思考满分的范围，都不看部分分了，果然这次就亏了。 &emsp;&emsp;我预感到我五年的 OI 要报废了。 day3&emsp;&emsp;我拼命让自己冷静下来，要是第二场考好了一切都还可以说，千万不要因为 day1 把自己的心态搞得乌烟瘴气。&emsp;&emsp;悄悄地，比赛又开始了。 &emsp;&emsp;t1，哇去掉 x 之后就是 2-sat 了。t2，大概是什么 dp 或网络流吧。t3 哇几何题，高一小朋友真会奶，noip 前说 noip 不考概率，noi 前说 noi 不考几何。。。不过这确实不按套路来，上一次几何已经是 8 年前的“月下柠檬树”了啊。。&emsp;&emsp;于是开始弄 t1。x 很少于是直接想到了 3^d 枚举每个 x 位置是什么车。这次也是我第一次用 tarjan 写 2-sat，脑补了一些细节之后写了将近 3h。。。&emsp;&emsp;t3 想不出非暴力之后，就开始写暴力。写完发现大样例 WA，我以为是爆 long long 的问题，结果换了 __int128 还是 WA，这时12点左右，t1 t2 都还没完工，心里特别的慌。。。&emsp;&emsp;赶紧弄 t2，建完图发现过期蔬菜处理有问题，心里很乱根本不能冷静想东西，临近结束赶紧把 xi=0 的分数拿了，然后比赛就结束了。 &emsp;&emsp;最后 60+24+0。 &emsp;&emsp;点开 t1 发现 n=20 都 T 了，这才忽然想到 3^8 情况下 memset 都会 T。。。然后开始调 t3，最后发现是叉积求面积的时候，我把栈大小写成了 n。。。&emsp;&emsp;讲题时意识到 t1 我不应该枚举 x 是什么，而是直接枚举 x 不是什么，这样就只有 2^d 次方了，而且建图也没有乱七八糟的讨论了。。。&emsp;&emsp;讲后面两题时我被叫了出去就没听到了。UPD：4 天后我发现我看错题了，题目大概是每个蔬菜被钦点了一个退役时间，而我以为是每天不管卖了多少都要再退役 x 个。。。这 tm 暴力网络流只需要把蔬菜拆成天数个点就行了啊。。。我说我怎么在考场上觉得这是个无解问题。。。 day3晚&emsp;&emsp;现在三试总分 250，手上没有任何协议。 &emsp;&emsp;于是就跑整栋楼找收留。转了一圈，要 D类cu 的屈指可数。&emsp;&emsp;不歧视 D 类的大概就只有人大和北邮了，全世界考差了的 D 都往人大跑。我从下午 6 点交表排队，等了一个晚上。&emsp;&emsp;从 5 点开始上上下下地跑，问政策，填表。我切实感受到 D铜没人权 这个事实。我只要考多 60 分这一切都不会发生，而这 60 分现在看来是多么的容易。。。 &emsp;&emsp;9 点多钟，人大老师宣布面试结束，还在排队的我连这最后一根稻草也抓不着了。 day4&emsp;&emsp;就这样两手空空地回家了。 场外&emsp;&emsp;去年 NOI 我打同步赛。结束之后，我说，算下来要拿银牌很容易啊，然后我写了一下每题该得多少多少分。有个去了 NOI 的同学回复说，上了考场，分是随便丢的啊。 &emsp;&emsp;这句话是对的。考场上是全新的环境，平时实力的多少并不能决定考场上考出来多少。成绩不能代表实力，它代表能力，代表一个人将它的所学表现出来的那种能力。 &emsp;&emsp;细想，我把考试看得太容易了，我学会做这题，我思考如何去思考这题，但这些都没有在考场上发挥出来。赛前我总结的常犯错误、做题策略，到了考场上又如同原形毕露。&emsp;&emsp;比赛，比综合素质，我输了。我纵使相信我有能力做出这些题，我无法改变自己 day1 没有梦想上暴力，没法提醒自己 d2t2 要看看样例，没法叫自己 d2t3 检查循环大小。分真的是随便丢的。 &emsp;&emsp;要真正做到把能力考出来，我可能一直缺一份成熟。训练中我就暴露出这个问题了，平时模拟赛我对待部分分的态度就不好，所以造成了 day1 的各种问题。而自己的思考模式一直都不完美，所以 day2 的很多东西都是差一些想到。这些小问题随时可以弄死一个人。 &emsp;&emsp;这时最后一次对 OI 做总结了，没什么战术性总结，大概都是些空话套话大话，我希望的是它对我接下来一年的高考有警示作用。 结束&emsp;&emsp;OI 就这么结束了。 &emsp;&emsp;其实从今年 APIO 开始我就没考好过。APIO 没牌，pkusc 头两场只会做签到题，thusc 甚至是在放弃签到题。直到现在 NOI，把那些大家都能拿八九十分的题弄得乌烟瘴气。&emsp;&emsp;我充分相信了我的省选真的是运气，碰巧遇到了很合我思维的题。所以后面的比赛就把我的菜鸡本质暴露无余。 &emsp;&emsp;尽管这个句号很不好看，但是真的要离开了。有那么多清华爷陪我高考我可能很知足了啊。我想，我经历过 OI 集训，我可能不怕高考吧。","categories":[{"name":"总结与游记","slug":"总结与游记","permalink":"http://kqp.world/categories/%E6%80%BB%E7%BB%93%E4%B8%8E%E6%B8%B8%E8%AE%B0/"},{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[]},{"title":"【CF360D】Levko and Sets 题解","slug":"【CF360D】Levko and Sets 题解","date":"2017-07-12T02:02:07.000Z","updated":"2024-04-24T03:59:22.836Z","comments":true,"path":"【CF360D】Levko and Sets 题解/","link":"","permalink":"http://kqp.world/%E3%80%90CF360D%E3%80%91Levko%20and%20Sets%20%E9%A2%98%E8%A7%A3/","excerpt":"题目大意&emsp;&emsp;有 $n$ 个数 $a_1…a_n$ 和 $m$ 个数 $b_1…b_m$ 和一个质数 $p$。&emsp;&emsp;第 $i$ 个集合是这样生成的：一开始只有一个 $1$。每次找集合内的一个元素 $c$ 和一个下标 $j~(j \\in [1,m])$，若 $c×a_i^{b_j} \\bmod p$ 不在集合里，则加进去。&emsp;&emsp;求这 $n$ 个集合的并集大小。&emsp;&emsp;$n\\le10^4,\\ m\\le10^5,\\ a_i&lt;p\\le10^9,\\ b_i&lt;10^9$&emsp;&emsp;时限 3s。","text":"题目大意&emsp;&emsp;有 $n$ 个数 $a_1…a_n$ 和 $m$ 个数 $b_1…b_m$ 和一个质数 $p$。&emsp;&emsp;第 $i$ 个集合是这样生成的：一开始只有一个 $1$。每次找集合内的一个元素 $c$ 和一个下标 $j~(j \\in [1,m])$，若 $c×a_i^{b_j} \\bmod p$ 不在集合里，则加进去。&emsp;&emsp;求这 $n$ 个集合的并集大小。&emsp;&emsp;$n\\le10^4,\\ m\\le10^5,\\ a_i&lt;p\\le10^9,\\ b_i&lt;10^9$&emsp;&emsp;时限 3s。 题解&emsp;&emsp;极好的数论题。 &emsp;&emsp;第 $i$ 个集合实际上是 $a_i^{\\sum 任意b}$。（$任意b$ 是指 $\\sum k_jb_j，~k_j \\in \\mathbb Z$）&emsp;&emsp;由扩展欧拉定理，指数是模 $p-1$ 意义下的。设 $B=gcd(b_1,b_2,…,b_m,p-1)$，则 $\\sum 任意b$ 等价于 $kB$ ($k \\in \\mathbb Z$)。（你可以用 polya 那套理论来理解这个道理，当只有一个 $b$ 的时候可证它是 gcd，当有多个 $b$ 的时候，合并两个 $b$ 可以看作是其中一个模另一个，因此也是 gcd。） &emsp;&emsp;底数不同于是用原根来表示，设 $a_i=g^{A_i}$，则第 $i$ 个集合表示为 $g^{A_i kB}$。&emsp;&emsp;由于 $B$ 是定值，$A_i$ 可以直接视为 $A_i×B$，也相当于一开始把 $a_i$ 视为 $a_i^B$。那么现在第 $i$ 个集合就相当于 $g^{kA_i}$。&emsp;&emsp;同理，设 $A’_i=\\gcd(A_i,p-1)$，则第 $i$ 个集合相当于 $g^{kA’_i}$。 &emsp;&emsp;现在就相当于有一堆 $A’_i$，它们都是 $p-1$ 的约数。求模 $p-1$ 意义下有多少数是某个 $A’_i$ 的倍数。&emsp;&emsp;这就可以容斥 dp 了。把 $A’_i$ 去重并从大到小排序，然后一个个计算贡献。这里用 $O(n^2)$ 的算法就可以了。 &emsp;&emsp;求 $A’_i$ 有很多种方法。传统方法是先求出原根 $g$，然后求 $A_i$，再求 $A’_i$。当然也有很方便的方法：第 $i$ 个集合的大小也是 $p-1$ 的约数，设为 $d_i=\\frac{p-1}{A’_i}$。由于 $A’_i$ 是最大公约数，所以要最小化 $d_i$，即找到最小的 $d_i$ 使得 $a_i^{d_i}≡1$（这里的 $a_i$ 是指 $a_i^B$）。","categories":[{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[{"name":"算法_数论","slug":"算法-数论","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E6%95%B0%E8%AE%BA/"}]},{"title":"【AtCoder Grand 017C】Snuke and Spells 题解","slug":"【AtCoder Grand 017C】Snuke and Spells 题解","date":"2017-07-10T02:27:16.000Z","updated":"2024-04-24T03:59:22.823Z","comments":true,"path":"【AtCoder Grand 017C】Snuke and Spells 题解/","link":"","permalink":"http://kqp.world/%E3%80%90AtCoder%20Grand%20017C%E3%80%91Snuke%20and%20Spells%20%E9%A2%98%E8%A7%A3/","excerpt":"题目大意&emsp;&emsp;有 $n$ 个球，每个球上有数字 $a_i$。&emsp;&emsp;游戏是这样的：若当前还剩 $k$ 个球，就把写有数字 $k$ 的球全部拿走，重复这个过程。你可以修改若干球上的数字，使得最后可以拿完所有的球。求最少修改多少个球。&emsp;&emsp;并且问题是动态的，有 $m$ 次操作，每次会修改一个球上的数字，每次修改完后问你游戏答案。&emsp;&emsp;$a_i \\leq n \\leq 2 \\times 10^5,\\ \\ m \\leq 2 \\times 10^5$","text":"题目大意&emsp;&emsp;有 $n$ 个球，每个球上有数字 $a_i$。&emsp;&emsp;游戏是这样的：若当前还剩 $k$ 个球，就把写有数字 $k$ 的球全部拿走，重复这个过程。你可以修改若干球上的数字，使得最后可以拿完所有的球。求最少修改多少个球。&emsp;&emsp;并且问题是动态的，有 $m$ 次操作，每次会修改一个球上的数字，每次修改完后问你游戏答案。&emsp;&emsp;$a_i \\leq n \\leq 2 \\times 10^5,\\ \\ m \\leq 2 \\times 10^5$ \\\\ \\\\ \\\\题解&emsp;&emsp;日常被欺诈。 &emsp;&emsp;如果数字 $x$ 有 $y$ 个球，我们看成 $(x-y+1, x)$ 这样一条线段。那现在数轴上就有很多条线段，其中没被覆盖的位置数量就是答案。 &emsp;&emsp;如何证明？&emsp;&emsp;首先这肯定是下界。&emsp;&emsp;其次我们能构造出一种方案使其可行。若当前数轴上有空位，那就说明别的地方肯定有重复覆盖的位置。重复覆盖要么是线段相交，要么是线段包含，而这两者都必定有线段的开头被重复覆盖，因此我们一定能找到这个开头，挖掉 $1$ 的长度来补数轴上的空位。&emsp;&emsp;因此这就是最优解。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;cstdio&gt;#define fo(i,a,b) for(int i=a;i&lt;=b;i++)using namespace std;const int maxn=2e5+5;int n,a[maxn],num[maxn];int ans,cov[maxn];void ADD(int x)&#123; if (x&lt;=0) return; if (++cov[x]==1) ans++;&#125;void DEC(int x)&#123; if (x&lt;=0) return; if (--cov[x]==0) ans--;&#125;int m;int main()&#123; scanf(&quot;%d %d&quot;,&amp;n,&amp;m); fo(i,1,n) &#123; scanf(&quot;%d&quot;,&amp;a[i]); num[a[i]]++; ADD(a[i]-num[a[i]]+1); &#125; while (m--) &#123; int x,y; scanf(&quot;%d %d&quot;,&amp;x,&amp;y); DEC(a[x]-num[a[x]]+1); num[a[x]]--; num[y]++; ADD(y-num[y]+1); a[x]=y; printf(&quot;%d\\n&quot;,n-ans); &#125;&#125;","categories":[{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[{"name":"算法_神奇的脑洞","slug":"算法-神奇的脑洞","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E7%A5%9E%E5%A5%87%E7%9A%84%E8%84%91%E6%B4%9E/"}]},{"title":"【Topcoder SRM697 Hard】【JZOJ5180】ConnectedStates 题解","slug":"【Topcoder SRM697 Hard】【JZOJ5180】ConnectedStates 题解","date":"2017-06-30T12:26:40.000Z","updated":"2024-04-24T03:59:22.867Z","comments":true,"path":"【Topcoder SRM697 Hard】【JZOJ5180】ConnectedStates 题解/","link":"","permalink":"http://kqp.world/%E3%80%90Topcoder%20SRM697%20Hard%E3%80%91%E3%80%90JZOJ5180%E3%80%91ConnectedStates%20%E9%A2%98%E8%A7%A3/","excerpt":"题目大意 &emsp;&emsp;$n \\le 2000,\\ w_i \\le 10^9$","text":"题目大意 &emsp;&emsp;$n \\le 2000,\\ w_i \\le 10^9$ \\\\ \\\\ \\\\题解&emsp;&emsp;稍微有点妙啊。。。 &emsp;&emsp;与度数有关的无根树计数，考虑 prufer 序。&emsp;&emsp;暴力可以直接 $O(n^3)$ dp 计算答案。 &emsp;&emsp;考虑优化。 &emsp;&emsp;假设第 $i$ 个数在 prufer 序的出现次数是 $a_i$，那么求的是： \\sum_{a_1+a_2+...+a_n=n-2} \\frac{(n-2)!}{a_1!a_2!...a_n!} \\prod_{i=1}^n (a_i+1)w_i^{a_i+1}&emsp;&emsp;其中与 $a$ 无关的是 $(n-2)!×\\prod w_i$，去掉之后原式变成： \\sum_{a_1+a_2+...+a_n=n-2} \\frac{\\prod_{i=1}^n (a_i+1)w_i^{a_i}}{a_1!a_2!...a_n!}&emsp;&emsp;接着考虑拆开 $\\prod (a_i+1)$，拆开后的每一项就相当于我选择一些 $a_i$ 乘起来。假设我选择的是 $a_{p_1},a_{p_2},…,a_{p_k}$，则有： \\sum_{a_1+a_2+...+a_n=n-2} \\sum_{p_1,p_2,...,p_k} \\frac{a_{p_1}×a_{p_2}×...×a_{p_k}×\\prod_{i=1}^n w_i^{a_i}}{a_1!a_2!...a_n!}&emsp;&emsp;上面的 $a$ 会跟下面的阶乘约掉，那么我可以一开始就给这一部分 $a$ 减 $1$，然后乘上后面少了的 $w$，相当于： \\sum_{p_1,p_2,...,p_k} w_{p_1}×w_{p_2}×...×w_{p_k}\\sum_{a_1+a_2+...+a_n=n-2-k} \\frac{\\prod_{i=1}^n w_i^{a_i}}{a_1!a_2!...a_n!}&emsp;&emsp;注意到我只要枚举 $k$ 的话，前后两部分就独立了。前面是个背包，所以现在化简后面。 &emsp;&emsp;后面这个东西跟 EGF（指数型生成函数） 很像，相当于求 ： \\begin{array}{rcl} &&[x^{n-2-k}]\\prod_{i=1}^n (\\sum_{j\\ge0} \\frac{w_i^jx^j}{j!})\\\\ &=&[x^{n-2-k}]\\prod_{i=1}^n e^{w_ix}\\\\ &=&[x^{n-2-k}]~e^{\\sum w_ix}\\\\ &=&[x^{n-2-k}]\\sum_{j\\ge0} \\frac{(\\sum w_i)^j x^j}{j!}\\\\ &=&\\frac{(\\sum w_i)^{n-2-k}}{(n-2-k)!} \\end{array}&emsp;&emsp;于是就。。做完了。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;cstdio&gt;#define fo(i,a,b) for(int i=a;i&lt;=b;i++)#define fd(i,a,b) for(int i=a;i&gt;=b;i--)using namespace std;typedef long long LL;const int maxn=2005;const LL mo=1e9+7;int n,w[maxn];LL sumw,prow=1;LL fac[maxn],ny[maxn],f[maxn][maxn];LL mi(LL x,LL y)&#123; LL re=1; for(; y; y&gt;&gt;=1, x=x*x%mo) if (y&amp;1) re=re*x%mo; return re;&#125;void Pre()&#123; fac[0]=ny[0]=1; fo(i,1,n) fac[i]=fac[i-1]*i%mo; ny[n]=mi(fac[n],mo-2); fd(i,n-1,1) ny[i]=ny[i+1]*(i+1)%mo; f[0][0]=1; fo(i,1,n) fo(j,0,i) &#123; f[i][j]=f[i-1][j]; if (j) (f[i][j]+=f[i-1][j-1]*w[i])%=mo; &#125;&#125;int main()&#123; scanf(&quot;%d&quot;,&amp;n); fo(i,1,n) &#123; scanf(&quot;%d&quot;,&amp;w[i]); if (!w[i]) &#123;printf(&quot;0\\n&quot;); return 0;&#125; (sumw+=w[i])%=mo; (prow*=w[i])%=mo; &#125; Pre(); LL ans=0; fo(k,0,n-2) (ans+=f[n][k]*mi(sumw,n-2-k)%mo*ny[n-2-k])%=mo; printf(&quot;%lld\\n&quot;,ans*prow%mo*fac[n-2]%mo);&#125;","categories":[{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[{"name":"算法_图论","slug":"算法-图论","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E5%9B%BE%E8%AE%BA/"},{"name":"算法_多项式/生成函数","slug":"算法-多项式-生成函数","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E5%A4%9A%E9%A1%B9%E5%BC%8F-%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/"}]},{"title":"【JZOJ100019】A 题解","slug":"【JZOJ100019】A 题解","date":"2017-06-30T00:09:15.000Z","updated":"2024-04-24T03:59:22.847Z","comments":true,"path":"【JZOJ100019】A 题解/","link":"","permalink":"http://kqp.world/%E3%80%90JZOJ100019%E3%80%91A%20%E9%A2%98%E8%A7%A3/","excerpt":"题目大意 &emsp;&emsp;$n \\le 10^5$","text":"题目大意 &emsp;&emsp;$n \\le 10^5$ \\\\ \\\\ \\\\解法1&emsp;&emsp;点分。 &emsp;&emsp;对于当前的分治，假设走到了点 $x$，那么 $x$ 的倍数和约数所代表的子树都不能走。&emsp;&emsp;然后用一个线段树维护当前哪些点能走，哪些不能走。离开这棵子树的时候，把不在这棵子树的标记撤销掉。 &emsp;&emsp;由于要用到撤销，所以要用主席树。 解法2&emsp;&emsp;先求不合法的路径的数量。 &emsp;&emsp;若 $(a,b)$ 这条路径不合法，则是它内部包含了形如 $(x,kx)$ 的路径。&emsp;&emsp;对于所有形如 $(x,kx)$ 的路径，假设 $x$ 是 dfs 序小的那个点，$y$ 是dfs 序大的那个点。$(a,b)$ 包含它当且仅当：&emsp;&emsp;1、若 $x$ 是 $y$ 的祖先，设 $g$ 是这条链上的 $x$ 的儿子，则 $dfn(a)&lt;dfn(g)，dfn(y)&lt;dfn(b)&lt;end(y)$ 或 $dfn(y)&lt;dfn(a)&lt;end(y)，end(g)&lt;dfn(b)$&emsp;&emsp;2、若 $x$ 不是 $y$ 的祖先，则 $dfn(x)&lt;dfn(a)&lt;end(x)，dfn(y)&lt;dfn(b)&lt;end(y)$ &emsp;&emsp;第一种情况是两个矩形，第二种情况是一个矩形，扫描线求面积并。 代码//解法2123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131#include&lt;cstdio&gt;#include&lt;algorithm&gt;#define fo(i,a,b) for(int i=a;i&lt;=b;i++)#define fd(i,a,b) for(int i=a;i&gt;=b;i--)using namespace std;typedef long long LL;const int maxn=1e5+5, maxrec=24e5+5, MX=17;struct TRST&#123; int nmin,num; TRST(int NMIN=0,int NUM=0) &#123;nmin=NMIN, num=NUM;&#125;&#125;;int n;int tot,go[2*maxn],next[2*maxn],f1[maxn];void ins(int x,int y)&#123; go[++tot]=y; next[tot]=f1[x]; f1[x]=tot;&#125;int tt[2],rx[2][maxrec],ry[2][maxrec],nt[2][maxrec],fr[2][maxn];void inr(int ty,int i,int x,int y)&#123; rx[ty][++tt[ty]]=x; ry[ty][tt[ty]]=y; nt[ty][tt[ty]]=fr[ty][i]; fr[ty][i]=tt[ty];&#125;int st[maxn],en[maxn],sum,fa[maxn][MX+5],deep[maxn];void dfs_dfn(int k,int last)&#123; deep[k]=deep[last]+1; fa[k][0]=last; fo(j,1,MX) fa[k][j]=fa[fa[k][j-1]][j-1]; st[k]=++sum; for(int p=f1[k]; p; p=next[p]) if (go[p]!=last) dfs_dfn(go[p],k); en[k]=sum;&#125;int find(int x,int y)&#123; fd(j,MX,0) if (deep[fa[y][j]]&gt;deep[x]) y=fa[y][j]; return y;&#125;TRST tr[4*maxn];int bz[4*maxn];void tr_js(int k,int l,int r)&#123; tr[k].num=r-l+1; if (l==r) return; int t=k&lt;&lt;1, t1=(l+r)&gt;&gt;1; tr_js(t,l,t1), tr_js(t+1,t1+1,r);&#125;TRST merge(TRST a,TRST b)&#123; if (a.nmin&lt;b.nmin) return a; else if (a.nmin&gt;b.nmin) return b; else return TRST(a.nmin,a.num+b.num);&#125;void update(int k,int t)&#123; if (!bz[k]) return; tr[t].nmin+=bz[k], tr[t+1].nmin+=bz[k]; bz[t]+=bz[k], bz[t+1]+=bz[k]; bz[k]=0;&#125;void tr_xg(int k,int l,int r,int x,int y,int z)&#123; if (l==x &amp;&amp; r==y) &#123; tr[k].nmin+=z; bz[k]+=z; return; &#125; int t=k&lt;&lt;1, t1=(l+r)&gt;&gt;1; update(k,t); if (y&lt;=t1) tr_xg(t,l,t1,x,y,z); else if (x&gt;t1) tr_xg(t+1,t1+1,r,x,y,z); else tr_xg(t,l,t1,x,t1,z), tr_xg(t+1,t1+1,r,t1+1,y,z); tr[k]=merge(tr[t],tr[t+1]);&#125;LL ans;void Scanline()&#123; tr_js(1,1,n); fo(i,1,n) &#123; for(int p=fr[0][i]; p; p=nt[0][p]) tr_xg(1,1,n,rx[0][p],ry[0][p],1); ans+=n-tr[1].num; for(int p=fr[1][i]; p; p=nt[1][p]) tr_xg(1,1,n,rx[1][p],ry[1][p],-1); &#125;&#125;int main()&#123; scanf(&quot;%d&quot;,&amp;n); fo(i,1,n-1) &#123; int x,y; scanf(&quot;%d %d&quot;,&amp;x,&amp;y); ins(x,y), ins(y,x); &#125; dfs_dfn(1,0); fo(i,1,n) for(int j=2*i; j&lt;=n; j+=i) &#123; int x=i, y=j; if (st[x]&gt;st[y]) swap(x,y); if (st[y]&lt;=en[x]) &#123; int g=find(x,y); inr(0,1,st[y],en[y]), inr(1,st[g]-1,st[y],en[y]); if (en[g]&lt;n) inr(0,st[y],en[g]+1,n), inr(1,en[y],en[g]+1,n); &#125; else &#123; inr(0,st[x],st[y],en[y]), inr(1,en[x],st[y],en[y]); &#125; &#125; Scanline(); printf(&quot;%lld\\n&quot;,(LL)n*(n-1)/2-ans);&#125;","categories":[{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[{"name":"算法_点分治","slug":"算法-点分治","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E7%82%B9%E5%88%86%E6%B2%BB/"},{"name":"算法_扫描线","slug":"算法-扫描线","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E6%89%AB%E6%8F%8F%E7%BA%BF/"}]},{"title":"【LOJ6087】毒瘤题 题解","slug":"【LOJ6087】毒瘤题 题解","date":"2017-06-21T09:06:24.000Z","updated":"2024-04-24T03:59:22.860Z","comments":true,"path":"【LOJ6087】毒瘤题 题解/","link":"","permalink":"http://kqp.world/%E3%80%90LOJ6087%E3%80%91%E6%AF%92%E7%98%A4%E9%A2%98%20%E9%A2%98%E8%A7%A3/","excerpt":"题目大意&emsp;&emsp;n 个数的数组，其中恰好有 k 个数出现了奇数次。把他们找出来。&emsp;&emsp;n&lt;=3e6， k&lt;=2&emsp;&emsp;空间 2M","text":"题目大意&emsp;&emsp;n 个数的数组，其中恰好有 k 个数出现了奇数次。把他们找出来。&emsp;&emsp;n&lt;=3e6， k&lt;=2&emsp;&emsp;空间 2M 这真是个有趣的问题 题解&emsp;&emsp;k=1 直接全部异或起来。 &emsp;&emsp;k=2 ，假设出现奇数次的是 a 和 b，那么把所有数异或起来得到的就是 s=a^b。&emsp;&emsp;对每个二进制位维护一个数 w[i]，当读入一个 x，x 的第 j 位为 1 的时候，就把 w[j]^=x。&emsp;&emsp;对于 s 的最高位的 1，那么一定是 a 和 b 之中，一个这一位为 1，一个这一位为 0。假设是第 j 位，那么 w[j] 肯定就是其中一个数。 代码123456789101112131415161718192021222324252627282930313233#include&lt;cstdio&gt;#include&lt;algorithm&gt;#define fo(i,a,b) for(int i=a;i&lt;=b;i++)#define fd(i,a,b) for(int i=a;i&gt;=b;i--)using namespace std;int n,k,xsum,xw[35];int main()&#123; scanf(&quot;%d %d&quot;,&amp;n,&amp;k); fo(i,1,n) &#123; int x; scanf(&quot;%d&quot;,&amp;x); xsum^=x; fo(j,0,31) if (x&amp;(1&lt;&lt;j)) xw[j]^=x; &#125; if (k==1) printf(&quot;%d\\n&quot;,xsum); else &#123; fd(j,31,0) if (xsum&amp;(1&lt;&lt;j)) &#123; int x=xw[j], y=xsum^xw[j]; if (x&gt;y) swap(x,y); printf(&quot;%d %d\\n&quot;,x,y); break; &#125; &#125;&#125;","categories":[{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[{"name":"算法_神奇的脑洞","slug":"算法-神奇的脑洞","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E7%A5%9E%E5%A5%87%E7%9A%84%E8%84%91%E6%B4%9E/"},{"name":"算法_位运算","slug":"算法-位运算","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/"}]},{"title":"【JZOJ5153】树形图求和 题解","slug":"【JZOJ5153】树形图求和 题解","date":"2017-06-21T04:46:26.000Z","updated":"2024-04-24T03:59:22.857Z","comments":true,"path":"【JZOJ5153】树形图求和 题解/","link":"","permalink":"http://kqp.world/%E3%80%90JZOJ5153%E3%80%91%E6%A0%91%E5%BD%A2%E5%9B%BE%E6%B1%82%E5%92%8C%20%E9%A2%98%E8%A7%A3/","excerpt":"题目大意 &emsp;&emsp;$N&lt;=300，M&lt;=10^5，w&lt;=10^9$","text":"题目大意 &emsp;&emsp;$N&lt;=300，M&lt;=10^5，w&lt;=10^9$ \\\\ \\\\ \\\\【60%】n&lt;=50，m&lt;=200&emsp;&emsp;有向图生成树计数：&emsp;&emsp;基尔霍夫矩阵是度数矩阵减邻接矩阵，现在把度数矩阵改成出度矩阵，然后以 $N$ 为根的话，答案就是 $M_{N,N}$。 &emsp;&emsp;考虑每一条边的贡献，那就是要计算强制选这条边之后的生成树个数。&emsp;&emsp;如果强制选 $(u_i,v_i,w_i)$，相当于把 $u_i$ 的其他出边删掉，只保留这条边。那对于基尔霍夫矩阵来说，相当于把 $u_i$ 这行改掉。 &emsp;&emsp;对于 60 分，每次暴力修改矩阵，算 $Det$。 【100%】&emsp;&emsp;对于快速计算某个矩阵修改一行（或一列）的 $Det$，有这么个公式： &emsp;&emsp;比如要把某行修改成 $c_1,c_2,…,c_n$，我们给每一行设个未知数 $x_i$，然后对每一列都列一条方程：$\\sum A_{i,j}x_i=c_j$，解出来。那么如果要把第 $i$ 行修改成这个，就给原来的 $Det$ 乘上 $x_i$。 &emsp;&emsp;所以可以先把方程解好，询问的时候直接乘。&emsp;&emsp;由于 $c$ 的值是不固定的，所以解方程是要解出这样的形式：$x_i=a_1c_1+a_2c_2+…+a_nc_n$。&emsp;&emsp;具体实现可以弄两个矩阵，左边是方程系数，右边是 $c$ 的系数，对左边高斯消元的同时，右边做相同的操作。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define fo(i,a,b) for(int i=a;i&lt;=b;i++)using namespace std;typedef long long LL;const int maxn=305, maxm=1e5+5;const LL mo=1e9+7;int n,m,u[maxm],v[maxm],w[maxm];LL mi(LL x,LL y)&#123; LL re=1; for(; y; y&gt;&gt;=1, x=x*x%mo) if (y&amp;1) re=re*x%mo; return re;&#125;LL D,J[maxn][maxn];void Det()&#123; D=1; fo(i,1,n-1) &#123; fo(j,i,n-1) if (J[j][i]!=0) &#123; swap(J[i],J[j]); if (i!=j) D*=-1; break; &#125; fo(j,i+1,n) &#123; LL c=J[j][i]*mi(J[i][i],mo-2)%mo; fo(k,i,n) (J[j][k]-=c*J[i][k])%=mo; &#125; &#125; fo(i,1,n-1) (D*=J[i][i])%=mo; D=(D+mo)%mo;&#125;LL G[maxn][maxn],Gc[maxn][maxn],c[maxn];void Gauss()&#123; fo(i,1,n) &#123; fo(j,i,n) if (G[j][i]!=0) &#123; swap(G[i],G[j]), swap(Gc[i],Gc[j]); break; &#125; LL c=mi(G[i][i],mo-2); fo(j,1,n) (G[i][j]*=c)%=mo, (Gc[i][j]*=c)%=mo; fo(j,1,n) if (j!=i) &#123; LL c=G[j][i]; fo(k,1,n) (G[j][k]-=c*G[i][k])%=mo, (Gc[j][k]-=c*Gc[i][k])%=mo; &#125; &#125;&#125;void Pre()&#123; fo(i,1,n) &#123; Gc[i][i]=1; fo(j,1,n) G[i][j]=J[j][i]; &#125; Gauss();&#125;int main()&#123; scanf(&quot;%d %d&quot;,&amp;n,&amp;m); fo(i,1,m) &#123; scanf(&quot;%d %d %d&quot;,&amp;u[i],&amp;v[i],&amp;w[i]); J[u[i]][u[i]]++; J[u[i]][v[i]]--; &#125; Pre(); Det(); LL ans=0; fo(i,1,m) if (u[i]&lt;n) &#123; LL x=(Gc[u[i]][u[i]]-Gc[u[i]][v[i]])%mo; (ans+=D*x%mo*w[i])%=mo; &#125; printf(&quot;%lld\\n&quot;,(ans+mo)%mo);&#125;","categories":[{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[{"name":"算法_线性代数","slug":"算法-线性代数","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"}]},{"title":"【CodeM初赛A 5】数列互质 题解","slug":"【CodeM初赛A 5】数列互质 题解","date":"2017-06-18T14:21:47.000Z","updated":"2024-04-24T03:59:22.840Z","comments":true,"path":"【CodeM初赛A 5】数列互质 题解/","link":"","permalink":"http://kqp.world/%E3%80%90CodeM%E5%88%9D%E8%B5%9BA%205%E3%80%91%E6%95%B0%E5%88%97%E4%BA%92%E8%B4%A8%20%E9%A2%98%E8%A7%A3/","excerpt":"题目大意&emsp;&emsp;给出一个长度为 $n$ 的序列 $a_1…a_n$，有 $m$ 个询问，每次询问给出 $l, r, k$，问 $a_l…a_r$ 中，有多少数的出现次数与 $k$ 互质。&emsp;&emsp;$n, m \\leq 5e4，1 \\leq a_i, k \\leq n$&emsp;&emsp;时限 6s","text":"题目大意&emsp;&emsp;给出一个长度为 $n$ 的序列 $a_1…a_n$，有 $m$ 个询问，每次询问给出 $l, r, k$，问 $a_l…a_r$ 中，有多少数的出现次数与 $k$ 互质。&emsp;&emsp;$n, m \\leq 5e4，1 \\leq a_i, k \\leq n$&emsp;&emsp;时限 6s \\\\ \\\\ \\\\题解&emsp;&emsp;区间问题可以考虑莫队，可以维护一个桶 $t_i$ 表示有多少数的出现次数是 $i$。 &emsp;&emsp;但是统计答案不方便，要把整个桶扫一次。 &emsp;&emsp;于是设个阈值 $s=\\sqrt n$。如果某个数在全局的出现次数 $&gt;s$，就提取出来单独对每个询问做贡献，剩下的数就做莫队。","categories":[{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[{"name":"算法_莫队/分块","slug":"算法-莫队-分块","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E8%8E%AB%E9%98%9F-%E5%88%86%E5%9D%97/"},{"name":"算法_根号平衡","slug":"算法-根号平衡","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E6%A0%B9%E5%8F%B7%E5%B9%B3%E8%A1%A1/"}]},{"title":"【JZOJ5149】超级绵羊异或 题解","slug":"【JZOJ5149】超级绵羊异或 题解","date":"2017-06-16T14:39:50.000Z","updated":"2024-04-24T03:59:22.857Z","comments":true,"path":"【JZOJ5149】超级绵羊异或 题解/","link":"","permalink":"http://kqp.world/%E3%80%90JZOJ5149%E3%80%91%E8%B6%85%E7%BA%A7%E7%BB%B5%E7%BE%8A%E5%BC%82%E6%88%96%20%E9%A2%98%E8%A7%A3/","excerpt":"题目大意&emsp;&emsp;求 $a\\oplus(a+b)\\oplus(a+2b)\\oplus…\\oplus(a+(n-1)b)$&emsp;&emsp;多组数据，$T \\leq 10^4$， $a,b,n \\leq 10^9$","text":"题目大意&emsp;&emsp;求 $a\\oplus(a+b)\\oplus(a+2b)\\oplus…\\oplus(a+(n-1)b)$&emsp;&emsp;多组数据，$T \\leq 10^4$， $a,b,n \\leq 10^9$ \\\\ \\\\ \\\\题解&emsp;&emsp;很特么简单的套路。。。 &emsp;&emsp;按位考虑，假设当前第 $x$ 位，那么只用看这 $n$ 个数中，是否有奇数个这一位为 $1$。&emsp;&emsp;这等价于这 $n$ 个数的第 $x$ 位加起来是否为奇数。&emsp;&emsp;因此第 $x$ 位的答案就是 $\\sum_{i=0}^{n-1} \\lfloor \\frac{a+bi}{2^x} \\rfloor \\pmod{2}$ &emsp;&emsp;于是这就是个类欧模板题。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;cstdio&gt;#define fo(i,a,b) for(int i=a;i&lt;=b;i++)#define fd(i,a,b) for(int i=a;i&gt;=b;i--)using namespace std;typedef long long LL;const LL mo=2;int n,a,b;LL f(LL a,LL b,LL c,LL n)&#123; if (!a) return (n+1)*(b/c)%mo; if (a&gt;=c || b&gt;=c) &#123; LL sqr=(n&amp;1) ?(n+1)/2*n :n/2*(n+1) ; return (f(a%c,b%c,c,n)+(a/c)*sqr+(n+1)*(b/c))%mo; &#125; else &#123; LL m=(a*n+b)/c; return (m*n-f(c,c-b-1,a,m-1)+mo)%mo; &#125;&#125;int T;int main()&#123; scanf(&quot;%d&quot;,&amp;T); while (T--) &#123; scanf(&quot;%d %d %d&quot;,&amp;n,&amp;a,&amp;b); LL ans=0; fd(x,62,0) &#123; LL c=1ll&lt;&lt;x; if (f(b,a,c,n-1)) ans+=c; &#125; printf(&quot;%lld\\n&quot;,ans); &#125;&#125;","categories":[{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[{"name":"算法_数论","slug":"算法-数论","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E6%95%B0%E8%AE%BA/"},{"name":"算法_位运算","slug":"算法-位运算","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/"}]},{"title":"【XJOI】path 题解","slug":"【XJOI】path 题解","date":"2017-06-13T09:39:19.000Z","updated":"2024-04-24T03:59:22.871Z","comments":true,"path":"【XJOI】path 题解/","link":"","permalink":"http://kqp.world/%E3%80%90XJOI%E3%80%91path%20%E9%A2%98%E8%A7%A3/","excerpt":"题目出自学军中学（我不记得题目叫什么名字了，这个题目是我乱起的） 题目大意&emsp;&emsp;给出一幅 $n$ 个点的有向图，边长是 $1$。&emsp;&emsp;求最大的 $k$，使得对于任意正整数 $L$（$L&lt;=$图中最长路径的长度），长度为 $L$ 的路径数是 $O(L^k)$ 的。若不存在则输出 -1。&emsp;&emsp;$n \\le 10^5$","text":"题目出自学军中学（我不记得题目叫什么名字了，这个题目是我乱起的） 题目大意&emsp;&emsp;给出一幅 $n$ 个点的有向图，边长是 $1$。&emsp;&emsp;求最大的 $k$，使得对于任意正整数 $L$（$L&lt;=$图中最长路径的长度），长度为 $L$ 的路径数是 $O(L^k)$ 的。若不存在则输出 -1。&emsp;&emsp;$n \\le 10^5$ $\\\\ $$\\\\ $$\\\\ $ 这是一道读题题&emsp;&emsp;读懂题就会做了 题解&emsp;&emsp;题目的意思是，对于任意长度 $L$，其方案数必须是一个多项式，最高次$&lt;=k$。 &emsp;&emsp;首先如果图中存在一个复杂环（就是存在环套环的意思），那么这里能贡献的方案数就是指数级别的了（走一下 A 环，再走一下 B 环，再走一下 A 环……），所以输出 -1。 &emsp;&emsp;于是就变成了一个只有简单环的图。我们缩点得到一幅 DAG。&emsp;&emsp;对于 DAG 上的某一条路径，有些点原来是环，假设有 $x$ 个这样的点。我现在走这条路径，假设这些环点我分别走了 $c_1、c_2、……、c_x$ 次。&emsp;&emsp;考虑这条路径对长度 $L$ 的贡献，相当于我枚举 $c_1、c_2、……、c_x$，使得它们加起来是 $L$。因此方案数是 $O(L^{x-1})$ &emsp;&emsp;因此在这个 DAG 上求一条点权最大的路径（若该点原来是环，点权就为 1，否则为 0），减 1 就是答案。","categories":[{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[{"name":"算法_图论","slug":"算法-图论","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E5%9B%BE%E8%AE%BA/"}]},{"title":"【Hackerrank 101Hack 43】【JZOJ5135】K-Inversion Permutations 题解","slug":"【Hackerrank 101Hack 43】【JZOJ5135】K-Inversion Permutations 题解","date":"2017-06-04T13:15:41.000Z","updated":"2024-04-24T03:59:22.842Z","comments":true,"path":"【Hackerrank 101Hack 43】【JZOJ5135】K-Inversion Permutations 题解/","link":"","permalink":"http://kqp.world/%E3%80%90Hackerrank%20101Hack%2043%E3%80%91%E3%80%90JZOJ5135%E3%80%91K-Inversion%20Permutations%20%E9%A2%98%E8%A7%A3/","excerpt":"题目大意&emsp;&emsp;求长度为 $n$、逆序对数量为 $k$ 的排列的数量。&emsp;&emsp;$n, k \\le 10^5$","text":"题目大意&emsp;&emsp;求长度为 $n$、逆序对数量为 $k$ 的排列的数量。&emsp;&emsp;$n, k \\le 10^5$ \\\\ \\\\ \\\\【50%】n, k&lt;=1000&emsp;&emsp;设 $f[i][j]$ 表示长度为 $i$、逆序对数量为 $j$ 的方案数。&emsp;&emsp;$f[i][j]=\\sum_{now=0}^{i-1} f[i-1][j-now]$ 【100%解法1】&emsp;&emsp;考虑每个元素的贡献（该元素前面有多少个比它大），可以得到一个贡献序列 $B$。其中该序列满足 $0&lt;=B[i]&lt;=i-1$，且 $\\sum B[i]=k$。&emsp;&emsp;该序列与原序列唯一对应，所以我们要求有多少不同的 $B$ 序列。 &emsp;&emsp;考虑 $B[i]$ 的生成函数： $1+x+x^2+…+x^{i-1}=\\frac{1-x^i}{1-x}$，因此最后和为 $k$ 的方案数就是 $\\prod_{i=1}^n \\frac{1-x^i}{1-x}$ 的 $x^k$ 的系数。 &emsp;&emsp;来一个不清真的做法。 &emsp;&emsp;设 $F(x)=\\prod_{i=1}^n \\frac{1-x^i}{1-x}$，则 \\ln F(x)=\\sum_{i=1}^n ln(1-x^i)-n~ln(1-x) \\\\ \\ln(1-x)=-(x+\\frac{x^2}{2}+\\frac{x^3}{3}+...) \\\\ \\ln(1-x^i)=-(x^i+\\frac{x^{2i}}{2}+\\frac{x^{3i}}{3}+...)&emsp;&emsp;用调和级数那样 $O(k~log~k)$ 处理 $ln~F(x)$，FFT 算 $e^{ln~F(x)}$ &emsp;&emsp;以上抄自 WerKeyTom_FTD 给的笔记，我还没学会 【100%解法2】&emsp;&emsp;来一个清真的做法。 \\begin{aligned} &\\prod_{i=1}^n \\frac{1-x^i}{1-x} \\\\ =& \\frac{\\prod_{i=1}^n (1-x^i)}{(1-x)^n} \\\\ =& \\prod_{i=1}^n (1-x^i)×\\sum_{i=0}^n \\dbinom{i+n-1}{n-1} x^i \\end{aligned}&emsp;&emsp;所以现在分成前面和后面两个部分，最后枚举前面是 $x^i$，后面就是 $x^{k-i}$，把对应系数乘起来即可。后面的系数是普通组合数，所以目标变成算前面的系数。 &emsp;&emsp;前面部分可以看成：有 $n$ 个物品，第 $i$ 个物品大小为 $i$，且选了 $x$ 个物品的话方案数要乘上 $(-1)^x$，求大小为 $k$ 的方案数。 &emsp;&emsp;这就是个经典 dp。设 $f[i][j]$ 表示用 $i$ 个互不相同的物品、和为 $j$ 的方案数。我们限定这 $i$ 个物品是有序（从小到大）的。&emsp;&emsp;转移有两种操作：一种是全体体积加 $1$，一种是新加一个大小为 $1$ 的物品。（注意新加一个物品的时候，$-1$ 的指数会变，所以这时候算方案数是 $f[i][j]-=…$。）&emsp;&emsp;这样垒上去可能会使某些物品大小超过 $n$，所以当某个物品超限的时候要及时减去，即 $f[i][j]+=f[i-1][j-(n+1)]$。（注意这里 $-1$ 的指数又变了，所以是加等于。） &emsp;&emsp;然后会发现物品最多只需要 $\\sqrt k$ 个，所以复杂度是 $O(k \\sqrt k)$ 代码//解法212345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#define fo(i,a,b) for(int i=a;i&lt;=b;i++)#define fd(i,a,b) for(int i=a;i&gt;=b;i--)using namespace std;typedef long long LL;const int maxn=1e5+5, maxsqrtk=448;const LL mo=1e9+7;int n,k;LL fac[2*maxn],ny[2*maxn];LL mi(LL x,LL y)&#123; LL re=1; for(; y; y&gt;&gt;=1, x=x*x%mo) if (y&amp;1) re=re*x%mo; return re;&#125;void C_Pre(int n)&#123; fac[0]=ny[0]=1; fo(i,1,n) fac[i]=fac[i-1]*i%mo; ny[n]=mi(fac[n],mo-2); fd(i,n-1,1) ny[i]=ny[i+1]*(i+1)%mo;&#125;LL C(int n,int m) &#123;return fac[n]*ny[m]%mo*ny[n-m]%mo;&#125;LL f[maxsqrtk+2][maxn],g[maxn];int main()&#123; scanf(&quot;%d %d&quot;,&amp;n,&amp;k); C_Pre(2*max(n,k)); f[0][0]=g[0]=1; fo(i,1,maxsqrtk) fo(j,1,k) &#123; if (j&gt;=i) (f[i][j]-=f[i-1][j-i])%=mo; // 新加一个大小为1的物品 if (j&gt;=i) (f[i][j]+=f[i][j-i])%=mo; // 全体+1 if (j&gt;=n+1) (f[i][j]+=f[i-1][j-(n+1)])%=mo; (g[j]+=f[i][j])%=mo; &#125; LL ans=0; fo(i,0,k) (ans+=g[i]*C(k-i+n-1,n-1))%=mo; printf(&quot;%lld\\n&quot;,(ans+mo)%mo);&#125;","categories":[{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[{"name":"算法_DP","slug":"算法-DP","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-DP/"},{"name":"算法_多项式/生成函数","slug":"算法-多项式-生成函数","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E5%A4%9A%E9%A1%B9%E5%BC%8F-%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/"},{"name":"算法_FFT/NTT","slug":"算法-FFT-NTT","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-FFT-NTT/"}]},{"title":"【AtCoder Grand 015C】Nuske vs Phantom Thnook 题解","slug":"【AtCoder Grand 015C】Nuske vs Phantom Thnook 题解","date":"2017-05-31T14:47:45.000Z","updated":"2024-04-24T03:59:22.822Z","comments":true,"path":"【AtCoder Grand 015C】Nuske vs Phantom Thnook 题解/","link":"","permalink":"http://kqp.world/%E3%80%90AtCoder%20Grand%20015C%E3%80%91Nuske%20vs%20Phantom%20Thnook%20%E9%A2%98%E8%A7%A3/","excerpt":"题目大意&emsp;&emsp;给出一个 $n\\times m$ 的 01 矩阵，任意两个 1 格子至多有一条路径连接（连通的定义是四连通）。&emsp;&emsp;有 $q$ 个询问，每次指定一个子矩阵，问该子矩阵内的 1 格子形成多少个连通块。&emsp;&emsp;$n, m \\le 2000, \\ q \\le 2\\times 10^5$","text":"题目大意&emsp;&emsp;给出一个 $n\\times m$ 的 01 矩阵，任意两个 1 格子至多有一条路径连接（连通的定义是四连通）。&emsp;&emsp;有 $q$ 个询问，每次指定一个子矩阵，问该子矩阵内的 1 格子形成多少个连通块。&emsp;&emsp;$n, m \\le 2000, \\ q \\le 2\\times 10^5$ \\\\ \\\\ \\\\解法&emsp;&emsp;这题乍一看感觉跟 apio2017 rainbow 很像，于是就去想平面图欧拉定理去了。。。 &emsp;&emsp;然后看到题解感觉要日藏獒 &emsp;&emsp;1 格子形成森林，森林的特征就是 连通块数=点数-边数，所以就预处理出二维前缀和表示该连通块内的点数和边数就行了。。。 思考&emsp;&emsp;这题的性质关键是给出的 1 格子是森林。如果不是森林？ &emsp;&emsp;基于这题，我想的是构出 dfs 树，那么按照上述方法会使答案偏大。考虑返祖边，返祖边如果覆盖了没被询问的边那么就有可能造成贡献，再讨论一下多条返祖边之间的影响，然后就发现。。。我讨论不出来了 &emsp;&emsp;不知道能不能做，反正我不会做。","categories":[{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[{"name":"算法_图论","slug":"算法-图论","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E5%9B%BE%E8%AE%BA/"}]},{"title":"【Hackerrank World11】Road Trip 题解","slug":"【Hackerrank World11】Road Trip 题解","date":"2017-05-31T07:49:43.000Z","updated":"2024-04-24T03:59:22.843Z","comments":true,"path":"【Hackerrank World11】Road Trip 题解/","link":"","permalink":"http://kqp.world/%E3%80%90Hackerrank%20World11%E3%80%91Road%20Trip%20%E9%A2%98%E8%A7%A3/","excerpt":"题目大意&emsp;&emsp;从左到右有 n 个城市，第 i 个城市到第 i+1 个城市的距离是 w[i]。到达第 i 个城市可以免费获得 g[i] 的油，你也可以自己另外买油，第 i 个城市的单价是 p[i]。&emsp;&emsp;现在 q 次询问，每次问 x[i] 到 y[i] 的最小花费。&emsp;&emsp;n, q&lt;=1e5， g, p, w&lt;=1e6","text":"题目大意&emsp;&emsp;从左到右有 n 个城市，第 i 个城市到第 i+1 个城市的距离是 w[i]。到达第 i 个城市可以免费获得 g[i] 的油，你也可以自己另外买油，第 i 个城市的单价是 p[i]。&emsp;&emsp;现在 q 次询问，每次问 x[i] 到 y[i] 的最小花费。&emsp;&emsp;n, q&lt;=1e5， g, p, w&lt;=1e6 【40%】n, q&lt;=1000&emsp;&emsp;每次询问 O(n) 的贪心。&emsp;&emsp;从 x 开始，假设不氪金最远能到 next[x]，则在 next[x] 处买油的价格就是 x 到 next[x] 的最小价格。&emsp;&emsp;以下方法都是基于该方法的优化。 【100%解法1】&emsp;&emsp;考虑从右到左枚举左端点 i，然后用线段树维护每个位置的要买的油量，以及（从 i 到每个位置的最小）油价。当然还有它们的积。 &emsp;&emsp;第一个东西很好维护，就是每次你看看第 i 个点到第 i+1 个点是多油还是少油，少了的话，少多少第 i 个点就要买多少，多了的话，那就从 i 到 next[i]-1 都不用买了，然后 next[i] 这里看看少了多少就买多少。这里就是区间赋值操作。&emsp;&emsp;第二个东西的变化过程跟单调栈是一样的，所以用个单调栈维护每种价格的控制范围，于是在线段树中也是区间赋值操作。 &emsp;&emsp;时间是 O(n log n) 【100%解法2】&emsp;&emsp;来个在线做法？ &emsp;&emsp;贪心的时候我们每次从 i 跳到 next[i]，这样每次只跳一步很慢，我们就倍增地跳。即：从 i 向 next[i] 连边，这样会形成一棵树，那么在树上倍增地跳。&emsp;&emsp;但是对于不同的起点，树边对应的价格是不同的，所以不能直接倍增。&emsp;&emsp;再开一棵树，假设点 i 在第一棵树中往上跳到 x 价格都不会变，但是跳到 father[x] 价格就变了的话，就在第二棵树中把 i 的父亲设为 x。这样就可以先在第二棵树上倍增，剩出来的一些东西再在第一棵树上倍增。 &emsp;&emsp;时间是 O(n log n) 代码//解法1123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include&lt;cstdio&gt;#include&lt;algorithm&gt;#define fo(i,a,b) for(int i=a;i&lt;=b;i++)#define fd(i,a,b) for(int i=a;i&gt;=b;i--)using namespace std;typedef long long LL;const int maxn=2e5+5;struct QST&#123; int x,y,i;&#125;;bool cmpQ(const QST &amp;a,const QST &amp;b) &#123;return a.x&gt;b.x;&#125;int n,q0,w[maxn],g[maxn],p[maxn];QST q[maxn];LL tr[4*maxn],sum[4*maxn],bz[4*maxn];bool zero[4*maxn];void update(int k,int t)&#123; if (zero[k]) &#123; tr[t]=tr[t+1]=sum[t]=sum[t+1]=0; zero[t]=zero[t+1]=1; zero[k]=0; &#125; if (bz[k]) &#123; bz[t]=bz[t+1]=bz[k]; sum[t]=tr[t]*bz[k]; sum[t+1]=tr[t+1]*bz[k]; &#125;&#125;void tr_xg(int ty,int k,int l,int r,int x,int y,LL z)&#123; if (l==x &amp;&amp; r==y) &#123; if (ty) &#123; sum[k]=tr[k]*z; bz[k]=z; &#125; else &#123; tr[k]=z; sum[k]=tr[k]*bz[k]; if (z==0) zero[k]=1; &#125; return; &#125; int t=k&lt;&lt;1, t1=(l+r)&gt;&gt;1; update(k,t); if (y&lt;=t1) tr_xg(ty,t,l,t1,x,y,z); else if (x&gt;t1) tr_xg(ty,t+1,t1+1,r,x,y,z); else tr_xg(ty,t,l,t1,x,t1,z), tr_xg(ty,t+1,t1+1,r,t1+1,y,z); tr[k]=tr[t]+tr[t+1]; sum[k]=sum[t]+sum[t+1];&#125;LL tr_cx(int k,int l,int r,int x,int y)&#123; if (l==x &amp;&amp; r==y) return sum[k]; int t=k&lt;&lt;1, t1=(l+r)&gt;&gt;1; update(k,t); if (y&lt;=t1) return tr_cx(t,l,t1,x,y); else if (x&gt;t1) return tr_cx(t+1,t1+1,r,x,y); else return tr_cx(t,l,t1,x,t1)+tr_cx(t+1,t1+1,r,t1+1,y);&#125;LL Ans[maxn],s[maxn];int z[maxn][2],z0,fr[maxn]; // fr就是每个点不氪金最远走到哪里int main()&#123; freopen(&quot;G.in&quot;,&quot;r&quot;,stdin); freopen(&quot;G.out&quot;,&quot;w&quot;,stdout); scanf(&quot;%d %d&quot;,&amp;n,&amp;q0); fo(i,1,n-1) scanf(&quot;%d&quot;,&amp;w[i]); fo(i,1,n) scanf(&quot;%d %d&quot;,&amp;g[i],&amp;p[i]); fo(i,1,q0) scanf(&quot;%d %d&quot;,&amp;q[i].x,&amp;q[i].y), q[i].i=i; sort(q+1,q+1+q0,cmpQ); w[n]=2139062143; fo(i,1,n) s[i]=s[i-1]+g[i]-w[i]; int wz=1; z[z0=1][0]=n; fd(i,n,1) &#123; while (z0 &amp;&amp; s[i-1]&lt;=s[z[z0][0]]) z0--; fr[i]=z[z0][0]; z[++z0][0]=i-1; &#125; z0=0; int j=1; fd(i,n,1) &#123; if (g[i]-w[i]&gt;=0) &#123; int x=fr[i]; tr_xg(0,1,1,n,i,x,0); if (x+1&lt;=n) tr_xg(0,1,1,n,x,x,s[i-1]-s[x]); &#125; else &#123; tr_xg(0,1,1,n,i,i,w[i]-g[i]); &#125; int wz=i; while (z0 &amp;&amp; p[i]&lt;=z[z0][0]) wz=z[z0--][1]; tr_xg(1,1,1,n,i,wz,p[i]); z[++z0][0]=p[i], z[z0][1]=wz; for(; j&lt;=q0 &amp;&amp; q[j].x==i; j++) if (i&lt;q[j].y) Ans[q[j].i]=tr_cx(1,1,n,i,q[j].y-1); &#125; fo(i,1,q0) printf(&quot;%lld\\n&quot;,Ans[i]);&#125;","categories":[{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[{"name":"算法_线段树","slug":"算法-线段树","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E7%BA%BF%E6%AE%B5%E6%A0%91/"}]},{"title":"【CF367D】Sereja and Sets 题解","slug":"【CF367D】Sereja and Sets 题解","date":"2017-05-25T01:13:41.000Z","updated":"2024-04-24T03:59:22.837Z","comments":true,"path":"【CF367D】Sereja and Sets 题解/","link":"","permalink":"http://kqp.world/%E3%80%90CF367D%E3%80%91Sereja%20and%20Sets%20%E9%A2%98%E8%A7%A3/","excerpt":"题目大意&emsp;&emsp;有 $m$ 个非空集合，他们两两交集为空，并集为 $[1, n]$。&emsp;&emsp;要你选若干个集合，假设他们的并排序后是数组 $b_1,\\cdots,b_{|b|}$，给定 $d$，要求 $b_1 \\le d$ $b_{i+1}−b_i \\le d$ $n−d+1 \\le b_{|b|}$ &emsp;&emsp;最后问你最少选几个集合能满足要求。&emsp;&emsp;$n,d\\le10^5,\\ m \\le 20$","text":"题目大意&emsp;&emsp;有 $m$ 个非空集合，他们两两交集为空，并集为 $[1, n]$。&emsp;&emsp;要你选若干个集合，假设他们的并排序后是数组 $b_1,\\cdots,b_{|b|}$，给定 $d$，要求 $b_1 \\le d$ $b_{i+1}−b_i \\le d$ $n−d+1 \\le b_{|b|}$ &emsp;&emsp;最后问你最少选几个集合能满足要求。&emsp;&emsp;$n,d\\le10^5,\\ m \\le 20$ 题解&emsp;&emsp;问题转化成：$1$~$n$ 每个数都有一个颜色，要你在这个数轴上选一些数，使得两两间隔（包括开头、结尾）不超过 $d$，并且选出的颜色种类数最少。 &emsp;&emsp;也就是说任意连续的 $d$ 个数中，至少有一个被选。假设这 $d$ 个数的颜色集合是 $S$，那么答案的颜色集合 $ans$ 必须与 $S$ 有交。&emsp;&emsp;也就是现在有 $n-d+1$ 个限制，你要求一个最小的 $ans$，使得 $ans$ 与所有限制有交。 &emsp;&emsp;有交不好做，于是考虑无交，即看看哪些 $ans$ 是不可行的。 S1 \\cap S2= \\emptyset \\Rightarrow S1 \\subseteq \\complement S2&emsp;&emsp;于是开一个 $2^{20}$ 的标记数组，把所有限制打上标记，然后从大到小合并标记，这样就知道哪些东西可以作为 $ans$ 哪些不可以了。","categories":[{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[{"name":"算法_位运算","slug":"算法-位运算","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/"}]},{"title":"【UOJ#152】汉诺塔 题解","slug":"【UOJ#152】汉诺塔 题解","date":"2017-05-25T00:34:09.000Z","updated":"2024-04-24T03:59:22.868Z","comments":true,"path":"【UOJ#152】汉诺塔 题解/","link":"","permalink":"http://kqp.world/%E3%80%90UOJ#152%E3%80%91%E6%B1%89%E8%AF%BA%E5%A1%94%20%E9%A2%98%E8%A7%A3/","excerpt":"题目大意&emsp;&emsp;三根柱子，$n$ 个盘子，编号 $1$~$n$，开始时盘子乱序套在一根柱子上。&emsp;&emsp;构造一种方案，用 $10^6$ 以内步数使所有盘子以递增序套在一根柱子上。&emsp;&emsp;$n \\leq 10^4$","text":"题目大意&emsp;&emsp;三根柱子，$n$ 个盘子，编号 $1$~$n$，开始时盘子乱序套在一根柱子上。&emsp;&emsp;构造一种方案，用 $10^6$ 以内步数使所有盘子以递增序套在一根柱子上。&emsp;&emsp;$n \\leq 10^4$ 题解&emsp;&emsp;这个题的目的是要把盘子排序。 &emsp;&emsp;$10^4$ 和 $10^6$ 是什么关系呢？——$n \\log n$？&emsp;&emsp;$n \\log n$ 有什么排序算法呢？——快排？归并？ &emsp;&emsp;要用一个不太依赖比较的排序，于是选择归并。 &emsp;&emsp;设当前柱子我们对 $[l,r]$ 进行排序，那么可以把盘子平均分到另两根柱子上，把他们分别排好序，再线性合并。&emsp;&emsp;这样就是 $O(n \\log n)$ 的了。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;cstdio&gt;#include&lt;vector&gt;#define fo(i,a,b) for(int i=a;i&lt;=b;i++)#define fd(i,a,b) for(int i=a;i&gt;=b;i--)using namespace std;const int maxn=1e4+5, maxk=1e6+5;struct op&#123; int a,b;&#125;;int n,ans0;vector&lt;int&gt; a;op ans[maxk];int d0,d[maxn];void dq(int a,int b,int c,vector&lt;int&gt; &amp;v) &#123; if (v.size()==1) return; int sz=v.size(), mid=sz&gt;&gt;1, sz1=mid, sz2=sz-mid; vector&lt;int&gt; v1,v2; v1.clear(); v2.clear(); fd(i,mid,1) &#123; ans[++ans0]=(op)&#123;a,b&#125;; v1.push_back(-v[i-1]); &#125; fd(i,sz,mid+1) &#123; ans[++ans0]=(op)&#123;a,c&#125;; v2.push_back(-v[i-1]); &#125; dq(b,a,c,v1); dq(c,a,b,v2); d0=0; for(int i=0, j=0; i&lt;sz1 || j&lt;sz2; ) if (i&lt;sz1 &amp;&amp; (j&gt;=sz2 || -v1[i]&gt;-v2[j])) &#123; d[++d0]=-v1[i++]; ans[++ans0]=(op)&#123;b,a&#125;; &#125; else &#123; d[++d0]=-v2[j++]; ans[++ans0]=(op)&#123;c,a&#125;; &#125; v.clear(); fd(i,d0,1) v.push_back(d[i]);&#125;int main() &#123; scanf(&quot;%d&quot;,&amp;n); fo(i,1,n) &#123; int x; scanf(&quot;%d&quot;,&amp;x); a.push_back(x); &#125; dq(1,2,3,a); printf(&quot;%d\\n&quot;,ans0); fo(i,1,ans0) printf(&quot;%d %d\\n&quot;,ans[i].a,ans[i].b);&#125;","categories":[{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[{"name":"算法_构造题","slug":"算法-构造题","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E6%9E%84%E9%80%A0%E9%A2%98/"},{"name":"算法_分治","slug":"算法-分治","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E5%88%86%E6%B2%BB/"}]},{"title":"北京20日游记（ctsc2017~thusc2017）","slug":"20days_in_beijing(ctsc2017-thusc2017)","date":"2017-05-23T03:31:54.000Z","updated":"2024-04-24T03:59:22.773Z","comments":true,"path":"20days_in_beijing(ctsc2017-thusc2017)/","link":"","permalink":"http://kqp.world/20days_in_beijing(ctsc2017-thusc2017)/","excerpt":"前言&emsp;&emsp;从北京回来，已经宛如一个野人了。头发指甲很长，面容憔悴。 &emsp;&emsp;北京20天，净收获是 CTSC 的一面银牌。&emsp;&emsp;旁边的人收获可就大了，金牌，银牌，还有清北协议。 &emsp;&emsp;就好像做了个很长很长的梦一样，一开始觉得自己好像比别人处境要好，到头来醒了发现自己跟别人一样两手空空地从宿舍赶到教室。 &emsp;&emsp;也 20 多天没写博客了，今天就来补一发游记。","text":"前言&emsp;&emsp;从北京回来，已经宛如一个野人了。头发指甲很长，面容憔悴。 &emsp;&emsp;北京20天，净收获是 CTSC 的一面银牌。&emsp;&emsp;旁边的人收获可就大了，金牌，银牌，还有清北协议。 &emsp;&emsp;就好像做了个很长很长的梦一样，一开始觉得自己好像比别人处境要好，到头来醒了发现自己跟别人一样两手空空地从宿舍赶到教室。 &emsp;&emsp;也 20 多天没写博客了，今天就来补一发游记。 游记CTSC&emsp;&emsp;来北京的第一场比赛。报清北的时候发现自己的奖项里除了 noip 就没有别的一等奖了，有一种动力油然而生。&emsp;&emsp;试机的时候跟大伙开了场 cf，富榄一队，fanvree+yxuanwkeith 一队，我一个人一队。愚蠢的单挑行为，下场就是被暴虐。 &emsp;&emsp;CTSC 算是难得的脑洞大开，两天都会做第一题，d1t1 乱想想到了个下标会动的桶，d2t1 急中生智发现了组合数 mod 2 的奥秘。&emsp;&emsp;然后别的题就什么都不会了，并且暴力基本不得分，简直像在浪一样。于是乎两天就只有 220。恰好 ag 线 190，捡了个银牌。&emsp;&emsp;然后想要在报名表上写 noip 以外的 1= 的愿望就空了。 &emsp;&emsp;然而参加 CTSC 的主要意义是看预备队爷玩。非常幸运能看到 15 人的风骚表现。&emsp;&emsp;论文答辩大家都很自信很大方很流畅，笑点主要来自评委们的无脑提问，貌似被笑了几次之后评委们也不敢问了。如何评价 yjqin 在论文答辩中巧妙批判 SCOI2017？&emsp;&emsp;见证了 xmk 的神奇经历。富榄说：“xmk 怎么奶都奶不死的”，于是 xmk 预备队垫底，然后富榄又说：“没事 xmk 肯定能翻的”，于是 xmk 跑到 rk2 去了。&emsp;&emsp;口试也是十分精彩，有矜持的选手，有自信的选手，还有挑拨离间的评委……&emsp;&emsp;最后就见证了假老师进队，正好是我校第一次进国家队十周年，十年磨一剑。富榄也拿到了非国家队第一名。 APIO&emsp;&emsp;考 APIO 的时候心态极其不好。想着清北报名表填不上 APIO，于是就没什么动力了。&emsp;&emsp;人这一悠闲下来啊，什么事都干得出来。&emsp;&emsp;考场上什么 jb 都想不出来，开场扔掉 t3，觉得 t2 很有趣于是爆肝 t2，最后只肝出来 4 分，t1 最后就交了两档。出来 30 几分，牌都没有。&emsp;&emsp;出考场听见人人都切了 t3，细想一下发现前不久打的 codejam 正好有一样的思路，都是两次 floyd，那题还是我想的。然后回想一下自己弃 t3 的原因，竟然发现好像没有原因。。。 &emsp;&emsp;突然就意识到好像我 OI 生涯所有能拿牌的比赛都结束了，迄今为止没有任何金牌。很想打死早上那个觉得这场比赛没有用的自己。略微惆怅。 北师大附中集训&emsp;&emsp;还有大约四天就清北了，于是留在北京。&emsp;&emsp;校 OI 群上对于过初审的同学和没过初审的同学是两种截然不同的语气。我顿时觉得这个世界很荒凉，仿佛没有夏令营就如同一个废人一样了。我是幸运的，但并不觉得有多高兴，我知道如果我夏令营失败了下场也是一样，给我的通知的语气可能会更奇怪。 &emsp;&emsp;在这边早上做 thu 模拟，晚上做 pku 模拟，不给洗澡，身为南方人感到十分难受。&emsp;&emsp;thu 模拟做得很好，后三场每场切一个题，最后一天想出了两个题但是第一题挂了。这个状态去考 thu 肯定没问题。&emsp;&emsp;pku 模拟做得不好。总是做完签到题之后就像死了似的，题目看上去很简单但是就是想不出什么东西。回宿舍之后经同学一提醒发现是很 sb 的题。。。 PKUSC&emsp;&emsp;其实本来对 pku 印象不是很好，听学长说进 pku 天天学数学，然后又看到今年 pku 在 thuwc 前抢生意、去强省送温暖但就是不送 GD。然后看到今年撞 thusc 的时间比去年还离谱，在学校转了一圈发现 pku 环境比 thu 差。&emsp;&emsp;就越发地想跳，很想跳。就是这种感觉。 &emsp;&emsp;数学考下来说不上崩溃，但是也很难接受，就只会 4 个题，并且 lg5 完全记不得是多少。（然而好像在伙伴中是很前的？？）&emsp;&emsp;两场 acm，都只做了签到题。第一场的 F 是个简单树形 dp，但是我打了复杂的版本最后调不出来；第二场的 B 只要不把环破成链就很好做，但是破成链就什么都不会了，然后也没多想一直在刚 E。最终两场总共 4 题，排名不上不下，于是决定跳。 &emsp;&emsp;其实早就计划好了，无论考好考坏都跳，考差了被迫跳，考好了说明有实力果断跳。 THUSC&emsp;&emsp;这天早上没去 pku，看榜看到 yxuanwkeith 好像挺稳的。 &emsp;&emsp;下午第一场，迟到 2 min。&emsp;&emsp;但是看完题之后对每道题都没有任何想法。觉得可能浪费时间就先扔了 t3，然后弄了 2h 的 t1 无果，又弄了 2h 的 t2 无果，期间想 t3 想了一会儿但是一直在贪心于是无果。&emsp;&emsp;第一天就这样在慌张中让掉了。犯了跟 APIO 一样的错误，都是扔掉的题没捡回来，t3 不知道为什么没想过费用流匹配，据说优化一下能有 70 分，不加任何优化而直接 zkw 有 100 分。。。 &emsp;&emsp;考完 d1 很不爽，出考场听到的“我今天最低 116 吧”“我不知道我 t3 能不能过啊”之类的，就像刀捅一样。晚上吃饭睡觉都没什么心情。 &emsp;&emsp;然而很快就 d2 了。看到 polya 题很是高兴，但直到最后 m&gt;4 还是 T。t1 知道是大数据结构题，想了很久觉得就算想出来也打不完就暴力了。t3 一看是几何提答就随便弄了两下弃了。 &emsp;&emsp;于是 d3 收到了短信。 &emsp;&emsp;清北都报了，也都爆了。 &emsp;&emsp;（UPD：后来听说高二面试线是 200 分，qaq 我差距好大啊。。） 比赛总结策略与难度辨别&emsp;&emsp;APIO、THUSC 都犯的一个最大的问题——扔掉的题没捡回来。&emsp;&emsp;恰好两场都扔的是水题，而且扔的是得分主力题，于是这两场比赛都挂得很惨。自己确实遵守了“每题至少想 20 min”的约定，但是想的时候却不是很尽力，“扔掉”这个行为很大的限制了思考它的专注度。&emsp;&emsp;但我不敢说我策略有错，经验告诉我，把部分时间集中起来专攻一个题，比起平均分配给三道题，很多时候效果要好。可能我还没找到这个度吧，最起码在思考扔掉的题的时候，应该全心全意，把它当作能做的题。 &emsp;&emsp;与此差不多的还有 PKU 的题，这么多场已经完全失去题目难度辨别能力了，看榜也救不回来。 &emsp;&emsp;也确实，现在没有一场比赛的难度是规规矩矩递增的，像我这种丧失难度判断能力的选手就很挂了。&emsp;&emsp;不过说到底这还是能力问题，很容易的问题本来就应该扫两眼就有想法，我扫了很多眼还是没想法就是失败了。这个就继续训练锻炼能力吧，思维灵活度进步空间很大。 思维能力&emsp;&emsp;大概很多题都是想死了一个方向，不知道该不该换。&emsp;&emsp;就像 PKU 第二场的 B，“理所应当”地认为环就应该拆成两条链，发现不会做的时候是根本没有怀疑过这个方向。 &emsp;&emsp;现在发现思维的周期性很严重，总是 极好-&gt;极坏-&gt;极好-&gt;极坏……&emsp;&emsp;我觉得首先要克服情绪的影响，上一场的好坏都必须在下一场开始之前忘掉。然后是硬实力的问题，实力够了再伤心也有高分。 这是一次长途旅行&emsp;&emsp;本来计划省选结束之后潜心修炼，结果是到北京来找空学习了。我在手机里放了很多杂题选讲，没事就看看，当作是学习了。 &emsp;&emsp;说是漫长，确实也漫长，10 天望京、5 天西单、5 天海淀。今天就像梦醒了似的要回去了，两手空空。（没给宿舍同学买烤鸭，CTSC 的银牌也不在我手上） &emsp;&emsp;省选完了之后没回家，于是省选的银牌一路跟着我周游列国。。。摸起来却感觉没什么温度了。 &emsp;&emsp;感谢 OI 吧，因为 OI 才有这么一趟经历。说不上是什么好经历，但肯定是忘不掉的了。出来长了很多见识，比如参观了大学，到处玩，见识别人的中学，见到很多大神。至少这个经历还是难得的。 有点伤感吧OI无金退役&emsp;&emsp;那是在八十中校门口那里，突然间就意识到的问题。 &emsp;&emsp;从六年级开始学的啊，比大部分人都要早。跟我一起开始学的大多已经进队，或者到处拿 1= 了，而我还是宛如一个智障一样的。&emsp;&emsp;回头看看我超越了很多人，但是向前看看很多人超越了我。青春无二，他们都有这么一段辉煌，而我留下的这个空白却是无法弥补的了。看着自己白着的过去很心痛。 &emsp;&emsp;出来四场比赛，充分说明我的那一点成功只是运气，可能省选和 CTSC 运气好碰到很符合自己思路的题。大部分情况都是想不到东西的。我依然不是高手。 清北不收&emsp;&emsp;说什么不伤心那都是假的，清北摆在面前然后自己浪死了，肯定是心痛的。&emsp;&emsp;d2 结束的时候反倒有一丝坦然，觉得自己不用再担心什么，可以安心考 sjtu 了。就像那种绝望之后心也不跳的可怕的宁静。&emsp;&emsp;晚上回来为了让自己有点精神也强行加入背面试稿的行列，第二天早上也傻乎乎地一起等手机响。可能也是有了一点希望吧，所以就再次经历绝望了。 &emsp;&emsp;我觉得 symbol 说的是对的，不要老想着 OI 能给我回报什么，当初学 OI 就是觉得好玩，就是不想把时间都花在文化课上而已。全世界都要考清华，稍微有点菜都上不了。 &emsp;&emsp; 23 号那天早上把 100 年没剪的头发梳了个整齐，梳得好像我要去面试似的。不为什么，大概就是一种信仰。 后记&emsp;&emsp;写着写着发现快成退役记了。。毕竟还有 NOI 没打，还不算真退役。 &emsp;&emsp;现在到 NOI 好像就真没什么比赛了，可以潜心修炼了。 &emsp;&emsp;现在回去至少能继续停课训练，嘲讽什么的过一会儿就没了。不能在学校的清北榜上留下名字确实是遗憾，不过低调点其实也没什么。 &emsp;&emsp;打 NOI，不想别的。","categories":[{"name":"总结与游记","slug":"总结与游记","permalink":"http://kqp.world/categories/%E6%80%BB%E7%BB%93%E4%B8%8E%E6%B8%B8%E8%AE%B0/"},{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[]},{"title":"【bzoj4883】棋盘上的守卫 题解","slug":"【bzoj4883】棋盘上的守卫 题解","date":"2017-05-06T15:16:29.000Z","updated":"2024-04-24T03:59:22.833Z","comments":true,"path":"【bzoj4883】棋盘上的守卫 题解/","link":"","permalink":"http://kqp.world/%E3%80%90bzoj4883%E3%80%91%E6%A3%8B%E7%9B%98%E4%B8%8A%E7%9A%84%E5%AE%88%E5%8D%AB%20%E9%A2%98%E8%A7%A3/","excerpt":"题目大意&emsp;&emsp;在一个 $n\\cdot m$ 的棋盘上要放置若干个守卫。每行必须恰好放置一个横向守卫，每列必须恰好放置一个纵向守卫。每个位置放置守卫的代价是 $w_{i,j}$，且每个位置最多只能放置一个守卫，一个守卫不能同时兼顾行列的防御。请计算控制整个棋盘的最小代价。&emsp;&emsp;$n\\cdot m \\le 10^5,\\ \\ w \\le 10^9$","text":"题目大意&emsp;&emsp;在一个 $n\\cdot m$ 的棋盘上要放置若干个守卫。每行必须恰好放置一个横向守卫，每列必须恰好放置一个纵向守卫。每个位置放置守卫的代价是 $w_{i,j}$，且每个位置最多只能放置一个守卫，一个守卫不能同时兼顾行列的防御。请计算控制整个棋盘的最小代价。&emsp;&emsp;$n\\cdot m \\le 10^5,\\ \\ w \\le 10^9$ 解法1&emsp;&emsp;首先考虑基本的网络流模型：&emsp;&emsp;建两排点，第一排点有 $n \\cdot m$ 个，代表每个格子；第二排点有 $n+m$ 个，代表行和列。然后每个格子向其对应的行和列连容量为 $1$、费用为 $w_{i,j}$ 的边，跑最大权匹配。 &emsp;&emsp;据说 zkw 或者 km 什么的大力艹就过了？？？ 解法2&emsp;&emsp;考虑用贪心来模拟费用流。 &emsp;&emsp;费用流的本质是每次找条最短的增广路。于是把边按照边权从小到大加入（指中间的边），假设当前加入的边，权值为 $w$，它对应的行和列是 $i$ 和 $j$。&emsp;&emsp;我们维护第二排点的连通性，这里的连通性不是指原图的连通性，而是我另外弄了个并查集，一开始互不连通。如果我把上面的加入操作视作是给 $i$ 和 $j$ 连上一条边，那么这里的每一条边相当于是第一排的一个点，这个连通性就代表第二排点的匹配情况。假如连通性是一棵树，则连通块内必有一点没被匹配；假如连通性是一个图（我们限制他只能是环套树，即一棵树再连一条边），则连通块内所有点都能匹配。（相当于是把边分给点，环套树是可以分完的，而树会空出一个点） &emsp;&emsp;那么对于一个加入操作我们分情况讨论：&emsp;&emsp;1、$i$ 和 $j$ 不连通。那么并查集里面就把它们连起来。假如两个连通块都是树，或者一个树一个图，那当前的 $w$ 就计入答案。&emsp;&emsp;2、$i$ 和 $j$ 连通，连通情况为一棵树。那就把树更新为图，并把 $w$ 计入答案。&emsp;&emsp;3、$i$ 和 $j$ 连通，连通情况为一个图。啥也不干。 &emsp;&emsp;这样就用贪心代替费用流了。","categories":[{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[{"name":"算法_网络流/匹配","slug":"算法-网络流-匹配","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E7%BD%91%E7%BB%9C%E6%B5%81-%E5%8C%B9%E9%85%8D/"},{"name":"算法_贪心","slug":"算法-贪心","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E8%B4%AA%E5%BF%83/"}]},{"title":"GDOI2017 省选抱抱我要滚了","slug":"GDOI2017","date":"2017-05-03T01:22:56.000Z","updated":"2024-04-24T03:59:22.777Z","comments":true,"path":"GDOI2017/","link":"","permalink":"http://kqp.world/GDOI2017/","excerpt":"引入&emsp;&emsp;It’s all over. So that’s it\\? Then we failed\\?&emsp;&emsp;No, there’s still another way. We just have to follow Fischer down there.&emsp;&emsp;Not enough time.&emsp;&emsp;No, but there will… there will be enough time down there.&emsp;&emsp;——《盗梦空间》 &emsp;&emsp;我他妈的不会字符串、几何、生成函数、splay外的平衡树……考个屁 OI 啊，收拾包袱回家高考了。&emsp;&emsp;不，还有一个方法，接着学下去就行了。&emsp;&emsp;哪里够时间啊。&emsp;&emsp;肛省选吧，过了省选就有时间了。 &emsp;&emsp;——是啊，过了省选，就有时间了。","text":"引入&emsp;&emsp;It’s all over. So that’s it\\? Then we failed\\?&emsp;&emsp;No, there’s still another way. We just have to follow Fischer down there.&emsp;&emsp;Not enough time.&emsp;&emsp;No, but there will… there will be enough time down there.&emsp;&emsp;——《盗梦空间》 &emsp;&emsp;我他妈的不会字符串、几何、生成函数、splay外的平衡树……考个屁 OI 啊，收拾包袱回家高考了。&emsp;&emsp;不，还有一个方法，接着学下去就行了。&emsp;&emsp;哪里够时间啊。&emsp;&emsp;肛省选吧，过了省选就有时间了。 &emsp;&emsp;——是啊，过了省选，就有时间了。 前言&emsp;&emsp;大概就是怀了上面的想法来了。 &emsp;&emsp;今年高二，最后一次省选，在东莞东华高中松山湖校区，钦定了自己的高考路。&emsp;&emsp;排第 21 名。加权分 60.85，省队线 63.35，1/3 校线 67.45。&emsp;&emsp;已经是发挥得最好的一次了，离省队线很接近，但是纪中发挥太好，8 个过线卡掉 3 个，我在纪中排第 9，离校线一大截。 &emsp;&emsp;旁边哭的哭，笑的笑。我不知道该哭该笑，我尽量做一个没有情绪的机器。 赛程回顾day-1 ~ day0&emsp;&emsp;本想对着 fanvree 给的复习纸把上面的poj复习题过一遍，由于各种浪最后基本没看。&emsp;&emsp;day0 的晚上就是背板、复习套路、聆听 fanvree 的教导~~、打歌~~。&emsp;&emsp;还是挺紧张的，拼尽全力不去想什么是明天。 day1&emsp;&emsp;开始了。 &emsp;&emsp;t1 kmp 瞎艹，过。t2 回想之前某个清华集训的 mex，发现不是一回事，然后发现也不能维护前缀后缀，过。t3 多个 trie 求 lcs，跳。t4 猜是结论题，跳。&emsp;&emsp;不记得是几点写完 t1 了，然后集中精力想 t2，发现可以先全局 mex 再看挖掉一棵子树的影响，一波乱写写到 10 点多拍出错，上了个厕所发现要求每棵子树独有的最小数，想都没想就写了线段树，卡常卡到 11 点出头还是虚的不行（不会测时间，只能掐秒表QaQ，秒表测出来是 2s 多），弃了。&emsp;&emsp;后面就瞎浪，本来打算写 t3 暴力，突然开始推 t4，按照错误的结论瞎写卡特兰数，结果过不了第二个样例。最后 t3 暴力写不出。 &emsp;&emsp;最后 100+100+0+0，day1 排名 19。很稳，但只是前排大众分，无竞争力，毕竟后面两题爆 0 是很恐怖的，不少dalao都切了t3，我校会 SAM 的几乎都切了。 day2&emsp;&emsp;t1 最短路瞎艹，过。t2 看上去很可做，待会来想。t3 这…这个…初看以为两天 4 个字符串题，跳。t4，数据结构题，跳。&emsp;&emsp;一直想着恰好 3 个海明距离以及数据随机到底是个什么性质，想了很多方法最后 10 点半不得不写暴力。11点开始想 t3，太心急了什么也没想到，乱写个费用流水分，发现最小步数对了但是方案是乱来的，11:40 开始写 t4 暴力，写完交卷。 &emsp;&emsp;最后 100+50+5+0，day2 排名 19，两天排名 20。今天妥妥的大众分，毫无竞争力。t2 没意识到是暴力题，t3 也没认真冷静地花时间，最终这两题都很失败。t4 太急了，两棵树共用一套深度，丢暴力。 day3&emsp;&emsp;前三题都长得像 dp 题，待会按顺序想，过。t4 woc栋栋的题，大致记得是两个 splay，弃。&emsp;&emsp;开始刚 t1，发现可以按照 b 值从小到大给每个点赋值，为了避免枚举子集就要同层转移，同层转移的话就要按拓扑序或者dfs序，那就搞定了，大概是 9 点多钟。拍完 t1 大概是 10 点钟，有点飘飘然了。后面几乎一直刚 t3 没刚出来，就随便写了点东西交了。 &emsp;&emsp;最后 100+0+0+30，day3 排名 10，三天排名 14。t2 炸精度了，t3 没把它转化成前缀和来想。 &emsp;&emsp;结束了。 简单总结题目&emsp;&emsp;大致还是符合 GDOI 的风范，有签到题，有难题，有弃疗题。&emsp;&emsp;但是这个风气好像不对了，day1 居然考生成函数！！！感觉 GDOI 要走高端路线了。&emsp;&emsp;今年三天一个数论也不考，直接炸了我校一位数论大王。 &emsp;&emsp;明显感觉我对比以前进步不少，以前只会做签到题和打暴力，去年甚至连签到分都没拿好。这次算是感受到了切题的乐趣，能切签到题以外的题，能在 day3 切题。&emsp;&emsp;但是暴力分拿的好像比以前还少，水分能力和优化能，这次就没显现出来。&emsp;&emsp;有几个别人眼中的水题，也是一堆原因导致没写出来。像 day1 的 trie 上建 SAM，模拟赛出现的时候没认真对待；day2 的后往前 dp，这个是没把主要时间花在这题上，并且自己也蠢；day3 的 t3，就是那种自己很蠢不知道往哪里想。这里说明思维跟人家还是差距很大。&emsp;&emsp;做题策略就是 day2 有问题，深陷 t2 拔不出，最后打 t4 暴力的时间也很少，所以 day2 的拿分就很亏。 分数&emsp;&emsp;省选分排 14 而加权分排 21，非常漂亮的 noip 杀。&emsp;&emsp;每次看着成绩单上，我往前数 5 个都是省选分比我低的，巨不爽。但是也没办法了，noip 菜也是菜的一种。去年发现自己换教室那题 v、n 打反的那一刻，就知道也许会有事情发生。现在它真的发生了。 &emsp;&emsp;不该丢的分，这次有 20 分，d2t4 的两棵树共用一套深度丢 10 分，d3t2 炸精度丢 10 分，比起以往极其不稳定的我已经很好了。前者是因为时间仓促+样例太水，后者是误认为输出过多的小数位会有 bug。 分析离省队线&emsp;&emsp;省队的最后两名，省选分是 495，我是 485，这里拉开 0.84 分；noip 他们都是 430 左右，这里大概拉 1.7 分。&emsp;&emsp;主要分差来自 noip 杀。省选分里也有很多奇奇怪怪的失误分，相比起来好像 noip 的失误分更容易拿到。不深究。 离校线&emsp;&emsp;这个差别就很大了，这 6.6 分几乎不由 noip 造成。&emsp;&emsp;对比 fanvree，差距主要是 d1t3。但是他会 d2t3，他能很快沿着后往前的思路想出 dp，我就很混乱。&emsp;&emsp;对比 yxuanwkeith，也是 d1t3，并且他 d3t3 写了 60 分，他观察到前缀和的性质而我没观察到。&emsp;&emsp;对比 crazy（这位是校线），差距主要在 d2t2、d2t4、d3t3，每题都比我多想到一些东西，分数凑一下就多出 100 了。&emsp;&emsp;对比所有人，别人拉我分的，大概都是我得很低分的题，比如三天我总共 0 了 5 题，这 5 题别人暴力的暴力，水的水，有个 30~40 分，东拼西凑 rank 就上去了。 &emsp;&emsp;一个很大的败笔是 d1t3，不会 SAM 也不会 trie 上建 SAM，模拟赛里面有这个题。考前 fanvree 建议我去复习别的东西，不把主要时间花在改题上。我不知道这个策略于我到底对还是错，他这样做成为了高手，我这样做反而使得我知识点有漏洞。 结束了&emsp;&emsp;现在确定我必须高考了。这倒是没什么好怕的，毕竟我文化课功底是有的，年级前十也考过，我相信给我一个高三我能搞好来。要是将来捞个一本协议还能养老。&emsp;&emsp;心中有对 OI 的信仰，不管怎样都很喜欢敲代码、比赛时的感觉，正如这五天，每天早上沾水梳个好头，不为别的，就是一种信仰，像壮士出征一样的信仰。不会因为省选滚蛋就觉得之前的行为很可笑，省选以后该打比赛的还继续打，该学的还继续学~~，该打的歌还继续打，该抽的卡还继续抽~~，这大概就是 だいすき 了。&emsp;&emsp;周围也有说我考得好的，其实就是一个互相羡慕的过程，别人羡慕我切 d3t1，我也羡慕别人切 d1t3、分高、进省队。遗憾是有的了，再没机会把名字留在红纸贺信上。&emsp;&emsp;我尽量不在社交平台上发 OI 相关的文字，所以这篇 blog 写着写着就很长了。看到空间、pyq 上很多 OIer 都在发进队的欢喜、退役的悲伤，我有时候也很想发一发。但我更希望做一个没有情绪的机器。 后记&emsp;&emsp;“过了省选就有时间了。”&emsp;&emsp;现在时间就在手上，20 天后，THUSC2017。","categories":[{"name":"总结与游记","slug":"总结与游记","permalink":"http://kqp.world/categories/%E6%80%BB%E7%BB%93%E4%B8%8E%E6%B8%B8%E8%AE%B0/"},{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[]},{"title":"【CF392D】Three Arrays 题解","slug":"【CF392D】Three Arrays 题解","date":"2017-04-24T14:13:40.000Z","updated":"2024-04-24T03:59:22.837Z","comments":true,"path":"【CF392D】Three Arrays 题解/","link":"","permalink":"http://kqp.world/%E3%80%90CF392D%E3%80%91Three%20Arrays%20%E9%A2%98%E8%A7%A3/","excerpt":"题目大意&emsp;&emsp;有三个数组 A、B、C，大小都为 n。&emsp;&emsp;设三个整数 a、b、c，使得数组中出现过的每个数在 A 的前 a 项、B 的前 b 项、C 的前 c 项至少出现一次。求最小的 a+b+c。&emsp;&emsp;n&lt;=1e5","text":"题目大意&emsp;&emsp;有三个数组 A、B、C，大小都为 n。&emsp;&emsp;设三个整数 a、b、c，使得数组中出现过的每个数在 A 的前 a 项、B 的前 b 项、C 的前 c 项至少出现一次。求最小的 a+b+c。&emsp;&emsp;n&lt;=1e5 关于题面&emsp;&emsp;英语渣看到 either or，觉得是每种数字只能出现在一个数组中。。。&emsp;&emsp;直到扒了几份 AC 代码下来跑才知道是可以出现在多个数组中。。。 题解&emsp;&emsp;枚举 a，想办法快速确定 b、c。 &emsp;&emsp;这时我们知道了一些数必须在 B、C 中出现。设这个数在 B 中第一次出现的位置是 pb，在 C 中第一次出现的位置是 pc。把 (pb, pc) 看作平面的一个点，那么我们要选的 b、c，就要满足 b&gt;pb 或 c&gt;pc，因此 (b, c) 一定在如下图所示的水平或垂直的折线上或者折线外： &emsp;&emsp;并且可以知道最优点一定可以在折点中找到。 &emsp;&emsp;于是用 set 维护折线，用 heap 维护最优折点。","categories":[{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[{"name":"算法_平衡树/set","slug":"算法-平衡树-set","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E5%B9%B3%E8%A1%A1%E6%A0%91-set/"}]},{"title":"【bzoj3328】PYXFIB 题解","slug":"【bzoj3328】PYXFIB 题解","date":"2017-04-22T14:21:30.000Z","updated":"2024-04-24T03:59:22.831Z","comments":true,"path":"【bzoj3328】PYXFIB 题解/","link":"","permalink":"http://kqp.world/%E3%80%90bzoj3328%E3%80%91PYXFIB%20%E9%A2%98%E8%A7%A3/","excerpt":"题目大意&emsp;&emsp;求： \\sum_{i=0}^{\\lfloor \\frac{n}{k} \\rfloor} C_{n}^{ik}F_{ik} \\pmod p&emsp;&emsp;其中 $F$ 表示斐波那契数列，$F[0]=F[1]=1$。 &emsp;&emsp;$n \\leq 10^{18},\\ k \\leq 20000,\\ p \\leq 10^9$ 且保证 $p$ 为质数、$p\\bmod k=1$","text":"题目大意&emsp;&emsp;求： \\sum_{i=0}^{\\lfloor \\frac{n}{k} \\rfloor} C_{n}^{ik}F_{ik} \\pmod p&emsp;&emsp;其中 $F$ 表示斐波那契数列，$F[0]=F[1]=1$。 &emsp;&emsp;$n \\leq 10^{18},\\ k \\leq 20000,\\ p \\leq 10^9$ 且保证 $p$ 为质数、$p\\bmod k=1$ \\\\ \\\\ \\\\题解&emsp;&emsp;首先斐波那契数列可以用矩阵来表示，设为 $A=\\begin{bmatrix} 1&amp;1 \\\\ 1&amp;0\\end{bmatrix}$，则 $F(i)=A^i$ 的左上角。&emsp;&emsp;于是原式等于\\sum_{i=0}^{\\lfloor \\frac{n}{k} \\rfloor} C_n^{ik}A^{ik} \\pmod p &emsp;&emsp;上标为 $ik$ 很难看，于是换种写法：\\sum_{i=0}^n ~[i \\bmod k=0]C_n^i A^i \\pmod p&emsp;&emsp;现在考虑怎么替换 $[i \\bmod k=0]$ 这个条件。（据说这个东西叫单位根反演？）&emsp;&emsp;令 $p$ 的原根为 $g$，设 $w=g^{\\frac{p-1}{k}}$，我们来观察一下 $\\sum_{j=0}^{k-1}w^{ij}$的性质。&emsp;&emsp;1、$i \\bmod k=0$：则 $w^{ij}$ 恒等于 $1$，因此原式 $=k$；&emsp;&emsp;2、$i \\bmod k\\not=0$：则由等比数列求和得：原式 $=\\frac{w^{ik}-1}{w^i-1}=\\frac{1-1}{w^i-1}=0$；&emsp;&emsp;综上，$[i \\bmod k=0]$ 可以替换成 $\\frac{1}{k}\\sum_{j=0}^{k-1}w^{ij}$&emsp;&emsp;（超厉害。。。）&emsp;&emsp;于是现在原式变成：\\sum_{i=0}^n C_n^i A^i \\frac{1}{k}\\sum_{j=0}^{k-1}w^{ij} \\pmod p&emsp;&emsp;发现 $C_n^i$ 乘上一堆上标为 $i$ 的东西很像二项式展开，于是交换一下顺序变成： \\begin{aligned} &\\frac{1}{k}\\sum_{j=0}^{k-1}\\sum_{i=0}^n C_n^i A^i w^{ij} \\pmod p \\\\ =&\\frac{1}{k}\\sum_{j=0}^{k-1}(Aw^j+I)^n \\pmod p \\end{aligned}&emsp;&emsp;其中 $I$ 表示单位矩阵。 &emsp;&emsp;然后，枚举 $j$ 就做完了。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#define fo(i,a,b) for(int i=a;i&lt;=b;i++)using namespace std;typedef long long LL;const int maxsqrtp=5e4+5;struct Arr&#123; LL n[2][2];&#125;;LL n,p;int k;LL mi(LL x,LL y)&#123; LL re=1; for(; y; y&gt;&gt;=1, (x*=x)%=p) if (y&amp;1) (re*=x)%=p; return re;&#125;int g,p0,pr[maxsqrtp];void find_g()&#123; int sqrtp=sqrt(p), pp=p-1; p0=0; fo(i,2,sqrtp) if (pp%i==0) &#123; pr[++p0]=i; while (pp%i==0) pp/=i; &#125; if (pp&gt;1) pr[++p0]=pp; for(g=2; ; g++) &#123; bool pd=1; fo(i,1,p0) if (mi(g,(p-1)/pr[i])==1) &#123;pd=0; break;&#125; if (pd) return; &#125;&#125;Arr F,I;Arr mul(Arr a,Arr b)&#123; Arr re; re.n[0][0]=(a.n[0][0]*b.n[0][0]+a.n[0][1]*b.n[1][0])%p; re.n[0][1]=(a.n[0][0]*b.n[0][1]+a.n[0][1]*b.n[1][1])%p; re.n[1][0]=(a.n[1][0]*b.n[0][0]+a.n[1][1]*b.n[1][0])%p; re.n[1][1]=(a.n[1][0]*b.n[0][1]+a.n[1][1]*b.n[1][1])%p; return re;&#125;Arr mulnum(Arr a,LL b)&#123; (a.n[0][0]*=b)%=p; (a.n[0][1]*=b)%=p; (a.n[1][0]*=b)%=p; (a.n[1][1]*=b)%=p; return a;&#125;Arr plusI(Arr a)&#123; (a.n[0][0]+=1)%=p; (a.n[1][1]+=1)%=p; return a;&#125;Arr Mi(Arr x,LL y)&#123; Arr re=I; for(; y; y&gt;&gt;=1, x=mul(x,x)) if (y&amp;1) re=mul(re,x); return re;&#125;int T;int main()&#123; F.n[0][0]=F.n[0][1]=F.n[1][0]=1; F.n[1][1]=0; I.n[0][0]=I.n[1][1]=1; scanf(&quot;%d&quot;,&amp;T); while (T--) &#123; scanf(&quot;%lld %d %lld&quot;,&amp;n,&amp;k,&amp;p); find_g(); LL w0=mi(g,(p-1)/k); LL ans=0, w=1; fo(j,0,k-1) &#123; Arr t=Mi(plusI(mulnum(F,w)),n); (ans+=t.n[0][0])%=p; (w*=w0)%=p; &#125; printf(&quot;%lld\\n&quot;,ans*mi(k,p-2)%p); &#125;&#125;","categories":[{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[{"name":"算法_神奇的脑洞","slug":"算法-神奇的脑洞","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E7%A5%9E%E5%A5%87%E7%9A%84%E8%84%91%E6%B4%9E/"},{"name":"算法_数论","slug":"算法-数论","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E6%95%B0%E8%AE%BA/"},{"name":"算法_矩阵乘法","slug":"算法-矩阵乘法","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95/"}]},{"title":"【AtCoder Grand 011E】Increasing Numbers 题解","slug":"【AtCoder Grand 011E】Increasing Numbers 题解","date":"2017-04-18T06:36:44.000Z","updated":"2024-04-24T03:59:22.821Z","comments":true,"path":"【AtCoder Grand 011E】Increasing Numbers 题解/","link":"","permalink":"http://kqp.world/%E3%80%90AtCoder%20Grand%20011E%E3%80%91Increasing%20Numbers%20%E9%A2%98%E8%A7%A3/","excerpt":"题目大意&emsp;&emsp;如果一个数，从高位到低位是递增的，则称为上升数，例如 1122345。&emsp;&emsp;现在有个大整数 $n$，求至少需要多少个上升数，使它们的和为 $n$。&emsp;&emsp;$n \\le 10^{5 \\times 10^5}$","text":"题目大意&emsp;&emsp;如果一个数，从高位到低位是递增的，则称为上升数，例如 1122345。&emsp;&emsp;现在有个大整数 $n$，求至少需要多少个上升数，使它们的和为 $n$。&emsp;&emsp;$n \\le 10^{5 \\times 10^5}$ \\\\ \\\\ \\\\解法1.1&emsp;&emsp;上升数可以拆成很多个形如 1111…111 的全 1 数，例如 1122345=1111111+11111+111+11+1。&emsp;&emsp;所以可以考虑把 $n$ 拆成全 1 数，然后合并。因为 1 个上升数最多由 9 个全 1 数合并而来，并且可以任意组合，所以最后的答案是 $\\lceil \\frac{全1数的数量}{9} \\rceil$，因此最小化全 1 数的数量即可。 &emsp;&emsp;然后全 1 数可以看成是 1+10+100+100……这样的等比数列和，因此一个 $n$ 位的全 1 数等于 $\\frac{10^n-1}{9}$。假设我们最后拆成的全 1 数有 $k$ 个，位数分别是 $a[1]…a[k]$，则有 $\\sum_{i=1}^{k}(10^{a[i]}-1)=9n$，我们要最小化 $k$。 &emsp;&emsp;枚举这个 $k$ 就行了，因为判断条件是 $9n+k$ 的数位和等于 $k$，所以$k$ 是 $O(5e5)$ 的。 解法1.2&emsp;&emsp;事实上这个 $k$ 不需要枚举，因为 $9n+k$ 的数位和的增长速度比 $k$ 慢，所以二分 $k$ 就行了。 解法2&emsp;&emsp;上述拆成全 1 数的方法其实证明了贪心是对的，即每次选最大的全 1 数，或者回到原题是每次选最大的上升数。比如 720464=699999+20465=699999+19999+466 &emsp;&emsp;因为 $n-a=n-(a+1)+1$，所以每次分离一个最大的上升数就相当于，从最高位开始找最长连续的上升序列，然后删掉这个序列，剩下的这个数+1。 &emsp;&emsp;所以就 $O(5e5)$ 地从高位开始扫。高精度+1的复杂度也是 $O(5e5)$。（每 10 次加法会用到第二位、每 100 次加法会用到第三位……所以是 $5e5+\\frac{5e5}{10}+\\frac{5e5}{100}+……$）","categories":[{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[{"name":"算法_贪心","slug":"算法-贪心","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E8%B4%AA%E5%BF%83/"}]},{"title":"【AtCoder Grand 013E】Placing Squares 题解","slug":"【AtCoder Grand 013E】Placing Squares 题解","date":"2017-04-16T02:50:09.000Z","updated":"2024-04-24T03:59:22.822Z","comments":true,"path":"【AtCoder Grand 013E】Placing Squares 题解/","link":"","permalink":"http://kqp.world/%E3%80%90AtCoder%20Grand%20013E%E3%80%91Placing%20Squares%20%E9%A2%98%E8%A7%A3/","excerpt":"题目大意&emsp;&emsp;有一个长度为 $n$ 的数轴（看作是 $n$ 个格子排成一行），其中有 $m$ 个交界位置被标记了。你要用若干正方形去覆盖这个数轴（如下图），有 3 个规定：&emsp;&emsp;1、正方形边长必须是正整数&emsp;&emsp;2、数轴要被恰好覆盖，即不能有空、不能有地方被多个正方形覆盖。&emsp;&emsp;3、被标记的位置不能是正方形的交界。&emsp;&emsp;一种方案的价值是所有正方形的面积的积。求所有合法方案的价值和。&emsp;&emsp;$n \\le 10^9,\\ m \\le 10^5$","text":"题目大意&emsp;&emsp;有一个长度为 $n$ 的数轴（看作是 $n$ 个格子排成一行），其中有 $m$ 个交界位置被标记了。你要用若干正方形去覆盖这个数轴（如下图），有 3 个规定：&emsp;&emsp;1、正方形边长必须是正整数&emsp;&emsp;2、数轴要被恰好覆盖，即不能有空、不能有地方被多个正方形覆盖。&emsp;&emsp;3、被标记的位置不能是正方形的交界。&emsp;&emsp;一种方案的价值是所有正方形的面积的积。求所有合法方案的价值和。&emsp;&emsp;$n \\le 10^9,\\ m \\le 10^5$ 题解&emsp;&emsp;这个很妙啊。。。 &emsp;&emsp;首先瞎写一个dp：$f[i]=\\sum_{j=0}^{i-1}f[j]*(i-j)^2$，然后发现这个平方非常不好搞。 &emsp;&emsp;于是转化模型，把 $x^2$ 看作是长度为 $x$ 的段内，恰好放一个红球和一个蓝球（可以放在同一位置）的方案数。&emsp;&emsp;于是可以设 $f[i][j]\\ (j \\in [0,2])$ 表示到了第 $i$ 个格子，当前段内有 $j$ 个球，的方案数。转移就是讨论一下 9 个转移，然后写出转移矩阵就可以矩阵乘法了。&emsp;&emsp;至于标记的位置，实际上是那些位置的 $f[i][2]$ 的转移要改一下，不能新开一个正方形。&emsp;&emsp;所以时间是 $O(m \\log n)$ 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;bits/stdc++.h&gt;#define fo(i,a,b) for(int i=a;i&lt;=b;i++)using namespace std;typedef long long LL;const int maxm=1e5+5;const LL mo=1e9+7;struct ARR&#123; LL n[3][3];&#125;;ARR re;ARR operator * (const ARR &amp;a,const ARR &amp;b)&#123; fo(i,0,2) fo(j,0,2) &#123; re.n[i][j]=0; fo(k,0,2) (re.n[i][j]+=a.n[i][k]*b.n[k][j])%=mo; &#125; return re;&#125;int m;LL n,x[maxm];ARR C,ans;void mi(LL y)&#123; for(; y; y&gt;&gt;=1, C=C*C) if (y&amp;1) ans=ans*C;&#125;int main()&#123; scanf(&quot;%lld %d&quot;,&amp;n,&amp;m); fo(i,1,m) scanf(&quot;%d&quot;,&amp;x[i]); x[++m]=n; sort(x+1,x+1+m); ans=(ARR)&#123;&#123;&#123;1,0,0&#125;,&#123;0,0,0&#125;,&#123;0,0,0&#125;&#125;&#125;; x[0]=-1; fo(i,1,m) &#123; LL len=x[i]-(x[i-1]+1); C=(ARR)&#123;&#123;&#123;1,2,1&#125;,&#123;0,1,1&#125;,&#123;1,2,2&#125;&#125;&#125;; mi(len); if (i==m) break; C=(ARR)&#123;&#123;&#123;1,2,1&#125;,&#123;0,1,1&#125;,&#123;0,0,1&#125;&#125;&#125;; ans=ans*C; &#125; printf(&quot;%lld\\n&quot;,ans.n[0][2]);&#125;","categories":[{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[{"name":"算法_神奇的脑洞","slug":"算法-神奇的脑洞","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E7%A5%9E%E5%A5%87%E7%9A%84%E8%84%91%E6%B4%9E/"},{"name":"算法_DP","slug":"算法-DP","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-DP/"},{"name":"算法_矩阵乘法","slug":"算法-矩阵乘法","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95/"}]},{"title":"【bzoj3451】【Tyvj1953】Normal 题解","slug":"【bzoj3451】【Tyvj1953】Normal 题解","date":"2017-04-14T12:48:22.000Z","updated":"2024-04-24T03:59:22.831Z","comments":true,"path":"【bzoj3451】【Tyvj1953】Normal 题解/","link":"","permalink":"http://kqp.world/%E3%80%90bzoj3451%E3%80%91%E3%80%90Tyvj1953%E3%80%91Normal%20%E9%A2%98%E8%A7%A3/","excerpt":"题目大意&emsp;&emsp;$n$ 个点的树，进行点分，每次随机选择分治中心，求期望复杂度。&emsp;&emsp;例如长度为 $3$ 的链，期望复杂度是 $\\frac{2}{3}(3+(2+1))+\\frac{1}{3}(3+(1+1))=\\frac{17}{3}$&emsp;&emsp;$n \\le 30000$","text":"题目大意&emsp;&emsp;$n$ 个点的树，进行点分，每次随机选择分治中心，求期望复杂度。&emsp;&emsp;例如长度为 $3$ 的链，期望复杂度是 $\\frac{2}{3}(3+(2+1))+\\frac{1}{3}(3+(1+1))=\\frac{17}{3}$&emsp;&emsp;$n \\le 30000$ 题解&emsp;&emsp;有点妙。。。 &emsp;&emsp;考虑每个点的贡献，其实就是它在点分树上的期望深度。&emsp;&emsp;也就是其他点成为它点分树祖先的概率和。&emsp;&emsp;考虑两个点 $i$ 和 $j$，$j$ 成为 $i$ 的祖先，当且仅当 $i$ 到 $j$ 的路径上，第一个被分治的是 $j$。&emsp;&emsp;因此期望复杂度是：\\sum_{i=1}^n\\sum_{j=1,j≠i}^n\\frac{1}{dis(i,j)} &emsp;&emsp;考虑用点分来求这个东西。&emsp;&emsp;对于当前子树，可以求出 $d[i]$ 表示到根距离为 $i$ 的路径数量。然后 $d$ 数组自己卷积一下就可以得到长度为 $i$ 的路径数量。&emsp;&emsp;因为 $d$ 的元素大小随分治而减小，所以点分+FFT的总时间是 $T(n)=O(n~log~n)+2T(\\frac{n}{2})=O(n \\log^2 n)$","categories":[{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[{"name":"算法_点分治","slug":"算法-点分治","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E7%82%B9%E5%88%86%E6%B2%BB/"},{"name":"算法_FFT/NTT","slug":"算法-FFT-NTT","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-FFT-NTT/"},{"name":"算法_概率与期望","slug":"算法-概率与期望","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E6%A6%82%E7%8E%87%E4%B8%8E%E6%9C%9F%E6%9C%9B/"}]},{"title":"【JZOJ5051】平行宇宙 题解","slug":"【JZOJ5051】平行宇宙 题解","date":"2017-04-14T04:41:15.000Z","updated":"2024-04-24T03:59:22.857Z","comments":true,"path":"【JZOJ5051】平行宇宙 题解/","link":"","permalink":"http://kqp.world/%E3%80%90JZOJ5051%E3%80%91%E5%B9%B3%E8%A1%8C%E5%AE%87%E5%AE%99%20%E9%A2%98%E8%A7%A3/","excerpt":"题目大意&emsp;&emsp;有 n 个宇宙，每个宇宙都连出去一条单向边。边的长度都是 1。&emsp;&emsp;现在要新加一些单向边（长度为 1），使得从 1 号节点出发到任意节点的最短路长度不超过 k。求最少加多少边。&emsp;&emsp;n&lt;=5e5， k&lt;=2e4","text":"题目大意&emsp;&emsp;有 n 个宇宙，每个宇宙都连出去一条单向边。边的长度都是 1。&emsp;&emsp;现在要新加一些单向边（长度为 1），使得从 1 号节点出发到任意节点的最短路长度不超过 k。求最少加多少边。&emsp;&emsp;n&lt;=5e5， k&lt;=2e4 题解&emsp;&emsp;它是个环套树（森林），那么树上的叶子节点肯定要跟 1 号节点连边。然后通过叶子往上推，树的部分就做完了。 &emsp;&emsp;然后单独看每个环，问题变成：有一个环，其中有些点已经染过色了，你要用长度为 k 的链去染这个环，求最少的链数。 &emsp;&emsp;把环破成链，倍长一下。我们枚举一个起点，从这个起点开始往后跳（即预处理一个 next 数组，表示第 i 个点往后走 k 步之后第一个没被染色的点是谁），跳到距离大于环长为止，跳的次数就是这个点的答案。&emsp;&emsp;假设有 i&lt; j 且 next[i]=next[j]，那么 j 跳到 next[j] 的时候，后面的事情跟 i 是一样的（当然 j 可能还要继续往后跳）。所以我们用并查集把跳过的缩起来，这样就可以保证每个点只会被跳一次了。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119#include&lt;cstdio&gt;#include&lt;algorithm&gt;#define fo(i,a,b) for(int i=a;i&lt;=b;i++)#define fd(i,a,b) for(int i=a;i&gt;=b;i--)using namespace std;const int maxn=5e5+5;int n,K,ans;int tot,go[maxn],next[maxn],f1[maxn],fa[maxn];void ins(int x,int y)&#123; go[++tot]=y; next[tot]=f1[x]; f1[x]=tot;&#125;int d[maxn],com[maxn];bool roll[maxn];void topo()&#123; int j=0; fo(i,1,n) if (!com[i]) d[++j]=i; for(int i=1; i&lt;=j; i++) &#123; if (--com[fa[d[i]]]==0) d[++j]=fa[d[i]]; &#125; fo(i,1,n) if (com[i]) roll[i]=1;&#125;int tim[maxn];bool bz[maxn];void dfs(int k)&#123; bz[k]=1; tim[k]=K+500; for(int p=f1[k]; p; p=next[p]) &#123; dfs(go[p]); tim[k]=min(tim[k],tim[go[p]]+1); &#125; if (k==1) tim[k]=0; else if (tim[k]&gt;K &amp;&amp; !roll[k]) &#123; tim[k]=1; ans++; &#125;&#125;int ga[2*maxn],stp[2*maxn];int get(int x)&#123; if (ga[x]==x) return x; int t=ga[x]; ga[x]=get(ga[x]); stp[x]+=stp[t]; return ga[x];&#125;int c0,c[2*maxn],f[2*maxn]; // f 就是上面说的 nextvoid calc(int x)&#123; c[c0=1]=x; for(int i=fa[x]; i!=x; i=fa[i]) c[++c0]=i; fo(i,1,c0) c[c0+i]=c[i]; fo(i,1,c0) dfs(c[i]); fo(i,1,2*c0) tim[c[i]]=min(tim[c[i]],tim[c[i-1]]+1); fo(i,1,2*c0) ga[i]=i, stp[i]=0; fd(i,2*c0,2*c0-K+1) f[i]=2*c0+1; int last=2*c0+1; fd(i,2*c0,K+1) &#123; if (tim[c[i]]&gt;K) last=i; f[i-K]=last; &#125; int nmin=n+500; fo(i,1,c0) if (tim[c[i]]&gt;K) &#123; int ans1=0, last=0; for(int j=i; j &amp;&amp; j-i+1&lt;=c0; j=f[j]) &#123; int t2=get(j); ans1+=1+stp[j]; if (last) &#123; int t1=get(last); ga[t1]=t2; stp[t1]+=stp[j]+1; &#125; j=t2; last=j; &#125; nmin=min(nmin,ans1); &#125; ans+=(nmin==n+500) ?0 :nmin ;&#125;int main()&#123; scanf(&quot;%d %d&quot;,&amp;n,&amp;K); fo(i,1,n) &#123; int x,y; scanf(&quot;%d %d&quot;,&amp;x,&amp;y); fa[x]=y; com[y]++; &#125; topo(); fo(i,1,n) if (!roll[i]) ins(fa[i],i); fo(i,1,n) if (roll[i] &amp;&amp; !bz[i]) calc(i); printf(&quot;%d\\n&quot;,ans);&#125;","categories":[{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[{"name":"算法_环套树","slug":"算法-环套树","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E7%8E%AF%E5%A5%97%E6%A0%91/"}]},{"title":"GDOI2017模拟1总结","slug":"GDOI2017模拟1总结","date":"2017-04-14T03:43:28.000Z","updated":"2024-04-24T03:59:22.778Z","comments":true,"path":"GDOI2017模拟1总结/","link":"","permalink":"http://kqp.world/GDOI2017%E6%A8%A1%E6%8B%9F1%E6%80%BB%E7%BB%93/","excerpt":"认真做，模拟最真实的退役情况 简单的场拿不够分，难的场分差被拉大，最终分数越排越后，D类都没有。题目都很有gdoi的风格，就是要等考完之后才发现是水题。 这几场脑子很空。day1，t2想到扫描线但不知道要用线段树维护什么，t3看到k很小只是想状压没想容斥，t4环上的部分就没想过枚举起点。day2 做慢了，t1想到SA没时间想下去，t4点剖以后不会处理。day3 就是都不知道应该往哪去想，t4暴力复杂度证错了写都不敢写。 很多东西就是，想到了觉得不可做然后就不想了，或者说不知道用什么方法解决就在乱想。想到了很多思路，都是正解靠边的，就是整理不起来。要加强的是分析题目性质的能力，需要一定的套路积累，也要很强的灵活性，又不能过于灵活不然容易想偏。 现在有个问题就是，我无法把握正解或者部分分的方向，想问题的深度和广度总是错误的，包括简单题也包括难题。做别人推荐给我的题，有些很显然的性质摆在眼前，我也会想偏。这个问题我不会解决，但我也不相信只有多刷题能解决。谁会解决谁教我吧，反正我跟正常人的思维周期性地合不在一起我也不知道为什么。我也不想老是追求大神的思维，然而靠自己确实是很多时候想不到正路。 我觉得说来说去都是现在想的东西太乱了，要睡个觉冷静一下，然后不带任何情绪地做题。","text":"认真做，模拟最真实的退役情况 简单的场拿不够分，难的场分差被拉大，最终分数越排越后，D类都没有。题目都很有gdoi的风格，就是要等考完之后才发现是水题。 这几场脑子很空。day1，t2想到扫描线但不知道要用线段树维护什么，t3看到k很小只是想状压没想容斥，t4环上的部分就没想过枚举起点。day2 做慢了，t1想到SA没时间想下去，t4点剖以后不会处理。day3 就是都不知道应该往哪去想，t4暴力复杂度证错了写都不敢写。 很多东西就是，想到了觉得不可做然后就不想了，或者说不知道用什么方法解决就在乱想。想到了很多思路，都是正解靠边的，就是整理不起来。要加强的是分析题目性质的能力，需要一定的套路积累，也要很强的灵活性，又不能过于灵活不然容易想偏。 现在有个问题就是，我无法把握正解或者部分分的方向，想问题的深度和广度总是错误的，包括简单题也包括难题。做别人推荐给我的题，有些很显然的性质摆在眼前，我也会想偏。这个问题我不会解决，但我也不相信只有多刷题能解决。谁会解决谁教我吧，反正我跟正常人的思维周期性地合不在一起我也不知道为什么。我也不想老是追求大神的思维，然而靠自己确实是很多时候想不到正路。 我觉得说来说去都是现在想的东西太乱了，要睡个觉冷静一下，然后不带任何情绪地做题。","categories":[{"name":"总结与游记","slug":"总结与游记","permalink":"http://kqp.world/categories/%E6%80%BB%E7%BB%93%E4%B8%8E%E6%B8%B8%E8%AE%B0/"},{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[]},{"title":"【hdu5219】Repeating 题解","slug":"【hdu5219】Repeating 题解","date":"2017-04-12T14:52:12.000Z","updated":"2024-04-24T03:59:22.845Z","comments":true,"path":"【hdu5219】Repeating 题解/","link":"","permalink":"http://kqp.world/%E3%80%90hdu5219%E3%80%91Repeating%20%E9%A2%98%E8%A7%A3/","excerpt":"题目大意&emsp;&emsp;给定一个长度为 n 的小写字符串，问有多少个子串没有循环节。&emsp;&emsp;n&lt;=1e5","text":"题目大意&emsp;&emsp;给定一个长度为 n 的小写字符串，问有多少个子串没有循环节。&emsp;&emsp;n&lt;=1e5 \\\\ \\\\ \\\\题解&emsp;&emsp;套路×套路 &emsp;&emsp;因为会出现大循环套小循环的情况，所以我们用莫比乌斯函数来容斥，那么问题变成，枚举一个循环长度 L，问有多少子串的循环节长度是 L 的倍数。 &emsp;&emsp;然后在字符串上每 L 个建立一个关键点。对相邻的两个关键点 i 和 j，假设这两个前缀的 lcs 是 l1，这两个后缀的 lcp 是 l2，那么把这个长度为 l1+L+l2 的字符串提取出来（i 往前 l1 步，j 往后 l2 步），这里面任意一个长度为 L 的倍数（除了 1 倍）的子串都满足循环节长度是 L 的倍数。&emsp;&emsp;为了避免计重，可限制 l1 &lt; L。","categories":[{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[{"name":"算法_数论","slug":"算法-数论","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E6%95%B0%E8%AE%BA/"},{"name":"算法_字符串","slug":"算法-字符串","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"【AtCoder Grand 012C】Tautonym Puzzle 题解","slug":"【AtCoder Grand 012C】Tautonym Puzzle 题解","date":"2017-04-12T06:44:53.000Z","updated":"2024-04-24T03:59:22.821Z","comments":true,"path":"【AtCoder Grand 012C】Tautonym Puzzle 题解/","link":"","permalink":"http://kqp.world/%E3%80%90AtCoder%20Grand%20012C%E3%80%91Tautonym%20Puzzle%20%E9%A2%98%E8%A7%A3/","excerpt":"题目大意&emsp;&emsp;如果一个序列，长度为偶数，从中间劈开之后左边跟右边是相同的，则称这个序列是好的。例如 {1, 2, 3, 1, 2, 3} 是好的，{1, 2, 3, 1, 2, 4} 是不好的。&emsp;&emsp;现在要你构造一个序列，满足三个条件： 序列长度 &lt;=200 元素大小 &lt;=100 恰有 n 个子序列是好的。 &emsp;&emsp;$n&lt;=10^{12}$","text":"题目大意&emsp;&emsp;如果一个序列，长度为偶数，从中间劈开之后左边跟右边是相同的，则称这个序列是好的。例如 {1, 2, 3, 1, 2, 3} 是好的，{1, 2, 3, 1, 2, 4} 是不好的。&emsp;&emsp;现在要你构造一个序列，满足三个条件： 序列长度 &lt;=200 元素大小 &lt;=100 恰有 n 个子序列是好的。 &emsp;&emsp;$n&lt;=10^{12}$ \\\\ \\\\ \\\\解法1&emsp;&emsp;考虑二进制拆分。 &emsp;&emsp;比如序列是 1 2 3 4 1 2 3 4，那他的好子序列个数就是 2^4。&emsp;&emsp;1e12 的二进制 35 位，所以需要的序列长度最坏是 2*(1+2+3+…+35)，需要的元素大小最坏是 1+2+3+…+35 解法2&emsp;&emsp;考虑倍增。 &emsp;&emsp;比如序列是 x1 x2 x3 x4 1 2 3 4，其中 x 是长度为 4 的排列，那他的好子序列个数就是 x 的上升子序列个数。&emsp;&emsp;假设当前方案数为 $ans$，要使 $ans\\cdot 2$，则变成 x1 x2 x3 x4 5 1 2 3 4 5；要使 $ans+1$，则变成 5 x1 x2 x3 x4 1 2 3 4 5。依此类推。&emsp;&emsp;所需要的序列长度最坏是 $4 \\cdot \\log(10^{12})$，元素个数最坏是 $2\\cdot \\log( 10^{12} )$","categories":[{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[{"name":"算法_神奇的脑洞","slug":"算法-神奇的脑洞","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E7%A5%9E%E5%A5%87%E7%9A%84%E8%84%91%E6%B4%9E/"},{"name":"算法_构造题","slug":"算法-构造题","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E6%9E%84%E9%80%A0%E9%A2%98/"}]},{"title":"【2017 X Samara Regional Intercollegiate Programming Contest I】Matrix God 题解","slug":"【2017 X Samara Regional Intercollegiate Programming Contest I】Matrix God 题解","date":"2017-04-10T13:18:40.000Z","updated":"2024-04-24T03:59:22.802Z","comments":true,"path":"【2017 X Samara Regional Intercollegiate Programming Contest I】Matrix God 题解/","link":"","permalink":"http://kqp.world/%E3%80%902017%20X%20Samara%20Regional%20Intercollegiate%20Programming%20Contest%20I%E3%80%91Matrix%20God%20%E9%A2%98%E8%A7%A3/","excerpt":"题目大意&emsp;&emsp;有三个 $n\\times n$ 的矩阵 $A$、$B$、$C$，问 $A\\times B$ 是否等于 $C$。&emsp;&emsp;元素在模 $10^9+7$ 意义下。&emsp;&emsp;$n \\leq 1000$","text":"题目大意&emsp;&emsp;有三个 $n\\times n$ 的矩阵 $A$、$B$、$C$，问 $A\\times B$ 是否等于 $C$。&emsp;&emsp;元素在模 $10^9+7$ 意义下。&emsp;&emsp;$n \\leq 1000$ \\\\ \\\\ \\\\题解&emsp;&emsp;新套路 get。 &emsp;&emsp;直接矩阵乘法 $O(n^3)$ 很大，考虑把这个降下来。 &emsp;&emsp;随机几个 $n\\times 1$ 的向量，比如是 $\\vec v$，那么就是判断 $AB\\vec v$ 是否等于 $C \\vec v$。 &emsp;&emsp;这样矩阵乘法就是 $O(n^2)$ 的了！！！ 证明&emsp;&emsp;UPD：终于在多年以后的毛营学到了证明 qaq &emsp;&emsp;如何分析这个算法的正确率呢？ &emsp;&emsp;如果 $\\exists \\vec v \\not= 0$，使得 $AB \\vec v \\not= C \\vec v$，那么 $AB$ 一定不等于 $C$。&emsp;&emsp;也就是说，我们的算法错误意味着 $\\exists \\vec v\\not= 0$，$AB \\vec v=C \\vec v$ 但 $AB\\not= C$。由 $AB \\vec v=C \\vec v$ 得： (AB-C)\\vec v=0&emsp;&emsp;这表示 $\\vec v∈Nul(AB-C)$。但由于 $AB-C\\not=0$，所以 $Rank(AB-C)&gt;0$，$\\dim Nul(AB-C)&lt;n$。因此，随机到一个这样一个向量 $\\vec v$ 的概率是 $\\frac{小于n维的空间}{n维空间}$，也就是 $0$。 &emsp;&emsp;也就是说，理论上，当矩阵内的数的取值是任意实数的话，只用随机一次就够了。 &emsp;&emsp;但很多时候矩阵内的数的取值是有限制的。例如，规定三个矩阵都是 01 矩阵，运算在 $\\bmod 2$ 意义下，那么 $\\frac{小于n维的空间}{n维空间}$ 就不能说等于 $0$ 了，而只能说是小于 $\\frac{1}{2}$。因此，要随机多几次，比如 10 次，使得错误概率 $P_{wrong}&lt;(\\frac{1}{2})^{10}=\\frac{1}{1024}$。&emsp;&emsp;当矩阵内的数的取值范围逐渐增大时，$\\frac{小于n维的空间}{n维空间}$ 越来越接近于 $0$，则可以随机少一些。","categories":[{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[{"name":"算法_线性代数","slug":"算法-线性代数","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"},{"name":"算法_随机大法","slug":"算法-随机大法","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E9%9A%8F%E6%9C%BA%E5%A4%A7%E6%B3%95/"}]},{"title":"JSOI2017 Round 1 游记","slug":"JSOI2017_Round1","date":"2017-04-10T01:19:00.000Z","updated":"2024-04-24T03:59:22.779Z","comments":true,"path":"JSOI2017_Round1/","link":"","permalink":"http://kqp.world/JSOI2017_Round1/","excerpt":"前言&emsp;&emsp;江苏，感觉规模比广东小，但是也是很有质量的地方。 &emsp;&emsp;大概是最后一次跑到别人的省选去了。。。&emsp;&emsp;然后跟省队好像差了 30 分？？ &emsp;&emsp;那么几趟练兵下来，都挂彩了。ZJOI 爆 0，JSOI 进不了队，接下来 GDOI。。。退役？？？","text":"前言&emsp;&emsp;江苏，感觉规模比广东小，但是也是很有质量的地方。 &emsp;&emsp;大概是最后一次跑到别人的省选去了。。。&emsp;&emsp;然后跟省队好像差了 30 分？？ &emsp;&emsp;那么几趟练兵下来，都挂彩了。ZJOI 爆 0，JSOI 进不了队，接下来 GDOI。。。退役？？？ 赛程回顾day0&emsp;&emsp;看了看这几年的 JSOI 题，感觉可做。（大概是很多个不难的题+1个几何题）这个画风还是蛮好的嘛。。。&emsp;&emsp;线性规划，好像没有讲太多 oi 相关的内容？？？ day1&emsp;&emsp;这个画风怎么跟预计的不一样啊？？？&emsp;&emsp;t1，树 O(n) 做，环内搞了好久不会做。。。t2，发现有循环节但是很大没卵用，按位拆开也不会。。。t3，最后 2h 才开始想着打个暴力什么的，打着打着发现 dp 能做，说不定 100*200*100*10 能跑过去诶，然后就拼命打，直至最后也过不了大样例 QAQ。。。最后前两题交暴力，第三题交个没过样例的 dp。 &emsp;&emsp;最后 60+10+0，t1 莫名其妙多了 20？？这 t3 数据也是gay里gay气的，JZ 全体 0 分，我上飞机再打一遍仍然过不了大样例。。。&emsp;&emsp;（UPD：我程序跑大样例漏了 [+[]] 和 [-[]] 两种情况。。。）&emsp;&emsp;（UPD：居然还可以 +[-[]]。。。） day2&emsp;&emsp;这个画风怎么还是不一样啊？？？&emsp;&emsp;t1，画了一会儿好像没有通解，那就直接暴力加优化了（但是心想 JSOI 不可能沦落到出暴力题的地步哇一定是我太弱了），t2 不会优化建图，从曼哈顿来推也没推出啥。。。t3 长得很像某 atcoder，但不太一样啊。。。于是今天三题暴力。 &emsp;&emsp;最后 50+20+30，很稳，却是低分。。。第二题，曼哈顿好像能水到满分？？？？只能说，不知道出题人在想什么。。。 收获&emsp;&emsp;这几场没有出现该拿的分没拿到，策略也很对，没有死磕在某一题上。棒棒哒！ &emsp;&emsp;要说低分那也是智商问题了。d1t1 没想出环的做法，可以说是当时的思路也不清晰，想出要求出传送点到居住点的最短路，然后再往下推好像就是在乱推了。。。d2t3 fanvree用 AC 证明了确实就是 atcoder 的方法，这样的话那我对讲过的题消化不良啊。。。&emsp;&emsp;智商问题了。&emsp;&emsp;看了看江苏省队的成绩，只有几个人是水了 d2t2 的，也就是说大家都还是很硬的啊。 &emsp;&emsp;数据有点水，我第一天多拿了20（然后被评委追着问到底加了什么优化 QAQ），第二天就少拿了很多分。&emsp;&emsp;确实我都没怎么把水分啊优化什么的当回事，在优化 d2t1 的暴力的时候我竟然还在打瞌睡。。。水分优化能力我是下等。 后记&emsp;&emsp;接下来只有大概 3 套还是 4 套 GDOI 模拟了。。。&emsp;&emsp;fanvree反正是怒了，提各种措施要保高二的省队。。。好像很不错的样子，挺好。&emsp;&emsp;详细会在计划中列出。","categories":[{"name":"总结与游记","slug":"总结与游记","permalink":"http://kqp.world/categories/%E6%80%BB%E7%BB%93%E4%B8%8E%E6%B8%B8%E8%AE%B0/"},{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[]},{"title":"【计蒜之道2016复赛】【计蒜客A1107】青云的网络设计方案 题解","slug":"【计蒜之道2016复赛】【计蒜客A1107】青云的网络设计方案 题解","date":"2017-04-07T02:18:01.000Z","updated":"2024-04-24T03:59:22.880Z","comments":true,"path":"【计蒜之道2016复赛】【计蒜客A1107】青云的网络设计方案 题解/","link":"","permalink":"http://kqp.world/%E3%80%90%E8%AE%A1%E8%92%9C%E4%B9%8B%E9%81%932016%E5%A4%8D%E8%B5%9B%E3%80%91%E3%80%90%E8%AE%A1%E8%92%9C%E5%AE%A2A1107%E3%80%91%E9%9D%92%E4%BA%91%E7%9A%84%E7%BD%91%E7%BB%9C%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%A1%88%20%E9%A2%98%E8%A7%A3/","excerpt":"题目大意&emsp;&emsp;有一棵树，有 $n$ 个点。现在将所有距离为 $2$ 的点对也连一条边。&emsp;&emsp;给出最终的图，请构造一棵原来的树。 &emsp;&emsp;多组数据，$T \\leq 10,\\ \\ n \\leq10^4,\\ \\ m \\leq 10^5$","text":"题目大意&emsp;&emsp;有一棵树，有 $n$ 个点。现在将所有距离为 $2$ 的点对也连一条边。&emsp;&emsp;给出最终的图，请构造一棵原来的树。 &emsp;&emsp;多组数据，$T \\leq 10,\\ \\ n \\leq10^4,\\ \\ m \\leq 10^5$ \\\\ \\\\ \\\\题解&emsp;&emsp;（很强势的题，可能由于那场复赛大家都在肝别的题吧，这题想想还是挺可做的。） &emsp;&emsp;首先随便扒一个点做根。我们把根叫做第 1 层。 &emsp;&emsp;从第 1 层扩出去的点，就是第 2 层和第 3 层了。我们把这些点叫做第 2/3 层。 &emsp;&emsp;那么从第 2/3 层扩出去的新点，就是第 4/5 层了。并且，如果这个新点只被访问了一次，说明是第 3 层访问了第 5 层，因此这个点是第 5 层；若被访问了 2 次，说明是第 2 层和第 3 层访问了第 4 层，因此这个点是第 4 层。&emsp;&emsp;也就是说，从 2/3 层往外扩，可以知道第 4 层和第 5 层。 &emsp;&emsp;然后从第 4 层往外扩，新点就是第 6 层；再从第 5 层往外扩，新点就是第 7 层…… &emsp;&emsp;最后的问题就是处理第 2 层和第 3 层。&emsp;&emsp;首先观察第 2/3 层的连边形成的图形。第 2 层的点之间互相连边，因此是一个团，而各自的第 3 层儿子们也是互相连边，因此形成的结构是：先有一个团，然后团上的某些点再向外连一个小团。&emsp;&emsp;因此可以得出结论：只考虑第 2/3 层的连边，如果有多种度数，那么度数最大的点一定是第 2 层的（称为情况 1）。但如果所有点度数一样，那么说明是第 2 层只有一个点（称为情况 2）。两种情况分别解决。 &emsp;&emsp;情况 1：我们找到了一个一定在第 2 层的点 $x$，那么它连不到的就是别人家的第 3 层，这些第 3 层连到的就是第 2 层。&emsp;&emsp;如果我们这样能确定另一个一定在第 2 层的点 $y$，那么剩下的点中，$y$ 能连到的就是第 2 层，连不到的就是 $x$ 的儿子也就是第 3 层，就做完了。&emsp;&emsp;如果无法确定 $y$，说明 $x$ 的兄弟都没有儿子。那么看是否存在第 4 层，第 4 层能连到的就是 $x$ 的儿子也就是第 3 层，连不到的就是第 2 层。如果不存在第 4 层，那么 $x$ 的兄弟团和儿子团其实是没有本质区别的，选择其中一个团作为儿子团，另一个团作为兄弟团就行了。 &emsp;&emsp;情况2：先看有没有第 5 层，第 5 层连到的都是第 3 层。完了之后，注意到第 2 层的那个点会连向所有第 4 层，而第 3 层的点只会连向部分第 4 层，因此看谁被第 4 层访问得最多，谁就是第 2 层。若有相同，任选皆可。 &emsp;&emsp;现在每个点的层数确定了。最后扫一遍即可。 &emsp;&emsp;UPD：2018icpc Regional Seoul 出了这个原题，但是不保证一定有解，因此还要判各种恶心的 -1 的情况。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126#include&lt;bits/stdc++.h&gt;#define fo(i,a,b) for(int i=a;i&lt;=b;i++)using namespace std;typedef long long LL;const int maxn=1e6+5;int n,m,cnt[maxn],dg[maxn],oo;vector&lt;int&gt; e[maxn];vector&lt;int&gt; lev[2*maxn];int deep[maxn];void ins(int l,int i)&#123; lev[l].push_back(i); deep[i]=l;&#125;void find1()&#123; for(int go:e[1]) ins(oo,go);&#125;void find23()&#123; for(int i:lev[oo]) for(int go:e[i]) if (!deep[go]) cnt[go]++; for(int i:lev[oo]) for(int go:e[i]) &#123; if (cnt[go]==2) ins(4,go); if (cnt[go]==1) ins(5,go); &#125;&#125;void find(int l)&#123; for(int i:lev[l]) for(int go:e[i]) if (!deep[go]) ins(l+2,go);&#125;int fa[maxn];void dfs_ans(int k,int last)&#123; fa[k]=last; for(int go:e[k]) if (deep[go]==deep[k]+1) dfs_ans(go,k);&#125;void init()&#123; fo(i,1,n) e[i].clear(), lev[i].clear(), deep[i]=fa[i]=dg[i]=cnt[i]=0; lev[oo].clear();&#125;int T;int main()&#123; scanf(&quot;%d&quot;,&amp;T); while (T--) &#123; scanf(&quot;%d %d&quot;,&amp;n,&amp;m); oo=100003; init(); fo(i,1,m) &#123; int x,y; scanf(&quot;%d %d&quot;,&amp;x,&amp;y); e[x].push_back(y), e[y].push_back(x); &#125; ins(1,1); find1(); find23(); for(int i=4; lev[i].size()&gt;0; i++) find(i); int fi=0, se=0; for(int i:lev[oo]) &#123; fi=i; for(int go:e[i]) if (deep[go]==oo) dg[go]++; &#125; fo(i,1,n) if (dg[i]&gt;dg[fi]) se=fi, fi=i; else if (dg[fi]&gt;dg[i] &amp;&amp; dg[i]&gt;dg[se]) se=i; if (!se &amp;&amp; fi) &#123; for(int i:lev[5]) for(int go:e[i]) if (deep[go]==oo) ins(3,go); memset(cnt,0,sizeof(cnt)); for(int i:lev[4]) for(int go:e[i]) if (deep[go]==oo) cnt[go]++; for(int i:lev[oo]) if (deep[i]==oo &amp;&amp; cnt[i]&gt;cnt[fi]) fi=i; ins(2,fi); for(int i:lev[oo]) if (deep[i]==oo) ins(3,i); &#125; else if (fi) &#123; memset(cnt,0,sizeof(cnt)); cnt[fi]=1; ins(2,fi); for(int go:e[fi]) if (deep[go]==oo || deep[go]==3) cnt[go]++; for(int i:lev[oo]) if (!cnt[i]) ins(3,i); for(int i:lev[oo]) if (!cnt[i]) for(int go:e[i]) if (deep[go]==oo) ins(2,go); bool pd=0; for(int i:lev[2]) if (i!=fi) &#123; pd=1; for(int go:e[i]) if (deep[go]==oo) ins(2,go); for(int i:lev[oo]) if (deep[i]==oo) ins(3,i); break; &#125; if (!pd) &#123; for(int go:e[fi]) if (deep[go]==4) for(int gogo:e[go]) if (deep[gogo]==oo) ins(3,gogo); for(int i:lev[3]) for(int go:e[i]) if (deep[go]==oo) ins(3,go); for(int i:lev[oo]) if (deep[i]==oo) &#123; fi=i; break; &#125; ins(2,fi); for(int go:e[fi]) if (deep[go]==oo) ins(2,go); for(int i:lev[oo]) if (deep[i]==oo) ins(3,i); &#125; &#125; dfs_ans(1,0); fo(i,2,n) printf(&quot;%d %d\\n&quot;,fa[i],i); &#125;&#125;","categories":[{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[{"name":"算法_构造题","slug":"算法-构造题","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E6%9E%84%E9%80%A0%E9%A2%98/"}]},{"title":"【计蒜客14899】积性函数（加强版） 题解","slug":"【计蒜客14899】积性函数（加强版） 题解","date":"2017-04-01T07:54:21.000Z","updated":"2024-04-24T03:59:22.881Z","comments":true,"path":"【计蒜客14899】积性函数（加强版） 题解/","link":"","permalink":"http://kqp.world/%E3%80%90%E8%AE%A1%E8%92%9C%E5%AE%A214899%E3%80%91%E7%A7%AF%E6%80%A7%E5%87%BD%E6%95%B0%EF%BC%88%E5%8A%A0%E5%BC%BA%E7%89%88%EF%BC%89%20%E9%A2%98%E8%A7%A3/","excerpt":"题目出自北方大学acm多校训练赛第四场 V1（原题）题目大意&emsp;&emsp;定义函数 $f(n,0)=1$， $f(n,m)=\\sum_{d|n}f(d,m-1) \\cdot f(\\frac{n}{d},m-1)$&emsp;&emsp;给定 $n,m$，求 $f(n,m) \\bmod 10007$&emsp;&emsp;多组数据，$T \\le 10,\\ n \\le 10^9,\\ m \\le 50$ &emsp;&emsp;（这题我想了十几分钟没想出来，然后jasonvictoryan走过来，想了10秒钟，想出了V2解法。。。）","text":"题目出自北方大学acm多校训练赛第四场 V1（原题）题目大意&emsp;&emsp;定义函数 $f(n,0)=1$， $f(n,m)=\\sum_{d|n}f(d,m-1) \\cdot f(\\frac{n}{d},m-1)$&emsp;&emsp;给定 $n,m$，求 $f(n,m) \\bmod 10007$&emsp;&emsp;多组数据，$T \\le 10,\\ n \\le 10^9,\\ m \\le 50$ &emsp;&emsp;（这题我想了十几分钟没想出来，然后jasonvictoryan走过来，想了10秒钟，想出了V2解法。。。） 题解&emsp;&emsp;据说 $n$ 的约数很少，直接暴力就。。。过了？？？ V2题目大意&emsp;&emsp;数据范围改成 $T \\le 10^3,\\ n \\le 10^{18},\\ m \\le 10^5$&emsp;&emsp;（这个模数感觉好容易误判。。。改成 $10^9+7$ 吧。。。） 题解&emsp;&emsp;长成 $f(i)=\\sum_{d|n} f(d)*f(\\frac{i}{d})$ 这个样子的，多半是积性函数。&emsp;&emsp;进而发现，同一层的 $f$ 是积性函数。（同一层是指 $m$ 相同） &emsp;&emsp;所以只用求出 $f(p_i^{c_i},m)$ 就行了，其中 $n=\\Pi p_i^{c_i}$ &emsp;&emsp;进而发现，这个东西跟 $p_i$ 没有关系，只跟 $c_i$ 有关。&emsp;&emsp;这里可能存在什么公式可以直接求出来，不过由于 $c_i&lt;64$，所以预处理也行。 &emsp;&emsp;然后大整数分解质因数用 pollard_rho。 代码123456789101112131415161718192021222324252627282930313233343536373839// 方法是 V2 的，数据范围是 V1 的，没打 pollard_rho#include&lt;cmath&gt;#include&lt;cstdio&gt;#define fo(i,a,b) for(int i=a;i&lt;=b;i++)using namespace std;const int mo=10007;int n,m,p0,p[100][2];int T,f[100][100];int main()&#123; fo(i,0,30) f[i][0]=1; fo(j,1,50) fo(i,0,30) fo(k,0,i) f[i][j]=(f[i][j]+f[k][j-1]*f[i-k][j-1])%mo; scanf(&quot;%d&quot;,&amp;T); while (T--) &#123; scanf(&quot;%d %d&quot;,&amp;n,&amp;m); int sqrtn=sqrt(n); p0=0; fo(i,2,sqrtn) if (n%i==0) &#123; p[++p0][0]=i; p[p0][1]=0; for(; n%i==0; n/=i) p[p0][1]++; &#125; if (n&gt;1) p[++p0][0]=n, p[p0][1]=1; int ans=1; fo(i,1,p0) ans=ans*f[p[i][1]][m]%mo; printf(&quot;%d\\n&quot;,ans); &#125;&#125;","categories":[{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[{"name":"算法_数论","slug":"算法-数论","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E6%95%B0%E8%AE%BA/"}]},{"title":"一些“出现次数”相关的序列模型","slug":"一些“出现次数”相关的序列模型","date":"2017-03-31T13:32:35.000Z","updated":"2024-04-24T03:59:22.882Z","comments":true,"path":"一些“出现次数”相关的序列模型/","link":"","permalink":"http://kqp.world/%E4%B8%80%E4%BA%9B%E2%80%9C%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E2%80%9D%E7%9B%B8%E5%85%B3%E7%9A%84%E5%BA%8F%E5%88%97%E6%A8%A1%E5%9E%8B/","excerpt":"V1（【COCI 2016/2017 #5】Poklon）题目大意&emsp;&emsp;给出一个长度为 $n$ 的序列 $a_1…a_n$。&emsp;&emsp;有 $Q$ 次询问，每次询问序列中的一个区间，有多少个数恰好出现两次。&emsp;&emsp;$n,Q \\leq 5 \\times 10^5$","text":"V1（【COCI 2016/2017 #5】Poklon）题目大意&emsp;&emsp;给出一个长度为 $n$ 的序列 $a_1…a_n$。&emsp;&emsp;有 $Q$ 次询问，每次询问序列中的一个区间，有多少个数恰好出现两次。&emsp;&emsp;$n,Q \\leq 5 \\times 10^5$ 题解&emsp;&emsp;套路题。 &emsp;&emsp;记 $last_i$ 表示上一个与 $a_i$ 相同的是谁。&emsp;&emsp;把询问按右端点排序，然后从左往右扫这个序列，并用线段树维护右端点为当前位置的区间的答案。当扫到第 $i$ 位的时候，就给区间 $[ last_{last_i}+1 , last_i ]$ 加 $1$，给区间 $[ last_{last_{last_i}}+1 , last_{last_i} ]$ 减 $1$。然后处理右端点为 $i$ 的询问。&emsp;&emsp;时间复杂度 $O(n \\log n)$ V1.1题目大意&emsp;&emsp;给出一个长度为 $n$ 的序列 $a_1…a_n$。&emsp;&emsp;有 $Q$ 次询问，每次询问序列中的一个区间，出现了多少种数。&emsp;&emsp;$n,Q \\leq 10^5$ 题解&emsp;&emsp;跟 V1 差不多的套路，每次新加入 $i$，就在 $[ last_i+1, i ]$ 这个区间 $+1$。&emsp;&emsp;维护一个指针（单调向前）还可以统计有多少个区间出现了全部的数。&emsp;&emsp;时间复杂度 $O(n \\log n)$ V1.2题目大意&emsp;&emsp;给出一个长度为 $n$ 的序列 $a_1…a_n$。&emsp;&emsp;有 $m$ 次操作：&emsp;&emsp; 1：单点修改&emsp;&emsp; 2：询问序列的某个区间内有多少个数恰好出现 1 次&emsp;&emsp;（可强制在线） &emsp;&emsp;$n,m \\leq 10^5$ 题解&emsp;&emsp;蒟蒻我想不到什么好方法啊。。。&emsp;&emsp;离线的话可以用带修改莫队来艹，时间复杂度 $O(n^{\\frac{5}{3}})$&emsp;&emsp;在线可以树套树，第一棵树表示左端点，第二棵树表示右端点。单点修改相当于插入删除，类似 V1 那样讨论一下。时间复杂度 $O(n \\log^2 n)$。（不知会不会炸空间。。。） V2题目大意&emsp;&emsp;给出一个长度为 $n$ 的序列 $a_1…a_n$。&emsp;&emsp;有 $m$ 次操作：&emsp;&emsp; 1：单点修改&emsp;&emsp; 2：询问序列有多少个子区间，满足区间内每个数最多出现 1 次 &emsp;&emsp;$n,m \\leq 10^5$ 题解1&emsp;&emsp;设 $f_i$ 表示以 $i$ 为左端点，最右能到多少。那么 $\\sum f_i$ 就是答案。&emsp;&emsp;记 $last_i$ 表示上一个与 $a_i$ 相同的是谁，我们把 $last_i$ 向 $i$ 连一条线段，那么每条线段就有个存在时间。每条线段对 $f$ 的影响是区间取 min 操作（$[ l, r-1 ] ~\\min= r$）。&emsp;&emsp;我们按操作时间来分治，每个分治区间只考虑存在时间完全包含当前区间的线段。现在问题变成：有一堆区间取 min 操作，中间还有一些询问 $\\sum f[i]$，并且操作要可撤销。&emsp;&emsp;所以用主席树来维护，由于 $f$ 是递增的，所以区间取 min 可以看作是某一段的区间赋值，然后这样就可撤销啦！（加上空间回收就不怕 MLE 啦！） &emsp;&emsp;时间复杂度 $O(n \\log^2 n)$ 题解2&emsp;&emsp;来个在线做法。 &emsp;&emsp;还是用线段树维护 $f_i$ 表示以 $i$ 为左端点，最右能到多少。并且维护一下每个区间的答案。&emsp;&emsp;修改相当于删除一个 $last_i$ 和加入一个 $last_i$，这些讨论一下都是区间取 min 和区间赋值操作。&emsp;&emsp;然后询问，相当于要合并 $\\log$ 个区间。我们从右往左合并，每次我们知道右区间的最小的 $f$ 是多少，比如是 $f_x$，然后在左区间二分出 $f$ 值大于 $f_x$ 的区间，这时候就可以知道对答案的影响了。 &emsp;&emsp;时间复杂度 $O(n \\log^2 n)$ V2.1题目大意&emsp;&emsp;给出一个长度为 $n$ 的序列 $a_1…a_n$，和一个常数 $k$。&emsp;&emsp;有 $m$ 次操作：&emsp;&emsp; 1：单点修改&emsp;&emsp; 2：询问序列的某个区间内有多少个子区间，满足区间内每个数最多出现 $k$ 次 &emsp;&emsp;$n,m \\leq 1e5,~k \\leq 5$ 题解&emsp;&emsp;可以用 V2 的解法1，然后主席树询问的时候改成区间询问。&emsp;&emsp;$k$ 次就相当于线段是 $last_{ last_{ …(k次) } }$ 连向 $i$ 的线段。 V2.2（【bzoj 2017省选十连测】 巧克力）题目大意&emsp;&emsp;给出一个长度为 $n$ 的序列 $a_1…a_n$。&emsp;&emsp;有 $m$ 次操作：&emsp;&emsp; 1：单点修改&emsp;&emsp; 2：询问第 $x$ 次修改操作后的序列有多少个子区间，满足区间内每个数最多出现 1 次 &emsp;&emsp;$n,m \\leq 1e5$，强制在线 题解&emsp;&emsp;V2 的解法2，把修改操作可持久化一下 V3（【CodeM 初赛A】5）题目大意&emsp;&emsp;给出一个长度为 $n$ 的序列 $a_1…a_n$，有 $m$ 个询问，每次询问给出 $l, r, k$，问 $a_l~a_r$ 中，有多少数的出现次数与 $k$ 互质。&emsp;&emsp;$n,m \\leq 5e4,~1\\leq a_i,k \\leq n$&emsp;&emsp;时限 6s 题解&emsp;&emsp;区间问题可以考虑莫队，可以维护一个桶 $t_i$ 表示有多少数的出现次数是 $i$。 &emsp;&emsp;但是统计答案不方便，要把整个桶扫一次。 &emsp;&emsp;于是设个阈值 $S=\\sqrt n$。如果某个数在全局的出现次数 $&gt;S$，就提取出来单独对每个询问做贡献，剩下的数就做莫队。 V4（学长出题）题目大意&emsp;&emsp;上面的题的出现次数都是固定的，如果不固定呢？ &emsp;&emsp;给出一个长度为 $n$ 的序列 $a_1…a_n$。&emsp;&emsp;有 $Q$ 次询问，每次询问给出 $l,r,k$，问区间 $[l,r]$ 有多少个数的出现次数小于等于 $k$。&emsp;&emsp;$n,Q \\leq 10^5$ 题解&emsp;&emsp;一种比较直接的想法是，莫队，用一个树状数组维护每个数的出现次数。时间 $O(n\\sqrt n~log~n)$。&emsp;&emsp;但这样有点慢。 &emsp;&emsp;实际上，出现次数我们需要的是一个前缀和。我们直接维护前缀和。&emsp;&emsp;莫队时的本质是增加一个数或去掉一个数，因此造成的影响只会是某个数的出现次数加 $1$ 或减 $1$，对应在前缀和上最多只影响 1 位。比如 $5$ 在当前区间出现了 $3$ 次，现在又加了一个 $5$ 进来，它的出现次数由 $3$ 变成 $4$，那么前缀和数组就只是 $3$ 这个位置减 $1$。&emsp;&emsp;因此就不用树状数组了，直接记录前缀和数组每个位置的变化量和一个全局量（某个数从 $0$ 次变为 $1$ 次，是同时给数组所有元素 $+1$）就行了。这样就是 $O(n\\sqrt n)$ 了。 V5（【Ynoi2016】掉进兔子洞）题目大意&emsp;&emsp;一个长为 $n$ 的序列 $a$。&emsp;&emsp;有 $m$ 个询问，每次询问三个区间，把三个区间中同时出现的数一个一个删掉，问最后三个区间剩下的数的个数和，询问独立。&emsp;&emsp;注意这里删掉指的是一个一个删，不是把等于这个值的数直接删完，&emsp;&emsp;比如三个区间是 $[1,2,2,3,3,3,3]$，$[1,2,2,3,3,3,3]$ 与 $[1,1,2,3,3]$，就一起扔掉了 1 个 $1$，1 个 $2$，2 个 $3$。 &emsp;&emsp;$n,m \\leq 10^5,~1 \\leq a_i \\leq 10^9$&emsp;&emsp;3s，512M 题解&emsp;&emsp;说到出现次数，还是不能缺少 bitset。有时候莫队+bitset 是处理“数字是否出现”或“出现次数”的好办法。至于 bitset 如何处理相同的数字，那就是这题为例了。&emsp;&emsp;这里是题解 未完待续","categories":[{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[{"name":"算法_线段树","slug":"算法-线段树","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"name":"算法_莫队/分块","slug":"算法-莫队-分块","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E8%8E%AB%E9%98%9F-%E5%88%86%E5%9D%97/"}]},{"title":"关于 Pollard_Rho 的期望复杂度的证明","slug":"proof_of_complexity_of_Pollard_Rho","date":"2017-03-29T23:33:30.000Z","updated":"2024-04-24T03:59:22.789Z","comments":true,"path":"proof_of_complexity_of_Pollard_Rho/","link":"","permalink":"http://kqp.world/proof_of_complexity_of_Pollard_Rho/","excerpt":"转载自 ZYQN’s Database，但是原文找不到了。 设我们要分解 $n$，$n=n_1n_2(n_1&lt;=n_2)$，我们构造的序列为 $a_i$，$a_i~mod~n_1=b_i$ 因为 $a_i$ 可近似看为随机序列，根据生日悖论可以推出其出现循环的期望步数为 $\\sqrt n$，$b_i$ 同理。 因为 $n&gt;n_1$，所以在 $b_i$ 循环之后，$a_i$ 有很大可能没有进入循环，此时 $a_i-a_j=(k_in_1+b_i)-(k_jn_1+b_j)=(k_i-k_j)n_1+(b_i-b_j)=(k_i-k_j)n_1$。于是求 gcd 即可求出 $n_1$。 因为 $b_i$ 的循环期望是 $\\sqrt n_1$，而 $n_1&lt;=\\sqrt n$，所以最后是 $O(n^{\\frac{1}{4}})$","text":"转载自 ZYQN’s Database，但是原文找不到了。 设我们要分解 $n$，$n=n_1n_2(n_1&lt;=n_2)$，我们构造的序列为 $a_i$，$a_i~mod~n_1=b_i$ 因为 $a_i$ 可近似看为随机序列，根据生日悖论可以推出其出现循环的期望步数为 $\\sqrt n$，$b_i$ 同理。 因为 $n&gt;n_1$，所以在 $b_i$ 循环之后，$a_i$ 有很大可能没有进入循环，此时 $a_i-a_j=(k_in_1+b_i)-(k_jn_1+b_j)=(k_i-k_j)n_1+(b_i-b_j)=(k_i-k_j)n_1$。于是求 gcd 即可求出 $n_1$。 因为 $b_i$ 的循环期望是 $\\sqrt n_1$，而 $n_1&lt;=\\sqrt n$，所以最后是 $O(n^{\\frac{1}{4}})$","categories":[{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[{"name":"算法_数论","slug":"算法-数论","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E6%95%B0%E8%AE%BA/"}]},{"title":"【bzoj4426】最大生产率 题解","slug":"【bzoj4426】最大生产率 题解","date":"2017-03-29T13:14:14.000Z","updated":"2024-04-24T03:59:22.832Z","comments":true,"path":"【bzoj4426】最大生产率 题解/","link":"","permalink":"http://kqp.world/%E3%80%90bzoj4426%E3%80%91%E6%9C%80%E5%A4%A7%E7%94%9F%E4%BA%A7%E7%8E%87%20%E9%A2%98%E8%A7%A3/","excerpt":"题目大意&emsp;&emsp;有 n 个工人，每个工人的工作时间为 l[i]…r[i]。&emsp;&emsp;你要把工人分成 p 个组，每个组的贡献是该组工人的 min(r)-max(l)，即工作时间的交集。&emsp;&emsp;你的分组要保证每组的贡献是正数，且每个人都要有分组。&emsp;&emsp;求最大总贡献。&emsp;&emsp;p&lt;=n&lt;=1000（原题是 200）， l, r&lt;=1e6， 保证有解。","text":"题目大意&emsp;&emsp;有 n 个工人，每个工人的工作时间为 l[i]…r[i]。&emsp;&emsp;你要把工人分成 p 个组，每个组的贡献是该组工人的 min(r)-max(l)，即工作时间的交集。&emsp;&emsp;你的分组要保证每组的贡献是正数，且每个人都要有分组。&emsp;&emsp;求最大总贡献。&emsp;&emsp;p&lt;=n&lt;=1000（原题是 200）， l, r&lt;=1e6， 保证有解。 题解&emsp;&emsp;看到这个首先想到把工人按时间排个序，然后发现连续一段分一组好像是坠吼的？？&emsp;&emsp;如果出现一个工人包含了另一个工人的情况，这样就错了。 &emsp;&emsp;所以要把工人分成两类，一类是不包含任何其它工人的，一类是会包含其他工人的。&emsp;&emsp;那么第一类工人按时间排序之后，连续一段分一组就最优了。讲道理这就是个简单dp了，用四边形不等式可以优化到 n^2，这个跟 poj1160 差不多。&emsp;&emsp;讲道理第二类工人本来也应该这样dp一下的，但是。。。首先这类人不满足连续一段分一组最优的性质，其次他们贪心就行了。。。一个人独占一组肯定是最优的，因此这一类人按工作时长排序，从大到小选就好了，选不到的就相当于把他扔到第一类去找他包含的那组。&emsp;&emsp;（这也可以理解为什么第一类人不能贪心，因为他们选不到的不能被扔到别的地方去） &emsp;&emsp;最后就是枚举两类人各分成多少组就行了。","categories":[{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[{"name":"算法_DP","slug":"算法-DP","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-DP/"}]},{"title":"【SCOI2016】萌萌哒 题解","slug":"【SCOI2016】萌萌哒 题解","date":"2017-03-29T03:36:25.000Z","updated":"2024-04-24T03:59:22.865Z","comments":true,"path":"【SCOI2016】萌萌哒 题解/","link":"","permalink":"http://kqp.world/%E3%80%90SCOI2016%E3%80%91%E8%90%8C%E8%90%8C%E5%93%92%20%E9%A2%98%E8%A7%A3/","excerpt":"题目大意&emsp;&emsp;你要构造 $n$ 个数，满足 $m$ 个限制，每个限制条件给出两个长度相等的区间，表示这两个区间的数要一样。比如限制是 [1, 3] 和 [3, 5]，那 {1, 2, 1, 2, 1} 就是满足条件的。&emsp;&emsp;求方案数。&emsp;&emsp;$n \\le 10^5$","text":"题目大意&emsp;&emsp;你要构造 $n$ 个数，满足 $m$ 个限制，每个限制条件给出两个长度相等的区间，表示这两个区间的数要一样。比如限制是 [1, 3] 和 [3, 5]，那 {1, 2, 1, 2, 1} 就是满足条件的。&emsp;&emsp;求方案数。&emsp;&emsp;$n \\le 10^5$ 题解&emsp;&emsp;这看上去，就很并查集。。。 &emsp;&emsp;暴力的并查集就是对于每个限制，枚举区间的每个数，合并。 &emsp;&emsp;改进一下就是用 ST 表，ST 表共 $O(\\log n)$ 层，每层 $O(n)$ 个元素，给这总共 $O(n \\log n)$ 个元素维护并查集。对于区间 $[l_1,r_1]$ 要跟 $[l_2,r_2]$ 合并，找到最大的 $2^t \\le r_1-l_1+1$，然后在并查集上合并 $[l_1,l_1+2^t-1]$ 与 $[l_2,l_2+2^t-1]$、$[r_1-2^t+1,r_1]$ 与 $[r_2-2^t+1,r_2]$。最后从大到小遍历一遍 ST 表，对于区间 $[l,r]$，让 $[l,mid]$ 和 $[mid+1,r]$ 分别连向 $[l,r]$ 的并查集根对应的两个子区间。 相关题目&emsp;&emsp;GDOI2016 回文树：改进一下然后放到树上。（假老师出考场怒 D 这题） 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#define fo(i,a,b) for(int i=a;i&lt;=b;i++)#define fd(i,a,b) for(int i=a;i&gt;=b;i--)using namespace std;typedef long long LL;const int maxn=1e5+5, MX=17;const LL mo=1e9+7;int n,m;int ga[maxn*MX+5];int get(int x) &#123;return (ga[x]==x) ?x :ga[x]=get(ga[x]) ;&#125;int Log[maxn],bh[maxn][MX+5],sum;void rmq_pre()&#123; fo(i,1,n) Log[i]=log(i)/log(2); fo(j,0,MX) &#123; int len=1&lt;&lt;j; fo(i,1,n-len+1) bh[i][j]=++sum; &#125; fo(i,1,sum) ga[i]=i;&#125;LL mi(LL x,LL y)&#123; LL re=1; for(; y; y&gt;&gt;=1, x=x*x%mo) if (y&amp;1) re=re*x%mo; return re;&#125;int fir[maxn*MX+5];int main()&#123; scanf(&quot;%d %d&quot;,&amp;n,&amp;m); rmq_pre(); while (m--) &#123; int l1,r1,l2,r2; scanf(&quot;%d %d %d %d&quot;,&amp;l1,&amp;r1,&amp;l2,&amp;r2); if (l1&gt;l2) swap(l1,l2), swap(r1,r2); int t=Log[r1-l1+1]; ga[get(bh[l2][t])]=get(bh[l1][t]); ga[get(bh[r2-(1&lt;&lt;t)+1][t])]=get(bh[r1-(1&lt;&lt;t)+1][t]); &#125; fd(j,MX,1) &#123; int len=1&lt;&lt;j; fo(i,1,n-len+1) if (!fir[get(bh[i][j])]) fir[get(bh[i][j])]=i; else &#123; int x=fir[get(bh[i][j])]; ga[get(bh[x][j-1])]=get(bh[i][j-1]); ga[get(bh[x+len/2][j-1])]=get(bh[i+len/2][j-1]); &#125; &#125; LL ans=1; fo(i,1,n) if (get(bh[i][0])==bh[i][0]) ans=ans*10%mo; ans=ans*mi(10,mo-2)%mo *9%mo; printf(&quot;%lld\\n&quot;,ans);&#125;","categories":[{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[{"name":"算法_并查集","slug":"算法-并查集","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E5%B9%B6%E6%9F%A5%E9%9B%86/"}]},{"title":"【JZOJ5034】B 题解","slug":"【JZOJ5034】B 题解","date":"2017-03-28T14:53:45.000Z","updated":"2024-04-24T03:59:22.856Z","comments":true,"path":"【JZOJ5034】B 题解/","link":"","permalink":"http://kqp.world/%E3%80%90JZOJ5034%E3%80%91B%20%E9%A2%98%E8%A7%A3/","excerpt":"题目 &emsp;&emsp;$k \\leq n \\leq 50$，方案数 $\\bmod 998244353$","text":"题目 &emsp;&emsp;$k \\leq n \\leq 50$，方案数 $\\bmod 998244353$ 题解&emsp;&emsp;这个题很妙。。。 &emsp;&emsp;我们知道矩阵树定理，即基尔霍夫矩阵的任意一个 $n-1$ 阶主子式就是生成树个数。&emsp;&emsp;现在加了个限制，即原图的边最多不选 $k$ 个，怎么做呢？ &emsp;&emsp;其实就是要把原图边和非原图边用不同的方法表示。&emsp;&emsp;比如用 $x$ 表示一条原图边，用 $1$ 表示非原图边。这里的 $x$ 是多项式的一次未知数的意思。&emsp;&emsp;比如有个点连了 $3$ 条原图边、$2$ 条非原图边，那么它的度数就是 $3x+2$。相应地，邻接矩阵里也是用 $x$ 和 $1$ 来表示。&emsp;&emsp;那么此时的主子式就是一个多项式，其中 $x^i$ 的系数就表示保留 $i$ 条原图边的方案数。 &emsp;&emsp;现在的问题是如何把这个多项式求出来。可以用插值法的思想，给 $x$ 代入 $n$ 个不同的值，最后再插值求多项式。可以用拉格朗日插值法什么的。我用的是 DFT。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include&lt;cstdio&gt;#include&lt;algorithm&gt;#define fo(i,a,b) for(int i=a;i&lt;=b;i++)using namespace std;typedef long long LL;const int maxn=55, maxlen=150;const LL mo=998244353;int n,K,len;bool mp[maxn][maxn];LL G0[maxn][maxn][2];LL mi(LL x,LL y)&#123; LL re=1; for(; y; y&gt;&gt;=1, x=x*x%mo) if (y&amp;1) re=re*x%mo; return re;&#125;LL G[maxn][maxn],w[maxlen];LL Determinant(int n)&#123; LL d=1; fo(i,0,n) &#123; fo(j,i,n) if (G[j][i]&gt;0) &#123; swap(G[i],G[j]); if (j!=i) d*=-1; break; &#125; fo(j,i+1,n) &#123; LL c=(-G[j][i]*mi(G[i][i],mo-2)%mo+mo)%mo; fo(k,0,n) G[j][k]=(G[j][k]+c*G[i][k])%mo; &#125; &#125; fo(i,0,n) d=d*G[i][i]%mo; return (d%mo+mo)%mo;&#125;LL y[maxlen];int main()&#123; scanf(&quot;%d %d&quot;,&amp;n,&amp;K); K=n-1-K; if (n==1) &#123;printf(&quot;1\\n&quot;); return 0;&#125; for(len=1; len&lt;n; len&lt;&lt;=1); fo(i,1,n-1) &#123; int x; scanf(&quot;%d&quot;,&amp;x); G0[x][x][1]++, G0[i][i][1]++; G0[x][i][1]--, G0[i][x][1]--; mp[x][i]=mp[i][x]=1; &#125; fo(i,0,n-2) fo(j,i+1,n-1) if (!mp[i][j]) &#123; G0[i][i][0]++, G0[j][j][0]++; G0[i][j][0]--, G0[j][i][0]--; &#125; w[0]=1; w[1]=mi(3,(mo-1)/len); fo(i,2,len) w[i]=(w[i-1]*w[1])%mo; fo(wi,0,len-1) &#123; fo(i,0,n-1) fo(j,0,n-1) G[i][j]=((G0[i][j][0]+G0[i][j][1]*w[wi])%mo+mo)%mo; y[wi]=Determinant(n-2); &#125; LL ans=0; fo(i,K,len-1) fo(j,0,len-1) ans=(ans+y[j]*mi(w[len-i],j))%mo; printf(&quot;%lld\\n&quot;,ans*mi(len,mo-2)%mo);&#125;","categories":[{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[{"name":"算法_神奇的脑洞","slug":"算法-神奇的脑洞","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E7%A5%9E%E5%A5%87%E7%9A%84%E8%84%91%E6%B4%9E/"},{"name":"算法_线性代数","slug":"算法-线性代数","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"},{"name":"算法_多项式/生成函数","slug":"算法-多项式-生成函数","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E5%A4%9A%E9%A1%B9%E5%BC%8F-%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/"}]},{"title":"【ZJOI2017】树状数组 题解","slug":"【ZJOI2017】树状数组 题解","date":"2017-03-24T23:56:39.000Z","updated":"2024-04-24T03:59:22.874Z","comments":true,"path":"【ZJOI2017】树状数组 题解/","link":"","permalink":"http://kqp.world/%E3%80%90ZJOI2017%E3%80%91%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%20%E9%A2%98%E8%A7%A3/","excerpt":"题目大意&emsp;&emsp;有一个错误的树状数组，它的修改往前走，询问往后走（find(0) 的时候返回 0）。&emsp;&emsp;现在有一个初始全 0 的序列，有两种操作：&emsp;&emsp;1 x y：在区间 [ x, y ] 中等概率随机一个 i，然后 a[i]=(a[i]+1)%2&emsp;&emsp;2 x y：询问 ( a[x]+…+a[y] )%2&emsp;&emsp;求这个错误树状数组对于每个询问回答正确的概率。&emsp;&emsp;n, m&lt;=1e5","text":"题目大意&emsp;&emsp;有一个错误的树状数组，它的修改往前走，询问往后走（find(0) 的时候返回 0）。&emsp;&emsp;现在有一个初始全 0 的序列，有两种操作：&emsp;&emsp;1 x y：在区间 [ x, y ] 中等概率随机一个 i，然后 a[i]=(a[i]+1)%2&emsp;&emsp;2 x y：询问 ( a[x]+…+a[y] )%2&emsp;&emsp;求这个错误树状数组对于每个询问回答正确的概率。&emsp;&emsp;n, m&lt;=1e5 题解&emsp;&emsp;这个题的询问时的 x=1 的话要特殊考虑。 询问 x&gt;1&emsp;&emsp;这个树状数组在 find(x) 的时候返回的是从 x 开始的后缀和。&emsp;&emsp;（可以打表发现，也可以从 change(y) 对 find(x) 的影响来证明，证明就是根据 y 和 x 的大小关系分别讨论。） &emsp;&emsp;因此询问 x 到 y，就是询问 ( a[x-1]+…+a[y-1] )%2&emsp;&emsp;因此回答错误当且仅当 x-1 的修改次数模 2 意义下不等于 y 的修改次数（即和为奇数）。 &emsp;&emsp;所以把询问看作点 (x-1, y)，我们用树套树来维护这个平面。第一棵树表示第一维坐标，第二棵树表示第二维坐标。&emsp;&emsp;对于修改操作 (x, y)，它会对三种询问点产生影响：若询问点只包含 x 或只包含 y，那么有 1/(y-x+1) 的几率反色；若两个都包含，则 2/(y-x+1) 的几率反色。 &emsp;&emsp;若当前为 0 的概率是 x，然后有 p 的几率反色，则 x 变成 x(1-p)+(1-x)p。此式也适用于标记合并。 询问 x=1&emsp;&emsp;这时候相当于询问前缀和是否等于后缀和。依然用上面的思想维护。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include&lt;cstdio&gt;#define fo(i,a,b) for(int i=a;i&lt;=b;i++)using namespace std;typedef long long LL;const int maxn=1e5+5, maxtr=4e7+5;const LL mo=998244353;int n,m;LL mul(LL x,LL y) //这里为了卡常写得有点丑&#123; LL t=(1-2*y)%mo; t=(t&lt;0) ?t+mo :t ; t=t*x+y; t=(t&gt;=mo) ?t%mo :t ; return t;&#125;int son[maxtr][2],bz[maxtr],root[4*maxn],sum;LL ans;void xg_sec(int &amp;k,int l,int r,int x,int y,LL z)&#123; if (!k) bz[ k=++sum ]=0; if (l==x &amp;&amp; r==y) &#123; bz[k]=mul(bz[k],z); return; &#125; int t1=(l+r)&gt;&gt;1; if (y&lt;=t1) xg_sec(son[k][0],l,t1,x,y,z); else if (x&gt;t1) xg_sec(son[k][1],t1+1,r,x,y,z); else xg_sec(son[k][0],l,t1,x,t1,z), xg_sec(son[k][1],t1+1,r,t1+1,y,z);&#125;void xg_fir(int k,int l,int r,int x1,int y1,int x2,int y2,LL z)&#123; if (l==x1 &amp;&amp; r==y1) &#123; xg_sec(root[k],0,n,x2,y2,z); return; &#125; int t=k&lt;&lt;1, t1=(l+r)&gt;&gt;1; if (y1&lt;=t1) xg_fir(t,l,t1,x1,y1,x2,y2,z); else if (x1&gt;t1) xg_fir(t+1,t1+1,r,x1,y1,x2,y2,z); else xg_fir(t,l,t1,x1,t1,x2,y2,z), xg_fir(t+1,t1+1,r,t1+1,y1,x2,y2,z);&#125;void cx_sec(int k,int l,int r,int x)&#123; while (l&lt;r) &#123; if (!k) return; ans=mul(ans,bz[k]); int t1=(l+r)&gt;&gt;1; if (x&lt;=t1) k=son[k][0], r=t1; else k=son[k][1], l=t1+1; &#125; if (k) ans=mul(ans,bz[k]);&#125;void cx_fir(int k,int l,int r,int x,int y)&#123; while (l&lt;r) &#123; if (root[k]) cx_sec(root[k],0,n,y); int t=k&lt;&lt;1, t1=(l+r)&gt;&gt;1; if (x&lt;=t1) k=t, r=t1; else k=t+1, l=t1+1; &#125; if (root[k]) cx_sec(root[k],0,n,y);&#125;LL mi(LL x,LL y)&#123; LL re=1; for(; y; y&gt;&gt;=1, x=x*x%mo) if (y&amp;1) re=re*x%mo; return re;&#125;int main()&#123; scanf(&quot;%d %d&quot;,&amp;n,&amp;m); while (m--) &#123; int ty,x,y; scanf(&quot;%d %d %d&quot;,&amp;ty,&amp;x,&amp;y); if (ty==1) &#123; LL p=mi(y-x+1,mo-2); if (1&lt;=x-1) xg_fir(1,0,n,1,x-1,x,y,p); if (y+1&lt;=n) xg_fir(1,0,n,x,y,y+1,n,p); xg_fir(1,0,n,x,y,x,y,p*2%mo); xg_fir(1,0,n,0,0,0,x-1,1); if (y+1&lt;=n) xg_fir(1,0,n,0,0,y+1,n,1); xg_fir(1,0,n,0,0,x,y,p*(y-x)%mo); &#125; else &#123; ans=1; cx_fir(1,0,n,x-1,y); printf(&quot;%lld\\n&quot;,ans); &#125; &#125;&#125;","categories":[{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[{"name":"算法_线段树","slug":"算法-线段树","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"name":"算法_概率与期望","slug":"算法-概率与期望","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E6%A6%82%E7%8E%87%E4%B8%8E%E6%9C%9F%E6%9C%9B/"}]},{"title":"【ZJOI2017】仙人掌 题解","slug":"【ZJOI2017】仙人掌 题解","date":"2017-03-24T08:20:31.000Z","updated":"2024-04-24T03:59:22.874Z","comments":true,"path":"【ZJOI2017】仙人掌 题解/","link":"","permalink":"http://kqp.world/%E3%80%90ZJOI2017%E3%80%91%E4%BB%99%E4%BA%BA%E6%8E%8C%20%E9%A2%98%E8%A7%A3/","excerpt":"题目大意&emsp;&emsp;给出一个无重边无自环的无向连通图（n 个点 m 条边），问有多少种再往上加边的方案，使得新图是仙人掌。&emsp;&emsp;多组数据， n&lt;=5e5， $\\sum m$&lt;=1e6","text":"题目大意&emsp;&emsp;给出一个无重边无自环的无向连通图（n 个点 m 条边），问有多少种再往上加边的方案，使得新图是仙人掌。&emsp;&emsp;多组数据， n&lt;=5e5， $\\sum m$&lt;=1e6 首先&emsp;&emsp;先要判断读入的图是否是仙人掌。 一开始的想法&emsp;&emsp;部分分有树，就先想树怎么做。&emsp;&emsp;很直观地设 f[i] 表示 i 为根的子树的方案数，g[i] 表示有一条路要往上走的方案数。&emsp;&emsp;不考虑根的匹配的话，那就是儿子的 f 或 g 乘起来，并且保证 g 有偶数个，再乘上偶数个两两匹配的方案数。&emsp;&emsp;再考虑根的匹配，相当于枚举一个儿子，然后乘上其他儿子的方案数。 &emsp;&emsp;但是这样做不到线性。因为仙人掌不能含有重边（儿子的根不能和父亲相连），因此在转移的时候，我们总是需要得出一个对所有儿子的值，然后再枚举去掉一个儿子之后的值，而前一个做不到 O(1)，因此后一个也不可能 O(n)。&emsp;&emsp;这样暴力做是 O(n^2) 的，据说 FFT 可以 log^2？？ 对于树&emsp;&emsp;然后就需要一个转化。&emsp;&emsp;我们把最后的非环边强行看作两条重边，这样转化之后相当于每个点都必须要有一条延伸出去的边，也就是去掉了不能有重边的限制。（妙啊。。。）&emsp;&emsp;然后这样的 dp 就比之前的好转移了。f 就是儿子的 g 乘起来，再乘个两两匹配的方案数，g 就是 f 再加上选一个儿子出来然后其他儿子任意的方案数。（不懂请看代码） &emsp;&emsp;（这时的模型也可以看成是：选若干路径覆盖所有树边，的方案数） 对于无向图&emsp;&emsp;如果读入的图是个仙人掌，那只要把环边全部断掉就是森林了。因为环边不能参与任何运算，所以去掉是没问题的。&emsp;&emsp;（妙啊。。。×2） 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122#include&lt;cstdio&gt;#include&lt;algorithm&gt;#define fo(i,a,b) for(int i=a;i&lt;=b;i++)#define fd(i,a,b) for(int i=a;i&gt;=b;i--)using namespace std;typedef long long LL;const int maxn=5e5+5, maxm=1e6+5;const LL mo=998244353;int n,m;int ReadInt()&#123; char ch=getchar(); int data=0; while (ch&lt;&#x27;0&#x27; || ch&gt;&#x27;9&#x27;) ch=getchar(); do&#123; data=data*10+ch-&#x27;0&#x27;; ch=getchar(); &#125; while (ch&gt;=&#x27;0&#x27; &amp;&amp; ch&lt;=&#x27;9&#x27;); return data;&#125;int tot,fro[2*maxm],go[2*maxm],next[2*maxm],f1[maxn];bool bt[2*maxm];void ins(int x,int y)&#123; fro[++tot]=x; go[tot]=y; bt[tot]=1; next[tot]=f1[x]; f1[x]=tot;&#125;int dfn[maxn],low[maxn],sum,z[maxn],z0,rt[maxn];bool bz[maxn];bool tarjan(int k,int last)&#123; dfn[k]=low[k]=++sum; bz[k]=1; z[++z0]=k; bool pd=0; for(int p=f1[k]; p; p=next[p]) if (go[p]!=last) &#123; if (!bz[go[p]]) &#123; if (!tarjan(go[p],k)) return 0; low[k]=min(low[k],low[go[p]]); if (low[go[p]]&lt;dfn[k]) &#123; if (pd) return 0; pd=1; &#125; &#125; else &#123; low[k]=min(low[k],dfn[go[p]]); if (dfn[go[p]]&lt;dfn[k]) &#123; if (pd) return 0; pd=1; &#125; &#125; &#125; if (dfn[k]==low[k]) &#123; for(; z[z0]!=k; z0--) rt[z[z0]]=k; rt[k]=k; z0--; &#125; return 1;&#125;LL f[maxn],g[maxn],F[maxn];void dfs(int k,int last)&#123; rt[k]=0; LL sum=1; int num=0; for(int p=f1[k]; p; p=next[p]) if (bt[p] &amp;&amp; go[p]!=last) &#123; dfs(go[p],k); num++; sum=sum*g[go[p]]%mo; &#125; f[k]=F[num]*sum%mo; g[k]=(num==0) ?1 :(f[k]+sum*F[num-1]%mo*num)%mo ;&#125;int T;int main()&#123; F[0]=F[1]=1; fo(i,2,500000) F[i]=(F[i-1]+F[i-2]*(i-1))%mo; scanf(&quot;%d&quot;,&amp;T); while (T--) &#123; n=ReadInt(), m=ReadInt(); tot=0; fo(i,1,n) f1[i]=bz[i]=0; fo(i,1,m) &#123; int x=ReadInt(), y=ReadInt(); ins(x,y), ins(y,x); &#125; sum=0; if (!tarjan(1,0)) &#123;printf(&quot;0\\n&quot;); continue;&#125; fo(p,1,tot) if (rt[fro[p]]==rt[go[p]]) bt[p]=0; LL ans=1; fo(i,1,n) if (rt[i]) &#123; dfs(i,0); ans=ans*f[i]%mo; &#125; printf(&quot;%lld\\n&quot;,ans); &#125;&#125;","categories":[{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[{"name":"算法_DP","slug":"算法-DP","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-DP/"}]},{"title":"ZJOI2017 round1 游记","slug":"ZJOI2017_round1","date":"2017-03-24T00:42:18.000Z","updated":"2024-04-24T03:59:22.800Z","comments":true,"path":"ZJOI2017_round1/","link":"","permalink":"http://kqp.world/ZJOI2017_round1/","excerpt":"前言&emsp;&emsp;第一次参加外省的省选呢~&emsp;&emsp;像往届那样，最后一年周游列国，到处打比赛，目的是积（dao）累（chu）经（qu）验（lang）。&emsp;&emsp;成绩还没发。。。但是。。。只能说幸好不是我们的省选。。。","text":"前言&emsp;&emsp;第一次参加外省的省选呢~&emsp;&emsp;像往届那样，最后一年周游列国，到处打比赛，目的是积（dao）累（chu）经（qu）验（lang）。&emsp;&emsp;成绩还没发。。。但是。。。只能说幸好不是我们的省选。。。 赛程回顾day-2~day0&emsp;&emsp;听课+coci2016/2017 +永夜抄 &emsp;&emsp;这个讲课内容比 WC 清真多啦！！！我能听懂好多哦，题也感觉很可做。&emsp;&emsp;看了 coci 最近的一套题。。。这歪果仁特么是用天河二号做比赛的吧，1e7 的标算居然是 m log m 的 Kruscal？？？用惯了国内的老爷机，看到 1e7 只会想线性做法。 day1&emsp;&emsp;延误 45min。。。&emsp;&emsp;这个题目好像不太清真啊。。。你让我以后怎么看黄金拼图&emsp;&emsp;看上去 t1 可做，于是几乎 4h 在刚 t1。最后 t2 和 t3 都交的 10 分暴力。&emsp;&emsp;t1 不断地改程序最终写了个线性的树做法（不会开大栈测不了大样例，也没时间对拍，生死未卜（UPD：死了，一堆东西没考虑）），发现仙人掌只需要在 dp 上再套一个 dp 好像就行了！！好恶心的代码啊不写了。 &emsp;&emsp;出考场别人告诉我，仙人掌只需要把环边全部断掉，就是森林了。。。&emsp;&emsp;我勒个去假设我树写对了的话，那就这样飞了 50 分！！！？？？&emsp;&emsp;特么是不是全场只有我没发现这个性质啊。。。 总结代码能力&emsp;&emsp;t1 写了 4h，这就是问题所在。&emsp;&emsp;我相信代码一定不是非得写一次才能知道到底对还是错，尤其是这种大码量题，写一次的代价是很大的。这说明我在写代码之前的分析能力很弱。&emsp;&emsp;通常，想出做法之后会很激动，然后到底对还是错就不好判断了，这时候的思维是很糊涂的。 &emsp;&emsp;最好的方法我觉得是模拟一些小数据先，不一定是样例，也不只是样例，反正最后代码打出来也是先测小数据。&emsp;&emsp;并且在想方法的时候要花点时间把实现细节也过一下，提前排除掉不可实现的脑洞，也提前熟知每一步要怎样写，避免在写的时候再想，写的时候想的应该是每一个步骤的反例。 全局策略&emsp;&emsp;先\\%一发本校大神 jasonvictoryan，他切了 t2 然后成绩是浙江前十。假老师切了两个题好厉害啊根本\\%不动&emsp;&emsp;然后就想想我对 t2 是什么态度。。。哦我把时间都花在 t1 上了所以对 t2 没态度。。。&emsp;&emsp;这种策略是长时间高难度比赛的一种，但是不能普遍适用，如果题目简单些，那应该把 t1 的时间拿出来写别的东西，或者如果像 GDOI 那样 4h 4 个题也得牺牲 t1 的时间。4h 刚 t1 这真的是在浪。&emsp;&emsp;t2 要冷静下来才能分析出那个反向树状数组的性质，最后一个小时来分析很容易急躁，想不出来的。 其他&emsp;&emsp;反正 t1 写这么久会产生很多问题。。。&emsp;&emsp;比如没时间对拍，这个真的危险。&emsp;&emsp;比如其他题的高档部分分没去思考，这个对分数有很大影响。&emsp;&emsp;比如还可能写着写着就写偏了，然后之前想到的东西（脑洞、反例等）就没考虑了。 后记&emsp;&emsp;离省队差的还是思维为主啊。。。树形dp、仙人掌环边什么的，逻辑清晰些才能棒棒啊~ &emsp;&emsp;后面还有 JSOI，然后就到 GDOI 了。看下能不能不留遗憾地考一场？","categories":[{"name":"总结与游记","slug":"总结与游记","permalink":"http://kqp.world/categories/%E6%80%BB%E7%BB%93%E4%B8%8E%E6%B8%B8%E8%AE%B0/"},{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[]},{"title":"【Hackerrank World9】【JZOJ5020】Box Operations 题解","slug":"【Hackerrank World9】【JZOJ5020】Box Operations 题解","date":"2017-03-17T09:01:05.000Z","updated":"2024-04-24T03:59:22.845Z","comments":true,"path":"【Hackerrank World9】【JZOJ5020】Box Operations 题解/","link":"","permalink":"http://kqp.world/%E3%80%90Hackerrank%20World9%E3%80%91%E3%80%90JZOJ5020%E3%80%91Box%20Operations%20%E9%A2%98%E8%A7%A3/","excerpt":"题目大意&emsp;&emsp;给出一个长度为 $n$ 的序列。&emsp;&emsp;有 4 种操作：&emsp;&emsp;$1\\ l\\ r\\ c$：给 $a_l,\\cdots,a_r$ 加上 $c$；（$c$ 可为负）&emsp;&emsp;$2\\ l\\ r\\ d$：给 $a_l,\\cdots,a_r$ 除以 $d$ 下取整；（$\\lfloor-0.5\\rfloor=1$）&emsp;&emsp;$3\\ l\\ r$：求 $a_l,\\cdots,a_r$ 的最小值；&emsp;&emsp;$4\\ l\\ r$：求 $a_l,\\cdots,a_r$ 的和。 &emsp;&emsp;$n, q \\leq 10^5$&emsp;&emsp;$|a| \\leq 10^9,\\ |c| \\leq 10^4,\\ 2\\leq d\\leq 10^9$","text":"题目大意&emsp;&emsp;给出一个长度为 $n$ 的序列。&emsp;&emsp;有 4 种操作：&emsp;&emsp;$1\\ l\\ r\\ c$：给 $a_l,\\cdots,a_r$ 加上 $c$；（$c$ 可为负）&emsp;&emsp;$2\\ l\\ r\\ d$：给 $a_l,\\cdots,a_r$ 除以 $d$ 下取整；（$\\lfloor-0.5\\rfloor=1$）&emsp;&emsp;$3\\ l\\ r$：求 $a_l,\\cdots,a_r$ 的最小值；&emsp;&emsp;$4\\ l\\ r$：求 $a_l,\\cdots,a_r$ 的和。 &emsp;&emsp;$n, q \\leq 10^5$&emsp;&emsp;$|a| \\leq 10^9,\\ |c| \\leq 10^4,\\ 2\\leq d\\leq 10^9$ \\\\ \\\\ \\\\题解&emsp;&emsp;这题的关键就是如何用线段树维护区间除法。 &emsp;&emsp;首先，一个数除 log 次，就会变成 0（或者 -1）。所以我们在不断地做除法的过程中，会有很多可以同时操作的连续段。 &emsp;&emsp;（想到这里之后我在考场上是这样做的：对于一个区间，如果他们除出来都是相同的，就打上除法标记，否则递归下去。然后发现除法标记瞬间爆 longlong……然后我就设个阈值，除法标记达到阈值之后强制下传，然后发现阈值居然要小于100……就狗带了） &emsp;&emsp;为了不打除法标记，我们这样操作：&emsp;&emsp;对于当前要做除法的区间 $[l,r]$：设区间最小值为 $x$，最大值为 $y$，要除以 $z$，若 $x-\\lfloor\\frac{x}{z}\\rfloor=y-\\lfloor\\frac{y}{z}\\rfloor$（即差量相同），那么直接给这个区间打上减法标记，否则递归下去。 &emsp;&emsp;时间分析：&emsp;&emsp;对于加法操作：每次最多增加 $2$ 个颜色段，所以总的颜色段最多是 $3n$。&emsp;&emsp;对于除法操作：相邻的两个颜色段最多 $2\\log$ 次操作就合并了。&emsp;&emsp;所以总的操作次数是 $O(n \\log n)$，加上线段树就是 $O(n \\log^2 n)$ &emsp;&emsp;（也可以用势能分析：由于相邻的两个颜色段最多 $O(\\log)$ 次操作就合并，所以我们把一个颜色段拆成 $\\log$ 份来看，设势函数 $\\Phi$ 表示当前这些颜色段的数量。一次加法操作就会使势差加 $2\\log$，实际用时视为 $1$；一次除法操作假设遍历了 $x$ 个区间，那么势差减 $x$，实际用时也是 $x$。因此估价函数最后算出来是 $O(n \\log n)$，加上线段树就是 $O(n \\log^2 n)$） 相关题&emsp;&emsp;UOJ#228 基础数据结构练习题&emsp;&emsp;此题是区间开方运算，跟区间除法的思路是一样的。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162#include&lt;cstdio&gt;#include&lt;algorithm&gt;#define fo(i,a,b) for(int i=a;i&lt;=b;i++)using namespace std;typedef long long LL;const int maxn=1e5+5;struct TR&#123; LL nmin,nmax,sum,len;&#125;;int n,a[maxn];int ReadInt()&#123; char ch=getchar(); int data=0, tag=1; while ((ch&lt;&#x27;0&#x27; || ch&gt;&#x27;9&#x27;) &amp;&amp; ch!=&#x27;-&#x27;) ch=getchar(); do&#123; if (ch==&#x27;-&#x27;) tag=-1; else data=data*10+ch-&#x27;0&#x27;; ch=getchar(); &#125; while (ch&gt;=&#x27;0&#x27; &amp;&amp; ch&lt;=&#x27;9&#x27; || ch==&#x27;-&#x27;); return data*tag;&#125;LL DIV(LL x,LL y) &#123;return x/y-(x&lt;0 &amp;&amp; x%y!=0);&#125;TR tr[4*maxn];LL bz[4*maxn];void update(int k,int ls,int rs)&#123; if (bz[k]==0) return; tr[ls].nmin+=bz[k]; tr[ls].nmax+=bz[k]; tr[ls].sum+=bz[k]*tr[ls].len; bz[ls]+=bz[k]; tr[rs].nmin+=bz[k]; tr[rs].nmax+=bz[k]; tr[rs].sum+=bz[k]*tr[rs].len; bz[rs]+=bz[k]; bz[k]=0;&#125;void merge(int k,int ls,int rs)&#123; tr[k].nmin=(tr[ls].nmin&lt;tr[rs].nmin) ?tr[ls].nmin :tr[rs].nmin; tr[k].nmax=(tr[ls].nmax&gt;tr[rs].nmax) ?tr[ls].nmax :tr[rs].nmax; tr[k].sum=tr[ls].sum+tr[rs].sum;&#125;void tr_js(int k,int l,int r)&#123; tr[k].len=r-l+1; if (l==r) &#123; tr[k].nmin=tr[k].nmax=tr[k].sum=a[l]; return; &#125; int t=k&lt;&lt;1, t1=(l+r)&gt;&gt;1; tr_js(t,l,t1), tr_js(t+1,t1+1,r); merge(k,t,t+1);&#125;void xg_ad(int k,int l,int r,int x,int y,LL z)&#123; if (l==x &amp;&amp; r==y) &#123; tr[k].nmin+=z; tr[k].nmax+=z; tr[k].sum+=tr[k].len*z; bz[k]+=z; return; &#125; int t=k&lt;&lt;1, t1=(l+r)&gt;&gt;1; update(k,t,t+1); if (y&lt;=t1) xg_ad(t,l,t1,x,y,z); else if (x&gt;t1) xg_ad(t+1,t1+1,r,x,y,z); else xg_ad(t,l,t1,x,t1,z), xg_ad(t+1,t1+1,r,t1+1,y,z); merge(k,t,t+1);&#125;void re_dv(int k,int l,int r,LL z)&#123; LL tm=tr[k].nmin-DIV(tr[k].nmin,z); if (tm==tr[k].nmax-DIV(tr[k].nmax,z)) &#123; tr[k].nmin-=tm; tr[k].nmax-=tm; tr[k].sum-=tm*tr[k].len; bz[k]-=tm; return; &#125; int t=k&lt;&lt;1, t1=(l+r)&gt;&gt;1; update(k,t,t+1); re_dv(t,l,t1,z), re_dv(t+1,t1+1,r,z); merge(k,t,t+1);&#125;void xg_dv(int k,int l,int r,int x,int y,LL z)&#123; if (l==x &amp;&amp; r==y) &#123; re_dv(k,l,r,z); return; &#125; int t=k&lt;&lt;1, t1=(l+r)&gt;&gt;1; update(k,t,t+1); if (y&lt;=t1) xg_dv(t,l,t1,x,y,z); else if (x&gt;t1) xg_dv(t+1,t1+1,r,x,y,z); else xg_dv(t,l,t1,x,t1,z), xg_dv(t+1,t1+1,r,t1+1,y,z); merge(k,t,t+1);&#125;LL cx_min(int k,int l,int r,int x,int y)&#123; if (l==x &amp;&amp; r==y) return tr[k].nmin; int t=k&lt;&lt;1, t1=(l+r)&gt;&gt;1; update(k,t,t+1); if (y&lt;=t1) return cx_min(t,l,t1,x,y); else if (x&gt;t1) return cx_min(t+1,t1+1,r,x,y); else &#123; LL rel=cx_min(t,l,t1,x,t1), rer=cx_min(t+1,t1+1,r,t1+1,y); return (rel&lt;rer) ?rel :rer; &#125;&#125;LL cx_sum(int k,int l,int r,int x,int y)&#123; if (l==x &amp;&amp; r==y) return tr[k].sum; int t=k&lt;&lt;1, t1=(l+r)&gt;&gt;1; update(k,t,t+1); if (y&lt;=t1) return cx_sum(t,l,t1,x,y); else if (x&gt;t1) return cx_sum(t+1,t1+1,r,x,y); else return cx_sum(t,l,t1,x,t1)+cx_sum(t+1,t1+1,r,t1+1,y);&#125;int q;int main()&#123; scanf(&quot;%d %d&quot;,&amp;n,&amp;q); fo(i,1,n) a[i]=ReadInt(); tr_js(1,1,n); while (q--) &#123; int ty=ReadInt(), l=ReadInt(), r=ReadInt(); if (ty==1) &#123; LL d=ReadInt(); xg_ad(1,1,n,l,r,d); &#125; else if (ty==2) &#123; LL d=ReadInt(); xg_dv(1,1,n,l,r,d); &#125; else if (ty==3) &#123; printf(&quot;%lld\\n&quot;,cx_min(1,1,n,l,r)); &#125; else &#123; printf(&quot;%lld\\n&quot;,cx_sum(1,1,n,l,r)); &#125; &#125;&#125;","categories":[{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[{"name":"算法_线段树","slug":"算法-线段树","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E7%BA%BF%E6%AE%B5%E6%A0%91/"}]},{"title":"【JZOJ5017】拍苍蝇 题解","slug":"【JZOJ5017】拍苍蝇 题解","date":"2017-03-16T14:54:58.000Z","updated":"2024-04-24T03:59:22.856Z","comments":true,"path":"【JZOJ5017】拍苍蝇 题解/","link":"","permalink":"http://kqp.world/%E3%80%90JZOJ5017%E3%80%91%E6%8B%8D%E8%8B%8D%E8%9D%87%20%E9%A2%98%E8%A7%A3/","excerpt":"题目大意&emsp;&emsp;平面大小为 $Xp \\cdot Yp$，上面有 n 只苍蝇，每只坐标为 (xi, yi)。&emsp;&emsp;然后给出一个 $k$ 个顶点的多边形（可能为凹），你要将多边形放在平面上，规定顶点必须在整点上，且不能有苍蝇在多边形内或多边形上。&emsp;&emsp;求方案数。&emsp;&emsp;$Xp, Yp \\le 500， n \\le Xp \\cdot Yp$&emsp;&emsp;$k \\le 10^4$&emsp;&emsp;小测试点 1.5s，大测试点 3s。","text":"题目大意&emsp;&emsp;平面大小为 $Xp \\cdot Yp$，上面有 n 只苍蝇，每只坐标为 (xi, yi)。&emsp;&emsp;然后给出一个 $k$ 个顶点的多边形（可能为凹），你要将多边形放在平面上，规定顶点必须在整点上，且不能有苍蝇在多边形内或多边形上。&emsp;&emsp;求方案数。&emsp;&emsp;$Xp, Yp \\le 500， n \\le Xp \\cdot Yp$&emsp;&emsp;$k \\le 10^4$&emsp;&emsp;小测试点 1.5s，大测试点 3s。 答案为 1 的样例 题解&emsp;&emsp;我们把每一行看作是 01 序列，有苍蝇就是 1，没有就是 0。&emsp;&emsp;然后把多边形也看作是 01 矩阵，被多边形覆盖的就是 1，否则是 0。&emsp;&emsp;（求这个可以枚举每个点是否在多边形内（射线法），也可以基于此用类似前缀和的方法（我把每条边上方最近的整点打标记，然后从底向上前缀异或和，就知道每个点是在内还是外了，然后特殊处理边上的点）） 解法1&emsp;&emsp;有了上述方法之后我们就可以用 bitset 把这些东西存下来，然后暴力枚举多边形放哪，再用 bitset 判断。&emsp;&emsp;由于状态是不满的，所以可以过。 解法2（标算）&emsp;&emsp;把这些看成 01 序列（或矩阵）的话，就可以用 FFT 来代替 bitset 了。。。&emsp;&emsp;貌似是二维的 FFT，操作难度有点大。。。 解法1代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;bitset&gt;#define fo(i,a,b) for(int i=a;i&lt;=b;i++)using namespace std;typedef long long LL;const int maxn=250005, maxk=1e4+5, maxp=505;const int inf=2147483647;int xp,yp,kx,ky,n,k,X[maxk],Y[maxk],ex1[maxk],ex2[maxk],ey1[maxk],ey2[maxk];bitset&lt;maxp&gt; mp[maxp],fp[maxp];bitset&lt;maxp&gt; zero;bool bz[maxp][maxp];int main()&#123; scanf(&quot;%d %d %d&quot;,&amp;xp,&amp;yp,&amp;n); fo(i,1,n) &#123; int x,y; scanf(&quot;%d %d&quot;,&amp;x,&amp;y); mp[x][y]=1; &#125; scanf(&quot;%d&quot;,&amp;k); kx=ky=inf; fo(i,1,k) &#123; scanf(&quot;%d %d&quot;,&amp;X[i],&amp;Y[i]); kx=min(kx,X[i]), ky=min(ky,Y[i]); &#125; fo(i,1,k) X[i]-=kx, Y[i]-=ky; kx=ky=0; fo(i,1,k) &#123; kx=max(kx,X[i]), ky=max(ky,Y[i]); if (X[i]&gt;xp || Y[i]&gt;yp) &#123;printf(&quot;0\\n&quot;); return 0;&#125; &#125; fo(i,1,k) &#123; ex1[i]=X[i], ey1[i]=Y[i]; int t=(i%k)+1; ex2[i]=X[t], ey2[i]=Y[t]; if (ex1[i]&gt;ex2[i]) swap(ex1[i],ex2[i]), swap(ey1[i],ey2[i]); if (ex1[i]==ex2[i] &amp;&amp; ey1[i]&gt;ey2[i]) swap(ey1[i],ey2[i]); &#125; fo(i,1,k) if (ex1[i]!=ex2[i]) &#123; int ad=(ey1[i]&lt;ey2[i]) ?1 :-1; int y=ey1[i]; fo(x,ex1[i],ex2[i]) &#123; if (ad==1) &#123; while ((LL)(y-ey1[i])*(ex2[i]-x)&lt;(LL)(ey2[i]-y)*(x-ex1[i])) y+=ad; &#125; else &#123; while (x&gt;ex1[i] &amp;&amp; (LL)((y+ad)-ey1[i])*(ex2[i]-x)&gt;=(LL)(ey2[i]-(y+ad))*(x-ex1[i])) y+=ad; &#125; if ((LL)(y-ey1[i])*(ex2[i]-x)==(LL)(ey2[i]-y)*(x-ex1[i])) bz[x][y]=1; if (x&lt;ex2[i] &amp;&amp; y&lt;=ky) fp[x][y]=(fp[x][y]) ?0 :1 ; &#125; &#125; fo(i,0,kx) fo(j,1,ky) fp[i][j]=fp[i][j]^fp[i][j-1]; fo(i,0,kx) fo(j,0,ky) if (bz[i][j]) fp[i][j]=1; fo(i,1,k) if (ex1[i]==ex2[i]) fo(j,ey1[i],ey2[i]) fp[ex1[i]][j]=1; int ans=0; fo(x,0,xp-kx) fo(y,0,yp-ky) &#123; bitset&lt;maxp&gt; ans1=zero; fo(i,0,kx) ans1|=mp[x+i]&amp;(fp[i]&lt;&lt;y); ans+=(!ans1.any()); &#125; printf(&quot;%d\\n&quot;,ans);&#125;","categories":[{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[{"name":"算法_FFT/NTT","slug":"算法-FFT-NTT","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-FFT-NTT/"},{"name":"算法_几何","slug":"算法-几何","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E5%87%A0%E4%BD%95/"}]},{"title":"【Hackerrank University2】【JZOJ5008】Querying Sums on Strings 题解","slug":"【Hackerrank University2】【JZOJ5008】Querying Sums on Strings 题解","date":"2017-03-14T12:00:53.000Z","updated":"2024-04-24T03:59:22.843Z","comments":true,"path":"【Hackerrank University2】【JZOJ5008】Querying Sums on Strings 题解/","link":"","permalink":"http://kqp.world/%E3%80%90Hackerrank%20University2%E3%80%91%E3%80%90JZOJ5008%E3%80%91Querying%20Sums%20on%20Strings%20%E9%A2%98%E8%A7%A3/","excerpt":"题目大意 &emsp;&emsp;$n,~m,~k,~q~&lt;=~1e5$&emsp;&emsp;$\\sum |w|&lt;=1e5$&emsp;&emsp;1s， 512M","text":"题目大意 &emsp;&emsp;$n,~m,~k,~q~&lt;=~1e5$&emsp;&emsp;$\\sum |w|&lt;=1e5$&emsp;&emsp;1s， 512M \\\\ \\\\ \\\\题解&emsp;&emsp;这题的关键是要抓住“$\\sum |w|&lt;=1e5$”这个条件。 &emsp;&emsp;于是我们分 $k&lt;=\\sqrt{1e5}$ 和 $k&gt;\\sqrt{1e5}$ 两种情况来做。 &emsp;&emsp;当 $k&lt;=\\sqrt{1e5}$ 时：&emsp;&emsp;我们暴力枚举每个 $w$ 的每一个子串，然后求出该子串在 $s$ 中的出现次数，再看该子串被询问了多少次（这个可以预处理+二分什么的乱搞）。 &emsp;&emsp;当 $k&gt;\\sqrt{1e5}$ 时：&emsp;&emsp;此时的 $q&lt;=\\sqrt{1e5}$，因此直接求出每个询问子串的出现次数即可。 &emsp;&emsp;求一个串在 $s$ 中的出现次数可以用 SA 或 SAM。","categories":[{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[{"name":"算法_根号平衡","slug":"算法-根号平衡","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E6%A0%B9%E5%8F%B7%E5%B9%B3%E8%A1%A1/"},{"name":"算法_字符串","slug":"算法-字符串","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"猎奇！THUWC2017试机题","slug":"THUWC2017_pretest","date":"2017-03-10T07:03:08.000Z","updated":"2024-04-24T03:59:22.797Z","comments":true,"path":"THUWC2017_pretest/","link":"","permalink":"http://kqp.world/THUWC2017_pretest/","excerpt":"A题目大意&emsp;&emsp;一个长度为 $n$ 的序列，选择一个长度为 $k$ 的子序列，使得字典序最小。&emsp;&emsp;$O(n \\log n)$ 会被卡，要求线性。 &emsp;&emsp;（这题其实挺正常挺经典的。。。）","text":"A题目大意&emsp;&emsp;一个长度为 $n$ 的序列，选择一个长度为 $k$ 的子序列，使得字典序最小。&emsp;&emsp;$O(n \\log n)$ 会被卡，要求线性。 &emsp;&emsp;（这题其实挺正常挺经典的。。。） 解法&emsp;&emsp;本质是贪心，假设目前是第 $i$ 轮，上一轮选了第 $x$ 个，那么现在就是在 $[x+1,n-k+i]$ 里取最小值。&emsp;&emsp;求最小值的区间是滑窗向右的，可以用单调队列 A加强版题目大意&emsp;&emsp;这是一道交互题。&emsp;&emsp;先给你一个整数 $k$ ($k \\le 10^6$)，然后按顺序给你未知个整数 $a_1,\\cdots,a_n$（$n \\le 1.5 \\times 10^7$，$n$ 不输入），要求你求出一个长度为 $k$ 的字典序最小的子序列。&emsp;&emsp;内存 32M，即空间限制是 $O(k)$ 的。 解法1&emsp;&emsp;其实跟上一题是差不多的。。。&emsp;&emsp;由于不知道什么时候读完所有的数，所以要开多一个队列存最后读进来的 $k$ 个数，然后每来一个数，就把队头拿去维护单调队列。 解法2&emsp;&emsp;直接考虑每 $k$ 个数做一次。&emsp;&emsp;假设我们目前的答案子序列为 A，然后又读了 $k$ 个数存在 B 里，那我可以用两个指针扫这两个数组来合并。&emsp;&emsp;时间是 $O(n/k \\cdot k) = O(n)$。 B题目大意&emsp;&emsp;读入一个字符串（长度 &lt;= 20），请你读懂字符串的含义并用程序输出对应的数字。&emsp;&emsp;比如字符串是“This year”，你应该输出“2016”。&emsp;&emsp;该题有 20 组数据，每组数据的字符串都是相同的。&emsp;&emsp;该题可以多次提交，每次提交都能返回评测结果（AC、WA 等）。 猎奇题 解法1&emsp;&emsp;枚举答案显然是不行的。。。&emsp;&emsp;让机器变成 AI 读懂字符串好像也不行。。。&emsp;&emsp;只有我们自己想办法知道字符串是什么了。 &emsp;&emsp;试通过评测结果来推断字符串是什么。&emsp;&emsp;比如我们猜字符串第一位是 a，那么如果 s[1] 果然是 ‘a’，就让它返回 RE，否则让他返回 TLE。我们知道肯定有办法设计算法使它强行 RE 或 TLE 或其他什么的。&emsp;&emsp;然后每一次提交可以判断 20 次，所以可以在有限步数内得到字符串。 解法2&emsp;&emsp;用提交状态判断还是慢了点。&emsp;&emsp;我们可以考虑用时间来判断。比如，如果它第一位为 a，就让它循环 100 次，b 就 1000 次……这样一次提交就知道整个字符串了。&emsp;&emsp;时间误差比较大，所以可以再改，用空间来判！ C题目大意&emsp;&emsp;这是一道提答题，有 10 组数据。&emsp;&emsp;一组数据中，若读入是 x，正确答案是 ans，则 |ans-x|&lt;=5。&emsp;&emsp;一个测试点你输出 y，可以获得的分值是 max( 0, 11-e^|y-ans| )，分值会下取整。&emsp;&emsp;现在让你 AC 这个题。 解法&emsp;&emsp;得 10 分：y=ans&emsp;&emsp;得 8 分：|y-ans|=1&emsp;&emsp;得 3 分：|y-ans|=2&emsp;&emsp;其余得 0 分。 &emsp;&emsp;于是我们先猜 x，若不为 0 则再猜一次就出解；若为 0 就猜 x+5，再不行就 x-5，则一定出解了。&emsp;&emsp;最坏情况下，第 4 次提交即可 AC。","categories":[{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[{"name":"算法_神奇的脑洞","slug":"算法-神奇的脑洞","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E7%A5%9E%E5%A5%87%E7%9A%84%E8%84%91%E6%B4%9E/"}]},{"title":"【JZOJ4155】传送 题解","slug":"【JZOJ4155】传送 题解","date":"2017-03-09T08:03:58.000Z","updated":"2024-04-24T03:59:22.848Z","comments":true,"path":"【JZOJ4155】传送 题解/","link":"","permalink":"http://kqp.world/%E3%80%90JZOJ4155%E3%80%91%E4%BC%A0%E9%80%81%20%E9%A2%98%E8%A7%A3/","excerpt":"题目大意&emsp;&emsp;你在一个有 n 个点的环上，环上点按逆时针顺序标号为 0 到 n-1。你一开始在 0 号点。&emsp;&emsp;你在每一回合可以使用 k 种传送中的一种，第 i 种传送会将你按逆时针方向移动 a[i] 个点。&emsp;&emsp;有 m 个限制条件，对于每个限制条件 (xi, yi)，要求不能在第 xi 步之后在 yi 号点上。&emsp;&emsp;你要求出经过 L 步之后在 0 号点的方案数模 998244353。 &emsp;&emsp;n &lt;= 65536 且 n 为 2 的幂。&emsp;&emsp;L &lt;= 1e9， m &lt;= 15， k &lt;= 1e5&emsp;&emsp;时限 2s。","text":"题目大意&emsp;&emsp;你在一个有 n 个点的环上，环上点按逆时针顺序标号为 0 到 n-1。你一开始在 0 号点。&emsp;&emsp;你在每一回合可以使用 k 种传送中的一种，第 i 种传送会将你按逆时针方向移动 a[i] 个点。&emsp;&emsp;有 m 个限制条件，对于每个限制条件 (xi, yi)，要求不能在第 xi 步之后在 yi 号点上。&emsp;&emsp;你要求出经过 L 步之后在 0 号点的方案数模 998244353。 &emsp;&emsp;n &lt;= 65536 且 n 为 2 的幂。&emsp;&emsp;L &lt;= 1e9， m &lt;= 15， k &lt;= 1e5&emsp;&emsp;时限 2s。 题解&emsp;&emsp;L 这么大。。。于是我们想到矩阵乘法经典套路。&emsp;&emsp;设 f[i] 表示当前在 i 这个位置的方案数。我们根据 k 种传送把转移矩阵构出来好像就行了。&emsp;&emsp;限制的话很好处理，假设有个限制是 (xi, yi)，那就在乘 xi 次之后，把 f[yi] 赋值为 0。 &emsp;&emsp;但是这个转移矩阵太大了。 &emsp;&emsp;于是发现我们不需要矩阵，只需要一个 01 序列就行了。比如我们有一种传送是 a[i]，那就在序列 A 的第 a[i] 位标为 1。然后用 f 和 A 做一次循环卷积，这就相当于一次转移了。&emsp;&emsp;处理限制跟上面相同，即相当于把 L 分成很多段。时间复杂度 $O(mlog ~Ln~log~n)$ &emsp;&emsp;发现过不了。。。 &emsp;&emsp;这时候就可以用另一个经典套路了。&emsp;&emsp;对于卷积，我们先做一次 DFT，然后把 n 个点值分别幂 L 次，再做逆 DFT。&emsp;&emsp;可以证明，这样拆开来幂，跟合起来幂是一样的结果。具体请访问 YxuanwKeith的博客。&emsp;&emsp;这样时间就是 $O(m(log~n+n~log~L))$ tips&emsp;&emsp;循环卷积时，如果 n 是 2 的幂，可以直接把数组大小开成 n 做普通卷积。","categories":[{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[{"name":"算法_FFT/NTT","slug":"算法-FFT-NTT","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-FFT-NTT/"}]},{"title":"【hihocoder1455】Rikka with Tree III 题解","slug":"【hihocoder1455】Rikka with Tree III 题解","date":"2017-03-07T08:22:49.000Z","updated":"2024-04-24T03:59:22.846Z","comments":true,"path":"【hihocoder1455】Rikka with Tree III 题解/","link":"","permalink":"http://kqp.world/%E3%80%90hihocoder1455%E3%80%91Rikka%20with%20Tree%20III%20%E9%A2%98%E8%A7%A3/","excerpt":"题目大意&emsp;&emsp;现在有一颗 n 个点的有根树，每个点有点权 w[i]。在树上每一条从 $u$ 到 $v$ 的简单路径都能得到一个序列：按照顺序把经过的点的权值写下来，这个序列定义为 $A_{u,v}$，注意 $A_{u,v}$ 可能不等于 $A_{v,u}$。&emsp;&emsp;序列 $B$ 在树上出现过当且仅当存在 $u, v$ 满足 $B$ 是 $A_{u,v}$ 的子序列。&emsp;&emsp;整数 d 在树上出现过当且仅当存在以 d 为公差的长度不小于 3 的等差数列在树上出现过。&emsp;&emsp;问有多少个正整数 d 在树上出现过。 &emsp;&emsp;n&lt;=5e4， 1&lt;=w&lt;=n， 时限 2s。","text":"题目大意&emsp;&emsp;现在有一颗 n 个点的有根树，每个点有点权 w[i]。在树上每一条从 $u$ 到 $v$ 的简单路径都能得到一个序列：按照顺序把经过的点的权值写下来，这个序列定义为 $A_{u,v}$，注意 $A_{u,v}$ 可能不等于 $A_{v,u}$。&emsp;&emsp;序列 $B$ 在树上出现过当且仅当存在 $u, v$ 满足 $B$ 是 $A_{u,v}$ 的子序列。&emsp;&emsp;整数 d 在树上出现过当且仅当存在以 d 为公差的长度不小于 3 的等差数列在树上出现过。&emsp;&emsp;问有多少个正整数 d 在树上出现过。 &emsp;&emsp;n&lt;=5e4， 1&lt;=w&lt;=n， 时限 2s。 先考虑序列怎么做&emsp;&emsp;显然所谓的等差数列只要找三项就可以了。&emsp;&emsp;题目规定了等差数列必须从小到大，因此我们枚举中间一项是谁，这样就可以避免顺序问题。 &emsp;&emsp;比如我们枚举了 w[i] 作为中间项，那么就要在左边找 w[i]-d，右边找 w[i]+d，来更新答案。我们观察到这两项与中间项的距离是相等的，如何利用这一性质呢？ &emsp;&emsp;我们维护一个前缀 bitset（把它叫做 S1）和一个后缀 bitset （把它叫做 S2）。&emsp;&emsp;每插入一个 w，就把 S1 的第 n-w+1 位标为 1，把 S2 的第 w 位标为 1。&emsp;&emsp;当询问 w[i] 的时候，就把 S1 和 S2 都右移 w[i] 位（这就是为什么 S1 要反着存），再 and 起来，得到的东西记为 S3，那么 S3 中为 1 的位，就代表一个合法的 d。&emsp;&emsp;于是我们答案再维护一个 bitset（把它叫做 ans），每次就 ans &amp; S3，最后统计 ans 有多少位为 1 就行了。 到树上&emsp;&emsp;枚举了中间项 w[i] 之后，剩下两项有两种情况，一种是全在儿子里，一种是一个在儿子里，一个在子树外。&emsp;&emsp;所以如果每个点维护一个 bitset 的话，就相当于合并儿子的信息，合并完之后用整个子树跟子树外的再操作一下。从 dfs 序来看，子树外相当于两个（或一个）区间，所以也可以快速得到其 bitset。 &emsp;&emsp;但是这样会 MLE。 &emsp;&emsp;一种解决方法是分块。我们每个块维护一个 bitset，对于非完整块就暴力。这样需要根号个bitset。 &emsp;&emsp;另一种解决方法是莫队。对于点 i，把 i 的每个儿子当作一个询问区间，丢到莫队里。然后每个询问就相当于区间内和区间外的运算。这样需要 3 个bitset（当前区间内一个、区间外一个、答案一个）。","categories":[{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[{"name":"算法_莫队/分块","slug":"算法-莫队-分块","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E8%8E%AB%E9%98%9F-%E5%88%86%E5%9D%97/"},{"name":"算法_位运算","slug":"算法-位运算","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/"}]},{"title":"【hdu5382】GCD?LCM! 题解","slug":"【hdu5382】GCD!LCM! 题解","date":"2017-03-05T08:47:51.000Z","updated":"2024-04-24T03:59:22.846Z","comments":true,"path":"【hdu5382】GCD!LCM! 题解/","link":"","permalink":"http://kqp.world/%E3%80%90hdu5382%E3%80%91GCD!LCM!%20%E9%A2%98%E8%A7%A3/","excerpt":"题目大意&emsp;&emsp;令 $f(n)=\\sum_{i=1}^n\\sum_{j=1}^n~[~gcd(i,j)+lcm(i,j)≥n~]$，求 $S(n)=\\sum_{i=1}^nf(i)$。&emsp;&emsp;多组询问，$T \\le 10^5，n \\le 10^6$。","text":"题目大意&emsp;&emsp;令 $f(n)=\\sum_{i=1}^n\\sum_{j=1}^n~[~gcd(i,j)+lcm(i,j)≥n~]$，求 $S(n)=\\sum_{i=1}^nf(i)$。&emsp;&emsp;多组询问，$T \\le 10^5，n \\le 10^6$。 \\\\ \\\\ \\\\第一反应&emsp;&emsp;拿到式子大多数同学开始反演了。。。&emsp;&emsp;$T$ 这么大，还得能预处理。。。 &emsp;&emsp;直接刚反演的话，我反正是刚不出来，题解也不是这么做的。 题解&emsp;&emsp;考虑递推！！&emsp;&emsp;看 $f(n-1)$ 如何推到 $f(n)$。我们发现，就是少了 $i=n$ 或 $j=n$ 的情况，然后多了 $gcd+lcm=n-1$ 的情况。当 $i=n$ 或 $j=n$ 时，$lcm(i,j)≥n$，所以一定可以。因此递推式就是： f(n)=f(n-1)+2n-1-\\sum_{i=1}^{n-1}\\sum_{j=1}^{n-1}~[~\\gcd(i,j)+lcm(i,j)=n-1~]&emsp;&emsp;后面那部分就可以反演了。 \\begin{array}{rcl} g(n)&=&\\sum_{i=1}^n\\sum_{j=1}^n~[~gcd(i,j)+lcm(i,j)=n~]\\\\ &=&\\sum_{d=1}^n\\sum_{i=1}^{\\lfloor\\frac{n}{d}\\rfloor}\\sum_{j=1}^{\\lfloor\\frac{n}{d}\\rfloor}~[~gcd(i,j)=1~]~[~d+ijd=n~]\\\\ &=&\\sum_{d|n}\\sum_{i=1}^{\\lfloor\\frac{n}{d}\\rfloor-1}\\sum_{j=1}^{\\lfloor\\frac{n}{d}\\rfloor-1}~[~gcd(i,j)=1~]~[~ij=\\lfloor\\frac{n}{d}\\rfloor-1~]\\\\ &=&\\sum_{d|n}h(\\lfloor\\frac{n}{d}\\rfloor-1)\\\\ h(m)&=&\\sum_{i=1}^m\\sum_{j=1}^m~[~gcd(i,j)=1~]~[~ij=m~]\\\\ &=&2^{\\lambda(m)} \\end{array}&emsp;&emsp;其中 $\\lambda(m)$ 表示 $m$ 的质因数种类数，即 $m=p_1^{c_1}p_2^{c_2}…p_{\\lambda(m)}^{c_{\\lambda(m)}}$ &emsp;&emsp;到这一步，全部都可以预处理了。","categories":[{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[{"name":"算法_神奇的脑洞","slug":"算法-神奇的脑洞","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E7%A5%9E%E5%A5%87%E7%9A%84%E8%84%91%E6%B4%9E/"},{"name":"算法_数论","slug":"算法-数论","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E6%95%B0%E8%AE%BA/"}]},{"title":"【CF763B】Timofey and rectangles 题解","slug":"【CF763B】Timofey and rectangles 题解","date":"2017-03-05T07:39:19.000Z","updated":"2024-04-24T03:59:22.838Z","comments":true,"path":"【CF763B】Timofey and rectangles 题解/","link":"","permalink":"http://kqp.world/%E3%80%90CF763B%E3%80%91Timofey%20and%20rectangles%20%E9%A2%98%E8%A7%A3/","excerpt":"题目大意&emsp;&emsp;平面上有 $n$ 个矩形，每个矩形的边长都是奇数。并且矩形之间不会相交或者包含。&emsp;&emsp;现在你要用四种颜色去染这些矩形，使得相邻的矩形不同色。请给出一种染色方案，或者输出无解。&emsp;&emsp;$n \\le 5\\times 10^5$。","text":"题目大意&emsp;&emsp;平面上有 $n$ 个矩形，每个矩形的边长都是奇数。并且矩形之间不会相交或者包含。&emsp;&emsp;现在你要用四种颜色去染这些矩形，使得相邻的矩形不同色。请给出一种染色方案，或者输出无解。&emsp;&emsp;$n \\le 5\\times 10^5$。] 题解&emsp;&emsp;这个思路也是比较巧。。。 &emsp;&emsp;首先根据四色定理，一定有解。 &emsp;&emsp;现在我们要构造染色方案。关键是给每个矩形分配一种恰当的颜色。我们知道暴力是不行的，那就有一种想法，我根据矩形的参数计算出这个矩形该用什么颜色。由于颜色数只有 4，所以我们要找到一种合适的参数，它的大小也是 4。&emsp;&emsp;于是我们用这个：矩形右下角的横纵坐标奇偶性，恰好大小为 4。 &emsp;&emsp;下面来证明这是对的。只需证明，若两个矩形相邻，则他们横纵坐标奇偶性不会完全相同。&emsp;&emsp;设矩形 $a$ 的横长为 $c_a$，纵长为 $r_a$，右下角坐标为 $(x_a,y_a)$&emsp;&emsp;1、矩形 A 与矩形 B 呈上下相邻，A 在 B 上面：则 $y_A=y_B+r_B$，由于 $r_B$ 为奇数，因此 $y_A$ 与 $y_B$ 奇偶性不同。&emsp;&emsp;2、矩形 A 与矩形 B 呈左右相邻，A 在 B 左面：则 $x_A+c_B=x_B$，由于$c_B$ 为奇数，因此 $x_A$ 与 $x_B$ 奇偶性不同。&emsp;&emsp;证毕。","categories":[{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[{"name":"算法_构造题","slug":"算法-构造题","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E6%9E%84%E9%80%A0%E9%A2%98/"}]},{"title":"【codejam2008 Round1A】Numbers 题解","slug":"【codejam2008 Round1A】Numbers 题解","date":"2017-03-02T07:20:17.000Z","updated":"2024-04-24T03:59:22.839Z","comments":true,"path":"【codejam2008 Round1A】Numbers 题解/","link":"","permalink":"http://kqp.world/%E3%80%90codejam2008%20Round1A%E3%80%91Numbers%20%E9%A2%98%E8%A7%A3/","excerpt":"题目大意&emsp;&emsp;求 $(3+\\sqrt 5)^n$ 的整数部分最后三位。&emsp;&emsp;$n \\le 2 \\times 10^9$","text":"题目大意&emsp;&emsp;求 $(3+\\sqrt 5)^n$ 的整数部分最后三位。&emsp;&emsp;$n \\le 2 \\times 10^9$ 这真是个有趣的问题 解法&emsp;&emsp;考虑一项一项地乘&emsp;&emsp;某个数 $a+b\\sqrt 5$，给它乘个 $3+\\sqrt 5$ 之后，会变成 $(3a+5b)+(a+3b)\\sqrt 5$。&emsp;&emsp;于是可以考虑矩阵乘法。 &emsp;&emsp;但是直接这样矩阵乘法不能模！！！&emsp;&emsp;原因是，$a=a\\bmod 1000$，但 $b\\sqrt 5≠(b \\bmod 1000)\\sqrt 5$ &emsp;&emsp;所以再考虑 $(3-\\sqrt 5)^n$。设 $(3+\\sqrt 5)^n=a+b\\sqrt 5$，那么 $(3-\\sqrt 5)^n$ 就等于 $a-b\\sqrt 5$。两式相加得 $2a$。&emsp;&emsp;又由于 $0&lt;3-\\sqrt 5&lt;1$，所以 $0&lt;(3-\\sqrt 5)^n&lt;1$，因此答案就是 $2a-1$。&emsp;&emsp;于是我们矩阵乘法只需要求 $a$，这样就可以模了！！ &emsp;&emsp;（个人感觉妙啊。。。）","categories":[{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[{"name":"算法_神奇的脑洞","slug":"算法-神奇的脑洞","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E7%A5%9E%E5%A5%87%E7%9A%84%E8%84%91%E6%B4%9E/"},{"name":"算法_矩阵乘法","slug":"算法-矩阵乘法","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95/"}]},{"title":"【JZOJ4941】宝石魔术 题解","slug":"【JZOJ4941】宝石魔术 题解","date":"2017-02-22T14:24:03.000Z","updated":"2024-04-24T03:59:22.855Z","comments":true,"path":"【JZOJ4941】宝石魔术 题解/","link":"","permalink":"http://kqp.world/%E3%80%90JZOJ4941%E3%80%91%E5%AE%9D%E7%9F%B3%E9%AD%94%E6%9C%AF%20%E9%A2%98%E8%A7%A3/","excerpt":"题目大意&emsp;&emsp;有 Q 种操作。&emsp;&emsp;1、加入一个魔力为 x 的宝石；&emsp;&emsp;2、删去一个魔力为 x 的宝石（保证操作合法）；&emsp;&emsp;3、询问有多少种选取宝石的方法，使得选取的魔力和为 x；（不同下标的宝石视为不同，即两种方法不同当且仅当两种方法选取的宝石有不同）&emsp;&emsp;4、询问有多少种选取宝石的方法，使得选取的魔力和为 x。（不同魔力的宝石视为不同，即两种方法不同当且仅当某一种魔力值的宝石数量不同） &emsp;&emsp;Q, x&lt;=10^4，时限 3s。","text":"题目大意&emsp;&emsp;有 Q 种操作。&emsp;&emsp;1、加入一个魔力为 x 的宝石；&emsp;&emsp;2、删去一个魔力为 x 的宝石（保证操作合法）；&emsp;&emsp;3、询问有多少种选取宝石的方法，使得选取的魔力和为 x；（不同下标的宝石视为不同，即两种方法不同当且仅当两种方法选取的宝石有不同）&emsp;&emsp;4、询问有多少种选取宝石的方法，使得选取的魔力和为 x。（不同魔力的宝石视为不同，即两种方法不同当且仅当某一种魔力值的宝石数量不同） &emsp;&emsp;Q, x&lt;=10^4，时限 3s。 解法1&emsp;&emsp;这种东西肯定先想到 dp。&emsp;&emsp;设 f[i] 表示操作3条件下，魔力和为 i 的方案数；设 g[i] 表示操作4的方案数。f 是个01背包，而 g 是个多重背包。 &emsp;&emsp;然后这就是个动态dp了。&emsp;&emsp;f 的维护比较简单，插入就倒着扫一遍，删除就正着扫一遍。&emsp;&emsp;g 的维护比较麻烦，主要是它的转移跟数量有关。实现程序时瞎搞一下也可以使其成为线性。&emsp;&emsp;一次dp是 O(x) 的，所以总时间是 O(Qx)。 解法2&emsp;&emsp;考虑dp的生成函数。贴题解了。&emsp;&emsp;以下的 $cnt[i]$ 表示魔力值为 i 的宝石数量，$f[i][j]$ 表示01背包的dp 代码解法1123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include&lt;cstdio&gt;#include&lt;cstring&gt;#define fo(i,a,b) for(int i=a;i&lt;=b;i++)#define fd(i,a,b) for(int i=a;i&gt;=b;i--)using namespace std;typedef long long LL;const int maxn=1e4+5;const LL mo=1e9+7;int n,cnt[maxn];LL f[maxn],g[maxn];int ReadInt()&#123; char ch=getchar(); int data=0; while (ch&lt;&#x27;0&#x27; || ch&gt;&#x27;9&#x27;) ch=getchar(); do&#123; data=data*10+ch-&#x27;0&#x27;; ch=getchar(); &#125; while (ch&gt;=&#x27;0&#x27; &amp;&amp; ch&lt;=&#x27;9&#x27;); return data;&#125;char ReadChar()&#123; char ch=getchar(); while (ch!=&#x27;i&#x27; &amp;&amp; ch!=&#x27;q&#x27; &amp;&amp; ch!=&#x27;d&#x27; &amp;&amp; ch!=&#x27;R&#x27; &amp;&amp; ch!=&#x27;T&#x27;) ch=getchar(); return ch;&#125;LL gj[maxn],gp[maxn];void NewG(int x,int z)&#123; if (cnt[x]) &#123; fo(i,0,x-1) gj[i]=g[i]; fo(i,x,n) &#123; g[i]=(g[i]-gj[i-x]+mo)%mo; gj[i]=(gj[i-x]+g[i])%mo; if (i-cnt[x]*x&gt;=0) gj[i]=(gj[i]-g[i-cnt[x]*x]+mo)%mo; &#125; &#125; cnt[x]+=z; if (cnt[x]) &#123; memcpy(gp,g,sizeof(g)); fo(i,0,x-1) gj[i]=gp[i]; fo(i,x,n) &#123; g[i]=(g[i]+gj[i-x])%mo; gj[i]=(gj[i-x]+gp[i])%mo; if (i-cnt[x]*x&gt;=0) gj[i]=(gj[i]-gp[i-cnt[x]*x]+mo)%mo; &#125; &#125;&#125;int Q;int main()&#123; n=10000; f[0]=g[0]=1; scanf(&quot;%d&quot;,&amp;Q); while (Q--) &#123; char ty=ReadChar(); if (ty==&#x27;i&#x27;) &#123; int x=ReadInt(); fd(i,n,x) f[i]=(f[i]+f[i-x])%mo; NewG(x,1); &#125; else if (ty==&#x27;d&#x27;) &#123; int x=ReadInt(); fo(i,x,n) f[i]=(f[i]-f[i-x]+mo)%mo; NewG(x,-1); &#125; else &#123; char now=ReadChar(); int x=ReadInt(); printf(&quot;%lld\\n&quot;,(now==&#x27;T&#x27;) ?f[x] :g[x] ); &#125; &#125;&#125;","categories":[{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[{"name":"算法_DP","slug":"算法-DP","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-DP/"},{"name":"算法_多项式/生成函数","slug":"算法-多项式-生成函数","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E5%A4%9A%E9%A1%B9%E5%BC%8F-%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/"}]},{"title":"THU的有趣的OI面试题","slug":"THU_OI_interview","date":"2017-02-20T08:32:08.000Z","updated":"2024-04-24T03:59:22.797Z","comments":true,"path":"THU_OI_interview/","link":"","permalink":"http://kqp.world/THU_OI_interview/","excerpt":"&emsp;&emsp;由于太过蒟蒻，没能去thuwc2017。&emsp;&emsp;从大神口中得知了一些比较有趣的面试题，于是想做个收集。","text":"&emsp;&emsp;由于太过蒟蒻，没能去thuwc2017。&emsp;&emsp;从大神口中得知了一些比较有趣的面试题，于是想做个收集。 V1&emsp;&emsp;来源：THUWC2017 题目&emsp;&emsp;给你一个长度为 n 的 01 串，求出 1 的个数。 解法&emsp;&emsp;扫一遍是 O(n) 的。忽略读入的话是可以更快的。&emsp;&emsp;压位，比如我把它 16 位压一次，然后做一个 2^16 的预处理，这样时间就变成 n/16 了。&emsp;&emsp;当然，作为面试你还可以这么回（zhuang）答（bi）：“我们可以使用分布式算法，有多少个 node，我们就把这个串平均分成那么多份，然后每个 node 传一份。这样时间就是 $O(\\frac{n}{num(node)})。$” V2&emsp;&emsp;来源：THUWC2017 题目&emsp;&emsp;给定一个随机生成器，它有 p 的概率返回 0，(1-p) 的概率返回 1，其中 p∈(0, 1)。&emsp;&emsp;现在你要构造一个使用这个生成器的算法，使得返回 0 和返回 1 的概率相等。 解法&emsp;&emsp;这题关键是要找到两个东西，它们发生的概率是相同的。&emsp;&emsp;于是我们发现，生成 0 1 的概率跟生成 1 0 的概率是相同的，都是 p(1-p)。&emsp;&emsp;因此我们随机生成两个数 x 和 y，直到 x≠y 为止，然后返回 x。 &emsp;&emsp;（个人感觉这个题妙啊。。。） V3&emsp;&emsp;来源：THUSC2016 题目&emsp;&emsp;有一个长度为奇数的数列，其中只有 1 个数与其他不同。要求你找出这个数。 解法&emsp;&emsp;最直观的是扫一遍，若当前的数与前一个不相同，则根据前后判断一下。&emsp;&emsp;事实上有常数更小的方法，把序列异或起来，得到的就是答案。这样可以用位运算代替 if。","categories":[{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[{"name":"算法_神奇的脑洞","slug":"算法-神奇的脑洞","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E7%A5%9E%E5%A5%87%E7%9A%84%E8%84%91%E6%B4%9E/"}]},{"title":"GDKOI2017蚝油记","slug":"GDKOI2017","date":"2017-02-20T01:24:47.000Z","updated":"2024-04-24T03:59:22.776Z","comments":true,"path":"GDKOI2017/","link":"","permalink":"http://kqp.world/GDKOI2017/","excerpt":"前言&emsp;&emsp;不亏，收获了我想要的。&emsp;&emsp;1、了解了我与高手之间、我与省队之间的差距。&emsp;&emsp;2、收获了一丝自信","text":"前言&emsp;&emsp;不亏，收获了我想要的。&emsp;&emsp;1、了解了我与高手之间、我与省队之间的差距。&emsp;&emsp;2、收获了一丝自信 赛程回顾day0&emsp;&emsp;早上看gdkoi2013、gdkoi2013选拔赛、gdoi2013，算是不想改题于是找些思考吧，发现初一觉得很不可做的题原来是sb题。。 day1&emsp;&emsp;看题：t1，乱做题；t2，是括号序哦，线段树线段树线段树……；t3，什么玩意儿，数学题，polya？？；t4：区间dp加优化，是不是某种决策单调性？？&emsp;&emsp;然后半小时 t1，将近2h打t2，就到11点了。。。后面搞后两题暴力搞不出来。&emsp;&emsp;最后 100+100+10+0 day2&emsp;&emsp;看题：t1，肯定是公式题；t2，某种巧妙的脑洞吧；t3，双sigma带gcd哦。。经典模型；t4，我可能读了假小学。。。&emsp;&emsp;然后，将近2h调t1，搞完之后用dsu搞掉了t2，又到11点了。。。t3没多想写了个带根号的 Mobius，t4暴力又没搞出来。。。&emsp;&emsp;最后 100+50+20+0，t2 因为题意问题丢了 50 分。 应该快一点&emsp;&emsp;本次考试暴露出最大的问题就是一个字： &emsp;&emsp;慢。 &emsp;&emsp;两天都是，搞完前两题就11点了。d1是调t2的线段树，一开始打了3棵，后面又删掉了1棵；d2是调t1的公式，伴随各种逻辑不清晰。&emsp;&emsp;一是代码能力差，狂打错；二是逻辑不清晰，就是打着打着就想错了一些东西，或者漏了一些东西；三是debug能力差，发现一个错误要很久。&emsp;&emsp;多练吧。。。 由稳到凶&emsp;&emsp;这两场很稳，没有说出现noip那种v打成n的错误，也没有脑洞上的错误。就这样每天稳两个题。&emsp;&emsp;但是稳而不凶，表现在每天后两题几乎不得分。&emsp;&emsp;这样的后果就是：能排到不错的名次，但是进不了队。 &emsp;&emsp;像这次题目明显的放水倾向，则高手之间的差距靠每天后两题拉开。像我这种后两题几乎不得分的，就被刷下去了。&emsp;&emsp;很多不是dalao的分数很硬（除去那些因为看错题而水到分的），就是因为他们暴力或水法拿分拿得很凶。 &emsp;&emsp;所以要想尽办法去凶。比如，时间不够的时候果断上暴力，保证题目有分。比如，想不到东西的时候，打水法、随机化什么的。我这个水法得分的能力很差。&emsp;&emsp;如果说很高的部分分的话，那就是能力问题了，所以能力也是很欠缺。 往后其实是未知数&emsp;&emsp;都不知道我能不能进市队呢。。。&emsp;&emsp;都不知道我有没有机会去别的省选呢。。。&emsp;&emsp;都不知道我能不能申请到ctsc/apio呢。。。&emsp;&emsp;都不知道我省赛怎样呢。。。 如果有的话&emsp;&emsp;那就去咯。","categories":[{"name":"总结与游记","slug":"总结与游记","permalink":"http://kqp.world/categories/%E6%80%BB%E7%BB%93%E4%B8%8E%E6%B8%B8%E8%AE%B0/"},{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[]},{"title":"【JZOJ4970】B 题解","slug":"【JZOJ4970】B 题解","date":"2017-02-16T14:39:17.000Z","updated":"2024-04-24T03:59:22.855Z","comments":true,"path":"【JZOJ4970】B 题解/","link":"","permalink":"http://kqp.world/%E3%80%90JZOJ4970%E3%80%91B%20%E9%A2%98%E8%A7%A3/","excerpt":"题目大意&emsp;&emsp;给定 $N, M, K$，数组 $a[N][M], b[N]$。定义 c[i]=\\sum_{j=0}^{N-1}a[j][~b[ij \\bmod N]~]&emsp;&emsp;求第 $K$ 大的 $c[i]$。 &emsp;&emsp;$N \\le 250000$ 且 $N$ 为质数，$2 \\le m \\le 4$&emsp;&emsp;$0 \\le a_{ij} &lt; 1024,\\ 0 \\le b &lt; m$","text":"题目大意&emsp;&emsp;给定 $N, M, K$，数组 $a[N][M], b[N]$。定义 c[i]=\\sum_{j=0}^{N-1}a[j][~b[ij \\bmod N]~]&emsp;&emsp;求第 $K$ 大的 $c[i]$。 &emsp;&emsp;$N \\le 250000$ 且 $N$ 为质数，$2 \\le m \\le 4$&emsp;&emsp;$0 \\le a_{ij} &lt; 1024,\\ 0 \\le b &lt; m$ \\\\ \\\\ \\\\题解&emsp;&emsp;观察式子，发现有两个不好做的地方： $i$ 是乘上 $j$； $b$ 数组是下标。 &emsp;&emsp;所以我们要做一些变化。 &emsp;&emsp;对于 $i=0$ 或 $j=0$，特殊处理掉，以下不考虑。&emsp;&emsp;那么剩下的 $i$ 和 $j$ 都可以用原根的幂来表示了，这样就将乘法化成加法了。设 $i=g^x,\\ j=g^y$&emsp;&emsp;于是原式变成 c[x]=\\sum_{y=1}^{N-1}a[y][~b[(x+y) \\bmod (N-1)]~]&emsp;&emsp;对 $a$ 数组的每一列单独考虑。比如说我们考虑到第 $i$ 列，那我们定义一个 $B$ 数组：$B[j]=(b[j]==i)$&emsp;&emsp;这样原式变成 c_i[x]=\\sum_{y=1}^{N-1}a[y][i] \\cdot B[(x+y) \\bmod (N-1)]&emsp;&emsp;把 $a$ 数组倒过来，即把 $a[y][i]$ 放到 $a[-y][i]$ 的位置上： c_i[x]=\\sum_{y=1}^{N-1}a[-y][i] \\cdot B[x+y]&emsp;&emsp;这样就是个循环卷积了。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#define fo(i,a,b) for(int i=a;i&lt;=b;i++)using namespace std;typedef long long LL;const int maxn=3e5+5, maxlen=6e5+5;const double pi=acos(-1), eps=1e-3;struct Z&#123; double x,y; Z(double X=0, double Y=0) &#123;x=X, y=Y;&#125;&#125;;Z operator +(const Z &amp;a,const Z &amp;b) &#123;return Z(a.x+b.x,a.y+b.y);&#125;Z operator -(const Z &amp;a,const Z &amp;b) &#123;return Z(a.x-b.x,a.y-b.y);&#125;Z operator *(const Z &amp;a,const Z &amp;b) &#123;return Z(a.x*b.x-a.y*b.y,a.x*b.y+a.y*b.x);&#125;int n,m,k,a[maxn][5],b[maxn];LL c[maxn];int len,rv[maxlen];Z W[maxlen],B[maxlen],A[maxlen],tp[maxlen];void DFT(Z *a,int sig)&#123; fo(i,0,len-1) tp[rv[i]]=a[i]; for(int m=2; m&lt;=len; m&lt;&lt;=1) &#123; int hal=m&gt;&gt;1; fo(j,0,hal-1) &#123; Z w=W[(j*(len/m)*sig+len)%len]; for(int k=j; k&lt;len; k+=m) &#123; Z u=tp[k], v=tp[k+hal]*w; tp[k]=u+v; tp[k+hal]=u-v; &#125; &#125; &#125; fo(i,0,len-1) a[i]=tp[i];&#125;void FFT(Z *a,Z *b)&#123; DFT(a,1), DFT(b,1); fo(i,0,len-1) a[i]=a[i]*b[i]; DFT(a,-1); fo(i,0,len-1) a[i].x/=len;&#125;int G[22]=&#123;5,127,509,2039,8191,32749,65521,131071,249989,249973,249971,2,3,2,7,17,2,17,3,2,5,6&#125;;int gx[maxn];void Pre()&#123; int g; fo(i,0,10) if (G[i]==n) &#123;g=G[i+11]; break;&#125; //本题加上样例共11个数据，每个n已列出 gx[0]=1; fo(i,1,n) gx[i]=gx[i-1]*g%n; for(len=1; len&lt;2*n; len&lt;&lt;=1); for(int i=0, j, k, l; i&lt;len; rv[k]=i++) &#123; W[i]=Z(cos(i*2*pi/len),sin(i*2*pi/len)); for(j=i, k=0, l=1; l&lt;len; j&gt;&gt;=1, l&lt;&lt;=1) k=(k&lt;&lt;1)+(j&amp;1); &#125;&#125;int main()&#123; scanf(&quot;%d %d %d&quot;,&amp;n,&amp;m,&amp;k); fo(j,0,m-1) fo(i,0,n-1) scanf(&quot;%d&quot;,&amp;a[i][j]); fo(i,0,n-1) scanf(&quot;%d&quot;,&amp;b[i]); Pre(); fo(i,0,n-1) c[i]+=a[0][b[0]]; fo(j,1,n-1) c[0]+=a[j][b[0]]; fo(i,0,m-1) &#123; fo(j,0,len-1) A[j]=B[j]=Z(0,0); fo(j,1,n-1) &#123; A[j-1]=Z(a[gx[n-j]][i],0); B[j]=(b[gx[j]]==i) ?Z(1,0) :Z(0,0) ; &#125; FFT(A,B); fo(j,0,len-1) c[gx[j%(n-1)]]+=(LL)(A[j].x+0.5); &#125; sort(c,c+n); printf(&quot;%lld\\n&quot;,c[n-k]);&#125;","categories":[{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[{"name":"算法_数论","slug":"算法-数论","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E6%95%B0%E8%AE%BA/"},{"name":"算法_FFT/NTT","slug":"算法-FFT-NTT","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-FFT-NTT/"}]},{"title":"WC2017总结","slug":"WC2017","date":"2017-02-09T12:17:14.000Z","updated":"2024-04-24T03:59:22.799Z","comments":true,"path":"WC2017/","link":"","permalink":"http://kqp.world/WC2017/","excerpt":"&emsp;&emsp;吾之于WC，如蛙之于井底，仰而望天之高，跃而不及地。","text":"&emsp;&emsp;吾之于WC，如蛙之于井底，仰而望天之高，跃而不及地。 Part 1突然开始的WC模拟&emsp;&emsp;noip2016在11月20日结束，经过一段时间的乱搞，我们于12月开始，为期3个月的WC大征途。 &emsp;&emsp;（GD压线进入wc！！？？？实在是蒟蒻一只） &emsp;&emsp;WC这难度。。。比省选不知道高到哪里去了！！！&emsp;&emsp;第一次接触WC的我，一开始的那几场模拟，感觉题题不可做。思维难度各种虐我，高级算法各种嘲讽我，还有突然流行的线性代数，搞得我是一脸懵逼。忽然看到了别有洞天的oi？？？&emsp;&emsp;symbol说，改掉这些题，你的实力会指数级提升。 我是这样想的，noip已经过了，退役前再没机会考水题了，不如趁现在就学会做难题。 这题好难&emsp;&emsp;偶尔能有几场搞到不错的分数。大部分模拟赛垫底或几乎垫底。&emsp;&emsp;首先是看完题根本没思路，不知道往哪里想。按fzr说的，分析题目性质，然后3h没了！？？看下部分分，偶尔能有可观的部分分，大部分是只会最低档的那10分20分的暴力（感觉1年的东西又白学了（不是那个白学））。&emsp;&emsp;noip暴露出分数拿不稳的问题，在模拟赛中没有可观的改进，各种暴力跪。大家都不会正解，都在暴力+优化+水，然后混到很高的分，好多次我想到不错的想法然后打跪了。&emsp;&emsp;感觉永远都有小错误。 我可能考了假联考&emsp;&emsp;然后弄了个四校联考，最后几场还去了学军。 &emsp;&emsp;全场三四十人，我好像从来都是rank20多或者30多，是纪中收尾大队的第一名。&emsp;&emsp;依旧是各种不会。领略了各种脑洞、各种线性代数。有时候考完真心觉得自己脑洞小了那么一点点，或者粗心了那么一点点。但是其实对比一下samjia2000、jasonvictoryan什么的，就真的发现自己脑洞不是一般的小，实在是小得不行。。。 Part 2WC走起&emsp;&emsp;来到绍一，见识了各种dalao，见识了漂亮的宿舍。&emsp;&emsp;听了很多有趣的课，比如物理啦、线代与多项式啦、通信与压缩啦、底层优化啦……&emsp;&emsp;听懂的，有比如border与等差数列、近似算法、突然插入的burnside。两只猫讲的圆方树，感觉ddp讲过？？？&emsp;&emsp;感觉很棒的，是ioi2016题目讨论，day1day2的六个题我一个也切不下来，day0的最后一题也是，但是听了题解之后又觉得十分巧妙。。。大概我这种咸鱼就是搞不来这种巧妙的东西了。松爷的卡常技巧，感觉也是十分的妙。&emsp;&emsp;听不懂的，太多了。。。毛爷一口流利的湖南话介绍一个多项式算法不知道是啥；假老师猪猪侠标准的普通话介绍一个比带花树还快的矩阵求一般图匹配的算法，线代渣表示必须要买本书看看了；wwwwodddd和dkf讲的线代与多项式，我就直接滚粗去看富榄课件了。。。 比赛&emsp;&emsp;终于开始了。&emsp;&emsp;t1，嗯，很正常的传统题，看了没什么想法，部分分有暴力、树、环、环套树、网格图、仙人掌……t2，卡常传统题三合一，原来这场比赛有5题。。。t3，提答，还tm是课上讲过的。。。t2和t3都是随堂小测！！？？？&emsp;&emsp;感觉5h过得就像3h一样快，t1码了前三档，t2码完暴力，t3就居然只弄了8分！！！t3好多点的第一个数据都是可以弄的，全部都没弄，然后t1和t2好像也没什么思路了。。woc比赛结束了！！？？ 评讲&emsp;&emsp;又到了见证自己弱智的时刻了&emsp;&emsp;t1，暴力可以上40分，不明白自己为什么看不出状态数只有那么少。。。然后我打的环和环套树也因为漏考虑了些情况导致挂了。&emsp;&emsp;t2，线性排序居然没想到基数排序！！！这时才回忆起课上讲过的线性+归并思路。。。然后第三个任务居然是 n^2 的暴力加一个 /8 的优化。。。虽然出题人被全场怒婊，但是还是要反思一下我为什么没有梦想，居然不去测一下大数据然后卡一波常。。。&emsp;&emsp;t3，就是反思自己为什么前面做得这么慢了，反正观察数据发现一堆可以做的分。。。&emsp;&emsp;就这样，一只 Cu 终了WC2017。 Part 3收获&emsp;&emsp;三个月超高难度训练结束了，收获也是蛮多的。&emsp;&emsp;最主要的还是做了一通难题带来的收获。首先，通过难题，我算是认识到了更高层的oi境界；其次，做这些难题，对我的思维灵活性、知识量、线代知识带来更高的要求；然后，改这些题，也不断刷新着我对oi的认（xin）识（ren）；最后，我的博客多了一堆以WC为前缀的文章。&emsp;&emsp;其实说到底还是感受到自己还有一大截脑洞要打开，自己还有一堆东西要学。&emsp;&emsp;寒假也做了很多比赛，像cf啦、uoj啦、hackerrank啦，很遗憾没有如计划所写那样自己开两场cf来练练。不过做这种题，感觉我还能咬得动一些，至少想法还是很多的，有时候想出正解不想打，就变成口胡场了。。。&emsp;&emsp;要说WC带来的收获，讲课算是很大的，WC十分明显地摆出了我跟dalao们的差距（他们什么都会，而且很稳，我看了题就没什么想法，并且很不稳）。这个成绩是没什么收获的了，要说有一点，那就是我头一次感受到协议原来离自己辣么近。某群上放大炮说80分能签pku无条件一本，虽然是吃了诈胡，但是真的给了我希望，也逼我更加想办法在赛场上打开脑洞。 接下来&emsp;&emsp;接下来就是省选咯。。中规中矩地，koi练一次，停课搞一波，省选耍一耍，夏令营考一考，然后最后去个noi看看能不能不退役就这样了。&emsp;&emsp;考大学的机会，目前错过了挺多的，反正也没什么办法，不管了。&emsp;&emsp;所以接下来就是要，中规中矩的，努力稳省赛。省赛要是能稳，做什么都顺利。做了3个月难题，不知道以后做省选题会不会觉得简单？&emsp;&emsp;离省队还有一大截，首先把省赛必备的那些知识点在最后这一两个月里搞定，然后通过模拟赛、自己网上找比赛，打开脑洞。详细的计划会今后列出。接下来这个学期，花在oi上的时间应当是更多了。 Part 4 生命不息，竞争不止。——ganxi","categories":[{"name":"总结与游记","slug":"总结与游记","permalink":"http://kqp.world/categories/%E6%80%BB%E7%BB%93%E4%B8%8E%E6%B8%B8%E8%AE%B0/"},{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[]},{"title":"【CF762E】Radio stations 题解","slug":"【CF762E】Radio stations 题解","date":"2017-01-26T04:30:24.000Z","updated":"2024-04-24T03:59:22.838Z","comments":true,"path":"【CF762E】Radio stations 题解/","link":"","permalink":"http://kqp.world/%E3%80%90CF762E%E3%80%91Radio%20stations%20%E9%A2%98%E8%A7%A3/","excerpt":"题目大意&emsp;&emsp;数轴上有 n 个广播站。第 i 个广播站坐标为 x[i]，信号半径为 r[i]，频率为 f[i]。&emsp;&emsp;规定两个广播站 i 和 j（i&lt; j）是可互相到达的，当且仅当 min(r[i], r[j])&lt;=|x[i]-x[j]|&emsp;&emsp;规定两个广播站 i 和 j（i&lt; j）是互相干扰的，当且仅当 i 和 j 可互相到达，且 |f[i]-f[j]|&lt;=k&emsp;&emsp;求有多少对广播站互相干扰。&emsp;&emsp;n&lt;=10^5， k&lt;=10&emsp;&emsp;x[i], r[i]&lt;=10^9， f[i]&lt;=10^4","text":"题目大意&emsp;&emsp;数轴上有 n 个广播站。第 i 个广播站坐标为 x[i]，信号半径为 r[i]，频率为 f[i]。&emsp;&emsp;规定两个广播站 i 和 j（i&lt; j）是可互相到达的，当且仅当 min(r[i], r[j])&lt;=|x[i]-x[j]|&emsp;&emsp;规定两个广播站 i 和 j（i&lt; j）是互相干扰的，当且仅当 i 和 j 可互相到达，且 |f[i]-f[j]|&lt;=k&emsp;&emsp;求有多少对广播站互相干扰。&emsp;&emsp;n&lt;=10^5， k&lt;=10&emsp;&emsp;x[i], r[i]&lt;=10^9， f[i]&lt;=10^4 题解&emsp;&emsp;假设我们把广播站按 r 从大到小排序，那么顺序枚举到第 i 个广播站时，对于 1&lt;=j&lt; i，互相到达的条件就是 x[i]-r[i]&lt;=x[j]&lt;=x[i]+r[i]，也就是说，满足条件的 j 在第一个限制中是一个区间。 &emsp;&emsp;注意到 k 很小，f 也很小。所以我们从这里入手。&emsp;&emsp;对每个 f 都建一棵以 x 为轴的线段树。然后把广播站按 r 从大到小的顺序插入。对于第 i 个广播站的询问，枚举 j 所在的 f，这个最多只有 2k+1 次枚举，所以每次询问最多查找 2k+1 棵线段树。&emsp;&emsp;在线段树里我们是查找区间 [x[i]-r[i], x[i]+r[i]] 里有多少个点。","categories":[{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[{"name":"算法_偏序关系","slug":"算法-偏序关系","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E5%81%8F%E5%BA%8F%E5%85%B3%E7%B3%BB/"}]},{"title":"【WC2017四校联考5】B君的宴请 题解","slug":"【WC2017四校联考5】B君的宴请 题解","date":"2017-01-25T03:10:40.000Z","updated":"2024-04-24T03:59:22.870Z","comments":true,"path":"【WC2017四校联考5】B君的宴请 题解/","link":"","permalink":"http://kqp.world/%E3%80%90WC2017%E5%9B%9B%E6%A0%A1%E8%81%94%E8%80%835%E3%80%91B%E5%90%9B%E7%9A%84%E5%AE%B4%E8%AF%B7%20%E9%A2%98%E8%A7%A3/","excerpt":"题目大意&emsp;&emsp;n 把椅子排成一个环。&emsp;&emsp;现在要撤掉一部分，使得只剩下恰好 k 把椅子，并且剩下的任意两把椅子原先不相邻。&emsp;&emsp;若两种方案可以经过旋转、翻转互相等价，则认为本质相同。&emsp;&emsp;求本质不同的方案数 $\\bmod 10^9+7$","text":"题目大意&emsp;&emsp;n 把椅子排成一个环。&emsp;&emsp;现在要撤掉一部分，使得只剩下恰好 k 把椅子，并且剩下的任意两把椅子原先不相邻。&emsp;&emsp;若两种方案可以经过旋转、翻转互相等价，则认为本质相同。&emsp;&emsp;求本质不同的方案数 $\\bmod 10^9+7$ 一个比较“正统”的思路&emsp;&emsp;首先把撤与不撤看作是01染色，0 表示撤，1 表示保留。 &emsp;&emsp;考虑 burnside 引理。&emsp;&emsp;置换群大小为 2n，包括 n 个旋转置换和 n 个旋转+翻转置换。 &emsp;&emsp;考虑 n 个旋转置换的不动点。&emsp;&emsp;对于第 i 个旋转置换（0&lt;= i &lt;=n-1），只有前面 d=gcd(i,n) 个元素可自由选择颜色。所以模型变成：长度为 d 的序列，我要分配 k’ 个黑色进去，要求任意两个黑色不相邻，且头尾不能同时为黑，的方案数。&emsp;&emsp;（这里因为原序列被划分成 n/d 段，所以这里 k’=k/(n/d)，如果不能整除则视为该置换下不动点为 0。）&emsp;&emsp;那么这个模型就是一个组合数模型了。先不考虑头尾的限制。类似于挡板原理，我们把作为间隔的 k’-1 个白点抽出来，则 k’ 个黑点就没有不相邻的限制了，所以方案数就是 $C_{d-(k’-1)}^{k’}$。如果考虑头尾限制，则用总的减去头尾同时为黑的方案数，头尾同时为黑意味着次头和次尾同时为白，所以方案数是 $C_{(d-4)-((k’-2)-1)}^{k’-2}$ &emsp;&emsp;考虑 n 个旋转+翻转置换的不动点。我们知道旋转+翻转置换可以等价为翻转置换。&emsp;&emsp;n 为奇数时，对称轴穿过一个点和一个空隙，设这个点为 A。由于空隙旁的两个点相邻，所以他们必为白色。若 k 为奇数，则 A 为黑色，A 的下一个点为白色，所以方案数是 $C_{(\\lfloor\\frac{n}{2}\\rfloor-2)-(\\lfloor\\frac{k}{2}\\rfloor-1)}^{\\lfloor\\frac{k}{2}\\rfloor}$。若 k 为偶数，则 A 为白色，方案数类似。&emsp;&emsp;n 为偶数时，对称轴有两种，各有 n/2 条。一种是穿过两个点的，一种是穿过两个空隙的。分析方法类似，第一种对称轴要讨论 k 的奇偶性，第二种对称轴则要求 k 必须是偶数，否则为0。 一个大家都想到的思路&emsp;&emsp;这里就直接搬题解了。 &emsp;&emsp;首先考虑 k 个椅子之间的一个置换（而不是像通常那样考虑 n 个椅子的情况）&emsp;&emsp;对于 k=1 和 k=2，可以直接计算答案。&emsp;&emsp;对于更大的 k 的情况，同样需要计算旋转和轴对称。&emsp;&emsp;如果 k 个椅子的位置确定，那么接下来的步骤就是将 n-k 个将要被撤掉的椅子，放进 k 个椅子的间隔中，使得每个间隔中至少有一个椅子。&emsp;&emsp;旋转的情况比较简单，就是和最大公约数相关。&emsp;&emsp;如果是轴对称的话，还需要根据 k 的奇偶性进行迚一步的讨论。&emsp;&emsp;如果 k 是奇数，那么对称之后一定是(k-1)/2 对 和 单独的一个点&emsp;&emsp;如果 k 是偶数，那么对称后可能是 k/2 对，还可能是 k/2-1 对和 2 个单独的点 代码//用第一种方法的12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;cstdio&gt;#define fo(i,a,b) for(int i=a;i&lt;=b;i++)using namespace std;typedef long long LL;const int maxn=1e6+5;const LL mo=1e9+7;int n,k;LL gcd(LL a,LL b) &#123;return (b) ?gcd(b,a%b) :a ;&#125;LL mi(LL x,LL y)&#123; LL re=1; for(; y; y&gt;&gt;=1, x=x*x%mo) if (y&amp;1) re=re*x%mo; return re;&#125;LL fac[maxn],ny[maxn];LL C(LL n,LL m)&#123; if (n&lt;0 || m&lt;0) return 0; return fac[n]*ny[m]%mo*ny[n-m]%mo;&#125;int main()&#123; scanf(&quot;%d %d&quot;,&amp;n,&amp;k); if (n==1 || k==0) &#123;printf(&quot;1\\n&quot;); return 0;&#125; fac[0]=ny[0]=1; fo(i,1,n) fac[i]=fac[i-1]*i%mo, ny[i]=mi(fac[i],mo-2)%mo; LL ans=0; fo(i,1,n) &#123; LL d=gcd(i,n); if (k%(n/d)!=0) continue; int kk=k/(n/d); if (d==1) continue; ans=(ans+C(d-(kk-1),kk)-C(d-4-(kk-3),kk-2)+mo)%mo; &#125; if (n&amp;1) &#123; if (k&amp;1) ans=(ans+C(n/2-2-(k/2-1),k/2)*n%mo)%mo; else ans=(ans+C(n/2-1-(k/2-1),k/2)*n%mo)%mo; &#125; else &#123; if (k%2==0) ans=(ans+C(n/2-2-(k/2-1),k/2)*(n/2)%mo)%mo; if (k&amp;1) &#123; ans=(ans+C(n/2-2-(k/2-1),k/2)*n%mo)%mo; &#125; else &#123; ans=(ans+(C(n/2-1-(k/2-1),k/2)+C(n/2-3-((k-2)/2-1),(k-2)/2))%mo*(n/2)%mo)%mo; &#125; &#125; ans=ans*mi(n*2,mo-2)%mo; printf(&quot;%lld\\n&quot;,ans);&#125;","categories":[{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[{"name":"算法_群论","slug":"算法-群论","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E7%BE%A4%E8%AE%BA/"}]},{"title":"【WC2017四校联考2】看门狗 题解","slug":"【WC2017四校联考2】看门狗 题解","date":"2017-01-24T07:51:42.000Z","updated":"2024-04-24T03:59:22.869Z","comments":true,"path":"【WC2017四校联考2】看门狗 题解/","link":"","permalink":"http://kqp.world/%E3%80%90WC2017%E5%9B%9B%E6%A0%A1%E8%81%94%E8%80%832%E3%80%91%E7%9C%8B%E9%97%A8%E7%8B%97%20%E9%A2%98%E8%A7%A3/","excerpt":"题目大意&emsp;&emsp;一棵树有 n 个节点，根是 1。每条边有个长度。&emsp;&emsp;对于每个点 i，给出 L[i] 和 R[i]，求以点 i 为根的子树中，边数在 [ L[i], R[i] ] 内的路径的最长长度。若不存在则为-1。&emsp;&emsp;输出$\\sum_{i=1}^n23333^{n-i}Ans[i]~mod~998244353$&emsp;&emsp;n&lt;=10^6， 边权&lt;=10^9","text":"题目大意&emsp;&emsp;一棵树有 n 个节点，根是 1。每条边有个长度。&emsp;&emsp;对于每个点 i，给出 L[i] 和 R[i]，求以点 i 为根的子树中，边数在 [ L[i], R[i] ] 内的路径的最长长度。若不存在则为-1。&emsp;&emsp;输出$\\sum_{i=1}^n23333^{n-i}Ans[i]~mod~998244353$&emsp;&emsp;n&lt;=10^6， 边权&lt;=10^9 首先的思路&emsp;&emsp;枚举点对的其中一个点，然后用数据结构找到另一个点，使得答案最大。这个数据结构可以用线段树什么的。&emsp;&emsp;然后这个就可以启发式合并。 第一种写法&emsp;&emsp;正常的启发式合并，自底向上合并。&emsp;&emsp;log^2，并且常数挺大。 第二种写法&emsp;&emsp;像树链剖分一样的那种启发式合并。&emsp;&emsp;先划分轻重链。对于每个点，先递归轻儿子，再递归重儿子，然后枚举轻儿子合并一下。若当前节点是它父亲的重儿子，则信息保留，否则信息清空。（即信息保留的原则是：轻儿子清空，重儿子保留）&emsp;&emsp;log^2，常数小。 优化&emsp;&emsp;注意答案只跟深度有关。&emsp;&emsp;所以划分轻重链时的依据应是深度（即长链剖分）。枚举轻儿子的时候，不必要枚举每一个点，而是枚举每一个深度。&emsp;&emsp;合并是 n 次的，再加上数据结构就是一个log了。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define fo(i,a,b) for(int i=a;i&lt;=b;i++)using namespace std;typedef long long LL;const int maxn=1e6+5;const LL mo=998244353;int n,l[maxn],r[maxn];int tot,go[maxn],next[maxn],f1[maxn];LL val[maxn];void ins(int x,int y,LL z)&#123; go[++tot]=y; val[tot]=z; next[tot]=f1[x]; f1[x]=tot;&#125;int deep[maxn],size[maxn],Hson[maxn],maxr;LL a[maxn];void dfs_size(int k,int last,LL s) //这里的size是以深度为标准的&#123; size[k]=deep[k]=deep[last]+1; maxr=max(maxr,deep[k]); a[k]=s; for(int p=f1[k]; p; p=next[p]) &#123; dfs_size(go[p],k,s+val[p]); size[k]=max(size[k],size[go[p]]); if (size[go[p]]&gt;size[Hson[k]]) Hson[k]=go[p]; &#125;&#125;LL tr[4*maxn];bool bz[4*maxn];void update(int k,int t)&#123; if (bz[k]==0) return; tr[t]=tr[t+1]=-1; bz[t]=bz[t+1]=1; bz[k]=0;&#125;void tr_xg(int k,int l,int r,int x,LL z)&#123; if (l==r) &#123; tr[k]=max(tr[k],z); return; &#125; int t=k&lt;&lt;1, t1=(l+r)&gt;&gt;1; update(k,t); if (x&lt;=t1) tr_xg(t,l,t1,x,z); else tr_xg(t+1,t1+1,r,x,z); tr[k]=max(tr[t],tr[t+1]);&#125;LL tr_cx(int k,int l,int r,int x,int y)&#123; if (x&gt;y) return -1; if (l==x &amp;&amp; r==y) return tr[k]; int t=k&lt;&lt;1, t1=(l+r)&gt;&gt;1; update(k,t); if (y&lt;=t1) return tr_cx(t,l,t1,x,y); else if (x&gt;t1) return tr_cx(t+1,t1+1,r,x,y); else return max(tr_cx(t,l,t1,x,t1), tr_cx(t+1,t1+1,r,t1+1,y));&#125;LL ans;LL mi(LL x,LL y)&#123; LL re=1; for(; y; y&gt;&gt;=1, x=x*x%mo) if (y&amp;1) re=re*x%mo; return re;&#125;LL sum,nowbh[maxn],depmax[maxn]; //为了不至于每次都清空depmax，于是用时间标记。void dfs1(int k)&#123; depmax[deep[k]]=(nowbh[deep[k]]&lt;sum) ?a[k] :max(depmax[deep[k]],a[k]) ; nowbh[deep[k]]=sum; for(int p=f1[k]; p; p=next[p]) dfs1(go[p]);&#125;void dfs(int k)&#123; for(int p=f1[k]; p; p=next[p]) if (go[p]!=Hson[k]) &#123; dfs(go[p]); bz[1]=1; &#125; if (Hson[k]) &#123; dfs(Hson[k]); LL ans1=-1; LL t=tr_cx(1,1,maxr,l[k]+deep[k],min(r[k]+deep[k],maxr)); if (t&gt;-1) ans1=t-a[k]; tr_xg(1,1,maxr,deep[k],a[k]); for(int p=f1[k]; p; p=next[p]) if (go[p]!=Hson[k]) &#123; ++sum; dfs1(go[p]); fo(i,deep[go[p]],size[go[p]]) &#123; LL t=tr_cx(1,1,maxr,max(1,l[k]+2*deep[k]-i),min(r[k]+2*deep[k]-i,maxr)); if (t&gt;-1) ans1=max(ans1,depmax[i]+t-a[k]*2); &#125; fo(i,deep[go[p]],size[go[p]]) tr_xg(1,1,maxr,i,depmax[i]); &#125; ans1%=mo; ans=(ans+mi(23333,n-k)*ans1%mo+mo)%mo; &#125; else &#123; tr_xg(1,1,maxr,deep[k],a[k]); ans=(ans-mi(23333,n-k)%mo+mo)%mo; &#125;&#125;int main()&#123; scanf(&quot;%d&quot;,&amp;n); fo(i,1,n) scanf(&quot;%d %d&quot;,&amp;l[i],&amp;r[i]); fo(i,2,n) &#123; int u; LL c; scanf(&quot;%d %lld&quot;,&amp;u,&amp;c); ins(u,i,c); &#125; dfs_size(1,0,0); memset(tr,255,sizeof(tr)); memset(bz,255,sizeof(bz)); dfs(1); printf(&quot;%lld\\n&quot;,ans);&#125;","categories":[{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[{"name":"算法_启发式合并","slug":"算法-启发式合并","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E5%90%AF%E5%8F%91%E5%BC%8F%E5%90%88%E5%B9%B6/"}]},{"title":"【WC2017四校联考3】优美的树 题解","slug":"【WC2017四校联考3】优美的树 题解","date":"2017-01-17T14:03:17.000Z","updated":"2024-04-24T03:59:22.869Z","comments":true,"path":"【WC2017四校联考3】优美的树 题解/","link":"","permalink":"http://kqp.world/%E3%80%90WC2017%E5%9B%9B%E6%A0%A1%E8%81%94%E8%80%833%E3%80%91%E4%BC%98%E7%BE%8E%E7%9A%84%E6%A0%91%20%E9%A2%98%E8%A7%A3/","excerpt":"题目大意&emsp;&emsp;众所周知，树是n 个节点n-1 条边的结构，而所谓的优美的树需要满足如下条件：&emsp;&emsp;1. 这是一棵有根二叉树；&emsp;&emsp;2. 非叶节点需有两个儿子；&emsp;&emsp;3. 不可以变换为k-左偏树。&emsp;&emsp;所谓的k-左偏树是指一棵有k 个叶子的树，每个非叶节点的右儿子均为叶子且均有左儿子。&emsp;&emsp;所谓的变换指的是经过若干次如下两种变换：&emsp;&emsp;1. 删去一个节点的两个儿子；&emsp;&emsp;2. 用一个节点的某个儿子替换该节点。&emsp;&emsp;如下图，若k=3 则这不是一棵优美的树。&emsp;&emsp;现在给你k 和n，想要你求出叶子数为1,2,3…n 的优美的树分别有多少。&emsp;&emsp;n,k&lt;=5000","text":"题目大意&emsp;&emsp;众所周知，树是n 个节点n-1 条边的结构，而所谓的优美的树需要满足如下条件：&emsp;&emsp;1. 这是一棵有根二叉树；&emsp;&emsp;2. 非叶节点需有两个儿子；&emsp;&emsp;3. 不可以变换为k-左偏树。&emsp;&emsp;所谓的k-左偏树是指一棵有k 个叶子的树，每个非叶节点的右儿子均为叶子且均有左儿子。&emsp;&emsp;所谓的变换指的是经过若干次如下两种变换：&emsp;&emsp;1. 删去一个节点的两个儿子；&emsp;&emsp;2. 用一个节点的某个儿子替换该节点。&emsp;&emsp;如下图，若k=3 则这不是一棵优美的树。&emsp;&emsp;现在给你k 和n，想要你求出叶子数为1,2,3…n 的优美的树分别有多少。&emsp;&emsp;n,k&lt;=5000 【30%】n,k&lt;=500&emsp;&emsp;设 $f[i][j]$ 表示有 n 叶子节点、向左深度最大为 j 的这种形态的树的数量。&emsp;&emsp;转移就是枚举两棵树合并。&emsp;&emsp;卡下常数好像能70分。 【100%】&emsp;&emsp;首先去掉那 n+1 个叶子节点，这样就去掉了每个节点一定要有两个儿子的限制。（woc我怎么就想不到）&emsp;&emsp;按先序遍历的顺序来dp。（woc我怎么就想不到×2）&emsp;&emsp;设 $f[i][j]$ 表示先序遍历到了第 i 个节点，从 1 到 i 的向左深度为 j，的方案数。转移就是枚举下一个点放哪，可以放自己的左儿子，也可以放祖先（包括）的右儿子。&emsp;&emsp;有多少祖先缺右儿子呢？其实，我们向左走了 j 步，就相当于有 j 个祖先缺右儿子。（woc我怎么就想不到×3） 代码1234567891011121314151617181920212223242526272829#include&lt;cstdio&gt;#define fo(i,a,b) for(int i=a;i&lt;=b;i++)#define fd(i,a,b) for(int i=a;i&gt;=b;i--)using namespace std;typedef long long LL;const int maxn=5005;const LL mo=1e9+9;int n,k;LL f[maxn][maxn],g[maxn][maxn];int main()&#123; scanf(&quot;%d %d&quot;,&amp;k,&amp;n); n--; k-=2; g[0][0]=1; fo(i,1,n) &#123; fo(j,1,k) f[i][j]=g[i-1][j-1]; fd(j,k,0) g[i][j]=(g[i][j+1]+f[i][j])%mo; &#125; printf(&quot;1\\n&quot;); fo(i,1,n) printf(&quot;%lld\\n&quot;,g[i][1]);&#125;","categories":[{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[{"name":"算法_DP","slug":"算法-DP","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-DP/"}]},{"title":"【搬自bzoj4423】【JZOJ3839】Baby Step 题解","slug":"【搬自bzoj4423】【JZOJ3839】Baby Step 题解","date":"2017-01-13T13:08:04.000Z","updated":"2024-04-24T03:59:22.875Z","comments":true,"path":"【搬自bzoj4423】【JZOJ3839】Baby Step 题解/","link":"","permalink":"http://kqp.world/%E3%80%90%E6%90%AC%E8%87%AAbzoj4423%E3%80%91%E3%80%90JZOJ3839%E3%80%91Baby%20Step%20%E9%A2%98%E8%A7%A3/","excerpt":"题目大意&emsp;&emsp;有一个大小为 R*R 的网格图。&emsp;&emsp;n 次操作，每次炸掉一条边，然后问炸掉的这条边连的两个点是否还连通。&emsp;&emsp;强制在线。&emsp;&emsp;R&lt;=500","text":"题目大意&emsp;&emsp;有一个大小为 R*R 的网格图。&emsp;&emsp;n 次操作，每次炸掉一条边，然后问炸掉的这条边连的两个点是否还连通。&emsp;&emsp;强制在线。&emsp;&emsp;R&lt;=500 解法&emsp;&emsp;这题学到了一个不错的套路。 &emsp;&emsp;题目就是一个无向图，动态删边，问连通性。&emsp;&emsp;对于一般无向图没什么规律，而对于网格图就不同了。因为网格图是平面图，平面图的删边相当于其对偶图的连边。&emsp;&emsp;所以就是把原图的对偶图弄出来，一开始对偶图上的点都不连通。如果在原图上删一条边，就在对偶图上连上相应的边。如果在对偶图连边之前，要连的两点已经联通，就说明原图的那条边是桥。&emsp;&emsp;所以一个并查集就搞完了。","categories":[{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[{"name":"算法_图论","slug":"算法-图论","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E5%9B%BE%E8%AE%BA/"}]},{"title":"【JZOJ4937】与运算 题解","slug":"【JZOJ4937】与运算 题解","date":"2017-01-12T14:03:00.000Z","updated":"2024-04-24T03:59:22.854Z","comments":true,"path":"【JZOJ4937】与运算 题解/","link":"","permalink":"http://kqp.world/%E3%80%90JZOJ4937%E3%80%91%E4%B8%8E%E8%BF%90%E7%AE%97%20%E9%A2%98%E8%A7%A3/","excerpt":"题目大意&emsp;&emsp;对于一个序列 $a_1,\\cdots,a_n$，定义 $f_i$ 表示序列前 $i$ 项依次进行按位与运算后的值。一个序列的价值为 $\\sum_{i=1}^n f_i$。&emsp;&emsp;现在给你一个序列 $a_1,\\cdots,a_n$，你需要把它重新排列，使得序列价值尽量大。&emsp;&emsp;$n, a_i \\le 10^6$","text":"题目大意&emsp;&emsp;对于一个序列 $a_1,\\cdots,a_n$，定义 $f_i$ 表示序列前 $i$ 项依次进行按位与运算后的值。一个序列的价值为 $\\sum_{i=1}^n f_i$。&emsp;&emsp;现在给你一个序列 $a_1,\\cdots,a_n$，你需要把它重新排列，使得序列价值尽量大。&emsp;&emsp;$n, a_i \\le 10^6$ 解法&emsp;&emsp;一个序列的 $f$ 值一定是成段的，可以根据这个进行 dp。设 $g[i]$ 表示当前 $f$ 值为 $i$ 的时候的最大答案。那么转移就是枚举一个 $j$，然后 $g[i]=max(g[j]+i*(cnt[i]-cnt[j]))$，其中 $cnt[x]$ 表示有多少个 $a[i]$ 包含了 $x$ 这个状态。 &emsp;&emsp;所以现在其实就是要求 $cnt$，可以用分治来求。（UPD：若干年过去了，现在知道这东西叫高维前缀和） 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;cstdio&gt;#include&lt;algorithm&gt;#define fo(i,a,b) for(int i=a;i&lt;=b;i++)#define fd(i,a,b) for(int i=a;i&gt;=b;i--)using namespace std;typedef long long LL;const int maxn=1e6+5, MX=25, maxN=2e6+5;int n,N,a[maxn],er[MX];LL f[maxN]; //这里的f就是上述的cntvoid dfs_f(int l,int r)&#123; if (l==r) return; int mid=(l+r)&gt;&gt;1; dfs_f(l,mid), dfs_f(mid+1,r); int enc=mid+1-l; fo(i,l,mid) f[i]+=f[i+enc];&#125;LL g[maxN];int main()&#123; scanf(&quot;%d&quot;,&amp;n); N=(1&lt;&lt;20)-1; fo(i,1,20) er[i]=1&lt;&lt;(i-1); fo(i,1,n) scanf(&quot;%d&quot;,&amp;a[i]); fo(i,1,n) f[a[i]]++; dfs_f(0,N); fd(i,N-1,0) fo(j0,1,20) if ((i&amp;er[j0])==0) &#123; int j=i|er[j0]; g[i]=max(g[i],g[j]+i*(f[i]-f[j])); &#125; printf(&quot;%lld\\n&quot;,g[0]);&#125;","categories":[{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[{"name":"算法_DP","slug":"算法-DP","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-DP/"}]},{"title":"【JZOJ3987】Tree 题解","slug":"【JZOJ3987】Tree 题解","date":"2017-01-07T14:50:31.000Z","updated":"2024-04-24T03:59:22.848Z","comments":true,"path":"【JZOJ3987】Tree 题解/","link":"","permalink":"http://kqp.world/%E3%80%90JZOJ3987%E3%80%91Tree%20%E9%A2%98%E8%A7%A3/","excerpt":"题目大意 &emsp;&emsp;$N \\le 5000$&emsp;&emsp;$V, T &lt; LIMIT \\le 10^5$","text":"题目大意 &emsp;&emsp;$N \\le 5000$&emsp;&emsp;$V, T &lt; LIMIT \\le 10^5$ 【测试点1~3】N&lt;=2000， T=0&emsp;&emsp;暴力。 【测试点4~6】N&lt;=2000， LIMIT, T&lt;=100&emsp;&emsp;先枚举 C。 &emsp;&emsp;求平均肯定先二分，二分完之后相当于要选一些路径，然后每条路径减去一个值，最后判断是否大于一个值。&emsp;&emsp;设 $f_{i,0/1/2}$ 表示：以 i 为根的子树，0 表示点 i 不选，1 表示点 i 选了并且将来还要往上走，2 表示点 i 选了并且将来不往上走（即有条路径在点 i 处转弯）&emsp;&emsp;转移比较显然。 【测试点7~12】N&lt;=1000， LIMIT, T&lt;=10^5&emsp;&emsp;发现 C 不能枚举了。&emsp;&emsp;可是，比如我现在有个 C，而所有的 V[i]+C 都不等于 LIMIT-1，那就说明我这个 C 肯定不是最优的。&emsp;&emsp;因此有用的 C 最多只有 N 个。 &emsp;&emsp;dp照常。 【测试点13~20】N&lt;=5000&emsp;&emsp;上述方法被卡常了。&emsp;&emsp;优化1：对于每个 C （已经最多 N 个了），在做二分之前先假设 mid 是当前的 ans，用二分的判断函数判断一下是否可行，若不可行则continue。这样可以去掉很多无用的二分。&emsp;&emsp;优化2：用随机大法打乱 C 的枚举顺序，据说这样期望变成了 $O(n \\log n)$。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define fo(i,a,b) for(int i=a;i&lt;=b;i++)#define fd(i,a,b) for(int i=a;i&gt;=b;i--)using namespace std;const int maxn=5005, maxL=1e5+5;const double eps=1e-8;int n,L,v[maxn],T;int tot,go[2*maxn],next[2*maxn],f1[maxn];void ins(int x,int y)&#123; go[++tot]=y; next[tot]=f1[x]; f1[x]=tot;&#125;double f[maxn][3],g[maxn],Mid;void dfs(int k,int last,int c)&#123; double rl=((v[k]+c)%L)/Mid, fir=0, sec=0, sum=0; for(int p=f1[k]; p; p=next[p]) if (go[p]!=last) &#123; dfs(go[p],k,c); sum+=g[go[p]]; double t=f[go[p]][1]-g[go[p]]; if (t-fir&gt;eps) &#123; sec=fir; fir=t; &#125; else if (t-sec&gt;eps) sec=t; &#125; f[k][0]=sum; f[k][1]=sum+fir+rl; f[k][2]=sum+fir+sec+rl; g[k]=max(f[k][0],max(f[k][1]-1,f[k][2]-1));&#125;bool check(double mid,double c)&#123; Mid=mid; memset(f,0,sizeof(f)); memset(g,0,sizeof(g)); dfs(1,0,c); return (g[1]&gt;1);&#125;int vt[maxn],vt0;//存可能的Cbool bz[maxL];int main()&#123; srand(101); scanf(&quot;%d %d&quot;,&amp;n,&amp;L); fo(i,1,n) scanf(&quot;%d&quot;,&amp;v[i]); fo(i,1,n-1) &#123; int x,y; scanf(&quot;%d %d&quot;,&amp;x,&amp;y); ins(x,y), ins(y,x); &#125; scanf(&quot;%d&quot;,&amp;T); vt[++vt0]=0; vt[++vt0]=T; fo(i,1,n) &#123; v[i]%=L; if (L-1-v[i]&lt;=T &amp;&amp; !bz[v[i]]) vt[++vt0]=L-1-v[i], bz[v[i]]=1; &#125; random_shuffle(vt+1,vt+1+vt0);//优化2 double ans=0; fo(ci,1,vt0) &#123; if (!check(ans,vt[ci])) continue;//优化1 double l=0, r=(double)n*(L-1); while (l+eps&lt;=r) &#123; double mid=(l+r)/2; if (check(mid,vt[ci])) l=mid+eps; else r=mid-eps; &#125; ans=max(ans,l-eps); &#125; printf(&quot;%.7f\\n&quot;,ans);&#125;","categories":[{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[{"name":"算法_DP","slug":"算法-DP","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-DP/"},{"name":"算法_随机大法","slug":"算法-随机大法","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E9%9A%8F%E6%9C%BA%E5%A4%A7%E6%B3%95/"}]},{"title":"【51nod 1055 & 1056】最长等差数列及V2 题解","slug":"【51nod 10551056】最长等差数列及V2 题解","date":"2017-01-07T14:29:24.000Z","updated":"2024-04-24T03:59:22.821Z","comments":true,"path":"【51nod 10551056】最长等差数列及V2 题解/","link":"","permalink":"http://kqp.world/%E3%80%9051nod%2010551056%E3%80%91%E6%9C%80%E9%95%BF%E7%AD%89%E5%B7%AE%E6%95%B0%E5%88%97%E5%8F%8AV2%20%E9%A2%98%E8%A7%A3/","excerpt":"V1题目大意&emsp;&emsp;$n$ 个不同的正整数，找出由这些数组成的最长的等差数列。&emsp;&emsp;$n \\le 10000,\\ a_i \\le 10^9$","text":"V1题目大意&emsp;&emsp;$n$ 个不同的正整数，找出由这些数组成的最长的等差数列。&emsp;&emsp;$n \\le 10000,\\ a_i \\le 10^9$ 【$O(n^3)$】&emsp;&emsp;设 $f_{i,j}$ 表示：以第 $i$ 项和第 $j$ 项（$i&gt;j$）作为数列最后两项，的最长长度。 &emsp;&emsp;转移就是找一个 $k$，使得 $a_i-a_j=a_j-a_k$，然后就 $f_{i,j}=f_{j,k}+1$。 &emsp;&emsp;三个变量的枚举，所以是 $O(n^3)$。 【$O(n^2 \\log n)$】&emsp;&emsp;我们观察，枚举了 $i$ 和 $j$ 之后，$a_k$ 的值是确定的。&emsp;&emsp;那么搞个东西存下对于每个 $j$ 同一类的 $k$ 的最大 $f$ 值就好了。&emsp;&emsp;如果一开始离散化这个数组，那可以二分求这个 $k$，所以带个 $\\log$。 【$O(n^2)$】&emsp;&emsp;实际上不需要离散化也不需要二分，因为如果 $j$ 从大到小枚举，那么 $k$ 是单调递减的。&emsp;&emsp;于是就 $O(n^2)$ 了。 V2题目大意&emsp;&emsp;$n$ 个不同的正整数，问是否存在由这些数组成的等差数列长度 $\\ge 200$。若没有，输出无解，若有，输出最长长度&emsp;&emsp;$n \\le 50000,\\ a_i \\le 10^9$ 【随机大法】&emsp;&emsp;我同桌说，看到 $\\ge 200$ 这种东西，应当要考虑近似算法。 &emsp;&emsp;随机两个下标作为数列的中间两项，然后往两边扩展。做一次的时间是 $O(n)$。&emsp;&emsp;然后不能随机太多，也不要随机重复，所以把数组打乱顺序，取前面大概1000组就可以了。 &emsp;&emsp;如果要求的长度过小（比如 3），那这个算法是很难找出来的，但 200 的话还是可以的。","categories":[{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[{"name":"算法_DP","slug":"算法-DP","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-DP/"},{"name":"算法_随机大法","slug":"算法-随机大法","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E9%9A%8F%E6%9C%BA%E5%A4%A7%E6%B3%95/"}]},{"title":"Good Bye 了 2016","slug":"sum2016","date":"2016-12-31T15:59:50.000Z","updated":"2024-04-24T03:59:22.794Z","comments":true,"path":"sum2016/","link":"","permalink":"http://kqp.world/sum2016/","excerpt":"&emsp;&emsp;恰逢cf有场比赛叫 good bye 2016，借此作标题。&emsp;&emsp;这不是cf题解，这是年终总结。 我为此加个“了”字来区分了。","text":"&emsp;&emsp;恰逢cf有场比赛叫 good bye 2016，借此作标题。&emsp;&emsp;这不是cf题解，这是年终总结。 我为此加个“了”字来区分了。 是的呢&emsp;&emsp;已经到12月31了呢。&emsp;&emsp;好高兴好鸡冻哦，自己又走过一年了。更目标明确地说，自己又当了一年OIer了呢！&emsp;&emsp;今年这个OI历程，真的很难忘（虽然每一年其实都很难忘），发生了很多事情，这个人也是改变了很多。2016年，我的年级从高一升到高二，经历的比赛从gdkoi2016到noip2016，水平从智障到智障……这样一来，真的又很多感慨油然而生呢！ 划分阶段1月到2月：备战gdkoi&emsp;&emsp;这段时间，刚经历了noip2015，那时的自己算是半个智障，noip之前临时抱佛脚才学了个倍增求lca（想想自己都高一了才学这个真的是害羞），加之水平不够等各种原因，noip2015考了个压线1=。&emsp;&emsp;所以这段时间，我处于noip组水平以上gdkoi组水平以下，一个非常尴尬的分组，感觉会的很多，做起题来又啥都不会。选啥组都比较尴尬。&emsp;&emsp;另外专题已经开始推了。感谢gdoi2016专题训练，使我领悟到高境界。 &emsp;&emsp;最终gdkoi的时候，我记得我还是很有梦想的，但最后考下来才知道我到底是个怎样的菜鸡（51名好像）。当时一场考试使我顿然醒悟，明白了自己跟省队水平的差距，感觉自己领悟了一丝OI题的奥妙。 3月到5月：省赛+apio&emsp;&emsp;自从这场koi，我深刻意识到努力方向：知识性缺漏太多，需要恶补专题；思维性缺漏太大，需要脑洞大开。&emsp;&emsp;3到4月是冲省队集训时间。这个时期真的对我是个巨大的提升，因为樊神组织了高一专题推进，我也是在这个时候真正的彻底的搞掉了一些专题，感觉自己的学识一下子上升了不少。感觉自己领悟了一丝OI题的奥妙×2。&emsp;&emsp;虽然到后面4月末，高二回来一起做最后几套gdoi模拟的时候，依然被虐成菜鸡，但是那时的自己，心里是有底的，我明白自己对于省赛知识已经掌握了个基本，只要考场上脑洞灵光，进队是真的有可能的。 &emsp;&emsp;然后，gdoi2016就来了！怀着自信，笑望蓝天进场。&emsp;&emsp;结果day1就炸了。day1才30分，宣告高一赛季结束。当时整个人特别懵逼，不明白为啥连中学生数学题那样的d1t1也只能搞10分出来。想了想可能是各种脑残原因吧就不管这么多，day2day3结果还不错。整场下来总排四十几。&emsp;&emsp;考完整场之后做了很多总结，反思了好几星期。感觉自己领悟了一丝OI题的奥妙×3，也更清晰了自己离省队的距离，自己这个差距若大若小，想想自己还有个高二，也就突然有了奋斗的信念。 &emsp;&emsp;然后就来了个apio。算了这个没什么好说的，感觉自己那菜鸡模样就是去玩的。&emsp;&emsp;也不是没用意义，毕竟人生第一次走进thu校园，感受到了高校的美好（美+好）。走出大门的那一刻，给自己立下了无限的flag。 5月到6月：和平度过高一尾声&emsp;&emsp;因为是高一，所以没进省队就要回去补文化课了，跟OI若即若离。所以这段时间就这样飘飘地~~飘过去了。&emsp;&emsp;这两个月领了暑假noip专题任务。怀着从头再来的信念，我开始认认真真地搞专题，毕竟是我第一次负责专题啊。&emsp;&emsp;参加了很多网络赛，codejam、baidu star、jisuanke……，一开始只是想要件衣服，然后发现打这些比赛挺好玩的，从此爱上网络赛。（虽然好像前两个结果不太好）&emsp;&emsp;这两个月不知道有没有提升实力。我思考了很多脑洞题，包括很多水题，更多的是在总结dp（专题任务）。 7月到8月：高二赛季开始了！&emsp;&emsp;亦可赛艇！！&emsp;&emsp;7月集训+8月集训，又是一次实力大提升。首先，做了很多gdoi模拟，每天都是做题改题做题改题……发挥不错的时候能考到ran1。我相信是找到了做gdoi模拟的一丝感觉。&emsp;&emsp;学会了写博客。&emsp;&emsp;自己讲了dp专题，也听了别人的noip专题，然后发现只有我把noip专题做成了noi难度。然后这些好像收获都不大啊。。。倒是听栋栋的《根号算法》有点收获。&emsp;&emsp;中间休息的20天要出一套省赛题和一套联赛题，因为不想总是搬搬搬，就搞了很多时间。体会到了出(ban)题人的辛苦，但也更能看透一个题的本质、考点什么的。&emsp;&emsp;中间还去了计(pian)蒜(chi)客(pian)决(he)赛，打了一次AI，发现自己始终还是咸鱼。。。&emsp;&emsp;中间还做了noi2016同步赛，感觉自己始终还是咸鱼。。。&emsp;&emsp;在bol哥的指引下学会了列计划。在同学们的指引下学会了打codeforces。&emsp;&emsp;光荣地入了 LL 教&emsp;&emsp;两个月就这么过去了。。。感觉自己领悟了一丝OI题的奥妙×4。临走时领了gdoi2017专题任务——数论。 9月到11月：noip2016&emsp;&emsp;初赛满分，给我带来喜悦，也让我立下了noip要上500的flag。&emsp;&emsp;然后就停课了。&emsp;&emsp;感觉停课这段时间状态出奇地好，只要考简单题rank就挺高。心想着现在做简单题应当是没什么问题了，这次的flag也应当能实现了。&emsp;&emsp;也没去钻研很难的专题，但是既然省赛专题又开始了，我也就去听，不过这次讲的就比上一次难很多了，听不懂的我果断放了。心想着要好好锻炼脑洞为主，于是就把还没搞懂的记录下来，打算noip以后再搞，唯一有钻研的是数论，毕竟我要讲。。。 &emsp;&emsp;noip2016就来了！&emsp;&emsp;noip2016就这样砸了！！！各种小失误，包括太激动没拍，v 打成 n，没开精度，等等，什么问题都有。&emsp;&emsp;考了399分，比上年才高29分，广东排到71，全国就不用说了，本来指望为自己冲省队垫块砖的，结果现在成了拖后腿。有点感觉这一年都白搭了。&emsp;&emsp;反思了很久，总结了很多，然后伤心，失落，然后给自己明确了今后的目标。发现离省队水平越来越近了，但是自己总是要犯各种各样的小问题，无论是OI还是文化课，都是这样，会做的总是做错。这我很苦恼。&emsp;&emsp;但无论如何，noip就过去了。bol哥态度也很明确，我们就是一路走下去没错的。其实我清楚，无论我现在多么失魂落魄，我也已经是有实力的人了，憋足一口气，鼓足干劲，力争上游，明年省赛冲出来，这是唯一的选择了！！！ &emsp;&emsp;然后GD就被扣了两个名额，我发现自己压力越来越大了。。。 11月到12月：呜呜呜~&emsp;&emsp;noip以后的时光基本上是在惆怅中度过的了。毕竟noip还是考差了的，然后段考也不咋地。&emsp;&emsp;本想打算按计划来的，好好补专题，做脑洞，结果因为文化课等原因一拖再拖，拖到12月终于搞完了自己的专题。开始搞别人的专题以及给自己下训练任务。好像也没搞到多少啊。。&emsp;&emsp;做wc模拟赛，巨难，几场下来基本都垫底。&emsp;&emsp;这个星期刚刚学会FFT。。。&emsp;&emsp;打了cf的goodbye2016，结果手速渣坑得我啊。。。连hack的机会都没了&emsp;&emsp;然后，2016就结束了。 真的不平凡呢&emsp;&emsp;我其实真的从一个菜鸡提升到了半个菜鸡啊！！2016年，我的水平提升了很多，2016年1月1日我很懵懂，碰见难题就是个mengbier。经过一次又一次集训，一次又一次大赛，我不断地升华对OI的认识，不断思索樊神教我的做题策略和思维模式，不停地刷新自己的解题思维体系。发现自己的认知真的深了，成熟了。&emsp;&emsp;这年和去年一样，不平凡，因为这两年我迈的步伐特别大。我深刻感受到了郑桦所谓的“初中浪高中恶补”的辛苦，感觉我走上了他的老路。但他成功了，我还是个未知数。。。&emsp;&emsp;头一次吧，头一次感到每场比赛都是有压力的，毕竟自己剩下的比赛越来越少了。然而今年重要的比赛我基本都挂了，这让我有些心痛吧，还是很不平凡的呢~ 真的感谢&emsp;&emsp;真的感谢2016，带给了我很多。。。&emsp;&emsp;感谢bol哥，感谢403的dalao们，感谢gd省以及四处给予过我帮助的dalao们。 HELLO！！黄金拼图HELLO！！2017！！","categories":[{"name":"总结与游记","slug":"总结与游记","permalink":"http://kqp.world/categories/%E6%80%BB%E7%BB%93%E4%B8%8E%E6%B8%B8%E8%AE%B0/"}],"tags":[]},{"title":"【CF741C】Arpa's overnight party and Mehrdad's silent entering 题解","slug":"【CF741C】Arpa's overnight party and Mehrdad's silent entering 题解","date":"2016-12-14T14:39:33.000Z","updated":"2024-04-24T03:59:22.838Z","comments":true,"path":"【CF741C】Arpa's overnight party and Mehrdad's silent entering 题解/","link":"","permalink":"http://kqp.world/%E3%80%90CF741C%E3%80%91Arpa's%20overnight%20party%20and%20Mehrdad's%20silent%20entering%20%E9%A2%98%E8%A7%A3/","excerpt":"题目大意&emsp;&emsp;有 n 对情侣坐在 2n 个板凳上，板凳排成环形。每张凳子恰好坐一个人。&emsp;&emsp;现在有两种食物分给他们。规定：1、每对情侣中，俩人不能分到同一种食物；2、环上任意三个相邻的人，不能全分到同一种食物。&emsp;&emsp;给出情侣关系，请构造一种方案或输出 -1。&emsp;&emsp;n&lt;=10^5","text":"题目大意&emsp;&emsp;有 n 对情侣坐在 2n 个板凳上，板凳排成环形。每张凳子恰好坐一个人。&emsp;&emsp;现在有两种食物分给他们。规定：1、每对情侣中，俩人不能分到同一种食物；2、环上任意三个相邻的人，不能全分到同一种食物。&emsp;&emsp;给出情侣关系，请构造一种方案或输出 -1。&emsp;&emsp;n&lt;=10^5 题解&emsp;&emsp;大体思路是：我给这幅图连边，然后 01 染色，成功则输出方案，不成功则输出 -1。定义两个点直接相连表示这两点不同色。&emsp;&emsp;（最后会发现一定有解） &emsp;&emsp;首先，有情侣关系的两个点肯定是要连边的了。&emsp;&emsp;考虑环上相邻三个点的连边情况，只有以下三种情况（不考虑这三个点中的情侣关系）：&emsp;&emsp;会发现，一定会有一条边连着相邻的两个点。那我们考虑直接在相邻的点上连边。 &emsp;&emsp;于是构造方法如下：首先情侣连边，然后在原图的相邻点对上，隔一对连一条边，形如：（蓝边表示情侣连边，红边表示相邻点对隔一对连一条） &emsp;&emsp;为什么要隔一对连一条？因为这样可以限制每个点的度数最多为2，即图上的环全是简单环。&emsp;&emsp;为什么这样没有奇环？因为如果有奇环，那么奇环上必有相邻的两条边同色。而根据定义，红边和蓝边都不可能相邻。","categories":[{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[{"name":"算法_构造题","slug":"算法-构造题","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E6%9E%84%E9%80%A0%E9%A2%98/"}]},{"title":"【JZOJ4916】完全背包问题 题解","slug":"【JZOJ4916】完全背包问题 题解","date":"2016-12-10T09:01:15.000Z","updated":"2024-04-24T03:59:22.853Z","comments":true,"path":"【JZOJ4916】完全背包问题 题解/","link":"","permalink":"http://kqp.world/%E3%80%90JZOJ4916%E3%80%91%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%20%E9%A2%98%E8%A7%A3/","excerpt":"题目大意&emsp;&emsp;有 $n$ 种物品，体积分别为 $v_1,\\cdots,v_n$，每种物品无限个。&emsp;&emsp;现在有 $m$ 次询问，每次询问给定一个容量为 $w$ 的背包，问是否存在一种物品选择方案，使背包恰好装满。同时，要求所选物品中，体积不小于 $L$ 的物品总数量不超过 $C$ 件。&emsp;&emsp;$n \\le 50,\\ \\ m \\le 10^5,\\ \\ w \\le 10^{18}$&emsp;&emsp;$v_i \\le 10000,\\ \\ L \\le 20000,\\ \\ C \\le 30$","text":"题目大意&emsp;&emsp;有 $n$ 种物品，体积分别为 $v_1,\\cdots,v_n$，每种物品无限个。&emsp;&emsp;现在有 $m$ 次询问，每次询问给定一个容量为 $w$ 的背包，问是否存在一种物品选择方案，使背包恰好装满。同时，要求所选物品中，体积不小于 $L$ 的物品总数量不超过 $C$ 件。&emsp;&emsp;$n \\le 50,\\ \\ m \\le 10^5,\\ \\ w \\le 10^{18}$&emsp;&emsp;$v_i \\le 10000,\\ \\ L \\le 20000,\\ \\ C \\le 30$ 题解&emsp;&emsp;设 $n$ 种物品中最小的是 $v_1$。&emsp;&emsp;若 $v_1 \\ge L$，即全是大件物品，那么总体积不超过 $\\max{v_i} \\cdot C$，用暴力一点的 dp 搞掉。以下讨论 $v_1 &lt; L$ 的情况。 &emsp;&emsp;经典套路：设 $dp_{i,j}$ 表示：用了 $j$ 件大件物品和若干小件物品，使得体积 $\\bmod v_1$ 等于 $i$ ，的最小体积。询问答案的时候直接看 $dp_{w\\ \\bmod\\ v_1, 0\\cdots C}$ 是否小于等于 $w$ 即可。（因为如果存在合法方案，那么这个合法方案去掉 $v_1$ 的物品之后必然满足总体积 $\\le w$ 且体积 $\\bmod v_1 = w \\bmod v_1$ 且大件物品不超过 $C$）&emsp;&emsp;然后观察这个转移，我们选大件物品的话，转移到 $j+1$ 没什么问题，但是如果选小件物品，就会出现后效性，即这个转移路径是个环。&emsp;&emsp;这里有两种解决方法：第一种是把 dp 转移看成最短路问题，跑个 dijkstra 或者 spfa；第二种是，观察发现转移中出现的环都是简单环，假设是体积 $V_1 \\to V_2 \\to V_3 \\to \\cdots \\to V_1$，那么这些 $V$ 中必有一个 dp 值最小的 $V_x$，它不可能从 $V_{x-1}$ 转移而来，这样就破环为链了，可以顺序 dp 了。","categories":[{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[{"name":"算法_DP","slug":"算法-DP","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-DP/"},{"name":"算法_最短路模型","slug":"算法-最短路模型","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E6%9C%80%E7%9F%AD%E8%B7%AF%E6%A8%A1%E5%9E%8B/"}]},{"title":"【noip2016】换教室 题解","slug":"【noip2016】换教室 题解","date":"2016-12-03T09:12:06.000Z","updated":"2024-04-24T03:59:22.862Z","comments":true,"path":"【noip2016】换教室 题解/","link":"","permalink":"http://kqp.world/%E3%80%90noip2016%E3%80%91%E6%8D%A2%E6%95%99%E5%AE%A4%20%E9%A2%98%E8%A7%A3/","excerpt":"题目大意&emsp;&emsp;给出一幅 v 个点的无向图，表示教室及其连边。&emsp;&emsp;有 n 个时刻，每个时刻正常要到教室 c[i] 上课，如果该时刻有申请更换，则到教室 d[i] 上课。&emsp;&emsp;你只能在一切开始之前提交申请，且最多申请换 m 个时刻。第 i 个时刻申请成功的概率为 k[i]。&emsp;&emsp;求移动路程的期望最小值。&emsp;&emsp;n,m&lt;=2000， v&lt;=300","text":"题目大意&emsp;&emsp;给出一幅 v 个点的无向图，表示教室及其连边。&emsp;&emsp;有 n 个时刻，每个时刻正常要到教室 c[i] 上课，如果该时刻有申请更换，则到教室 d[i] 上课。&emsp;&emsp;你只能在一切开始之前提交申请，且最多申请换 m 个时刻。第 i 个时刻申请成功的概率为 k[i]。&emsp;&emsp;求移动路程的期望最小值。&emsp;&emsp;n,m&lt;=2000， v&lt;=300 对于那副图的处理&emsp;&emsp;Floyd求出任意两点最短路，然后那幅图就没用了。 dp&emsp;&emsp;一开始我设的是 $f[i][j][0/1]$ 表示，到第 i 个时刻，已经申请了 j 次，第 i 个时刻是否换教室，的最小期望。&emsp;&emsp;这样推一推就发现是错的了。因为申请与否跟最终换不换教室是两回事。 &emsp;&emsp;所以应该设 $f[i][j][0/1]$ 表示，到第 i 个时刻，已经申请了 j 次，第 i 个时刻是否申请，的最小期望。&emsp;&emsp;然后这样就相当于 i-1 的 0 和 1 两个点，转移到 i 的 0 和 1 两个点。总共四种转移，每种转移的期望代价就考虑一下多大概率是从 c[i-1] 来、多大概率从 d[i-1] 来，多大概率到 c[i] 去、多大概率到 d[i] 去，然后相应地乘上最短路即可。 告诉我v、n打反的不止我一个&emsp;&emsp;T^T&emsp;&emsp;QAQ 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define fo(i,a,b) for(int i=a;i&lt;=b;i++)#define fd(i,a,b) for(int i=a;i&gt;=b;i--)using namespace std;typedef long long LL;const int maxn=2005, maxv=305;const LL inf=1e11;int n,m,v,e,rm[maxn][2];double k[maxn];int dis[maxv][maxv];void Floyd()&#123; fo(k,1,v) fo(i,1,v) if (i!=k &amp;&amp; dis[i][k]&lt;dis[0][0]) fo(j,1,v) if (j!=i &amp;&amp; j!=k &amp;&amp; dis[k][j]&lt;dis[0][0] &amp;&amp; dis[i][j]&gt;dis[i][k]+dis[k][j]) dis[i][j]=dis[i][k]+dis[k][j];&#125;double Min(double x,double y)&#123; if (x&gt;inf &amp;&amp; y&gt;inf) return inf; if (x&gt;inf) return y; if (y&gt;inf) return x; if (x&lt;y) return x; else return y;&#125;double f[maxn][maxn][2];int main()&#123; freopen(&quot;classroom.in&quot;,&quot;r&quot;,stdin); freopen(&quot;classroom.out&quot;,&quot;w&quot;,stdout); scanf(&quot;%d %d %d %d&quot;,&amp;n,&amp;m,&amp;v,&amp;e); fo(i,1,n) scanf(&quot;%d&quot;,&amp;rm[i][0]); fo(i,1,n) scanf(&quot;%d&quot;,&amp;rm[i][1]); fo(i,1,n) scanf(&quot;%lf&quot;,&amp;k[i]); memset(dis,127,sizeof(dis)); fo(i,1,e) &#123; int x,y,w; scanf(&quot;%d %d %d&quot;,&amp;x,&amp;y,&amp;w); dis[x][y]=min(dis[x][y],w); dis[y][x]=min(dis[y][x],w); &#125; fo(i,1,v) dis[i][i]=0; Floyd(); fo(i,1,n) fo(j,0,m) fo(c,0,1) f[i][j][c]=inf; f[1][0][0]=f[1][1][1]=0; fo(i,2,n) fo(j,0,m) fo(c,0,1) &#123; double t=k[i-1]*dis[rm[i-1][1]][rm[i][0]]+(1-k[i-1])*dis[rm[i-1][0]][rm[i][0]]; f[i][j][0]=Min(f[i-1][j][0]+dis[rm[i-1][0]][rm[i][0]],f[i-1][j][1]+t); if (j) &#123; double t1=k[i]*dis[rm[i-1][0]][rm[i][1]]+(1-k[i])*dis[rm[i-1][0]][rm[i][0]]; t=k[i-1]*k[i]*dis[rm[i-1][1]][rm[i][1]]+(1-k[i-1])*k[i]*dis[rm[i-1][0]][rm[i][1]]; t+=k[i-1]*(1-k[i])*dis[rm[i-1][1]][rm[i][0]]+(1-k[i-1])*(1-k[i])*dis[rm[i-1][0]][rm[i][0]]; f[i][j][1]=Min(f[i-1][j-1][0]+t1,f[i-1][j-1][1]+t); &#125; &#125; double ans=inf; fo(j,0,m) ans=min(ans,Min(f[n][j][0],f[n][j][1])); printf(&quot;%.2f\\n&quot;,ans);&#125;","categories":[{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[{"name":"算法_DP","slug":"算法-DP","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-DP/"},{"name":"算法_概率与期望","slug":"算法-概率与期望","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E6%A6%82%E7%8E%87%E4%B8%8E%E6%9C%9F%E6%9C%9B/"}]},{"title":"noip2016退役记","slug":"noip2016","date":"2016-11-26T03:50:15.000Z","updated":"2024-04-24T03:59:22.786Z","comments":true,"path":"noip2016/","link":"","permalink":"http://kqp.world/noip2016/","excerpt":"我终究还是一个不会发挥的人呵。 退役了&emsp;&emsp;学oi五年了，没上400。 &emsp;&emsp;考这次noip，集训了三周，三周展现出很好的发挥水平，偶尔会有很尴尬的情况。然后上考场，成了又一次偶尔。&emsp;&emsp;然后这个分吧，确实成了别人的优势，接下来wc、apio什么的会很难申请，省赛先被拖了一截。","text":"我终究还是一个不会发挥的人呵。 退役了&emsp;&emsp;学oi五年了，没上400。 &emsp;&emsp;考这次noip，集训了三周，三周展现出很好的发挥水平，偶尔会有很尴尬的情况。然后上考场，成了又一次偶尔。&emsp;&emsp;然后这个分吧，确实成了别人的优势，接下来wc、apio什么的会很难申请，省赛先被拖了一截。 赛程&emsp;&emsp;day1：看完题马上意识到今年画风突变。题目难度是1-&gt;3-&gt;2，然后就这个顺序来做。t1很顺利，t3一开始方程设得不对，后来经历1h多，在边思考边实践的情况下得出正解，搞完就10点半了。此时t2想到一个要打很长的95分算法，于是赶紧打了，最后11点40没调完。 &emsp;&emsp;day2：看完题马上意识到今天才是真·day1。t1看着题目中的公式就想复杂了，9点45才搞完。t2看着暴力有六七十就先打了，t3看着暴力也有六七十就顺手加了个优化。打完就发现快结束了。 丢分点严重性排序&emsp;&emsp;1、d1t3的Floyd把 v 打成 n，丢分约100，运气好可以只丢60。&emsp;&emsp;2、d2t3没加精度，丢分约20~100，看出题人心情。&emsp;&emsp;3、d1t2写的95分程序没调完，最后交暴力，丢分约75。&emsp;&emsp;3、d2t2不会，丢分约40。（现在应该要把这题列入能力之内了） 一些理解情绪化&emsp;&emsp;高二的noip，挺重要也挺珍贵的，稍不留神oi生涯就全没了。然后就不停地告诉自己稍不留神就跪了……这就是严重的情绪化。&emsp;&emsp;“研究表明，过高或过低的情绪化，是粗心率最高的阶段。”&emsp;&emsp;这貌似可以解释为什么我d1t3会把 v 打成 n 了。一开始超级严肃，所以想出t3之后很开心，得意忘形。这么激动根本不会注意到打错。。。&emsp;&emsp;省赛怎么办？压力比这次noip还大。&emsp;&emsp;也没什么大赛给我去尝试新的调整办法了，所以解决方法就是少点关注自己为什么写错，而是关注自己写错了以后如何检查出来。 拍的意义&emsp;&emsp;首先，拍不是万能的，有各种各样的错误是拍不能检查出来的。&emsp;&emsp;但是出于两个原因，拍成为最高效的调试手段。一是它可以快速找出大部分问题，包括算法整体问题和细节问题。二是在打拍的过程中，也就是再写一遍的过程中，会突然意识到之前没意识到的东西。这一点是常被忽略的。&emsp;&emsp;这次d1t3出于时间紧迫，暴力的很多东西是我直接复制源代码的，这使我丧失了重打代码的机会。我一直想，如果让我得以重新打一遍Floyd，我会不会就发现了循环变量打错这一问题？我觉得是会的。 关于细节处理&emsp;&emsp;就是说想到一些小问题时，写下来（草稿纸或者记事本），然后码完后一条条对着加。&emsp;&emsp;这次d2t3想到精度问题就是没记下来，后来就忘了。&emsp;&emsp;感觉自己好懒，这些问题懒得记，最后后悔什么都没加。 关于失误&emsp;&emsp;其实总结这么多会犯错误的方面，仍然是不知道下次会犯什么错误。&emsp;&emsp;但我知道下一次肯定还会犯错误，几乎不可避免地，错大错小也未知。&emsp;&emsp;所以保证最后得分可观，还有方法就是把硬实力分搞上去，留给自己失误的成本，或者叫给自己丢分留余地，用难题的得分去弥补水题的失分。&emsp;&emsp;富爷也会失误，但是他失误了还有500分，而我失误了就只有300分，这就是最直观的，也是最根本的差别。 后记&emsp;&emsp;朝前看，只剩省赛。&emsp;&emsp;noip挂了就挂了，但是省赛存在翻盘的可能性。&emsp;&emsp;然后我要做的就是把这个可能性搞到最大，具体就是提升水平，提升自己不犯错误的能力。&emsp;&emsp;进入省赛准备阶段，按照计划进行。","categories":[{"name":"总结与游记","slug":"总结与游记","permalink":"http://kqp.world/categories/%E6%80%BB%E7%BB%93%E4%B8%8E%E6%B8%B8%E8%AE%B0/"},{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[]},{"title":"noip考前大总结","slug":"noip考前大总结","date":"2016-11-16T14:52:23.000Z","updated":"2024-04-24T03:59:22.787Z","comments":true,"path":"noip考前大总结/","link":"","permalink":"http://kqp.world/noip%E8%80%83%E5%89%8D%E5%A4%A7%E6%80%BB%E7%BB%93/","excerpt":"三周的模拟赛&emsp;&emsp;应该说，做出了很好的水平，有超过90\\%的noip模拟赛和约60\\%的省选模拟赛rank靠前。有ak的场，有被我艹到很高分的难题。用以前的话来说就是“状态空前的好”。 &emsp;&emsp;省赛模拟不稳，有3场垫底或近乎垫底，有一场rank中等。我做难题对于思维的依赖程度很高，一旦发现不到什么东西就几乎什么分都拿不到了。&emsp;&emsp;noip模拟很稳。对于最后几场难度与noip接近的模拟，基本保持着前两题全切的状态。能切的题没拿到分的情况共发生2次。","text":"三周的模拟赛&emsp;&emsp;应该说，做出了很好的水平，有超过90\\%的noip模拟赛和约60\\%的省选模拟赛rank靠前。有ak的场，有被我艹到很高分的难题。用以前的话来说就是“状态空前的好”。 &emsp;&emsp;省赛模拟不稳，有3场垫底或近乎垫底，有一场rank中等。我做难题对于思维的依赖程度很高，一旦发现不到什么东西就几乎什么分都拿不到了。&emsp;&emsp;noip模拟很稳。对于最后几场难度与noip接近的模拟，基本保持着前两题全切的状态。能切的题没拿到分的情况共发生2次。 省赛知识学习&emsp;&emsp;主要是专题和模拟赛。专题，现在讲完了网络流和数据结构，字符串也讲了一些了，我是没有全部都听的，像讲LCT以上的东西（比如toptree）的时候，鉴于我目前为止splay都没码过，果断弃了。&emsp;&emsp;专题和模拟赛落下的知识点，还是有的。noip以后，思维锻炼不再是迫在眉睫，所以会集中精力补知识，包括专题精学和oj填坑计划。 现状&emsp;&emsp;这两个多月（尤其是9月）很喜欢想问题，常在排队、回宿舍时挂上一些题（偶尔会是哲学）。当然由于才这样不久，思维水平未展现出预期效果，此行为用处如何还需以后验证。&emsp;&emsp;码速和代码正确率均有提升，其中码速提升不明显，主要体现在打的时候思维乱，打着打着就不知道要干什么了。从最后的几场比赛来看，一次打对的正确率有较大提升，通过一系列措施使最后得分不出失误的概率有较大提升。&emsp;&emsp;思考速度和程度还是对题目难度、精神状态有一定的依赖性。现阶段对问题的分析往往把握不到重点，对条件及各种性质的分析能力不够，对各种问题的应对措施（包括模型转换、套路应用、方法出现偏差等）不够。&emsp;&emsp;心态不稳。临近比赛结束会不自主地紧张，或多或少影响了最后难题的思考（不过偶尔也会是促进作用）。与原来认知有偏差时会有点慌。&emsp;&emsp;与更高层次人群相比，知识尚有缺漏，而且不小。 对于noip&emsp;&emsp;我相信，上述的“不够”对于noip来说还是够的。&emsp;&emsp;noip最主要还是得稳，体现在送的题和送的部分分一定要全拿。若按照去年难度来讲，每天前两题应当是要稳拿的了，第三题就算就算拿不到100至少也要去到第三档部分分。 &emsp;&emsp;知识储备相对noip来说应是没有问题的。只要能灵活运用好那些数据结构、公式定理，然后能够一针见血地发现题目本质，就可以了。关键是不要被已有知识卡死，不要耗死在一些小问题上。&emsp;&emsp;实现操作上，对于代码正确率的把控，我还不算很稳，之前往往程序没打对，也没能留出充足的时间做验证步骤。但结合最近的模拟赛看来，这个问题严重性已得到下降。 比赛常见问题总结&emsp;&emsp;问题：&emsp;&emsp;1、对于noip模拟：前两题在会的情况下码速不够，直接断送第三题的高分机会。&emsp;&emsp;2、偶尔会有没判0、爆栈等丢个5分10分的错误，偶尔会有&emsp;&emsp;3、看到一道题好像会做，一激动就把时间全花在上面了。&emsp;&emsp;4、临近结束，一慌起来，连暴力都不会打。&emsp;&emsp;5、由于时间复杂度估计错误而导致正解不敢打。&emsp;&emsp;6、由于多余的变量查看、数据画图过多等多余步骤引起的时间浪费。 &emsp;&emsp;措施：&emsp;&emsp;1、适当提高一点码速，打代码时保持清醒的头脑，时刻明确自己正在干什么、自己要干什么。&emsp;&emsp;2、选择最恰当的方法来码。那句话说得好：“每多一行代码，就多一次把 i 打成 j 的机会。”方法以正确、简洁为优，冗余代码一定去除。&emsp;&emsp;3、多方法调试。眼调、输出调、拍、各种小数据测。时刻警醒拍真的不是万能的。&emsp;&emsp;4、控制好情绪，看题不激动，结束不慌张。深呼吸，念“南无地藏王菩萨”。&emsp;&emsp;5、要有梦想。打目前想到的最优的方法，无论能否过（如果是暴力要顺手加优化）。注意各个版本的程序的存档。&emsp;&emsp;6、出了bug先整体感知，不要一上来就断点。","categories":[{"name":"总结与游记","slug":"总结与游记","permalink":"http://kqp.world/categories/%E6%80%BB%E7%BB%93%E4%B8%8E%E6%B8%B8%E8%AE%B0/"},{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[]},{"title":"【JZOJ4893】过河 题解","slug":"【JZOJ4893】过河 题解","date":"2016-11-14T13:16:58.000Z","updated":"2024-04-24T03:59:22.853Z","comments":true,"path":"【JZOJ4893】过河 题解/","link":"","permalink":"http://kqp.world/%E3%80%90JZOJ4893%E3%80%91%E8%BF%87%E6%B2%B3%20%E9%A2%98%E8%A7%A3/","excerpt":"题目大意&emsp;&emsp;有条河，河的一岸是直线 y=0，另一岸是直线 y=w，长度无限。&emsp;&emsp;河上有 n 个木桩，坐标为 (x[i],y[i])，每个木桩上可以搭一个圆盘。共有 m 种圆盘，每种半径为 r[i]，价格为 c[i]。圆盘可以伸到岸上。&emsp;&emsp;两个圆盘连通当且仅当相切或相交。&emsp;&emsp;问如何搭圆盘，能以最小的价格从河的一岸走到另一岸。若走不到则-1。&emsp;&emsp;数据组数&lt;=10；n,m&lt;=250；w,x,r&lt;=10^9；y&lt;=w；c&lt;=10^6","text":"题目大意&emsp;&emsp;有条河，河的一岸是直线 y=0，另一岸是直线 y=w，长度无限。&emsp;&emsp;河上有 n 个木桩，坐标为 (x[i],y[i])，每个木桩上可以搭一个圆盘。共有 m 种圆盘，每种半径为 r[i]，价格为 c[i]。圆盘可以伸到岸上。&emsp;&emsp;两个圆盘连通当且仅当相切或相交。&emsp;&emsp;问如何搭圆盘，能以最小的价格从河的一岸走到另一岸。若走不到则-1。&emsp;&emsp;数据组数&lt;=10；n,m&lt;=250；w,x,r&lt;=10^9；y&lt;=w；c&lt;=10^6 样例&emsp;&emsp;类似这样 【60%】n,m&lt;=35&emsp;&emsp;拆点。每个木桩搭配每种盘子都作为一个点，则一共有 n×m 个点。&emsp;&emsp;再暴力把边连上，跑最短路。 【另25%】所有x=0&emsp;&emsp;相当于所有点在一条轴上，那就搞个dp。&emsp;&emsp;设 f[i][j] 表示第 i 个桩，放第 j 种盘，的最小代价。转移时加些前缀优化就可以做到3次方。 【100%】n,m&lt;=250&emsp;&emsp;考虑60分的那个最短路模型，关键就是要把边的数量压下来。&emsp;&emsp;首先，如果有盘子半径比别人小，价格又比别人贵，肯定是没用的。用排序加单调栈去掉这些盘子，这样盘子就单调了。&emsp;&emsp;一个点表示为 (a,b)，表示第 a 个桩放第 b 种圆盘。&emsp;&emsp;我们观察可得，连边最浪费的就是，假设 (a,b) 要连向 (c,d)，那所有可能的 d 都要连一次。想想，我们如果连向第 d 种盘子，那就已经代表了比它大的盘子都可以连，这就可以去掉一些冗边。&emsp;&emsp;所以对于 (a,b) 连向第 c 个桩，我们只连半径最小的 d。然后对于每个点 (a,b)，向 (a,b+1) 连一条长度为 c[b+1]-c[b] 的边（当然这里的盘子是排好序的）。这样就实现了上述想法，并且把边数压到了 n^2m。 代码&emsp;&emsp;//其实边数还是很大，这种图应当要用Dijkstra，但是我写了spfa。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define fo(i,a,b) for(int i=a;i&lt;=b;i++)using namespace std;typedef long long LL;const int maxn=255, maxp=63000, maxe=18e6+5;const double sml=1e-7;struct P&#123; int r,c;&#125;;bool cmp(const P &amp;a,const P &amp;b) &#123;return a.r&lt;b.r || a.r==b.r &amp;&amp; a.c&gt;b.c;&#125;int n,m,w,sum,x[maxn],y[maxn];P p1[maxn],p[maxn];int tot,go[maxe],val[maxe],next[maxe],f1[maxp];void ins(int x,int y,int z)&#123; go[++tot]=y; val[tot]=z; next[tot]=f1[x]; f1[x]=tot;&#125;double DIS(int a,int b)&#123; return sqrt((double)(x[a]-x[b])*(x[a]-x[b])+(double)(y[a]-y[b])*(y[a]-y[b]));&#125;LL dis[maxp],inf;int d[8*maxp];bool bz[maxp];void spfa()&#123; memset(dis,127,sizeof(dis)); dis[0]=0; inf=dis[1]; bz[0]=1; d[1]=0; int maxi=7*maxp; for(int i=1, j=1, ii=1, jj=1; ii&lt;=jj; ii++, i=i%maxi+1) &#123; for(int p=f1[d[i]]; p; p=next[p]) if (dis[go[p]]&gt;dis[d[i]]+val[p]) &#123; dis[go[p]]=dis[d[i]]+val[p]; if (!bz[go[p]]) &#123; jj++; j=j%maxi+1; bz[ d[j]=go[p] ]=1; if (dis[d[i%maxi+1]]&gt;dis[d[j]]) swap(d[i%maxi+1],d[j]); &#125; &#125; bz[d[i]]=0; &#125;&#125;int T;int main()&#123; scanf(&quot;%d&quot;,&amp;T); while (T--) &#123; scanf(&quot;%d %d %d&quot;,&amp;n,&amp;m,&amp;w); sum=n*m+1; fo(i,1,n) scanf(&quot;%d %d&quot;,&amp;x[i],&amp;y[i]); fo(i,1,m) scanf(&quot;%d %d&quot;,&amp;p1[i].r,&amp;p1[i].c); sort(p1+1,p1+1+m,cmp); int m0=0; fo(i,1,m) &#123; p[++m0]=p1[i]; while (m0&gt;1 &amp;&amp; p[m0-1].r&lt;=p[m0].r &amp;&amp; p[m0-1].c&gt;=p[m0].c) &#123; m0--; p[m0]=p[m0+1]; &#125; &#125; m=m0; tot=0; memset(f1,0,sizeof(f1)); fo(i,1,n) fo(j,1,n) if (i!=j) &#123; double ds=DIS(i,j)-sml; int jm=m+1; fo(im,1,m) &#123; while (jm&gt;1 &amp;&amp; ds&lt;=(LL)p[im].r+p[jm-1].r) jm--; if (jm &amp;&amp; jm&lt;=m) ins((i-1)*m+im,(j-1)*m+jm,p[jm].c); &#125; &#125; fo(i,1,n) fo(im,1,m) &#123; if (p[im].r&gt;=y[i]) ins(0,(i-1)*m+im,p[im].c); if (p[im].r&gt;=w-y[i]) ins((i-1)*m+im,sum,0); if (im&lt;m) ins((i-1)*m+im,(i-1)*m+im+1,p[im+1].c-p[im].c); &#125; spfa(); if (dis[sum]==inf) printf(&quot;impossible\\n&quot;); else printf(&quot;%lld\\n&quot;,dis[sum]); &#125;&#125;","categories":[{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[{"name":"算法_最短路模型","slug":"算法-最短路模型","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E6%9C%80%E7%9F%AD%E8%B7%AF%E6%A8%A1%E5%9E%8B/"}]},{"title":"【JZOJ4872】太阳神 题解","slug":"【JZOJ4872】太阳神 题解","date":"2016-11-09T14:06:15.000Z","updated":"2024-04-24T03:59:22.852Z","comments":true,"path":"【JZOJ4872】太阳神 题解/","link":"","permalink":"http://kqp.world/%E3%80%90JZOJ4872%E3%80%91%E5%A4%AA%E9%98%B3%E7%A5%9E%20%E9%A2%98%E8%A7%A3/","excerpt":"题目大意&emsp;&emsp;求这玩意儿： \\sum_{a=1}^n\\sum_{b=1}^n~[~lcm(a,b)>n~]&emsp;&emsp;$n \\le 10^{10}$","text":"题目大意&emsp;&emsp;求这玩意儿： \\sum_{a=1}^n\\sum_{b=1}^n~[~lcm(a,b)>n~]&emsp;&emsp;$n \\le 10^{10}$ 【首先】&emsp;&emsp;显然算出 $lcm&lt;=n$ 的数对的数量，然后用 $n^2$ 去减。以下 $ans$ 表示的都是小于等于的数量。 【20%】n&lt;=2000&emsp;&emsp;暴力。 【40%】n&lt;=10^7 \\begin{array}{rcl} ans&=&\\sum_{a=1}^n\\sum_{b=1}^n~[~\\frac{ab}{gcd(a,b)}","categories":[{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[{"name":"算法_数论","slug":"算法-数论","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E6%95%B0%E8%AE%BA/"}]},{"title":"noip2016集训第一周总结","slug":"noip2016集训第一周总结","date":"2016-11-05T15:48:32.000Z","updated":"2024-04-24T03:59:22.787Z","comments":true,"path":"noip2016集训第一周总结/","link":"","permalink":"http://kqp.world/noip2016%E9%9B%86%E8%AE%AD%E7%AC%AC%E4%B8%80%E5%91%A8%E6%80%BB%E7%BB%93/","excerpt":"成绩&emsp;&emsp;从上周六到今天，总共是8场模拟赛，有两场垫底，其余都挺好。&emsp;&emsp;充分说明了我成绩的不稳定性，会做就很高分，脑洞一抽就什么都没了。","text":"成绩&emsp;&emsp;从上周六到今天，总共是8场模拟赛，有两场垫底，其余都挺好。&emsp;&emsp;充分说明了我成绩的不稳定性，会做就很高分，脑洞一抽就什么都没了。 首先应当反思&emsp;&emsp;我现阶段做题是否非常依赖脑洞？？？ &emsp;&emsp;我觉得是的。解决方法有两个，一个是提升脑洞水平，使得即使依赖脑洞也没什么问题。二是完善应对策略或者叫做题套路，使得当脑洞没打开的时候，有足够的措施保证分数不低甚至能够通过套路推出正解。fzr很是推荐第一种，我自然是觉得两个都要，才能保证效率。&emsp;&emsp;当然，还跟我是否冷静有关。我只要冷静下来，思维效率会高很多，这就需要强大的心理素质保证心平气和。目前有两大因素很干扰我，一是如果比赛时间接近结束而依然不佳，我会越来越焦虑，二是如果周围人敲键盘敲得很猛很自信，还不时笑一笑起来跳个舞，我也会被吓到。 题的难度及收获&emsp;&emsp;相对平时的gdoi模拟已经是简单很多了，个别题对我来说挺难的，有我薄弱的知识点，也有令我脑洞阻塞的题。&emsp;&emsp;比如连续两天考了概率题，概率题我从前是一脸懵逼，现在我起码两天都会打50分的暴力了。虽然考场上推不出正解，但是相比以前的自己，进步还是贼大的。&emsp;&emsp;又比如考到了许多经典不常见模型，像蚂蚁过独木桥、超大容量背包，等等，有些是学习，有些算复习。 这周以后&emsp;&emsp;首先是明确了大方向——noip只剩俩星期，以提高思维稳定性为主要目标。&emsp;&emsp;专题学习，学习到了很多东西，尽管在noip上基本没用。有些高难度模板如果现在没时间打，留到noip以后不迟。&emsp;&emsp;依然要保证脑中随时有可思考的东西，重建9月份那时的思考热潮。","categories":[{"name":"总结与游记","slug":"总结与游记","permalink":"http://kqp.world/categories/%E6%80%BB%E7%BB%93%E4%B8%8E%E6%B8%B8%E8%AE%B0/"},{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[]},{"title":"【搬自TC_SRM583 Hard】【JZOJ4844】抗拒黄泉 题解","slug":"【搬自TC_SRM583 Hard】【JZOJ4844】抗拒黄泉 题解","date":"2016-11-04T14:46:42.000Z","updated":"2024-04-24T03:59:22.876Z","comments":true,"path":"【搬自TC_SRM583 Hard】【JZOJ4844】抗拒黄泉 题解/","link":"","permalink":"http://kqp.world/%E3%80%90%E6%90%AC%E8%87%AATC_SRM583%20Hard%E3%80%91%E3%80%90JZOJ4844%E3%80%91%E6%8A%97%E6%8B%92%E9%BB%84%E6%B3%89%20%E9%A2%98%E8%A7%A3/","excerpt":"题目大意&emsp;&emsp;有一个 $n \\times m$ 的棋盘，每个格子要么是 0 要么是 1。每天等概率地选择一个 1 格子进行标记，若某时刻每行、每列都至少有一个格子被标记，则结束。求结束的期望天数。&emsp;&emsp;$n,m \\le 20,\\ \\ n \\times m \\le 200$","text":"题目大意&emsp;&emsp;有一个 $n \\times m$ 的棋盘，每个格子要么是 0 要么是 1。每天等概率地选择一个 1 格子进行标记，若某时刻每行、每列都至少有一个格子被标记，则结束。求结束的期望天数。&emsp;&emsp;$n,m \\le 20,\\ \\ n \\times m \\le 200$ 【50%】n,m&lt;=8&emsp;&emsp;设 $f[s1][s2]$ 表示行状态为 $s1$、列状态为 $s2$，到达结束的期望天数。&emsp;&emsp;设总的 1 格子数量为 $tot$，那么对于当前状态，有 $t[s1][s2]$ 个 1 格子你选它不会改变当前状态，剩余 $tot-t[s1][s2]$ 个 1 格子则会改变当前状态。&emsp;&emsp;则 $f[s1][s2]=\\frac{t[s1][s2]}{tot}(f[s1][s2]+1)+\\sum\\frac{1}{tot}(f[s1’][s2’]+1)$，移一下项就解出来了。 【100%】n,m&lt;=20, n*m&lt;=200&emsp;&emsp;设 $F(i)$ 表示经过 $i$ 次操作结束的概率，$P(i)$ 表示经过 $i$ 次操作仍未结束的概率，则 \\begin{array}{rcl} ans&=&\\sum_{i=1}^\\infty F(i)×i\\\\ &=&\\sum_{i=0}^\\infty(P(i)-P(i+1))×(i+1)\\\\ &=&\\sum_{i=0}^\\infty P(i) \\end{array}&emsp;&emsp;考虑如何计算 $P(i)$。既然未结束，则一定是漏掉了一些行或列。漏掉的意思是那些行和那些列所包含的 1 格子永远选不到。设行列状态为 $S$，设选中该状态包含的 1 格子的概率为 $p(S)$（这个是小写），则容斥一下可得到 P(i)=\\sum_{|S|是奇数}(1-p(S))^i-\\sum_{|S|是偶数}(1-p(S))^i&emsp;&emsp;所以 ans=\\sum_{i=0}^\\infty \\sum_{|S|是奇数}(1-p(S))^i-\\sum_{|S|是偶数}(1-p(S))^i&emsp;&emsp;等比数列公式一下可得 ans=\\sum_{|S|是奇数}\\frac{1}{p(S)}-\\sum_{|S|是偶数}\\frac{1}{p(S)}&emsp;&emsp;设总的 1 格子数量为 $tot$，$S$包含的 1 格子数量为 $t[S]$，则 ans=\\sum_{|S|是奇数}\\frac{tot}{t(S)}-\\sum_{|S|是偶数}\\frac{tot}{t(S)}&emsp;&emsp;设使 $t[S]=X$ 的状态 $S$ 数量为 $num[X]$（这里的数量是指容斥后的数量，即奇数减偶数），则 ans=\\sum_{X=1}^{tot}num[X]×\\frac{tot}{X}&emsp;&emsp;求 $num[X]$ 则是一个简单状压dp，不赘述。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define fo(i,a,b) for(int i=a;i&lt;=b;i++)#define fd(i,a,b) for(int i=a;i&gt;=b;i--)using namespace std;typedef long long LL;const int maxn=25, maxN=2e4+5;int n,m,N,mp[maxn][maxn],er[maxn],b0;int w[maxN];int get(int x)&#123; int re=0; for(; x; x-=(x&amp;(-x))) re++; return re;&#125;int Sb[maxn],bl[maxn],br[maxn];LL f[205][2],num[205];int main()&#123; fo(i,1,20) er[i]=1&lt;&lt;(i-1); scanf(&quot;%d %d&quot;,&amp;n,&amp;m); fo(i,1,n) fo(j,1,m) scanf(&quot;%d&quot;,&amp;mp[i][j]); if (n&gt;m) //n、m必有一个&lt;=14，为了方便下面的状压dp，把小的作为行 &#123; fo(i,1,n) fo(j,(i&lt;=m)?i:1,m) swap(mp[i][j],mp[j][i]); swap(n,m); &#125; N=(1&lt;&lt;n)-1; fo(j,1,m) &#123; Sb[j]=Sb[j-1]; fo(i,1,n) if (mp[i][j]) &#123; bl[j]+=er[i]; br[i]++; Sb[j]++; b0++; &#125; &#125; fo(s,0,N) w[s]=get(s); fo(s,0,N) &#123; int st=0; fo(i,1,n) if (s&amp;er[i]) &#123; if (!br[i]) &#123;st=-1; break;&#125; st+=br[i]; &#125; if (st==-1) continue; memset(f,0,sizeof(f)); f[st][0]=1; fo(j,1,m) if (Sb[j]-Sb[j-1]) fd(i,min(st+Sb[j],b0),st) &#123; LL g[2]=&#123;f[i][0],f[i][1]&#125;; f[i][0]=f[i][1]=0; fo(k,0,1) &#123; f[i][k]+=g[k]; if (i+get(bl[j]-(s&amp;bl[j]))&lt;=b0) f[i+w[bl[j]-(s&amp;bl[j])]][k^1]+=g[k]; &#125; &#125; fo(i,st,b0) &#123; fo(k,0,1) if ((get(s)^k)&amp;1) num[i]+=f[i][k]; else num[i]-=f[i][k]; &#125; &#125; long double ans=0; fo(x,1,b0) ans+=num[x]*(long double)b0/x; printf(&quot;%.5f\\n&quot;,(double)ans);&#125;","categories":[{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[{"name":"算法_DP","slug":"算法-DP","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-DP/"},{"name":"算法_概率与期望","slug":"算法-概率与期望","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E6%A6%82%E7%8E%87%E4%B8%8E%E6%9C%9F%E6%9C%9B/"}]},{"title":"10月大总结","slug":"10月大总结","date":"2016-10-31T09:14:14.000Z","updated":"2024-04-24T03:59:22.768Z","comments":true,"path":"10月大总结/","link":"","permalink":"http://kqp.world/10%E6%9C%88%E5%A4%A7%E6%80%BB%E7%BB%93/","excerpt":"$\\ \\ $","text":"$\\ \\ $ 这个月&emsp;&emsp;第一周国庆假，第二周搞段考，第三周搞初赛，因此充分花在OI上的貌似只有一周多。 在OI上&emsp;&emsp;开始联考，好的很好，差的很差，想到就会做，没想到就几乎拿不到分。&emsp;&emsp;空闲时间基本拿来做专题，做自己的数论ppt，以及学习已经讲了课的内容。&emsp;&emsp;关于计划，几乎没动过。coci，本月可以说是一点没动。每周一题，也就找了一个题，计蒜客网站要验证之后也就没管它了。 相比9月&emsp;&emsp;相比9月好像无法让自己思考起来，做ppt很多时候脑子是空白的。&emsp;&emsp;模拟赛，有些考得好，有些不好。稍微在难题中证明思维水平有提高，但没有在简单题上证明码速有大进步。 以后&emsp;&emsp;最重要的是还有三周就noip了，不管怎样先搞这个。&emsp;&emsp;下个月的计划应该分两部分，noip以前和noip以后。noip以前主要是专题和noip题，noip以后就要开始恶补难点以及填坑了。&emsp;&emsp;无论怎样还是要让自己思考起来，手边随时要有可以思考的东西（物理、数学、人生、哲学也可以）","categories":[{"name":"总结与游记","slug":"总结与游记","permalink":"http://kqp.world/categories/%E6%80%BB%E7%BB%93%E4%B8%8E%E6%B8%B8%E8%AE%B0/"},{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[]},{"title":"【JZOJ4830】分组 题解","slug":"【JZOJ4830】分组 题解","date":"2016-10-31T08:55:19.000Z","updated":"2024-04-24T03:59:22.852Z","comments":true,"path":"【JZOJ4830】分组 题解/","link":"","permalink":"http://kqp.world/%E3%80%90JZOJ4830%E3%80%91%E5%88%86%E7%BB%84%20%E9%A2%98%E8%A7%A3/","excerpt":"题目大意&emsp;&emsp;有 n 个同学，每个同学有个速度值 s[i]，现在给所有人分组，一个组产生的代价为该组内同学的速度值极差（若只有一个人则代价为0）。求总代价不超过 K 的方案数。&emsp;&emsp;n&lt;=200，K&lt;=1000，s[i]&lt;=500","text":"题目大意&emsp;&emsp;有 n 个同学，每个同学有个速度值 s[i]，现在给所有人分组，一个组产生的代价为该组内同学的速度值极差（若只有一个人则代价为0）。求总代价不超过 K 的方案数。&emsp;&emsp;n&lt;=200，K&lt;=1000，s[i]&lt;=500 【20%】n&lt;=10&emsp;&emsp;状压乱搞 【100%】&emsp;&emsp;一个组只与其中的最大值和最小值有关，且代价为最大值减最小值。所以先把 s 排个序（从大到小），这样能保证一个组的代价一定是加上最前面的 s，减去最后面的 s。 &emsp;&emsp;设 f[i,j,k] 表示前 i 个人，开了 j 个组（已开头未结尾），总代价为 k，的方案数。&emsp;&emsp;考虑第 i 个人，他有 4 种选择：1、独立成组，则 f[i+1,j,k]+=f[i,j,k]；2、新开一个组，则 f[i+1,j+1,k+s[i]]+=f[i,j,k]；3、插入一个组，则 f[i+1,j,k]+=f[i,j,k]×j；4、结束一个组，则 f[i+1,j-1,k-s[i]]+=f[i,j,k]×j。 &emsp;&emsp;但是这样 k 的范围就不好控制了。所以做些修改。&emsp;&emsp;设 ss[i]=s[i]-s[i+1]，若一个组最大的人是 x，最小的人是 y，则代价为 ss[x]+ss[x+1]+ss[x+2]+…+ss[y-1]。&emsp;&emsp;所以转移方程修改为：1、f[i+1,j,k+ss[i]×j]+=f[i,j,k]；2、f[i+1,j+1,k+ss[i]×(j+1)]+=f[i,j,k]；3、f[i+1,j,k+ss[i]×j]+=f[i,j,k]×j；4、f[i+1,j-1,k+ss[i]×(j-1)]+=f[i,j,k]×j。 代码123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define fo(i,a,b) for(int i=a;i&lt;=b;i++)using namespace std;typedef long long LL;const int maxn=205, maxk=1005;const LL mo=1e9+7;int n,K,a[maxn],s[maxn];LL f[2][maxn][maxk];int main()&#123; scanf(&quot;%d %d&quot;,&amp;n,&amp;K); fo(i,1,n) scanf(&quot;%d&quot;,&amp;a[i]); sort(a+1,a+1+n); fo(i,1,n) s[i]=a[n-i+1]-a[n-i]; f[0][0][0]=1; int p=0; fo(i,1,n) &#123; memset(f[p^1],0,sizeof(f[p^1])); fo(j,0,i) fo(k,0,K) &#123; if (k+s[i]*j&lt;=K) f[p^1][j][k+s[i]*j]=(f[p^1][j][k+s[i]*j]+f[p][j][k])%mo; if (j &amp;&amp; k+s[i]*j&lt;=K) f[p^1][j][k+s[i]*j]=(f[p^1][j][k+s[i]*j]+f[p][j][k]*j)%mo; if (j&lt;i &amp;&amp; k+s[i]*(j+1)&lt;=K) f[p^1][j+1][k+s[i]*(j+1)]=(f[p^1][j+1][k+s[i]*(j+1)]+f[p][j][k])%mo; if (j &amp;&amp; k+s[i]*(j-1)&lt;=K) f[p^1][j-1][k+s[i]*(j-1)]=(f[p^1][j-1][k+s[i]*(j-1)]+f[p][j][k]*j)%mo; &#125; p^=1; &#125; LL ans=0; fo(k,0,K) ans=(ans+f[p][0][k])%mo; printf(&quot;%lld\\n&quot;,ans);&#125;","categories":[{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[{"name":"算法_DP","slug":"算法-DP","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-DP/"}]},{"title":"【改自CC_CHSEQ22】【JZOJ4807】破解 题解","slug":"【改自CC_CHSEQ22】【JZOJ4807】破解 题解","date":"2016-10-06T12:28:18.000Z","updated":"2024-04-24T03:59:22.878Z","comments":true,"path":"【改自CC_CHSEQ22】【JZOJ4807】破解 题解/","link":"","permalink":"http://kqp.world/%E3%80%90%E6%94%B9%E8%87%AACC_CHSEQ22%E3%80%91%E3%80%90JZOJ4807%E3%80%91%E7%A0%B4%E8%A7%A3%20%E9%A2%98%E8%A7%A3/","excerpt":"题目大意&emsp;&emsp;一个 n 位的初始为全 0 的 01 串，给定 m 个区间（1&lt;=l[i]&lt;=r[i]&lt;=n），每次选择其中任意一个，将01串上对应的子段取反。执行任意次操作，求能产生多少种不同的01串。&emsp;&emsp;n&lt;=10^7， m&lt;=10^5","text":"题目大意&emsp;&emsp;一个 n 位的初始为全 0 的 01 串，给定 m 个区间（1&lt;=l[i]&lt;=r[i]&lt;=n），每次选择其中任意一个，将01串上对应的子段取反。执行任意次操作，求能产生多少种不同的01串。&emsp;&emsp;n&lt;=10^7， m&lt;=10^5 【30%】n,m&lt;=10&emsp;&emsp;暴力 【60%】n&lt;=10^7，m&lt;=20&emsp;&emsp;01串有种经典的表示方法是：第 1 位不变，对于 i&gt;=2，第 i 位为 0 表示该位与上一位相同，为 1 表示与上一位不同。例如 0011010111100 表示为 0010111100010。&emsp;&emsp;所以对于一种操作 [ l[i], r[i] ]，相当于把01串（新表示法）的第 l[i] 位和第 r[i]+1 位取反。&emsp;&emsp;所以每种操作可以看作是一个只含 2 个 1 的01串。如果把位数离散化一下，就变成了 long long 以内的二进制数了。然后问题变成从这 m 个数中选任意个异或起来，求结果有多少种。&emsp;&emsp;所以暴力枚举每个数选还是不选，然后hash判重。 【100%】n&lt;=10^7，m&lt;=10^5&emsp;&emsp;考虑上述思想优化。&emsp;&emsp;对于操作 [ l[i], r[i] ]，连一条 l[i] 到 r[i]+1 的边。假设我们可以对边进行01染色（其实就是代表做不做这个操作），每个点的颜色就等于连着它的边的颜色和 mod 2（相当于最后这个位置是 0 还是 1）。&emsp;&emsp;显然对于每个连通块是独立的。而每个连通块假设有 k 个点，那方案数就是 2^(k-1)。数学归纳法证明：当只有 1 个点是成立的；对于从连通块连向新点的边，显然方案数是乘2，对于连通块内部的连边，我染0色则是原方案，我染1色则把原方案取反还是同样效果，所以方案数还是乘2。&emsp;&emsp;所以假设 a 个点分成 b 个连通块，最终答案就是 2^(a-b)。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;cstdio&gt;#include&lt;algorithm&gt;#define fo(i,a,b) for(int i=a;i&lt;=b;i++)using namespace std;typedef long long LL;const int maxm=1e5+5;const LL mo=1e9+7;int n,m,l[maxm],r[maxm];LL er[maxm];struct B&#123;int num,i,lr;&#125; b[2*maxm];int b0,maxr;bool cmpB(const B &amp;a,const B &amp;b) &#123;return a.num&lt;b.num;&#125;void discretize()&#123; b0=0; fo(i,1,m) b[++b0].num=l[i], b[b0].i=i, b[b0].lr=0; fo(i,1,m) b[++b0].num=r[i], b[b0].i=i, b[b0].lr=1; sort(b+1,b+1+b0,cmpB); maxr=0; fo(i,1,b0) &#123; if (b[i].num!=b[i-1].num) maxr++; if (b[i].lr==0) l[b[i].i]=maxr; else r[b[i].i]=maxr; &#125;&#125;int fa[maxm];int get(int x) &#123;return (fa[x]==x) ?x :fa[x]=get(fa[x]) ;&#125;int T;int main()&#123; er[0]=1; fo(i,1,100000) er[i]=er[i-1]*2%mo; scanf(&quot;%d&quot;,&amp;T); while (T--) &#123; scanf(&quot;%d %d&quot;,&amp;n,&amp;m); n++; fo(i,1,m) &#123; scanf(&quot;%d %d&quot;,&amp;l[i],&amp;r[i]); r[i]++; &#125; discretize(); fo(i,1,maxr) fa[i]=i; fo(i,1,m) fa[get(l[i])]=get(r[i]); int k=0; fo(i,1,maxr) if (get(i)==i) k++; printf(&quot;%lld\\n&quot;,er[maxr-k]); &#125;&#125;","categories":[{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[{"name":"算法_图论","slug":"算法-图论","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E5%9B%BE%E8%AE%BA/"},{"name":"算法_位运算","slug":"算法-位运算","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/"}]},{"title":"9月大总结","slug":"9月大总结","date":"2016-10-04T23:52:07.000Z","updated":"2024-04-24T03:59:22.773Z","comments":true,"path":"9月大总结/","link":"","permalink":"http://kqp.world/9%E6%9C%88%E5%A4%A7%E6%80%BB%E7%BB%93/","excerpt":"关于水平&emsp;&emsp;感觉是提升了，也可能是因为后期题目简单。&emsp;&emsp;难题都有很好的思路，一些不算太难的也能切。现在做noip模拟都是向着ak去的了。&emsp;&emsp;整个月的思考量显著增加。&emsp;&emsp;然而，思维水平上去了，思维速度没提高，有些题想很久搞到荒废了很多时间&emsp;&emsp;做题时的心境还是比较杂。 关于计划&emsp;&emsp;总的来说，实际拥有时间小于计划用有时间，计划无法圆满。&emsp;&emsp;学校的题，后半个月基本都切，前半个月有待填坑。&emsp;&emsp;coci没有达到预期的两套题，只做了#7全套和#6的一些。但是我觉得我的习惯挺吼的，我习惯把水题拓展（条件加强、数据加强），我觉得从拓展中收获的不亚于接触难题。&emsp;&emsp;专题，慢慢来。。。这个要精不能急&emsp;&emsp;每周一题这个想法是最初我打算拿来检验脑洞水平的，原以为时间足够可以做3~4题，实际上一周一题都很费劲。耗时主要如下：1、找题，想了一会儿然后发现就是个简单模拟或者模板题而又不能扩展的，没必要做；2、按照这种方法筛选出来的题得让我想很久（嗯不过这才是目标）。 关于未来&emsp;&emsp;学校题、专题为第一优先级，coci为第二优先级，每周一题为第三优先级&emsp;&emsp;coci与专题继续精推&emsp;&emsp;每周一题在时间不充分的情况下予以暂停","text":"关于水平&emsp;&emsp;感觉是提升了，也可能是因为后期题目简单。&emsp;&emsp;难题都有很好的思路，一些不算太难的也能切。现在做noip模拟都是向着ak去的了。&emsp;&emsp;整个月的思考量显著增加。&emsp;&emsp;然而，思维水平上去了，思维速度没提高，有些题想很久搞到荒废了很多时间&emsp;&emsp;做题时的心境还是比较杂。 关于计划&emsp;&emsp;总的来说，实际拥有时间小于计划用有时间，计划无法圆满。&emsp;&emsp;学校的题，后半个月基本都切，前半个月有待填坑。&emsp;&emsp;coci没有达到预期的两套题，只做了#7全套和#6的一些。但是我觉得我的习惯挺吼的，我习惯把水题拓展（条件加强、数据加强），我觉得从拓展中收获的不亚于接触难题。&emsp;&emsp;专题，慢慢来。。。这个要精不能急&emsp;&emsp;每周一题这个想法是最初我打算拿来检验脑洞水平的，原以为时间足够可以做3~4题，实际上一周一题都很费劲。耗时主要如下：1、找题，想了一会儿然后发现就是个简单模拟或者模板题而又不能扩展的，没必要做；2、按照这种方法筛选出来的题得让我想很久（嗯不过这才是目标）。 关于未来&emsp;&emsp;学校题、专题为第一优先级，coci为第二优先级，每周一题为第三优先级&emsp;&emsp;coci与专题继续精推&emsp;&emsp;每周一题在时间不充分的情况下予以暂停","categories":[{"name":"总结与游记","slug":"总结与游记","permalink":"http://kqp.world/categories/%E6%80%BB%E7%BB%93%E4%B8%8E%E6%B8%B8%E8%AE%B0/"},{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[]},{"title":"最大m子段和问题","slug":"最大m子段和问题","date":"2016-09-25T05:58:06.000Z","updated":"2024-04-24T03:59:22.883Z","comments":true,"path":"最大m子段和问题/","link":"","permalink":"http://kqp.world/%E6%9C%80%E5%A4%A7m%E5%AD%90%E6%AE%B5%E5%92%8C%E9%97%AE%E9%A2%98/","excerpt":"普通版题目大意&emsp;&emsp;一个长度为 $n$ 的序列 $a_1…a_n$，让你从中选出 $m$ 个连续段，使得选出来的和最大。","text":"普通版题目大意&emsp;&emsp;一个长度为 $n$ 的序列 $a_1…a_n$，让你从中选出 $m$ 个连续段，使得选出来的和最大。 【$O(nm)$】&emsp;&emsp;设 $f_{i,j}$ 表示前 $i$ 个数，共选了 $j$ 个连续段，所得到的最大和。&emsp;&emsp;设 $g_{i,j}=\\max\\{ f_{1..i, j} \\}$， 设 $S$ 表示 $a$ 的前缀和。 f_{i,j}=\\max\\{ S_i-S_k+g_{k,j-1} \\}&emsp;&emsp;然后搞一下就是 $O(nm)$ 的了。 【$O(m \\log n)$】&emsp;&emsp;源点向每一个点 $i$ 连一条容量为 $1$、费用为 $a_i$ 的边，每个点 $i$ 向 $i+1$ 连一条容量为 $1$、费用为 $a_{i+1}$ 的边，每个点向汇点连一条容量为 $1$、费用为 $0$ 的边。&emsp;&emsp;这样建图，每增广一次，相当于取出了一个连续段，又由于有反向弧这种操作，所以直接增广 $m$ 次就可以了。（当然，如果增广出来是负数，可以直接退出） &emsp;&emsp;当然直接跑费用流肯定会 T。&emsp;&emsp;引入费用流只是为了引入反向弧这种机制。我们发现实际上是每次贪心地选取一个最大子段而已，那么选完之后我们就把这段取反就行了。&emsp;&emsp;这个用线段树实现，维护的变量挺多的。 加强版题目大意&emsp;&emsp;给你一个长度为 $n$ 的序列 $a_1…a_n$，有如下两种操作：&emsp;&emsp;$1~x~y$：将 $a_x$ 的值改为 $y$&emsp;&emsp;$2~l~r~k$：询问区间 $[l, r]$ 的最大 $k$ 子段和。 【$O(m \\log n)$】&emsp;&emsp;像上面那样，既然都已经打了个线段树了，那就再加个单点修改。 代码普通123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122#include&lt;cstdio&gt;#include&lt;algorithm&gt;#define fo(i,a,b) for(int i=a;i&lt;=b;i++)using namespace std;typedef long long LL;const int maxn=5e4+5;struct TR&#123; LL s,sl,sr,st; int wzi,wzj,wzl,wzr;&#125;;int n,m;LL a[maxn];TR tr[2][4*maxn];bool bz[4*maxn];TR merge(TR a,TR b)&#123; TR re; re.s=a.s+b.s; if (a.st&gt;b.st) &#123; re.st=a.st; re.wzi=a.wzi, re.wzj=a.wzj; &#125; else &#123; re.st=b.st; re.wzi=b.wzi, re.wzj=b.wzj; &#125; if (a.sr+b.sl&gt;re.st) &#123; re.st=a.sr+b.sl; re.wzi=a.wzr, re.wzj=b.wzl; &#125; if (a.sl&gt;a.s+b.sl) &#123; re.sl=a.sl; re.wzl=a.wzl; &#125; else &#123; re.sl=a.s+b.sl; re.wzl=b.wzl; &#125; if (b.sr&gt;b.s+a.sr) &#123; re.sr=b.sr; re.wzr=b.wzr; &#125; else &#123; re.sr=b.s+a.sr; re.wzr=a.wzr; &#125; return re;&#125;void tr_js(int k,int l,int r)&#123; if (l==r) &#123; tr[0][k].s=tr[0][k].sl=tr[0][k].sr=tr[0][k].st=a[l]; tr[0][k].wzi=tr[0][k].wzj=tr[0][k].wzl=tr[0][k].wzr=l; tr[1][k].s=tr[1][k].sl=tr[1][k].sr=tr[1][k].st=-a[l]; tr[1][k].wzi=tr[1][k].wzj=tr[1][k].wzl=tr[1][k].wzr=l; return; &#125; int t=k&lt;&lt;1, t1=(l+r)&gt;&gt;1; tr_js(t,l,t1), tr_js(t+1,t1+1,r); tr[0][k]=merge(tr[0][t],tr[0][t+1]); tr[1][k]=merge(tr[1][t],tr[1][t+1]);&#125;void update(int k,int t)&#123; if (!bz[k]) return; swap(tr[0][t],tr[1][t]); swap(tr[0][t+1],tr[1][t+1]); bz[t]^=bz[k]; bz[t+1]^=bz[k]; bz[k]=0;&#125;void xg_many(int k,int l,int r,int x,int y)&#123; if (l==x &amp;&amp; r==y) &#123; swap(tr[0][k],tr[1][k]); bz[k]^=1; return; &#125; int t=k&lt;&lt;1, t1=(l+r)&gt;&gt;1; update(k,t); if (y&lt;=t1) xg_many(t,l,t1,x,y); else if (x&gt;t1) xg_many(t+1,t1+1,r,x,y); else xg_many(t,l,t1,x,t1), xg_many(t+1,t1+1,r,t1+1,y); tr[0][k]=merge(tr[0][t],tr[0][t+1]); tr[1][k]=merge(tr[1][t],tr[1][t+1]);&#125;LL get(int m)&#123; LL re=0; while (m--) &#123; if (tr[0][1].st&lt;0) break; re+=tr[0][1].st; xg_many(1,1,n,tr[0][1].wzi,tr[0][1].wzj); &#125; return re;&#125;int main()&#123; scanf(&quot;%d %d&quot;,&amp;n,&amp;m); fo(i,1,n) scanf(&quot;%lld&quot;,&amp;a[i]); tr_js(1,1,n); printf(&quot;%lld\\n&quot;,get(m));&#125; 加强123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159#include&lt;cstdio&gt;#include&lt;algorithm&gt;#define fo(i,a,b) for(int i=a;i&lt;=b;i++)using namespace std;const int maxn=1e5+5;struct TR&#123; int s,sl,sr,st,wzi,wzj,wzl,wzr;&#125;;int n,a[maxn];TR tr[2][4*maxn];bool bz[4*maxn];TR merge(TR a,TR b)&#123; TR re; re.s=a.s+b.s; if (a.st&gt;b.st) &#123; re.st=a.st; re.wzi=a.wzi, re.wzj=a.wzj; &#125; else &#123; re.st=b.st; re.wzi=b.wzi, re.wzj=b.wzj; &#125; if (a.sr+b.sl&gt;re.st) &#123; re.st=a.sr+b.sl; re.wzi=a.wzr, re.wzj=b.wzl; &#125; if (a.sl&gt;a.s+b.sl) &#123; re.sl=a.sl; re.wzl=a.wzl; &#125; else &#123; re.sl=a.s+b.sl; re.wzl=b.wzl; &#125; if (b.sr&gt;b.s+a.sr) &#123; re.sr=b.sr; re.wzr=b.wzr; &#125; else &#123; re.sr=b.s+a.sr; re.wzr=a.wzr; &#125; return re;&#125;void tr_js(int k,int l,int r)&#123; if (l==r) &#123; tr[0][k].s=tr[0][k].sl=tr[0][k].sr=tr[0][k].st=a[l]; tr[0][k].wzi=tr[0][k].wzj=tr[0][k].wzl=tr[0][k].wzr=l; tr[1][k].s=tr[1][k].sl=tr[1][k].sr=tr[1][k].st=-a[l]; tr[1][k].wzi=tr[1][k].wzj=tr[1][k].wzl=tr[1][k].wzr=l; return; &#125; int t=k&lt;&lt;1, t1=(l+r)&gt;&gt;1; tr_js(t,l,t1), tr_js(t+1,t1+1,r); tr[0][k]=merge(tr[0][t],tr[0][t+1]); tr[1][k]=merge(tr[1][t],tr[1][t+1]);&#125;void update(int k,int t)&#123; if (!bz[k]) return; swap(tr[0][t],tr[1][t]); swap(tr[0][t+1],tr[1][t+1]); bz[t]^=bz[k]; bz[t+1]^=bz[k]; bz[k]=0;&#125;void xg_single(int k,int l,int r,int x,int z)&#123; if (l==r) &#123; tr[0][k].s=tr[0][k].sl=tr[0][k].sr=tr[0][k].st=z; tr[1][k].s=tr[1][k].sl=tr[1][k].sr=tr[1][k].st=-z; return; &#125; int t=k&lt;&lt;1, t1=(l+r)&gt;&gt;1; update(k,t); if (x&lt;=t1) xg_single(t,l,t1,x,z); else xg_single(t+1,t1+1,r,x,z); tr[0][k]=merge(tr[0][t],tr[0][t+1]); tr[1][k]=merge(tr[1][t],tr[1][t+1]);&#125;void xg_many(int k,int l,int r,int x,int y)&#123; if (l==x &amp;&amp; r==y) &#123; swap(tr[0][k],tr[1][k]); bz[k]^=1; return; &#125; int t=k&lt;&lt;1, t1=(l+r)&gt;&gt;1; update(k,t); if (y&lt;=t1) xg_many(t,l,t1,x,y); else if (x&gt;t1) xg_many(t+1,t1+1,r,x,y); else xg_many(t,l,t1,x,t1), xg_many(t+1,t1+1,r,t1+1,y); tr[0][k]=merge(tr[0][t],tr[0][t+1]); tr[1][k]=merge(tr[1][t],tr[1][t+1]);&#125;TR tr_cx(int k,int l,int r,int x,int y)&#123; if (l==x &amp;&amp; r==y) return tr[0][k]; int t=k&lt;&lt;1, t1=(l+r)&gt;&gt;1; update(k,t); if (y&lt;=t1) return tr_cx(t,l,t1,x,y); else if (x&gt;t1) return tr_cx(t+1,t1+1,r,x,y); else return merge(tr_cx(t,l,t1,x,t1), tr_cx(t+1,t1+1,r,t1+1,y));&#125;int z[maxn][2],z0;int get(int m,int l,int r)&#123; int re=0; while (m--) &#123; TR t=tr_cx(1,1,n,l,r); if (t.st&lt;=0) break; re+=t.st; z[++z0][0]=t.wzi, z[z0][1]=t.wzj; xg_many(1,1,n,t.wzi,t.wzj); &#125; for(; z0; z0--) xg_many(1,1,n,z[z0][0],z[z0][1]); return re;&#125;int m;int main()&#123; scanf(&quot;%d&quot;,&amp;n); fo(i,1,n) scanf(&quot;%d&quot;,&amp;a[i]); tr_js(1,1,n); scanf(&quot;%d&quot;,&amp;m); while (m--) &#123; int ty,l,r,k; scanf(&quot;%d %d %d&quot;,&amp;ty,&amp;l,&amp;r); if (ty==0) &#123; xg_single(1,1,n,l,r); &#125; else &#123; scanf(&quot;%d&quot;,&amp;k); printf(&quot;%d\\n&quot;,get(k,l,r)); &#125; &#125;&#125;","categories":[{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[{"name":"算法_网络流/匹配","slug":"算法-网络流-匹配","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E7%BD%91%E7%BB%9C%E6%B5%81-%E5%8C%B9%E9%85%8D/"},{"name":"算法_线段树","slug":"算法-线段树","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E7%BA%BF%E6%AE%B5%E6%A0%91/"}]},{"title":"【COCI 2015/2016","slug":"【COCI 2015!2016 #7】PROZOR（加强版） 题解","date":"2016-09-25T00:46:07.000Z","updated":"2024-04-24T03:59:22.839Z","comments":true,"path":"【COCI 2015!2016 #7】PROZOR（加强版） 题解/","link":"","permalink":"http://kqp.world/%E3%80%90COCI%202015!2016%20#7%E3%80%91PROZOR%EF%BC%88%E5%8A%A0%E5%BC%BA%E7%89%88%EF%BC%89%20%E9%A2%98%E8%A7%A3/","excerpt":"题目大意&emsp;&emsp;在一个 $R \\times S$ 的平面上共有 $n$ 个点，现在给你一个边长为 $K$ 的正方形框，求最多能框住多少个点。&emsp;&emsp;$n \\le 10^5,\\ R, S, K \\le10^9$","text":"题目大意&emsp;&emsp;在一个 $R \\times S$ 的平面上共有 $n$ 个点，现在给你一个边长为 $K$ 的正方形框，求最多能框住多少个点。&emsp;&emsp;$n \\le 10^5,\\ R, S, K \\le10^9$ \\\\ \\\\ \\\\解法1&emsp;&emsp;扫描线。&emsp;&emsp;维护两条间隔为 $K$ 的扫描线，从左往右。现在问题就是在序列上选取一个长度为 $K$ 的段，使得该段包含最多的点。&emsp;&emsp;对于扫描线内纵坐标为 $y$ 的点，我们做两件事：在 $y$ 的位置+1、在 $y+K$ 的位置 -1。这样只要维护最大前缀和就行了（第 $i$ 个位置的前缀和实际上就是以 $i$ 为结尾的段内的点数）。用线段树或者平衡树都可以。&emsp;&emsp;时间复杂度 $O(n \\log n)$ 解法2&emsp;&emsp;这是经典的化面为点的思想。&emsp;&emsp;考虑框子的左上角落点 $A(x, y)$，我们只用这个来代表框子。&emsp;&emsp;对于平面上的每一个点，若框子能框到它，那么 $A$ 的范围则是一个正方形（具体是以该点为右下角、边长为 K 的正方形）。&emsp;&emsp;于是我们把原来的 $n$ 个点变成 $n$ 个正方形，把框子变成一个点，这样模型就变成了求平面上哪一点被覆盖得最多。这就是经典扫描线了。&emsp;&emsp;时间复杂度 $O(n \\log n)$","categories":[{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[{"name":"算法_扫描线","slug":"算法-扫描线","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E6%89%AB%E6%8F%8F%E7%BA%BF/"}]},{"title":"【JZOJ4800】周末晚会 题解","slug":"【JZOJ4800】周末晚会 题解","date":"2016-09-24T09:24:23.000Z","updated":"2024-04-24T03:59:22.850Z","comments":true,"path":"【JZOJ4800】周末晚会 题解/","link":"","permalink":"http://kqp.world/%E3%80%90JZOJ4800%E3%80%91%E5%91%A8%E6%9C%AB%E6%99%9A%E4%BC%9A%20%E9%A2%98%E8%A7%A3/","excerpt":"题目大意&emsp;&emsp;n 个人围绕着圆桌坐着，其中一些是男孩，另一些是女孩。你的任务是找出所有合法的方案数，使得不超过 k 个女孩座位是连续的。循环同构会被认为是同一种方案。&emsp;&emsp;数据组数 T&lt;=50， n, k&lt;=2000","text":"题目大意&emsp;&emsp;n 个人围绕着圆桌坐着，其中一些是男孩，另一些是女孩。你的任务是找出所有合法的方案数，使得不超过 k 个女孩座位是连续的。循环同构会被认为是同一种方案。&emsp;&emsp;数据组数 T&lt;=50， n, k&lt;=2000 【20%】n,k&lt;=20&emsp;&emsp;暴力还是有点麻烦。&emsp;&emsp;主要思想就是用最小表示法来去重。&emsp;&emsp;不多说了。。。 【100%】n,k&lt;=2000&emsp;&emsp;模型是burnside的经典模型。。。&emsp;&emsp;对于第 i 个置换（0&lt;=i&lt;=n-1），只有开头的 d=gcd(i,n) 个位置的颜色选择是自由的，然后把这一段复制 n/d 份构成完整序列。 &emsp;&emsp;看看这个 d 个位置有什么限制？1、连续的女孩（用0表示）不超过 k 个；2、开头连续的 0 加上末尾连续的 0 不超过 k 个，这是因为把这一段复制之后要头尾拼接。 &emsp;&emsp;直接在 d 个位置上dp不好搞，因为要维护头尾的 0 加起来不超过 k 个。所以设 $f[k][i]$ 表示：我搞 i 个位置出来，这 i 个位置头尾都是 1，其内部连续的 0 不超过 k，的方案数。（实际dp中第一维可以去掉）&emsp;&emsp;这个dp很好搞，对于 i 枚举上一个 1 放在哪里就行了，这是O(n)的。 &emsp;&emsp;回到题目，我现在要 d 个位置，那我们可以枚举 i，相当于枚举了 d 个中的一段，然后我们在前后补 0，总共补 d-i 个0。所以 i 的贡献就是 $f[k][i] \\times (d-i+1)$。这里我们可以看出维护一个 f 的前缀和以及一个 f×i 的前缀和就行了。&emsp;&emsp;头尾加起来 &lt;=k 就相当于 d-i&lt;=k。如果上面用前缀和的话，减掉不合法的就行了。 &emsp;&emsp;再特殊处理一下全段都是 0 就好了。 代码//这里我的 f 是从 0 开始的，所以 f[i] 的长度实际上是 i+112345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;cstdio&gt;#define fo(i,a,b) for(int i=a;i&lt;=b;i++)using namespace std;typedef long long LL;const int maxn=2005;const LL mo=1e8+7;int n,k;LL f[maxn],s[maxn][maxn],sx[maxn][maxn];void pre(int n)&#123; fo(k,1,n) &#123; f[0]=1; LL t=1; fo(i,1,n) &#123; f[i]=t; t=(t+f[i])%mo; if (i&gt;k) t=(t-f[i-k-1]+mo)%mo; &#125; s[k][0]=1; fo(i,1,n) &#123; s[k][i]=(s[k][i-1]+f[i])%mo; sx[k][i]=(sx[k][i-1]+f[i]*i%mo)%mo; &#125; &#125;&#125;int gcd(int a,int b) &#123;return (b) ?gcd(b,a%b) :a ;&#125;LL mi(LL x,LL y)&#123; LL re=1; for(; y; y&gt;&gt;=1, x=x*x%mo) if (y&amp;1) re=re*x%mo; return re;&#125;int T;int main()&#123; pre(2000); scanf(&quot;%d&quot;,&amp;T); while (T--) &#123; scanf(&quot;%d %d&quot;,&amp;n,&amp;k); if (n==0 || k==0) &#123;printf(&quot;0\\n&quot;); continue;&#125; LL ans=0; fo(i,0,n-1) &#123; LL d=gcd(n,i); ans=(ans+s[k][d-1]*d%mo-sx[k][d-1]+mo)%mo; if (d-k-2&gt;=0) ans=(ans-s[k][d-k-2]*d%mo+sx[k][d-k-2]+mo)%mo; if (k&gt;=n) ans=(ans+1)%mo; &#125; ans=ans*mi(n,mo-2)%mo; printf(&quot;%lld\\n&quot;,ans); &#125;&#125;","categories":[{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[{"name":"算法_群论","slug":"算法-群论","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E7%BE%A4%E8%AE%BA/"}]},{"title":"【JZOJ4796】三色图 题解","slug":"【JZOJ4796】三色图 题解","date":"2016-09-22T14:42:58.000Z","updated":"2024-04-24T03:59:22.850Z","comments":true,"path":"【JZOJ4796】三色图 题解/","link":"","permalink":"http://kqp.world/%E3%80%90JZOJ4796%E3%80%91%E4%B8%89%E8%89%B2%E5%9B%BE%20%E9%A2%98%E8%A7%A3/","excerpt":"题目大意&emsp;&emsp;现在你有一个二分图，你有三种颜色0,1,2，然后你要给图上的每一条边染一种颜色（也就是赋予该边一个0,1,2）的边权。我们定义点权 s(u) 为：所有与 u 相连的边的边权之和模三。&emsp;&emsp;你需要给出一种染色方案，使得对于该图任意一对通过一条边直接相连的点对点权不同。&emsp;&emsp;点数 n&lt;=1500，边数 m&lt;=10000","text":"题目大意&emsp;&emsp;现在你有一个二分图，你有三种颜色0,1,2，然后你要给图上的每一条边染一种颜色（也就是赋予该边一个0,1,2）的边权。我们定义点权 s(u) 为：所有与 u 相连的边的边权之和模三。&emsp;&emsp;你需要给出一种染色方案，使得对于该图任意一对通过一条边直接相连的点对点权不同。&emsp;&emsp;点数 n&lt;=1500，边数 m&lt;=10000 【20%】m&lt;=20&emsp;&emsp;暴力枚举每条边染什么色。 【100%】n&lt;=1500, m&lt;=1e4&emsp;&emsp;这是一个二分图，因此如果我们处理成左边的点全部为0色，右边的点全部不为0色，就一定满足条件。 &emsp;&emsp;考虑我们在右边任选两个连通的点，然后任选一条以这两个点为起止点的路径，将该路径上的边权按顺序分别加上 1、2、1、2、1、2……这样会发现，只有起止点的点权会改变，中途点的点权都不改变。 &emsp;&emsp;如此我们对于二分图的每个连通块，每次在右边找两个未处理的点，然后把连接这两个点的路径按上述规则加权。（具体实现可以先找一个未处理的点，然后dfs到另一个未处理的点）&emsp;&emsp;若对于一个连通块，右边的点为奇数？那么多出来的那个点可以跟同连通块的任意一个右点 x 配对，只要从 x 出发时，第一条边加的权是color[x]即可（这样保证 x 最终点权不为 0）。&emsp;&emsp;若对于一个连通块，右边的点只有一个？把该联通块左右互换一下即可。若互换之后右边还是只有一个点，说明该连通块本身只有左右一对点，那么输出不合法。 代码略丑不要介意。。。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include&lt;cstdio&gt;#define fo(i,a,b) for(int i=a;i&lt;=b;i++)using namespace std;const int maxm=1e4+5;int n1,n2,m;int tot,go[2*maxm],bh[2*maxm],next[2*maxm],f1[maxm];void ins(int x,int y,int z)&#123; go[++tot]=y; bh[tot]=z; next[tot]=f1[x]; f1[x]=tot;&#125;int fa[maxm];int get(int x) &#123;return (fa[x]==x) ?x :fa[x]=get(fa[x]) ;&#125;int bz[maxm],now,ans[maxm],clr[maxm];int dfs(int ty,int k,int c)&#123; if ((!ty &amp;&amp; k&gt;n1 || ty &amp;&amp; k&lt;=n1) &amp;&amp; !bz[k]) &#123;bz[k]=now; return k;&#125;; bz[k]=now; for(int p=f1[k]; p; p=next[p]) if (bz[go[p]]!=now) &#123; clr[k]=(clr[k]+c)%3; clr[go[p]]=(clr[go[p]]+c)%3; ans[bh[p]]=(ans[bh[p]]+c)%3; int re=dfs(ty,go[p],(c==1)?2:1); if (re!=-1) return re; clr[k]=(clr[k]-c+3)%3; clr[go[p]]=(clr[go[p]]-c+3)%3; ans[bh[p]]=(ans[bh[p]]-c+3)%3; &#125; return -1;&#125;int main()&#123; scanf(&quot;%d %d %d&quot;,&amp;n1,&amp;n2,&amp;m); fo(i,1,n1+n2) fa[i]=i; fo(i,1,m) &#123; int x,y; scanf(&quot;%d %d&quot;,&amp;x,&amp;y); ins(x,y+n1,i), ins(y+n1,x,i); fa[get(x)]=get(y+n1); &#125; fo(i,n1+1,n1+n2) if (!bz[i]) &#123; if (!f1[i]) continue; bz[i]=++now; int j=dfs(0,i,1); if (j==-1) &#123; fo(k,n1+1,n1+n2) if (i!=k &amp;&amp; get(k)==get(i)) &#123;j=k; break;&#125; if (j&gt;-1) &#123; now++; bz[i]=0; dfs(0,j,clr[j]); &#125; else &#123; for(int p=f1[i]; p; p=next[p]) &#123; now++; bz[i]=0; j=dfs(1,go[p],1); break; &#125; if (j==-1) &#123;printf(&quot;No\\n&quot;); return 0;&#125; &#125; &#125; &#125; printf(&quot;Yes\\n&quot;); fo(i,1,m) printf(&quot;%d &quot;,ans[i]);&#125;","categories":[{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[{"name":"算法_神奇的脑洞","slug":"算法-神奇的脑洞","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E7%A5%9E%E5%A5%87%E7%9A%84%E8%84%91%E6%B4%9E/"},{"name":"算法_构造题","slug":"算法-构造题","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E6%9E%84%E9%80%A0%E9%A2%98/"}]},{"title":"【bzoj2852】【vijos1504】强大的区间 题解","slug":"【bzoj2852】【vijos1504】强大的区间 题解","date":"2016-09-10T15:37:23.000Z","updated":"2024-04-24T03:59:22.829Z","comments":true,"path":"【bzoj2852】【vijos1504】强大的区间 题解/","link":"","permalink":"http://kqp.world/%E3%80%90bzoj2852%E3%80%91%E3%80%90vijos1504%E3%80%91%E5%BC%BA%E5%A4%A7%E7%9A%84%E5%8C%BA%E9%97%B4%20%E9%A2%98%E8%A7%A3/","excerpt":"题目大意&emsp;&emsp;给出两个实数 a、b，我们要求一个最小的正整数 k，使得区间 [ak, bk] 是一个包含至少一个整数的区间。&emsp;&emsp;比如 a=1.2，b=1.3，当 k=4 时，区间为 [4.8, 5.2]，包含了整数 5。&emsp;&emsp;a、b 的整数部分不超过maxlongint，小数部分不超过300位。","text":"题目大意&emsp;&emsp;给出两个实数 a、b，我们要求一个最小的正整数 k，使得区间 [ak, bk] 是一个包含至少一个整数的区间。&emsp;&emsp;比如 a=1.2，b=1.3，当 k=4 时，区间为 [4.8, 5.2]，包含了整数 5。&emsp;&emsp;a、b 的整数部分不超过maxlongint，小数部分不超过300位。 二分！？&emsp;&emsp;显然 k 是既有上界又有下界的，所以第一眼考虑二分。&emsp;&emsp;然而画一下数轴你就发现，这题没有二分性质。&emsp;&emsp;具体就不证了，举个栗子就好了：0.45 和 0.55，当 k=2 或 4 时，都合法，但是 k=3 时却不合法。 巧妙的辗转相除思路&emsp;&emsp;首先，[a, b] 的答案与 [a-1, b-1] 是相同的。因此我们可以先把这个区间变到 a=1 或者 a=0，那么答案就是1，不然的话就变成了这样解一个不等式：a×k &lt;= t &lt;= b×k，其中 k、t 为正整数。&emsp;&emsp;把 k 除掉，再取倒数，结果变成这个样子：t/b &lt;= k &lt;= t/a。&emsp;&emsp;然后我们发现问题变成了求区间 [1/a, 1/b] 的答案，这就迭代下去了。&emsp;&emsp;综上所述就是：对于每一层，我们有参数 $a$ 和 $b$，先把区间化成 $[a’, b’]$，其中 $a’&lt;1$。若 $b’&gt;=1$ 或者 $a’=0$，则返回 $\\lceil a \\rceil$，否则处理下一层（参数为 $1/b$ 和 $1/a$）并得到返回值 $t$，然后返回 $\\lceil a×t \\rceil$。注意，第一层作为最终答案层，返回情况跟别的层有所不同，处理一下。 精度&emsp;&emsp;据说这题精度不好搞！？&emsp;&emsp;我觉得首先要把小数化成分数吧，然后往后都用分数计算，这会好算很多。 时间复杂度&emsp;&emsp;这个过程是典型的辗转相除思想：先用一个数模另一个数，然后交换两个数，重复这一过程。&emsp;&emsp;所以时间就跟 gcd 一样，都是 log。","categories":[{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[{"name":"算法_神奇的脑洞","slug":"算法-神奇的脑洞","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E7%A5%9E%E5%A5%87%E7%9A%84%E8%84%91%E6%B4%9E/"},{"name":"算法_数论","slug":"算法-数论","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E6%95%B0%E8%AE%BA/"}]},{"title":"【bzoj4203】【JZ雅礼联考】同桌的你 题解","slug":"【bzoj4203】【JZ雅礼联考】同桌的你 题解","date":"2016-09-06T14:56:37.000Z","updated":"2024-04-24T03:59:22.832Z","comments":true,"path":"【bzoj4203】【JZ雅礼联考】同桌的你 题解/","link":"","permalink":"http://kqp.world/%E3%80%90bzoj4203%E3%80%91%E3%80%90JZ%E9%9B%85%E7%A4%BC%E8%81%94%E8%80%83%E3%80%91%E5%90%8C%E6%A1%8C%E7%9A%84%E4%BD%A0%20%E9%A2%98%E8%A7%A3/","excerpt":"","text":"题目大意&emsp;&emsp;共有n个同学，每个同学性别为 b[i] ，最喜欢的人是 a[i]。注意喜欢是单向的。&emsp;&emsp;小A希望能够出现尽可能多的同桌，满足同桌两人中存在一人，喜欢另一个人。不妨称这样的同桌叫“满意同桌”。&emsp;&emsp;在满足出现尽可能多的“满意同桌”的前提下，最大化男女同桌的组数。&emsp;&emsp;并输出其中一种方案。&emsp;&emsp;n&lt;=10^6 【20%】n&lt;=20&emsp;&emsp;枚举每个人是否和TA喜欢的人成为同桌。 【100%】n&lt;=10^6&emsp;&emsp;这是经典的环套树模型。&emsp;&emsp;先考虑一棵树怎么做。设 f[i,0/1] 表示第 i 个人，选还是不选，得到的最大答案（答案有两个值，是二维的）。规定每个点要是选的话，只能选TA的儿子。这就是个经典树形dp。&emsp;&emsp;而这题的环套树有个很好的性质：假设我断开了环上的 x-&gt;y 这条边，然后dp。若这时候的答案不是最优的，意味着 x 要跟 y 组一对，等价于连向 x 的那条边和 y 连出去的那条边都没有意义。那么把这两条其中一条边断掉，连上 x-&gt;y ，再做一遍dp，得出来就是最优答案。 &emsp;&emsp;至于输出一种方案，就记录每个状态从哪里来就行了。&emsp;&emsp;时间总共是两遍dp，加上一些琐碎的东西，总共O(n)。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define fo(i,a,b) for(int i=a;i&lt;=b;i++)#define fd(i,a,b) for(int i=a;i&gt;=b;i--)using namespace std;typedef pair&lt;int,int&gt; PAR;bool operator &gt; (PAR a,PAR b) &#123;return a.first&gt;b.first || a.first==b.first &amp;&amp; a.second&gt;b.second;&#125;PAR operator + (PAR a,PAR b) &#123;return make_pair(a.first+b.first, a.second+b.second);&#125;PAR operator - (PAR a,PAR b) &#123;return make_pair(a.first-b.first, a.second-b.second);&#125;const int maxn=1e6+5;int n,fa[maxn],sex[maxn];int tot,go[maxn],next[maxn],f1[maxn],fav[maxn];void ins(int x,int y)&#123; go[++tot]=y; next[tot]=f1[x]; f1[x]=tot; fav[y]=tot;&#125;int com[maxn],roll[maxn],d[maxn];void find_roll()&#123; int j=0; fo(i,1,n) if (!com[i]) d[++j]=i; for(int i=1; i&lt;=j; i++) &#123; if (--com[fa[d[i]]]==0) d[++j]=fa[d[i]]; &#125; roll[0]=0; fo(i,1,n) if (com[i]) roll[++roll[0]]=i;&#125;void make_d(int k,int pn)&#123; d[ d[0]=1 ]=k; for(int i=1; i&lt;=d[0]; i++) &#123; for(int p=f1[d[i]]; p; p=next[p]) if (p!=pn) d[++d[0]]=go[p]; &#125;&#125;PAR f[2][maxn][2],g[2][maxn];int fro[2][maxn];bool bz[maxn];void bfs_dp(int ty,int k,int pn)&#123; fd(i,d[0],1) &#123; int k=d[i]; bz[d[i]]=1; PAR sum=make_pair(0,0); for(int p=f1[k]; p; p=next[p]) if (p!=pn) sum=sum+g[ty][go[p]]; f[ty][k][0]=sum; f[ty][k][1]=make_pair(0,0); fro[ty][k]=0; for(int p=f1[k]; p; p=next[p]) if (p!=pn) &#123; PAR t=sum-g[ty][go[p]]+f[ty][go[p]][0]; t.first++; t.second+=sex[go[p]]^sex[k]; if (t&gt;f[ty][k][1]) &#123; f[ty][k][1]=t; fro[ty][k]=go[p]; &#125; &#125; if (f[ty][k][0]&gt;f[ty][k][1]) &#123; g[ty][k]=f[ty][k][0]; fro[ty][k]=0; &#125; else g[ty][k]=f[ty][k][1]; &#125;&#125;int cp[maxn][2],cp0;void bfs_ans(int ty,int k,int pn)&#123; fo(i,1,d[0]) &#123; int k=d[i]; if (fro[ty][k]) cp[++cp0][0]=k, cp[cp0][1]=fro[ty][k]; for(int p=f1[k]; p; p=next[p]) if (p!=pn) &#123; if (go[p]==fro[ty][k]) fro[ty][go[p]]=0; &#125; &#125;&#125;int T;int main()&#123; scanf(&quot;%d&quot;,&amp;T); while (T--) &#123; tot=0; memset(f1,0,sizeof(f1)); memset(com,0,sizeof(com)); scanf(&quot;%d&quot;,&amp;n); fo(i,1,n) &#123; scanf(&quot;%d %d&quot;,&amp;fa[i],&amp;sex[i]); sex[i]--; com[fa[i]]++; ins(fa[i],i); &#125; find_roll(); memset(bz,0,sizeof(bz)); int ans1=0, ans2=0; cp0=0; fo(x,1,n) if (!bz[x] &amp;&amp; com[x]) &#123; make_d(x,fav[x]); bfs_dp(0,x,fav[x]); make_d(fa[x],fav[fa[x]]); bfs_dp(1,fa[x],fav[fa[x]]); if (g[0][x]&gt;g[1][fa[x]]) &#123; ans1+=g[0][x].first, ans2+=g[0][x].second; make_d(x,fav[x]); bfs_ans(0,x,fav[x]); &#125; else &#123; ans1+=g[1][fa[x]].first, ans2+=g[1][fa[x]].second; bfs_ans(1,fa[x],fav[fa[x]]); &#125; &#125; printf(&quot;%d %d\\n&quot;,ans1,ans2); fo(i,1,ans1) printf(&quot;%d %d\\n&quot;,cp[i][0],cp[i][1]); &#125;&#125;","categories":[{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[{"name":"算法_DP","slug":"算法-DP","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-DP/"},{"name":"算法_环套树","slug":"算法-环套树","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E7%8E%AF%E5%A5%97%E6%A0%91/"}]},{"title":"【搬自CC_GERALD07】【JZ雅礼联考】Ztxz16学图论 题解","slug":"【搬自CC_GERALD07】【JZ雅礼联考】Ztxz16学图论 题解","date":"2016-09-03T04:14:13.000Z","updated":"2024-04-24T03:59:22.875Z","comments":true,"path":"【搬自CC_GERALD07】【JZ雅礼联考】Ztxz16学图论 题解/","link":"","permalink":"http://kqp.world/%E3%80%90%E6%90%AC%E8%87%AACC_GERALD07%E3%80%91%E3%80%90JZ%E9%9B%85%E7%A4%BC%E8%81%94%E8%80%83%E3%80%91Ztxz16%E5%AD%A6%E5%9B%BE%E8%AE%BA%20%E9%A2%98%E8%A7%A3/","excerpt":"题目大意&emsp;&emsp;给定N个点，M条无向边，Q个询问，每个询问给定L, R，问连上第L~R条边后，图中有多少联通块（询问之间互不影响）。&emsp;&emsp;n, m, q &lt;= 2e5&emsp;&emsp;时限3s","text":"题目大意&emsp;&emsp;给定N个点，M条无向边，Q个询问，每个询问给定L, R，问连上第L~R条边后，图中有多少联通块（询问之间互不影响）。&emsp;&emsp;n, m, q &lt;= 2e5&emsp;&emsp;时限3s 【20%】n,m,q&lt;=1000&emsp;&emsp;每个询问O(n)构图 【60%】n,m,q&lt;=50000&emsp;&emsp;莫队。&emsp;&emsp;由于并查集只支持添加而不支持删除，对于左端点落在第 k 块的询问，我们维护第 k+1 块以后的并查集，对于第 k 块内的操作每次暴力添加。&emsp;&emsp;开两个并查集，一个维护第 k+1 块以后的东西（左端点每到下一个块的时候暴力重构），另一个先把第一个并查集复制过来，再处理第 k 块的操作。 【100%】n,m,q&lt;=2e5&emsp;&emsp;还是莫队。&emsp;&emsp;上面的把一个并查集复制过来这个动作实在太慢了。&emsp;&emsp;第一个并查集维护的东西不变。对于第 k 块的操作，比如要连 x 到 y 的边，在第二个并查集里合并 dsu[x] 和 dsu[y]，这里的 dsu[] 指的是第一个并查集。每个询问搞完后都把第二个并查集初始化。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define fo(i,a,b) for(int i=a;i&lt;=b;i++)using namespace std;const int maxn=2e5+5;struct QT&#123; int l,r,fk,i;&#125;;bool cmp(const QT &amp;a,const QT &amp;b) &#123;return a.fk&lt;b.fk || a.fk==b.fk &amp;&amp; a.r&lt;b.r;&#125;int n,size,m,x[maxn],y[maxn];QT Q[maxn];int fa[2][maxn],ans[2];int get(int ty,int x) &#123;return (fa[ty][x]==x) ?x :fa[ty][x]=get(ty,fa[ty][x]) ;&#125;void merge(int ty,int x,int y)&#123; int t1=get(ty,x), t2=get(ty,y); if (t1!=t2) ans[ty]--, fa[ty][t1]=t2;&#125;int q,Ans[maxn];int main()&#123; scanf(&quot;%d %d %d&quot;,&amp;n,&amp;m,&amp;q); size=sqrt(m); fo(i,1,m) scanf(&quot;%d %d&quot;,&amp;x[i],&amp;y[i]); fo(i,1,q) &#123; scanf(&quot;%d %d&quot;,&amp;Q[i].l,&amp;Q[i].r); Q[i].fk=Q[i].l/size+1; Q[i].i=i; &#125; sort(Q+1,Q+1+q,cmp); fo(i,1,n) fa[1][i]=i; fo(i,1,q) &#123; if (Q[i].fk&gt;Q[i-1].fk) &#123; ans[0]=n; fo(j,1,n) fa[0][j]=j; fo(j,size*Q[i].fk,Q[i].r) merge(0,x[j],y[j]); &#125; else &#123; fo(j,max(Q[i-1].r+1,Q[i].fk*size),Q[i].r) merge(0,x[j],y[j]); &#125; ans[1]=ans[0]; int en=min(Q[i].r,Q[i].fk*size-1); fo(j,Q[i].l,en) merge(1,get(0,x[j]),get(0,y[j])); Ans[Q[i].i]=ans[1]; fo(j,Q[i].l,en) fa[1][fa[0][x[j]]]=fa[0][x[j]], fa[1][fa[0][y[j]]]=fa[0][y[j]]; &#125; fo(i,1,q) printf(&quot;%d\\n&quot;,Ans[i]);&#125;","categories":[{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[{"name":"算法_莫队/分块","slug":"算法-莫队-分块","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E8%8E%AB%E9%98%9F-%E5%88%86%E5%9D%97/"},{"name":"算法_并查集","slug":"算法-并查集","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E5%B9%B6%E6%9F%A5%E9%9B%86/"}]},{"title":"状态论","slug":"状态论","date":"2016-08-26T10:03:44.000Z","updated":"2024-04-24T03:59:22.884Z","comments":true,"path":"状态论/","link":"","permalink":"http://kqp.world/%E7%8A%B6%E6%80%81%E8%AE%BA/","excerpt":"从前我写总结会说：“这场比赛状态不好”“感觉这段时间丢了状态”“要保持一个好的状态，这样才能对付难题” 今天我意识到，状态这种东西，是虚的。","text":"从前我写总结会说：“这场比赛状态不好”“感觉这段时间丢了状态”“要保持一个好的状态，这样才能对付难题” 今天我意识到，状态这种东西，是虚的。 状态大部分由心态决定。调整心态的方法多了去了，磨练心志的方法更是天天有人吹。你比赛之前不看笑话书，就没资格说自己悲观焦虑想不到题。 状态不好不意味着做不好题。分析题目靠的不是状态，而是自己有一套完备的分析体系，对于任何问题任何步骤能在体系中找到相应的解决办法。没有思路实际上是体系的欠缺，自己套路不深不能怪睡不好觉。好的套路应该是万能的，能应对任何状态下的任何情况，如同智能程序时刻知道自己下一步执行什么命令。 状态不好时的补救措施缺失也容易让人把问题归咎于状态，状态不好，没想到问题，接下来应该怎么办，跳进贪心的坑如何转去思考dp、如何利用题目条件把数论转化成图论、码树剖调不出来如何删除最短的代码使他至少是个暴力……去寻找劣一点的算法扒部分分、马上码暴力、马上看下一题……反正问题从来就不是状态不好。 总之，我们不能把状态看成天命，成绩好坏从来就不是天说了算。 这套道理不仅适用于OI，也适合高考。","categories":[{"name":"总结与游记","slug":"总结与游记","permalink":"http://kqp.world/categories/%E6%80%BB%E7%BB%93%E4%B8%8E%E6%B8%B8%E8%AE%B0/"}],"tags":[]},{"title":"2016.8集训总结&自我剖析","slug":"2016.8集训总结自我剖析","date":"2016-08-26T09:38:08.000Z","updated":"2024-04-24T03:59:22.769Z","comments":true,"path":"2016.8集训总结自我剖析/","link":"","permalink":"http://kqp.world/2016.8%E9%9B%86%E8%AE%AD%E6%80%BB%E7%BB%93%E8%87%AA%E6%88%91%E5%89%96%E6%9E%90/","excerpt":"$\\ \\ $","text":"$\\ \\ $ 好多好多的模拟赛&emsp;&emsp;我都做得不是很好貌似。。。&emsp;&emsp;一开始还能切一两个题拿个高分，后面就不行了，被高一和初中虐，被雅礼虐。 好多好多的讲课&emsp;&emsp;栋爷的根号算法专题让我见识到了一系列稀奇古怪的根号算法，有的甚至长得像水法。&emsp;&emsp;然后一系列难题选讲。。。不能说让我见识到奇怪的知识，倒是有些题让我感觉很奇妙。 是时候来一发大总结了。问题&emsp;&emsp;思维能力弱。做难题时找不到方向，做简单模拟时切不下简单题。成绩差的根本原因。&emsp;&emsp;代码能力仍有提升空间，特别是思路很绕的题或者代码很长的题，往往打着打着就乱打了。直接导致时间的浪费。&emsp;&emsp;心态不稳定，临近比赛结束而还没想到什么的话会有较强的焦虑感。&emsp;&emsp;知识点有空缺，虽然这在noip上无伤大雅。 分析&emsp;&emsp;然而每个人的思维是不一样的，不能强求说我非得在考场上有富榄的思考方式，我能做的是完善我自己针对题目的一套分析体系。这么多年我自己有一套相对完备的分析体系（也可以叫做相对不完备的分析体系），在学习别人的解题思路时也get到了不少好的套路。我的目标（或者说人人都应该）是要让自己的体系变得万能，能分析出任何题目的任何优秀算法。&emsp;&emsp;有时候，想象自己拿到了一个题目，然后把所有可能性写下来，然后从可能性推出新的可能性，一一给出策略，感觉就像是在搞大分类讨论一样。&emsp;&emsp;心态的话，我觉得这真是个玄学的问题，我从小到大见过这么多大场面怎么还就浮躁了呢？可能就是因为大场面见太多了，一些不在计划内的状况会让我感到不可思议。这些天我有在比赛时放音乐，有效隔绝了噪音，包括外在的催人的键盘声和内在的情绪杂音。享受思考时那份纯粹的宁静。我需要源自内心的强大的bgm，强大到不需要外部声源就可以屏蔽杂音。&emsp;&emsp;最后来说说知识点的空缺，这个问题现在来说不是最重要的，毕竟noip不需要花式知识点。有一些noip模拟题弄了省赛及以上知识点，那些严格意义只是参考noip的赛制的省赛模拟而已。当务之急是解决上面三个。 面对即将到来的noip&emsp;&emsp;静候。","categories":[{"name":"总结与游记","slug":"总结与游记","permalink":"http://kqp.world/categories/%E6%80%BB%E7%BB%93%E4%B8%8E%E6%B8%B8%E8%AE%B0/"},{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[]},{"title":"用线段树维护树的直径","slug":"treediameter_by_segmenttree","date":"2016-08-22T13:54:40.000Z","updated":"2024-04-24T03:59:22.799Z","comments":true,"path":"treediameter_by_segmenttree/","link":"","permalink":"http://kqp.world/treediameter_by_segmenttree/","excerpt":"目的&emsp;&emsp;有时候我们需要快速回答一棵子树的直径，或者去掉一棵子树后形成的树的直径。普通的找直径方法是两遍 bfs，时间 $O(n)$，这里的方法用 $O(\\log n)$ 的时间回答。","text":"目的&emsp;&emsp;有时候我们需要快速回答一棵子树的直径，或者去掉一棵子树后形成的树的直径。普通的找直径方法是两遍 bfs，时间 $O(n)$，这里的方法用 $O(\\log n)$ 的时间回答。 操作首先&emsp;&emsp;我们做出一棵树的 dfs 序，然后以 dfs 序为轴建立线段树，每个区间维护直径 $len$，以及直径的两个端点 $x$ 和 $y$。&emsp;&emsp;会有这么一个问题：你按线段树划分区间，那一个区间内的点可能不连通啊！！！其实没问题的，因为我们最后询问的是一棵（子）树，意思是我们询问的东西肯定是连通的。所以操作时候不联通你就当它连通就好啦。&emsp;&emsp;还会有这么一个问题：直径可能不止一条啊！！！随便记录一条即可，下文解释。 最关键是这个合并&emsp;&emsp;区间内只有 1 个点的时候 $len=0$，$x,y$ 等于自己。&emsp;&emsp;现在考虑区间的合并。左区间有两个直径端点，右区间也有两个直径端点，这四个点中的最远点对，就是新区间的直径。&emsp;&emsp;注意我们这里用的距离是原树的距离（已经说过我们强行让一个区间的点是连通的了）。 &emsp;&emsp;简单证明一下。&emsp;&emsp;我们看作是 $x$ 所在的连通块通过边 $(x,y)$ 连向 $y$ 所在的连通块。&emsp;&emsp;若新直径不经过 $(x,y)$ ，则就是原来的两条直径取 $\\max$。&emsp;&emsp;若新直径经过 $(x,y)$ ，就要考虑 $x$ 延伸到哪儿、$y$ 延伸到哪儿了。由直径的定义可知，$x$ 能走到的最远点之一是 $x$ 所在连通块直径的端点，$y$ 同理。因此这时新直径的两个端点都是旧直径的端点。 &emsp;&emsp;（这个证明也适用于增量法求树的直径，即我给一棵树加一个新点，那么新直径必有一端点是旧直径的端点）&emsp;&emsp;（注意只能是树，普通图没有这些性质） 所以&emsp;&emsp;有了这个神奇的合并操作，我们就可以求树中任意一个联通块（子树或是去掉一个子树什么的）的直径啦！ 注意事项&emsp;&emsp;我们求点对距离时会用到 lca，然而线段树已经有一个 $\\log$ 了，如果碰到题目要卡两个 $\\log$，就要用 rmq 求 lca。 例题例题1 例题2","categories":[{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[{"name":"算法_线段树","slug":"算法-线段树","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E7%BA%BF%E6%AE%B5%E6%A0%91/"}]},{"title":"【JZOJ4727】挺进 题解","slug":"【JZOJ4727】挺进 题解","date":"2016-08-22T13:19:57.000Z","updated":"2024-04-24T03:59:22.850Z","comments":true,"path":"【JZOJ4727】挺进 题解/","link":"","permalink":"http://kqp.world/%E3%80%90JZOJ4727%E3%80%91%E6%8C%BA%E8%BF%9B%20%E9%A2%98%E8%A7%A3/","excerpt":"题目&emsp;&emsp;ETG 的地图是树形的，相邻房间有一定距离。一开始，系统会随机断掉一条边，然后把四个宝箱两两分布在每个联通块的最远点对上。&emsp;&emsp;一开始，小 Z 会出生在一个有宝箱的房间，然后他走到有另外一个宝箱的所在地，接着系统把他送到另一个联通块的某个宝箱处，然后小 Z 走到最后一个宝箱处，就通关了。&emsp;&emsp;小 Z 想知道他最多会走多少距离。 &emsp;&emsp;$n \\leq 10^5$","text":"题目&emsp;&emsp;ETG 的地图是树形的，相邻房间有一定距离。一开始，系统会随机断掉一条边，然后把四个宝箱两两分布在每个联通块的最远点对上。&emsp;&emsp;一开始，小 Z 会出生在一个有宝箱的房间，然后他走到有另外一个宝箱的所在地，接着系统把他送到另一个联通块的某个宝箱处，然后小 Z 走到最后一个宝箱处，就通关了。&emsp;&emsp;小 Z 想知道他最多会走多少距离。 &emsp;&emsp;$n \\leq 10^5$ 一句话题意&emsp;&emsp;给出一棵树，你可以选择断掉某一条边，然后取生成的两棵树的直径和。求这个和的最大值。 【50%】$n \\leq 1000$&emsp;&emsp;枚举断哪一条边，然后暴力求直径。 【100%解法1】$n \\leq 10^5$&emsp;&emsp;用线段树维护树的直径。&emsp;&emsp;枚举断哪一条边，这相当于分离出原树的一棵子树，我们可以在线段树中查找到这棵子树的直径，然后剩下的区间合并一下得到另一个直径。&emsp;&emsp;如果用倍增求 lca 时间是 $O(n \\log^2 n)$，会被卡。&emsp;&emsp;如果用 rmq 求 lca 时间是 $O(n \\log n)$。 【100%解法2】&emsp;&emsp;静态的子树直径可以用树形 DP，记录 $d1_i$ (最长链)，$d2_i$ (次长链)，$fa_i$（ $i$ 的父亲及以上的最长路）即可。时间复杂度 $O(n)$。&emsp;&emsp;思路是非常简单的，但是维护过程写起来讨论较多。 解法1代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#define fo(i,a,b) for(int i=a;i&lt;=b;i++)#define fd(i,a,b) for(int i=a;i&gt;=b;i--)using namespace std;typedef long long LL;const int maxn=(1e5)+5, MX=18;struct TR&#123; int x,y; LL len; TR(int X=0,int Y=0,LL LEN=0) &#123;x=X, y=Y, len=LEN;&#125;&#125;;int n;int tot,go[2*maxn],next[2*maxn],f1[maxn];LL val[2*maxn];void ins(int x,int y,LL z)&#123; go[++tot]=y; val[tot]=z; next[tot]=f1[x]; f1[x]=tot;&#125;int fa[2*maxn][MX+5],deep[maxn],ap[2*maxn],fir[2*maxn],Log[2*maxn],er[MX+5];void rmq_pre()&#123; fo(i,1,ap[0]) fa[i][0]=ap[i], Log[i]=log(i)/log(2); fo(i,0,MX) er[i]=1&lt;&lt;i; fo(j,1,MX) fo(i,1,ap[0]) &#123; fa[i][j]=fa[i][j-1]; if (i+er[j-1]&lt;=ap[0] &amp;&amp; deep[fa[i+er[j-1]][j-1]]&lt;deep[fa[i][j]]) fa[i][j]=fa[i+er[j-1]][j-1]; &#125;&#125;int lca(int x,int y)&#123; x=fir[x], y=fir[y]; if (x&gt;y) swap(x,y); int t=Log[y-x+1]; return (deep[fa[x][t]]&lt;deep[fa[y-er[t]+1][t]]) ?fa[x][t] :fa[y-er[t]+1][t] ;&#125;int st[maxn],en[maxn],sum,Tbh[maxn];LL dis[maxn];void dfs_pre(int k,int last,LL s)&#123; deep[k]=deep[last]+1; dis[k]=s; ap[++ap[0]]=k, fir[k]=ap[0]; Tbh[++sum]=k, st[k]=sum; for(int p=f1[k]; p; p=next[p]) if (go[p]!=last) &#123; dfs_pre(go[p],k,s+val[p]); ap[++ap[0]]=k; &#125; en[k]=sum;&#125;TR tr[4*maxn];LL DIS(int x,int y) &#123;return dis[x]+dis[y]-dis[lca(x,y)]*2;&#125;TR merge(TR a,TR b)&#123; TR re= (a.len&gt;b.len) ?a :b; if (DIS(a.x,b.x)&gt;re.len) re=TR(a.x,b.x,DIS(a.x,b.x)); if (DIS(a.x,b.y)&gt;re.len) re=TR(a.x,b.y,DIS(a.x,b.y)); if (DIS(a.y,b.x)&gt;re.len) re=TR(a.y,b.x,DIS(a.y,b.x)); if (DIS(a.y,b.y)&gt;re.len) re=TR(a.y,b.y,DIS(a.y,b.y)); return re;&#125;void tr_js(int k,int l,int r)&#123; if (l==r) &#123; tr[k].x=tr[k].y=Tbh[l]; tr[k].len=0; return; &#125; int t=k&lt;&lt;1, t1=(l+r)&gt;&gt;1; tr_js(t,l,t1), tr_js(t+1,t1+1,r); tr[k]=merge(tr[t],tr[t+1]);&#125;TR tr_cx(int k,int l,int r,int x,int y)&#123; if (l==x &amp;&amp; r==y) return tr[k]; int t=k&lt;&lt;1, t1=(l+r)&gt;&gt;1; if (y&lt;=t1) return tr_cx(t,l,t1,x,y); else if (x&gt;t1) return tr_cx(t+1,t1+1,r,x,y); else return merge(tr_cx(t,l,t1,x,t1),tr_cx(t+1,t1+1,r,t1+1,y));&#125;LL ans;void dfs(int k,int last)&#123; for(int p=f1[k]; p; p=next[p]) if (go[p]!=last) &#123; int St=st[go[p]], En=en[go[p]]; if (St==1) &#123; ans=max(ans,tr_cx(1,1,n,St,En).len+tr_cx(1,1,n,En+1,n).len); &#125; else if (En==n) &#123; ans=max(ans,tr_cx(1,1,n,1,St-1).len+tr_cx(1,1,n,St,En).len); &#125; else &#123; TR t=merge(tr_cx(1,1,n,1,St-1),tr_cx(1,1,n,En+1,n)); ans=max(ans,t.len+tr_cx(1,1,n,St,En).len); &#125; dfs(go[p],k); &#125;&#125;int main()&#123; scanf(&quot;%d&quot;,&amp;n); fo(i,1,n-1) &#123; int x,y; LL d; scanf(&quot;%d %d %lld&quot;,&amp;x,&amp;y,&amp;d); ins(x,y,d), ins(y,x,d); &#125; dfs_pre(1,0,0); rmq_pre(); tr_js(1,1,n); dfs(1,0); printf(&quot;%lld\\n&quot;,ans);&#125;","categories":[{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[{"name":"算法_线段树","slug":"算法-线段树","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"name":"算法_DP","slug":"算法-DP","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-DP/"}]},{"title":"【JZOJ4587】Snow的追寻 题解","slug":"【JZOJ4587】Snow的追寻 题解","date":"2016-08-22T12:59:01.000Z","updated":"2024-04-24T03:59:22.849Z","comments":true,"path":"【JZOJ4587】Snow的追寻 题解/","link":"","permalink":"http://kqp.world/%E3%80%90JZOJ4587%E3%80%91Snow%E7%9A%84%E8%BF%BD%E5%AF%BB%20%E9%A2%98%E8%A7%A3/","excerpt":"题目大意&emsp;&emsp;有一棵有 $n$ 个节点的根节点为 1 的树，他只能走一条不经过重复节点的路径。&emsp;&emsp;给出 $q$ 个形如“$x\\ y$”的询问，表示他不能走到 $x$ 和 $y$ 的子树中。现在他想知道对于每组询问，他能走的最长路径是多少，如果没有，输出 0。&emsp;&emsp;$n, q \\le 10^5$","text":"题目大意&emsp;&emsp;有一棵有 $n$ 个节点的根节点为 1 的树，他只能走一条不经过重复节点的路径。&emsp;&emsp;给出 $q$ 个形如“$x\\ y$”的询问，表示他不能走到 $x$ 和 $y$ 的子树中。现在他想知道对于每组询问，他能走的最长路径是多少，如果没有，输出 0。&emsp;&emsp;$n, q \\le 10^5$ \\\\ \\\\ \\\\【显然】&emsp;&emsp;可走的地方还是一棵树，而我们要求的路径就是这棵树的直径。 【50%】$n,q \\le 2000$&emsp;&emsp;每个询问暴力找直径。 【100%】$n,q \\le 10^5$&emsp;&emsp;我们需要用线段树维护树的直径。&emsp;&emsp;去掉两棵子树，相当于在 dfs 序上去掉两个区间（注意这两个区间可能有交或存在包含关系），我们把剩下的区间合并就行了。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#define fo(i,a,b) for(int i=a;i&lt;=b;i++)#define fd(i,a,b) for(int i=a;i&gt;=b;i--)using namespace std;typedef long long LL;const int maxn=(1e5)+5, MX=18;struct TR&#123; int x,y,len; TR(int X=0,int Y=0,int LEN=0) &#123;x=X, y=Y, len=LEN;&#125;&#125;;int n;int tot,go[2*maxn],next[2*maxn],f1[maxn];void ins(int x,int y)&#123; go[++tot]=y; next[tot]=f1[x]; f1[x]=tot;&#125;int fa[2*maxn][MX+5],deep[maxn],ap[2*maxn],fir[2*maxn],Log[2*maxn],er[MX+5];void rmq_pre()&#123; fo(i,1,ap[0]) fa[i][0]=ap[i], Log[i]=log(i)/log(2); fo(i,0,MX) er[i]=1&lt;&lt;i; fo(j,1,MX) fo(i,1,ap[0]) &#123; fa[i][j]=fa[i][j-1]; if (i+er[j-1]&lt;=ap[0] &amp;&amp; deep[fa[i+er[j-1]][j-1]]&lt;deep[fa[i][j]]) fa[i][j]=fa[i+er[j-1]][j-1]; &#125;&#125;int lca(int x,int y)&#123; x=fir[x], y=fir[y]; if (x&gt;y) swap(x,y); int t=Log[y-x+1]; return (deep[fa[x][t]]&lt;deep[fa[y-er[t]+1][t]]) ?fa[x][t] :fa[y-er[t]+1][t] ;&#125;int st[maxn],en[maxn],sum,Tbh[maxn];void dfs_pre(int k,int last)&#123; deep[k]=deep[last]+1; ap[++ap[0]]=k, fir[k]=ap[0]; Tbh[++sum]=k, st[k]=sum; for(int p=f1[k]; p; p=next[p]) if (go[p]!=last) &#123; dfs_pre(go[p],k); ap[++ap[0]]=k; &#125; en[k]=sum;&#125;TR tr[4*maxn];int DIS(int x,int y) &#123;return deep[x]+deep[y]-deep[lca(x,y)]*2;&#125;TR merge(TR a,TR b)&#123; if (a.len==-1) return b; TR re= (a.len&gt;b.len) ?a :b; if (DIS(a.x,b.x)&gt;re.len) re=TR(a.x,b.x,DIS(a.x,b.x)); if (DIS(a.x,b.y)&gt;re.len) re=TR(a.x,b.y,DIS(a.x,b.y)); if (DIS(a.y,b.x)&gt;re.len) re=TR(a.y,b.x,DIS(a.y,b.x)); if (DIS(a.y,b.y)&gt;re.len) re=TR(a.y,b.y,DIS(a.y,b.y)); return re;&#125;void tr_js(int k,int l,int r)&#123; if (l==r) &#123; tr[k].x=tr[k].y=Tbh[l]; tr[k].len=0; return; &#125; int t=k&lt;&lt;1, t1=(l+r)&gt;&gt;1; tr_js(t,l,t1), tr_js(t+1,t1+1,r); tr[k]=merge(tr[t],tr[t+1]);&#125;TR tr_cx(int k,int l,int r,int x,int y)&#123; if (l==x &amp;&amp; r==y) return tr[k]; int t=k&lt;&lt;1, t1=(l+r)&gt;&gt;1; if (y&lt;=t1) return tr_cx(t,l,t1,x,y); else if (x&gt;t1) return tr_cx(t+1,t1+1,r,x,y); else return merge(tr_cx(t,l,t1,x,t1),tr_cx(t+1,t1+1,r,t1+1,y));&#125;int q;int main()&#123; freopen(&quot;snow.in&quot;,&quot;r&quot;,stdin); freopen(&quot;snow.out&quot;,&quot;w&quot;,stdout); scanf(&quot;%d %d&quot;,&amp;n,&amp;q); fo(i,1,n-1) &#123; int x,y;; scanf(&quot;%d %d&quot;,&amp;x,&amp;y); ins(x,y), ins(y,x); &#125; dfs_pre(1,0); rmq_pre(); tr_js(1,1,n); while (q--) &#123; int x,y; scanf(&quot;%d %d&quot;,&amp;x,&amp;y); if (st[x]&gt;st[y]) swap(x,y); TR ans=TR(0,0,-1); if (1&lt;st[x]) ans=merge(ans,tr_cx(1,1,n,1,st[x]-1)); if (en[x]+1&lt;st[y]) ans=merge(ans,tr_cx(1,1,n,en[x]+1,st[y]-1)); int En=max(en[x],en[y]); if (En&lt;n) ans=merge(ans,tr_cx(1,1,n,En+1,n)); printf(&quot;%d\\n&quot;,(ans.len==-1) ?0 :ans.len ); &#125;&#125;","categories":[{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[{"name":"算法_线段树","slug":"算法-线段树","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E7%BA%BF%E6%AE%B5%E6%A0%91/"}]},{"title":"【JZ雅礼联考】斐波那契 题解","slug":"【JZ雅礼联考】斐波那契 题解","date":"2016-08-21T14:35:41.000Z","updated":"2024-04-24T03:59:22.858Z","comments":true,"path":"【JZ雅礼联考】斐波那契 题解/","link":"","permalink":"http://kqp.world/%E3%80%90JZ%E9%9B%85%E7%A4%BC%E8%81%94%E8%80%83%E3%80%91%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%20%E9%A2%98%E8%A7%A3/","excerpt":"题目大意&emsp;&emsp;定义Fibonacci数列为：$F[1]=1;~F[2]=1;~F[n]=F[n-1]+F[n-2]~(n&gt;2)$&emsp;&emsp;现有一个n个元素的数列$a$，进行m个操作，操作类型如下：&emsp;&emsp;1 L R$~$表示给$a_i$加上$F[i-L+1]$，其中 L&lt;=i&lt;=R&emsp;&emsp;2 L R$~$表示询问$\\sum_{i=L}^Ra_i~mod~(10^9+9)$&emsp;&emsp;1&lt;=n, m&lt;=10^5","text":"题目大意&emsp;&emsp;定义Fibonacci数列为：$F[1]=1;~F[2]=1;~F[n]=F[n-1]+F[n-2]~(n&gt;2)$&emsp;&emsp;现有一个n个元素的数列$a$，进行m个操作，操作类型如下：&emsp;&emsp;1 L R$~$表示给$a_i$加上$F[i-L+1]$，其中 L&lt;=i&lt;=R&emsp;&emsp;2 L R$~$表示询问$\\sum_{i=L}^Ra_i~mod~(10^9+9)$&emsp;&emsp;1&lt;=n, m&lt;=10^5 【40%】n,m&lt;=1000&emsp;&emsp;$O(nm)$暴力 【100%解法1】n,m&lt;=10^5&emsp;&emsp;考虑平衡规划（定期重构），把修改操作储存起来，储到了$\\sqrt{n}$个修改的时候更新原序列。&emsp;&emsp;修改更新原序列：每个位置维护一个二元组$(x,y)$，$x$表示它前一个元素的增加量，$y$表示自己的增加量。对于第 j 个修改$L_j$~$R_j$，我们使$y_{L_j}+=1$，$x_{R_j+1}-=F[Len_j]$，$y_{R_j+1}-=F[Len_j+1]$。（这个类似于+1-1标记）。然后做一遍类似Fibonacci一样的循环：$x_i+=y_{i-1}$，$y_i+=x_{i-1}+y_{i-1}$。这样，我们就处理出了每个元素的增加量，最后$a_i+=y_i$。&emsp;&emsp;询问：此时还剩下的修改操作在$\\sqrt{n}$个以内，我们可以对剩下的每一个修改操作直接计算出对答案的贡献，最后加上原序列的前缀和即可。&emsp;&emsp;时间复杂度$O(m\\sqrt{n})$ 【100%解法1.5】&emsp;&emsp;解法1的修改我们维护的是一个二元组，其实每个位置维护一个值就行了。这算是个优化吧。 【100%解法2】&emsp;&emsp;我们要知道这么些东西：&emsp;&emsp;1、若$H_1=a$，$H_2=b$，$H_n=H_{n-1}+H_{n-2}$，则$H_n=aF_{n-2}+bF_{n-1}$。&emsp;&emsp;2、推广一下，对于$H_1=a$、$H_2=b$的类Fibonacci数列，满足$\\sum_{i=1}^nH_i=H_{n+2}-b$&emsp;&emsp;因此我们只需知道数列的前两项就可以快速求和。&emsp;&emsp;用线段树维护区间内的数列的前两项。&emsp;&emsp;时间复杂度$O(m\\log n)$ 【100%解法3】&emsp;&emsp;我们知道Fibonacci数列是有通项公式的。&emsp;&emsp;科普：对于形如$F_n=pF_{n-1}+qF_{n-2}$的递推数列，令$x^2=px+q$，若该方程有两个不同的实数根$x_1$和$x_2$，则$F_n$的通项公式一定可以表示成$F_n=αx_1^n+βx_2^n$的形式&emsp;&emsp;事实上，在本题的模意义下，$F[n]≡276601605*(691504013^n − 308495997^n)$。&emsp;&emsp;于是任务变成维护两个等比数列。因为两个公比相同的等比数列可以直接相加，所以维护数列的首项即可。这个可以用线段树解决。&emsp;&emsp;时间复杂度$O(m \\log n)$ 解法1代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define fo(i,a,b) for(int i=a;i&lt;=b;i++)using namespace std;typedef long long LL;const int maxn=(1e5)+5;const LL mo=(1e9)+9;int n,sqrtn,m;LL a[maxn],Sa[maxn],f[maxn],Sf[maxn];int mdf[maxn][2],m0;LL d[maxn][2];int main()&#123; f[1]=f[2]=1; Sf[1]=1, Sf[2]=2; fo(i,3,maxn-5) f[i]=(f[i-1]+f[i-2])%mo, Sf[i]=(Sf[i-1]+f[i])%mo; scanf(&quot;%d %d&quot;,&amp;n,&amp;m); sqrtn=sqrt(n); fo(i,1,n) scanf(&quot;%lld&quot;,&amp;a[i]), Sa[i]=(Sa[i-1]+a[i])%mo; while (m--) &#123; int ty,l,r; scanf(&quot;%d %d %d&quot;,&amp;ty,&amp;l,&amp;r); if (ty==1) &#123; mdf[++m0][0]=l, mdf[m0][1]=r; if (m0==sqrtn) &#123; memset(d,0,sizeof(d)); fo(i,1,m0) &#123; d[mdf[i][0]][1]=(d[mdf[i][0]][1]+1)%mo; int len=mdf[i][1]-mdf[i][0]+1; d[mdf[i][1]+1][0]=(d[mdf[i][1]+1][0]-f[len]+mo)%mo; d[mdf[i][1]+1][1]=(d[mdf[i][1]+1][1]-f[len+1]+mo)%mo; &#125; fo(i,1,n) &#123; d[i][0]=(d[i][0]+d[i-1][1])%mo; d[i][1]=(d[i][1]+d[i-1][0]+d[i-1][1])%mo; &#125; fo(i,1,n) a[i]=(a[i]+d[i][1])%mo, Sa[i]=(Sa[i-1]+a[i])%mo; m0=0; &#125; &#125; else &#123; LL ans=(Sa[r]-Sa[l-1]+mo)%mo; fo(i,1,m0) &#123; int tl=max(l,mdf[i][0]), tr=min(r,mdf[i][1]); if (tl&lt;=tr) &#123; int ttl=tl-mdf[i][0]+1, ttr=ttl+tr-tl; ans=(ans+ Sf[ttr]-Sf[ttl-1]+mo )%mo; &#125; &#125; printf(&quot;%lld\\n&quot;,ans); &#125; &#125;&#125; 解法2代码来自LZH1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;cstdio&gt;#define min(x, y) ((x)&lt;(y)?(x):(y))#define max(x, y) ((x)&lt;(y)?(y):(x))const int N= 100005, K= 131072, P= 1e9+9;int num[K*2][2], sum[K*2], f[N][2], s[N][2];int a[N], c[20];int n, m, k, x, y, ans;void join(int q, int p, int t)&#123; sum[t]= (sum[t]+ ((long long)s[min(p, y)-x+1][0] - s[max(0, q-x)][0]+P + s[min(p, y)-x+1][1] - s[max(0, q-x)][1]+(long long)P) % P ) % P; if(x&lt;=q &amp;&amp; p&lt;=y)&#123; num[t][0]= (num[t][0]+(long long)f[q-x+1][0]+f[q-x+1][1])%P; num[t][1]= (num[t][1]+(long long)f[q-x+2][0]+f[q-x+2][1])%P; return; &#125; int mid= (q+p)&gt;&gt;1; if(x&lt;=mid) join(q, mid, t&lt;&lt;1); if(y&gt;mid) join(mid+1, p, t&lt;&lt;1|1);&#125;void find(int q, int p, int t)&#123; if(x&lt;=q &amp;&amp; p&lt;=y)&#123; ans= (ans+sum[t])%P; return; &#125; ans= (ans+num[t][0]*(s[min(p, y)-q+1][0]-(long long)s[max(0, x-q)][0]+P))%P; ans= (ans+num[t][1]*(s[min(p, y)-q+1][1]-(long long)s[max(0, x-q)][1]+P))%P; int mid= (q+p)&gt;&gt;1; if(x&lt;=mid) find(q, mid, t&lt;&lt;1); if(y&gt;mid) find(mid+1, p, t&lt;&lt;1|1);&#125;int read()&#123; register char ch; register int x; for(ch= getchar(); ch&lt;&#x27;0&#x27; || ch&gt;&#x27;9&#x27;; ch= getchar()); for(x= ch-&#x27;0&#x27;, ch= getchar(); ch&gt;=&#x27;0&#x27; &amp;&amp; ch&lt;=&#x27;9&#x27;; x= x*10+ch-&#x27;0&#x27;, ch= getchar()); return x;&#125;int main()&#123; n= read(); m= read(); for(register int i= 1; i&lt;=n; i++) a[i]= (a[i-1]+read())%P; f[1][0]= f[2][1]= 1; s[1][0]= s[2][1]= s[2][0]= 1; for(register int i= 2; i&lt;=n; i++)&#123; f[i+1][0]= (f[i][0]+ f[i-1][0])%P; f[i+1][1]= (f[i][1]+ f[i-1][1])%P; s[i+1][0]= (f[i+1][0]+ s[i][0])%P; s[i+1][1]= (f[i+1][1]+ s[i][1])%P; &#125; for(int i= 1; i&lt;=m; i++)&#123; k= read(); x= read(); y= read(); if(k==1)&#123; join(1, K, 1); &#125;else&#123; ans= 0; find(1, K, 1); ans= ((long long)ans+a[y]-a[x-1]+P+P)%P; printf(&quot;%d\\n&quot;, ans); &#125; &#125; return 0;&#125; 参考资料：Johann写的题解引用：lzh大神的代码","categories":[{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[{"name":"算法_数论","slug":"算法-数论","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E6%95%B0%E8%AE%BA/"},{"name":"算法_线段树","slug":"算法-线段树","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"name":"算法_平衡规划（定期重构）","slug":"算法-平衡规划（定期重构）","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E5%B9%B3%E8%A1%A1%E8%A7%84%E5%88%92%EF%BC%88%E5%AE%9A%E6%9C%9F%E9%87%8D%E6%9E%84%EF%BC%89/"}]},{"title":"【JZ雅礼联考】跳楼机 题解","slug":"【JZ雅礼联考】跳楼机 题解","date":"2016-08-21T09:06:23.000Z","updated":"2024-04-24T03:59:22.859Z","comments":true,"path":"【JZ雅礼联考】跳楼机 题解/","link":"","permalink":"http://kqp.world/%E3%80%90JZ%E9%9B%85%E7%A4%BC%E8%81%94%E8%80%83%E3%80%91%E8%B7%B3%E6%A5%BC%E6%9C%BA%20%E9%A2%98%E8%A7%A3/","excerpt":"题目&emsp;&emsp;Srwudi的家是一幢h层的摩天大楼。经过改造，srwudi的跳楼机可以采用以下四种方式移动：&emsp;&emsp;1、向上移动 $x$ 层；&emsp;&emsp;2、向上移动 $y$ 层；&emsp;&emsp;3、向上移动 $z$ 层；&emsp;&emsp;4、回到第一层。&emsp;&emsp;现在 DJL 在第一层，跳楼机也在第一层。求DJL可以乘坐跳楼机前往的楼层数。&emsp;&emsp;$h \\le 10^{18},\\ \\ x, y, z \\le 10^5$ 题目大意&emsp;&emsp;给出h、x、y、z，求 [1,h] 中有多少个数，可以表示成 ax+by+cz 的形式。","text":"题目&emsp;&emsp;Srwudi的家是一幢h层的摩天大楼。经过改造，srwudi的跳楼机可以采用以下四种方式移动：&emsp;&emsp;1、向上移动 $x$ 层；&emsp;&emsp;2、向上移动 $y$ 层；&emsp;&emsp;3、向上移动 $z$ 层；&emsp;&emsp;4、回到第一层。&emsp;&emsp;现在 DJL 在第一层，跳楼机也在第一层。求DJL可以乘坐跳楼机前往的楼层数。&emsp;&emsp;$h \\le 10^{18},\\ \\ x, y, z \\le 10^5$ 题目大意&emsp;&emsp;给出h、x、y、z，求 [1,h] 中有多少个数，可以表示成 ax+by+cz 的形式。 【这真是一个有趣的题目】 【40%】h,x,y,z&lt;=10^5&emsp;&emsp;设 f[i] 表示 i 能不能被跳到。f[1]=1。&emsp;&emsp;f[i]=f[i-x] | f[i-y] | f[i-z] 【100%】h&lt;=10^18&emsp;&emsp;假设我们最后再跳 x。&emsp;&emsp;发现如果我们只用 y 和 z，能够跳到 h1 和 h2 两个位置（h1&lt; h2），而 h1 可以用 x 来跳到 h2，那么为了避免重复，我们只保留 h1。&emsp;&emsp;设 $f[i]$ 表示仅用 y 和 z 来跳，能跳到的 %x 等于 i 的最小位置。那么显然 ans=\\sum_{i=0}^{x-1}(\\lfloor\\frac{h-f[i]}{x}\\rfloor+1)&emsp;&emsp;接下来考虑怎么求 $f$ 数组。我们发现这样两种转移 f[(i+y) \\bmod x]=f[i]+y \\\\ f[(i+z) \\bmod x]=f[i]+z&emsp;&emsp;于是这就是个最短路。跑一遍spfa求出 $f$ 数组，就可以计算答案了。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define fo(i,a,b) for(int i=a;i&lt;=b;i++)using namespace std;typedef long long LL;const int maxx=(1e5)+5;LL h;int x,y,z;int tot,go[2*maxx],next[2*maxx],f1[maxx];LL val[2*maxx];void ins(int x,int y,LL z)&#123; go[++tot]=y; val[tot]=z; next[tot]=f1[x]; f1[x]=tot;&#125;LL f[maxx];bool bz[maxx];int d[8*maxx];void spfa(int st)&#123; memset(f,127,sizeof(f)); f[st]=1; bz[st]=1; d[1]=st; for(int i=1, j=1; i&lt;=j; i++) &#123; for(int p=f1[d[i]]; p; p=next[p]) if (f[d[i]]+val[p]&lt;f[go[p]]) &#123; f[go[p]]=f[d[i]]+val[p]; if (!bz[go[p]]) &#123; bz[ d[++j]=go[p] ]=1; if (f[d[i+1]]&gt;f[d[j]]) swap(d[i+1],d[j]); &#125; &#125; bz[d[i]]=0; &#125;&#125;int main()&#123; scanf(&quot;%lld%d%d%d&quot;,&amp;h,&amp;x,&amp;y,&amp;z); fo(i,0,x-1) &#123; ins(i,(i+y)%x,y); ins(i,(i+z)%x,z); &#125; spfa(1%x); LL ans=0; fo(i,0,x-1) if (f[i]&lt;=h) ans+=(h-f[i])/x+1; printf(&quot;%lld\\n&quot;,ans);&#125;","categories":[{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[{"name":"算法_最短路模型","slug":"算法-最短路模型","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E6%9C%80%E7%9F%AD%E8%B7%AF%E6%A8%A1%E5%9E%8B/"}]},{"title":"【JZOJ4718】准备食物2 题解","slug":"【JZOJ4718】准备食物2 题解","date":"2016-08-20T12:41:48.000Z","updated":"2024-04-24T03:59:22.849Z","comments":true,"path":"【JZOJ4718】准备食物2 题解/","link":"","permalink":"http://kqp.world/%E3%80%90JZOJ4718%E3%80%91%E5%87%86%E5%A4%87%E9%A3%9F%E7%89%A92%20%E9%A2%98%E8%A7%A3/","excerpt":"题目大意&emsp;&emsp;现在觉有 m 种食物，第 i 种食物有 a[i] 份。觉要为 n 个宠物按编号顺序分配食物，每个宠物需要 1 份食物。&emsp;&emsp;觉通过读心，得出了每个宠物吃了每种食物后的喜悦值。觉还发现，对于其中一些宠物，假设它的编号为 i，如果 1~i-1 的宠物中，超过 s[i] 个被分配了第 num[i] 种食物，那么它会反动。&emsp;&emsp;在不反动的情况下，求所有宠物的喜悦值之和最大。&emsp;&emsp;1&lt;=n&lt;=200， 1&lt;=m&lt;=100， 0&lt;=喜悦值$v[i][j]$&lt;=10^5","text":"题目大意&emsp;&emsp;现在觉有 m 种食物，第 i 种食物有 a[i] 份。觉要为 n 个宠物按编号顺序分配食物，每个宠物需要 1 份食物。&emsp;&emsp;觉通过读心，得出了每个宠物吃了每种食物后的喜悦值。觉还发现，对于其中一些宠物，假设它的编号为 i，如果 1~i-1 的宠物中，超过 s[i] 个被分配了第 num[i] 种食物，那么它会反动。&emsp;&emsp;在不反动的情况下，求所有宠物的喜悦值之和最大。&emsp;&emsp;1&lt;=n&lt;=200， 1&lt;=m&lt;=100， 0&lt;=喜悦值$v[i][j]$&lt;=10^5 【20%】n,m&lt;=8&emsp;&emsp;暴力 【50%】没有宠物会反动&emsp;&emsp;左边一排 n 个点表示 n 个宠物，右边一排 m 个点表示 m 种食物，S 连向每个宠物容量 1 费用 0 的边，每个宠物连向每种食物容量 1 费用 $v[i][j]$ 的边，每种食物连向 T 容量 a[i] 费用 0 的边。跑最大费用最大流。 【100%】n&lt;=200, m&lt;=100&emsp;&emsp;沿用50分的图，我们现在要把反动限制加上去。&emsp;&emsp;对于一个反动限制，大概就是对于第 j 种食物，限制它 1~i 的宠物流过来的流量。所以很直观地，把每个食物拆成 n 个点，原来第 i 个宠物向第j种食物的连边就连到第 j 种食物的第 i 个点，然后每种食物的第 i 个点连向第 i+1 个点（有限制就容量 s[i] 费用 0，否则容量 inf 费用 0）。&emsp;&emsp;然而这样拆点我们发现太浪费了，限制最多 n 个，我们却拆成了 n*m 个点。所以我们考虑合并那些没用的点，具体来说就是，对于第 j 种食物，它有多少个限制，就拆成多少个点（为了方便，我们可以把 a[i] 也看作是一种限制）。 【100%小优化】&emsp;&emsp;对于同为 num[i] 的限制 i 和 j，若 i &lt; j 且 s[i]&gt;s[j] ，显然限制 i 是没有用的。这个可以用栈实现。","categories":[{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[{"name":"算法_网络流/匹配","slug":"算法-网络流-匹配","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E7%BD%91%E7%BB%9C%E6%B5%81-%E5%8C%B9%E9%85%8D/"}]},{"title":"【搬自Spoj-SOPARADE】第四次忍者大战 题解","slug":"【搬自Spoj-SOPARADE】第四次忍者大战 题解","date":"2016-08-18T11:48:56.000Z","updated":"2024-04-24T03:59:22.875Z","comments":true,"path":"【搬自Spoj-SOPARADE】第四次忍者大战 题解/","link":"","permalink":"http://kqp.world/%E3%80%90%E6%90%AC%E8%87%AASpoj-SOPARADE%E3%80%91%E7%AC%AC%E5%9B%9B%E6%AC%A1%E5%BF%8D%E8%80%85%E5%A4%A7%E6%88%98%20%E9%A2%98%E8%A7%A3/","excerpt":"题目大意&emsp;&emsp;现在要将n个忍者排成一行，每个忍者有一个标识a[i]（1&lt;=a[i]&lt;=4），相邻两个忍者的标识的差的绝对值一定要大于等于2，同时，有m组形如”b[1],b[2],b[3]…b[k]”的约束条件，表示这些忍者的标识各不相同。&emsp;&emsp;现在我们想知道，给出n和所有约束条件后，是否存在一种a序列，使得a满足这些条件。&emsp;&emsp;n,m&lt;=100000","text":"题目大意&emsp;&emsp;现在要将n个忍者排成一行，每个忍者有一个标识a[i]（1&lt;=a[i]&lt;=4），相邻两个忍者的标识的差的绝对值一定要大于等于2，同时，有m组形如”b[1],b[2],b[3]…b[k]”的约束条件，表示这些忍者的标识各不相同。&emsp;&emsp;现在我们想知道，给出n和所有约束条件后，是否存在一种a序列，使得a满足这些条件。&emsp;&emsp;n,m&lt;=100000 首先&emsp;&emsp;k大于4则无解。 【40%】n,m&lt;=16&emsp;&emsp;我们考虑第一个位选什么，发现选完之后，后面每个位最多只有两种选择。所以2^16的算法过掉40分。 【100%】n,m&lt;=10^5&emsp;&emsp;我们发现奇数位只能选1和2、偶数位只能选3和4。（如果奇数位选3和4，相当于把12和34反了过来，所以是一样的情况。）&emsp;&emsp;于是惊奇的发现可以2-SAT。先把每个位置拆成两个点，奇数位的两个点表示1和2，偶数位的两个点表示3和4。&emsp;&emsp;第一种限制：相邻两个位置差&gt;=2：奇数位的2向相邻的4连边；偶数位的3向相邻的1连边。&emsp;&emsp;第二种限制：给定的m个条件：当条件中的两个数同为奇数时，各自的1向对方的2连边，各自的2向对方的1连边；同为偶数时同理。一奇一偶不用管。&emsp;&emsp;连完边跑2-SAT就行啦！","categories":[{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[{"name":"算法_2-SAT","slug":"算法-2-SAT","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-2-SAT/"}]},{"title":"【GDOI2016】疯狂动物城 题解","slug":"【GDOI2016】疯狂动物城 题解","date":"2016-08-18T06:56:44.000Z","updated":"2024-04-24T03:59:22.842Z","comments":true,"path":"【GDOI2016】疯狂动物城 题解/","link":"","permalink":"http://kqp.world/%E3%80%90GDOI2016%E3%80%91%E7%96%AF%E7%8B%82%E5%8A%A8%E7%89%A9%E5%9F%8E%20%E9%A2%98%E8%A7%A3/","excerpt":"题目大意&emsp;&emsp;n个节点的一棵树，有三种操作。&emsp;&emsp;1：将x到y的路径上的所有点的点权加上delta&emsp;&emsp;2：询问x到y的答案。答案的计算为：对于路径上的点i，设它到y的距离为s，则i的贡献为1加到s。&emsp;&emsp;3：将这棵树恢复到第x次1操作之后的版本。&emsp;&emsp;操作数为m，强制在线。","text":"题目大意&emsp;&emsp;n个节点的一棵树，有三种操作。&emsp;&emsp;1：将x到y的路径上的所有点的点权加上delta&emsp;&emsp;2：询问x到y的答案。答案的计算为：对于路径上的点i，设它到y的距离为s，则i的贡献为1加到s。&emsp;&emsp;3：将这棵树恢复到第x次1操作之后的版本。&emsp;&emsp;操作数为m，强制在线。 【20%】n,m&lt;=1000&emsp;&emsp;对于1、2操作，暴力遍历x到y的路径去修改或求答案；并且我们存下每一次1操作后的版本，然后对于3操作，O(n)修改整棵树。&emsp;&emsp;时间复杂度O(nm) 【20% 树的形态为一条链，无操作3】n&lt;=30000, m&lt;=50000&emsp;&emsp;考虑询问。我们将x到y的路径分为x到lca和lca到y两部分。&emsp;&emsp;对于第一部分的点i，设它到y的距离为$s$，则$s=deep[i]+deep[y]-2deep[lca]$，i对答案的贡献为$a[i]\\frac{s(s+1)}2$，先不考虑除以2，设$t=deep[y]-2deep[lca]$（这个值对于第一部分的点来说是个常数），则贡献为$a[i]deep[i]^2+a[i]deep[i](2t+1)+a[i](t+t^2)$。&emsp;&emsp;对于第二部分的点i，$s=deep[y]-deep[i]$，设$t=deep[y]$，则贡献为$a[i]deep[i]^2-a[i]deep[i](2t+1)+a[i](t+t^2)$。&emsp;&emsp;可以发现，对于每个点i我们只需维护$a[i]deep[i]^2$、$a[i]deep[i]$和$a[i]$即可。这个就是线段树的基本功能了。（提醒：上述式子记得加上/2）&emsp;&emsp;时间复杂度O(m log n) 【40% 树的形态为一条链，有操作3】&emsp;&emsp;操作3显然就是要让我们把普通线段树加上可持久化。&emsp;&emsp;时间复杂度O(m logn)&emsp;&emsp;可以感觉到代码量已经膨胀了。 【100%】n,m&lt;=10^5，操作2&lt;=50000&emsp;&emsp;序列放在树上，通过树链剖分，转化为上述问题。&emsp;&emsp;时间复杂度O(m log^2) 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234#include&lt;cstdio&gt;#include&lt;algorithm&gt;#define fo(i,a,b) for(int i=a;i&lt;=b;i++)#define fd(i,a,b) for(int i=a;i&gt;=b;i--)using namespace std;typedef long long LL;const int maxn=(1e5)+5, MX=18, maxtr=7000004;const LL mo=20160501, er=10080251;struct TRTree&#123; LL d2,d1,ad2,ad1,a,bz,nowdelta;&#125;;int n,m;LL a[maxn],ans,ansd1[2],ansa[2],delta;int tot,go[2*maxn],next[2*maxn],f1[maxn];void ins(int x,int y)&#123; go[++tot]=y; next[tot]=f1[x]; f1[x]=tot;&#125;int d[maxn],fa[maxn],deep[maxn],size[maxn],Hson[maxn];void bfs_size()&#123; d[1]=1; deep[1]=1; for(int i=1, j=1; i&lt;=j; i++) &#123; for(int p=f1[d[i]]; p; p=next[p]) if (!deep[go[p]]) &#123; d[++j]=go[p]; deep[go[p]]=deep[d[i]]+1; fa[go[p]]=d[i]; &#125; &#125; fd(i,n,1) &#123; size[fa[d[i]]]+= (++size[d[i]]); if (size[d[i]] &gt; size[Hson[ fa[d[i]] ]]) Hson[fa[d[i]]]=d[i]; &#125;&#125;int sum,Tbh[maxn],Lbh[maxn],top[maxn];void New(int i,int sta)&#123; Lbh[i]=++sum; Tbh[sum]=i; top[i]=sta;&#125;void build()&#123; fo(i,1,n) if (!Lbh[d[i]]) &#123; for(int j=d[i]; j; j=Hson[j]) New(j,d[i]); &#125;&#125;int now,root[maxn],trsum,lasttrsum,son[maxtr][2],tm;TRTree tr[maxtr];void tr_js(int k,int l,int r)&#123; if (l==r) &#123; int x=Tbh[l]; tr[k].d1=(LL)deep[x]; tr[k].d2=(LL)deep[x]*deep[x]; tr[k].a=a[x]; tr[k].ad1=a[x]*tr[k].d1; tr[k].ad2=a[x]*tr[k].d2; return; &#125; int t1=(l+r)&gt;&gt;1; tr_js(son[k][0]=++trsum,l,t1), tr_js(son[k][1]=++trsum,t1+1,r); int ls=son[k][0], rs=son[k][1]; tr[k].ad2=(tr[ls].ad2+tr[rs].ad2)%mo; tr[k].ad1=(tr[ls].ad1+tr[rs].ad1)%mo; tr[k].a=(tr[ls].a+tr[rs].a)%mo; tr[k].d2=(tr[ls].d2+tr[rs].d2)%mo; tr[k].d1=(tr[ls].d1+tr[rs].d1)%mo;&#125;void tr_xg(int k,int last,int l,int r,int x,int y)&#123; if (k==trsum) tr[k]=tr[last]; if (l==x &amp;&amp; r==y) &#123; son[k][0]=son[last][0], son[k][1]=son[last][1]; tr[k].nowdelta=(tr[k].nowdelta+delta)%mo; tr[k].ad2=(tr[k].ad2+delta*tr[k].d2)%mo; tr[k].ad1=(tr[k].ad1+delta*tr[k].d1)%mo; tr[k].a=(tr[k].a+delta*(r-l+1))%mo; tr[k].bz=(tr[k].bz+delta)%mo; return; &#125; int t1=(l+r)&gt;&gt;1; if (y&lt;=t1) &#123; if (son[k][1]&lt;=lasttrsum) son[k][1]=son[last][1]; if (son[k][0]&lt;=lasttrsum) son[k][0]=++trsum; tr_xg(son[k][0],son[last][0],l,t1,x,y); &#125; else if (x&gt;t1) &#123; if (son[k][0]&lt;=lasttrsum) son[k][0]=son[last][0]; if (son[k][1]&lt;=lasttrsum) son[k][1]=++trsum; tr_xg(son[k][1],son[last][1],t1+1,r,x,y); &#125; else &#123; if (son[k][0]&lt;=lasttrsum) son[k][0]=++trsum; tr_xg(son[k][0],son[last][0],l,t1,x,t1); if (son[k][1]&lt;=lasttrsum) son[k][1]=++trsum; tr_xg(son[k][1],son[last][1],t1+1,r,t1+1,y); &#125; int ls=son[k][0], rs=son[k][1]; LL BZ=tr[k].bz; tr[k].ad2=(tr[ls].ad2+tr[rs].ad2+ BZ*tr[k].d2%mo )%mo; tr[k].ad1=(tr[ls].ad1+tr[rs].ad1+ BZ*tr[k].d1%mo )%mo; tr[k].a=(tr[ls].a+tr[rs].a+ BZ*(r-l+1)%mo )%mo;&#125;void upans(int k,int ty,LL z,LL len)&#123; ans=(ans+tr[k].ad2+ z*tr[k].d2%mo )%mo; ansd1[ty]=(ansd1[ty]+tr[k].ad1+ z*tr[k].d1%mo )%mo; ansa[ty]=(ansa[ty]+tr[k].a+ z*len%mo )%mo;&#125;void tr_cx(int k,int l,int r,int x,int y,bool ty,LL tbz)&#123; if (!k) return; tbz+=tr[k].bz; if (l==x &amp;&amp; r==y) &#123; tbz-=tr[k].nowdelta; upans(k,ty,tbz,r-l+1); return; &#125; int t1=(l+r)&gt;&gt;1; if (y&lt;=t1) tr_cx(son[k][0],l,t1,x,y,ty,tbz); else if (x&gt;t1) tr_cx(son[k][1],t1+1,r,x,y,ty,tbz); else tr_cx(son[k][0],l,t1,x,t1,ty,tbz), tr_cx(son[k][1],t1+1,r,t1+1,y,ty,tbz);&#125;void jump_xg(int x,int y)&#123; while (top[x]!=top[y]) &#123; if (deep[top[x]]&lt;deep[top[y]]) swap(x,y); tr_xg(root[tm],root[now],1,n,Lbh[top[x]],Lbh[x]); x=fa[top[x]]; &#125; if (deep[x]&lt;deep[y]) swap(x,y); tr_xg(root[tm],root[now],1,n,Lbh[y],Lbh[x]);&#125;int jump_cx(int x,int y)&#123; while (top[x]!=top[y]) &#123; if (deep[top[x]]&gt;deep[top[y]]) &#123; tr_cx(root[now],1,n,Lbh[top[x]],Lbh[x],0,0); x=fa[top[x]]; &#125; else &#123; tr_cx(root[now],1,n,Lbh[top[y]],Lbh[y],1,0); y=fa[top[y]]; &#125; &#125; if (deep[x]&gt;deep[y]) &#123; tr_cx(root[now],1,n,Lbh[y],Lbh[x],0,0); return y; &#125; else &#123; tr_cx(root[now],1,n,Lbh[x],Lbh[y],1,0); return x; &#125;&#125;int main()&#123; scanf(&quot;%d %d&quot;,&amp;n,&amp;m); fo(i,1,n-1) &#123; int u,v; scanf(&quot;%d %d&quot;,&amp;u,&amp;v); ins(u,v), ins(v,u); &#125; bfs_size(); build(); fo(i,1,n) scanf(&quot;%lld&quot;,&amp;a[i]); root[0]=trsum=1, tr_js(1,1,n); while (m--) &#123; int ty,x,y; scanf(&quot;%d %d&quot;,&amp;ty,&amp;x); if (ty==1) &#123; scanf(&quot;%d %lld&quot;,&amp;y,&amp;delta); x^=ans, y^=ans; lasttrsum=trsum; root[++tm]=++trsum; jump_xg(x,y); now=tm; &#125; else if (ty==2) &#123; scanf(&quot;%d&quot;,&amp;y); x^=ans, y^=ans; ans=0; ansd1[0]=ansd1[1]=ansa[0]=ansa[1]=0; int lca=jump_cx(x,y); LL t=deep[y]-2*deep[lca]; ans=(ans+ ansd1[0]*(2*t+1)%mo +ansa[0]*(t+t*t%mo)%mo) %mo; t=deep[y]; ans=(ans- ansd1[1]*(2*t+1)%mo +ansa[1]*(t+t*t%mo)%mo) %mo; ans=(ans+mo)%mo; ans=ans*er%mo; printf(&quot;%lld\\n&quot;,ans); &#125; else &#123; x^=ans; now=x; &#125; &#125;&#125;","categories":[{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[{"name":"算法_树链剖分","slug":"算法-树链剖分","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/"}]},{"title":"【JZ雅礼联考】Binary 题解","slug":"【JZ雅礼联考】Binary 题解","date":"2016-08-17T12:50:39.000Z","updated":"2024-04-24T03:59:22.858Z","comments":true,"path":"【JZ雅礼联考】Binary 题解/","link":"","permalink":"http://kqp.world/%E3%80%90JZ%E9%9B%85%E7%A4%BC%E8%81%94%E8%80%83%E3%80%91Binary%20%E9%A2%98%E8%A7%A3/","excerpt":"题目大意&emsp;&emsp;给定一个长度为 $n$ 的整数数列 $a$ 和 $q$ 次操作：&emsp;&emsp;修改操作：形如 1 x y，表示将 $a_x$ 的值修改为 $y$；&emsp;&emsp;询问操作：形如 2 x y，表示询问$\\sum_1^n(a_i+x)~and~y$的值。&emsp;&emsp;$n,q \\le 10^5$&emsp;&emsp;$0 \\le a_i,x,y \\le 2^{20}$","text":"题目大意&emsp;&emsp;给定一个长度为 $n$ 的整数数列 $a$ 和 $q$ 次操作：&emsp;&emsp;修改操作：形如 1 x y，表示将 $a_x$ 的值修改为 $y$；&emsp;&emsp;询问操作：形如 2 x y，表示询问$\\sum_1^n(a_i+x)~and~y$的值。&emsp;&emsp;$n,q \\le 10^5$&emsp;&emsp;$0 \\le a_i,x,y \\le 2^{20}$ 【40%】n,q&lt;=5000&emsp;&emsp;题目怎么说怎么做。 【另20%】所有询问的x=0&emsp;&emsp;二进制总共只有20位，直接记录每一位为1的有多少个数，假设记为cnt[i]查询时，y的第i个二进制位为1，就答案加上$2^i*cnt[i]$。 【100%】n,q&lt;=10^5&emsp;&emsp;我们还是对于每个二进制位单独考虑，且y这一位为1才考虑。&emsp;&emsp;不考虑+x时，我们还可以弄一棵值域线段树，那么cnt[i]所包含的数就是这样的：比i高的位任意，i位以内满足在 $[2^{i-1},2^i-1]$ 这个区间内。可以发现我们查询的区间对于整个值域来说并不连续，而是一段一段的，因此我们对每个二进制位都开一棵值域线段树，第i位的线段树存储的数则由 $a_i$ 变为 $a_i \\bmod 2^i$。这样我们操作第i位时，直接在第i位的线段树中查询$[2^{i-1},2^i-1]$内的数有多少个，就行了。&emsp;&emsp;接下来考虑+x。这个实际上是对查询区间的位移，比如当前查询区间$[2^{i-1},2^i-1]$，那么就变成$[2^{i-1}-x,2^i-1-x]$。要注意这里的x是$mod~2^i$的。唯一的问题就是区间左端点可能为负。这好办，先把0到右端点的正常操作，假设左端点变成了$-z$，那我们再查询$[2^i-z,2^i-1]$就行了。这里相当于是退位一样的东西。 代码//我把线段树换成树状数组，这样常数小代码短123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;cstdio&gt;#define fo(i,a,b) for(int i=a;i&lt;=b;i++)using namespace std;typedef long long LL;const int maxn=(1e5)+5, MX=20, maxc=(1&lt;&lt;20)+5;int n,a[maxn],er[MX+5];int c[MX+2][maxc];int lowbit(int x) &#123;return x&amp;(-x);&#125;void xg(int ty,int x,int z)&#123; if (x==0) &#123;c[ty][0]+=z; return;&#125; for(; x&lt;er[ty]; x+=lowbit(x)) c[ty][x]+=z;&#125;int get(int ty,int x)&#123; if (x&lt;0) return 0; int re=0; for(; x; x-=lowbit(x)) re+=c[ty][x]; return re+c[ty][0];&#125;int q;int main()&#123; fo(i,0,MX) er[i]=1&lt;&lt;i; scanf(&quot;%d %d&quot;,&amp;n,&amp;q); fo(i,1,n) &#123; scanf(&quot;%d&quot;,&amp;a[i]); fo(j,1,20) xg(j,a[i]%er[j],1); &#125; while (q--) &#123; int ty,x,y; scanf(&quot;%d %d %d&quot;,&amp;ty,&amp;x,&amp;y); if (ty==1) &#123; fo(i,1,20) xg(i,a[x]%er[i],-1); fo(i,1,20) xg(i,y%er[i],1); a[x]=y; &#125; else &#123; LL ans=0; fo(i,1,MX) if (y&amp;er[i-1]) &#123; int xx=x%er[i], st=er[i-1]-xx, en=er[i]-1-xx; if (st&lt;0) &#123; ans+=(LL)er[i-1]*get(i,en); if (i&gt;1) ans+=(LL)er[i-1]*(get(i,er[i]-1)-get(i,er[i]+st-1)); &#125; else &#123; ans+=(LL)er[i-1]*(get(i,en)-get(i,st-1)); &#125; &#125; printf(&quot;%lld\\n&quot;,ans); &#125; &#125;&#125;","categories":[{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[{"name":"算法_位运算","slug":"算法-位运算","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/"}]},{"title":"【断更】接下来的训练计划","slug":"【断更】接下来的训练计划","date":"2016-08-16T13:34:56.000Z","updated":"2024-04-24T03:59:22.878Z","comments":true,"path":"【断更】接下来的训练计划/","link":"","permalink":"http://kqp.world/%E3%80%90%E6%96%AD%E6%9B%B4%E3%80%91%E6%8E%A5%E4%B8%8B%E6%9D%A5%E7%9A%84%E8%AE%AD%E7%BB%83%E8%AE%A1%E5%88%92/","excerpt":"","text":"要做的事2016.9.1开始的一个月： 以学校的模拟赛题、知识点为主要任务。在时间有限的情况下优先该条。 周二、四花时间做coci。目标是在9月完成首页后两套题，并记录好的脑洞。 周一、三、五花时间做专题。按照目录进行。 每周随机一个oj（JZOJ、bzoj、CF、计蒜客），在上面随机至少1个题，不论难度、代码量，并记录好的脑洞。（题目若认定为普及组难度则继续随机） 2016.10.1开始的一个月： 以学校的模拟赛题、知识点为主要任务。在时间有限的情况下优先该条。 周二、四花时间做coci。目标是在10月完成2015~2016的#5和#6，并记录好的脑洞。 周一、三、五花时间做专题。按照目录进行。 每周一题，然而不强求。 2016.10.31~noip2016： 以学校的模拟赛题、知识点为主要任务。在时间有限的情况下优先该条。 学已讲专题，做自己的专题 noip的重难题、易错题，有价值的真题去做 手边时刻放一道可思考的题，可以来自coci、jzoj。 2016.12.1开始的一个月： 以学校的模拟赛题、知识点为主要任务。在时间有限的情况下优先该条。 学习专题，主要为安排的省赛专题，去实现高级算法模板，并至少解决课件例题。 oj开始填坑，随机选择标了星的题来做。该项在数论专题讲完后开始实行。 做coci、cf、bc的比赛！！！ 2017.1.1开始的一个月： 模拟赛改题 专题以模拟赛题涉及的为主，比如最近的博弈 oj填坑，随机选择标了星的题来做。 做各种高质量网络赛 2017.1.22~1.31： wc模拟题以及相应的A组题 写待写模板，以及把最近模拟赛涉及到的知识点写一写 开两场cf练习赛，每场从C开始做 春节hackerrank、26号uoj 2017.2.10开始的一个多星期 认真对待每一场koi模拟，踏踏实实改题，寻找稳的方法。 过一遍字符串、数据结构课件 有空的话研究一下WC课件 好好考gdkoi 2017.2.26开始的一个月 改题，欠下的太多了 过字符串、几何、博弈课件 思考题来源：cf、bc、atcoder、集训队作业、杂题选讲课件、coci 好好考浙江省选 2017.3.26开始的一个月 改题 专题复习 思考题来源：cf、集训队作业、coci（至少两套）、去年湖南集训 好好考江苏、GDOI模拟 2017.4.10~2017.4.26 GDOI 模拟*4 atcoder樊爷题集、coci 继续，并记录脑洞和扩展 过大家的专题复习课件，在 23 号前完成，若有多余时间则过专题讲课课件；23 号后去浏览大神博客里的好题、学习小记、总结 2017.5.3~2017.5.21 专攻智商题，收集共享上所有杂题选讲课件，以及浏览 jasonvictoryan 的博客。 补知识点。字符串（SAM为主）-&gt;数据结构（平衡树LCT为主）-&gt;多项式（生成函数为主） 参与网上的比赛（codejam、cf、bc等） 2017.5.31~2017.7.19 noi 模拟题 实现或精通一些未熟悉的算法（洲阁筛、SAM、ZKW、LCT、treap、矩阵树定理、几何、高次剩余那套理论……）","categories":[{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[]},{"title":"【搬自usaco2015Dec】【JZOJ4684】卡牌游戏 题解","slug":"【搬自usaco2015Dec】【JZOJ4684】卡牌游戏 题解","date":"2016-08-14T14:56:09.000Z","updated":"2024-04-24T03:59:22.877Z","comments":true,"path":"【搬自usaco2015Dec】【JZOJ4684】卡牌游戏 题解/","link":"","permalink":"http://kqp.world/%E3%80%90%E6%90%AC%E8%87%AAusaco2015Dec%E3%80%91%E3%80%90JZOJ4684%E3%80%91%E5%8D%A1%E7%89%8C%E6%B8%B8%E6%88%8F%20%E9%A2%98%E8%A7%A3/","excerpt":"usaco原题叫 High Card Low Card 【题目大意】&emsp;&emsp;有2n张牌，分别是1~2n。WWT有其中的n张牌，你有另n张。&emsp;&emsp;游戏规则本来是这样的：每一回合，你和WWT同时打出一张牌，谁大谁赢。但是，你可以在任意一个时刻将游戏规则改为“谁小谁赢”，但你只能改一次。&emsp;&emsp;现在给定WWT的牌和出牌顺序，求你最多赢多少局。&emsp;&emsp;n&lt;=50000","text":"usaco原题叫 High Card Low Card 【题目大意】&emsp;&emsp;有2n张牌，分别是1~2n。WWT有其中的n张牌，你有另n张。&emsp;&emsp;游戏规则本来是这样的：每一回合，你和WWT同时打出一张牌，谁大谁赢。但是，你可以在任意一个时刻将游戏规则改为“谁小谁赢”，但你只能改一次。&emsp;&emsp;现在给定WWT的牌和出牌顺序，求你最多赢多少局。&emsp;&emsp;n&lt;=50000 【n^2部分分】&emsp;&emsp;枚举分割点，然后分割点上面的排序，分割点下面的排序，做个贪心。 【n log n】&emsp;&emsp;还是枚举分割点，然后我们需要快速地知道分割点上面的答案f[i]以及分割点下面的答案g[i+1]。以f为例看看怎么求。 &emsp;&emsp;许多人会想到排序贪心，这搞了半天又回归到部分分。我们不必贪心，用线段树那样的分治就好了。&emsp;&emsp;把WWT的牌叫做a，你的牌叫做b。考虑一棵值域线段树（轴为1~2n），我插入1个a[i]，它只能被a[i]+1~2n打掉；我插入1个b[i]，它只能打掉1~b[i]-1。&emsp;&emsp;于是我们每个区间维护两个值：ta表示区间内有多少个a没被打掉，tb表示区间内有多少个b剩余。（想想如果a在区间的很右边，那它在这个区间内就打不掉的了，得留着放在更大的区间来打。b如果在区间很左边，那它在这个区间内打不到a的话，就留着在更大的区间去打）&emsp;&emsp;接下来就是两个区间的合并。假设当前区间的值为ta、tb，左儿子为ta[l]、tb[l]，右儿子为ta[r]、tb[r]。那么ta=ta[r]+max(0,ta[l]-tb[r])，tb=tb[l]+max(0,tb[r]-ta[l])。如果你理解了上面那段话，这个合并就很好理解了。以ta为例，ta[l]是可以被tb[r]干掉的，而ta[r]则不能被干掉，所以就这样合并啦。。。 &emsp;&emsp;回归本题。我们还是以f为例：顺序处理每一局。对于第i局，插入a，然后插入b，然后直接询问根节点的ta。注意根节点的ta就表示第1局到第i局共输了多少局，所以f[i]=i-ta。g数组同理。这样就做完啦。。。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;cstdio&gt;#include&lt;algorithm&gt;#define fo(i,a,b) for(int i=a;i&lt;=b;i++)#define fd(i,a,b) for(int i=a;i&gt;=b;i--)using namespace std;const int maxn=(1e5)+5;int n,m,a[maxn],b[maxn];int tr1[4*maxn][2],tr2[4*maxn][2];//第二维的0表示ta，1表示tbvoid tr_xg1(int k,int l,int r,int x,int z)&#123; if (l==r) &#123; if (z==1) tr1[k][0]=1; else tr1[k][1]=1; return; &#125; int t=k&lt;&lt;1, t1=(l+r)&gt;&gt;1; if (x&lt;=t1) tr_xg1(t,l,t1,x,z); else tr_xg1(t+1,t1+1,r,x,z); tr1[k][0]=tr1[t][0]+max(0,tr1[t+1][0]-tr1[t][1]); tr1[k][1]=tr1[t+1][1]+max(0,tr1[t][1]-tr1[t+1][0]);&#125;void tr_xg2(int k,int l,int r,int x,int z)&#123; if (l==r) &#123; if (z==1) tr2[k][0]=1; else tr2[k][1]=1; return; &#125; int t=k&lt;&lt;1, t1=(l+r)&gt;&gt;1; if (x&lt;=t1) tr_xg2(t,l,t1,x,z); else tr_xg2(t+1,t1+1,r,x,z); tr2[k][0]=tr2[t+1][0]+max(0,tr2[t][0]-tr2[t+1][1]); tr2[k][1]=tr2[t][1]+max(0,tr2[t+1][1]-tr2[t][0]);&#125;bool bz[maxn];int f[maxn],g[maxn];int main()&#123; scanf(&quot;%d&quot;,&amp;n); m=2*n; fo(i,1,n) &#123; scanf(&quot;%d&quot;,&amp;a[i]); bz[a[i]]=1; &#125; int b0=0; fd(i,m,1) if (!bz[i]) b[++b0]=i; fo(i,1,n) &#123; tr_xg1(1,1,m,a[i],-1); tr_xg1(1,1,m,b[i],1); f[i]=i-tr1[1][1]; &#125; fd(i,n,1) &#123; tr_xg2(1,1,m,a[i],-1); tr_xg2(1,1,m,b[i],1); g[i]=(n-i+1)-tr2[1][1]; &#125; int ans=0; fo(i,0,n) ans=max(ans,f[i]+g[i+1]); printf(&quot;%d\\n&quot;,ans);&#125;","categories":[{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[{"name":"算法_线段树","slug":"算法-线段树","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E7%BA%BF%E6%AE%B5%E6%A0%91/"}]},{"title":"2016.7集训总结","slug":"2016.7集训总结","date":"2016-07-21T14:35:37.000Z","updated":"2024-04-24T03:59:22.768Z","comments":true,"path":"2016.7集训总结/","link":"","permalink":"http://kqp.world/2016.7%E9%9B%86%E8%AE%AD%E6%80%BB%E7%BB%93/","excerpt":"$\\ \\ $","text":"$\\ \\ $ 写在前面&emsp;&emsp;作为新高二的第一个月，训练结束。&emsp;&emsp;可以说这个月收获。。。真的不是很大，新知识没学多少，模拟赛后面越做越烂。 联赛组&emsp;&emsp;做了六套noip模拟题，有几套做的还是很好的，当然其中也有数据出水了的原因。&emsp;&emsp;这几套题主要是有水题，并且能切，即便不水的题我也很快看出经典模型。&emsp;&emsp;最主要是这几天能切的题都切了。失分率较低。嗯，这个状态能维持多久？&emsp;&emsp;学到少量新算法，比如带修莫队，主要还是一些奇怪的脑洞。以及一些还没有学会的东西，比如线段树维护树的直径、第二类斯特林数的某些应用（雾） 省赛组&emsp;&emsp;同样做了六套gdoi模拟，反正分数很难看，没什么好脑洞。&emsp;&emsp;运用了一些很巧妙的数据结构处理方法，不得不说有的脑洞真的很巧妙。然而，只有一题我做得令自己满意（SCOIday2t2），其余基本上想出来了要么没打完要么打挂了。&emsp;&emsp;基本没打暴力，导致正解挂掉之后就没什么分了。&emsp;&emsp;基本没拍，不像做noip模拟时一样，打完正解顺带就拍完了。主要是基本上想啊想，想到差不多10点多了，开始打一个代码量大的正解，最后压线打完，或者剩余15分钟来不及打那恶心的暴力。 学到的\\&amp;没学到的东西&emsp;&emsp;已get：带修莫队、特殊环境下凸包的简便求法、许多处理问题的套♂路&emsp;&emsp;未get：线段树维护树的直径、第二类斯特林数及基本应用、倍增维护线性基、ST表那样倍增…… 经验总结&emsp;&emsp;一定要打拍！一定要打拍！一定要打拍！拍是唯一能保证程序正确的手段！真的，这几场模拟（特别是省赛模拟）死在没拍的题太多了，要么没时间拍，要么暴力难打，一切的一切都只说明了一个问题——太慢了！！！&emsp;&emsp;一定要腾出时间打暴力！&emsp;&emsp;代码能力极差，打得又慢又错，赛后改题调试三天三夜没调出一个bug&emsp;&emsp;思维速度极差，这主要是针对省赛模拟而言的，每次都差不多到10点多才有点思路开始打，每次都打到11点多发现是萎的。 暑假在一开始就gg了&emsp;&emsp;任务： 出7个题，至少4个原创 写一个专题 改题 暑假作业！！ 恶补工程项目类知识，力求计蒜之道不垫底；看科技杂志，力求赛场上像Mpq一样大喊“哇靠这题我见过！！！”","categories":[{"name":"总结与游记","slug":"总结与游记","permalink":"http://kqp.world/categories/%E6%80%BB%E7%BB%93%E4%B8%8E%E6%B8%B8%E8%AE%B0/"},{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[]},{"title":"【GDOI2016】互补约数 题解","slug":"【GDOI2016】互补约数 题解","date":"2016-05-24T09:29:57.000Z","updated":"2024-04-24T03:59:22.841Z","comments":true,"path":"【GDOI2016】互补约数 题解/","link":"","permalink":"http://kqp.world/%E3%80%90GDOI2016%E3%80%91%E4%BA%92%E8%A1%A5%E7%BA%A6%E6%95%B0%20%E9%A2%98%E8%A7%A3/","excerpt":"题目大意 \\sum_{i=1}^n\\sum_{d|i}gcd(d,\\frac{i}{d})","text":"题目大意 \\sum_{i=1}^n\\sum_{d|i}gcd(d,\\frac{i}{d}) \\\\ \\\\ \\\\【20%】$n \\le 10^5$&emsp;&emsp;暴力枚举 $i$，然后根号枚举 $d$。&emsp;&emsp;时间复杂度 $O(n\\sqrt n)$ 【50%】$n \\le 10^7$&emsp;&emsp;双sigma带gcd的形式考虑反演。 \\begin{aligned} &\\sum_{i=1}^n\\sum_{d|i}\\gcd(d,\\frac{i}{d}) \\\\ =&\\sum_{d=1}^{\\sqrt n}d*f(d) \\\\ &其中f(d)=\\sum_{i=1}^n\\sum_{j|i}(\\gcd(j,\\frac{i}{j})==d) \\end{aligned}&emsp;&emsp;接下来我们考虑如何快速求 $f(d)$，方法众多，这里介绍一种非Mobius的方法。&emsp;&emsp;由于$i$分解成两个因数之后，两个因数都要含因子$d$，因此$i$本身应该是$d^2$的倍数。所以我们不枚举$i$，而是直接枚举$ti=\\frac{i}{d^2}$，相当于$j$和$\\frac{i}{j}$已经同时约去了$d$。所以 f(d)=\\sum_{ti=1}^{\\lfloor \\frac{n}{d^2} \\rfloor}\\sum_{td|ti}(\\gcd(td,\\frac{ti}{td})==1)&emsp;&emsp;我们现在其实是把 $ti$ 分解成两个因数，然后两个因数互质。考虑将 $ti$ 分解质因数，那么对于 $ti$ 的同一种质因子，$td$ 要么将它全选，要么全不选。因此第二个sigma只与$ti$的质因数种类数有关。设 $g[ti]$ 表示 $ti$ 的质因数种类数，则 f(d)=\\sum_{ti=1}^{\\lfloor \\frac{n}{d^2} \\rfloor}2^{g[ti]}&emsp;&emsp;我们只需预处理 $g$ 数组即可。&emsp;&emsp;时间复杂度主要在预处理上，所以是 $O(n)$。（注意那个$\\lfloor \\frac{n}{d^2} \\rfloor$，由于分母以平方速度增长，所以整个分数下降速度是很快的） 【100%】$n \\le 10^{11}$&emsp;&emsp;上述解法的瓶颈在于$g[ti]$不好求，因为$ti$最大会达到$n$，预处理存不下，现场求又慢。所以对于$f(d)$我们要换一种求法。&emsp;&emsp;事实上，求$f(d)$是Mobius反演的经典问题。 \\begin{aligned} f(d)&=\\sum_{i=1}^n\\sum_{j|i}(\\gcd(j,\\frac{i}{j})==d) \\\\ &=\\sum_{i=1}^n\\sum_{j=1,\\ ij \\le n}^n(\\gcd(i,j)==d) \\end{aligned}&emsp;&emsp;令$m=\\lfloor \\frac{n}{d^2} \\rfloor$，则上式 \\begin{aligned} &=\\sum_{i=1}^m\\sum_{j=1,\\ ij \\le m}^m(\\gcd(i,j)==1) \\\\ &=\\sum_{D=1}^m\\mu(D)\\sum_{t=1}^{\\lfloor \\frac{m}{D^2} \\rfloor}\\lfloor \\frac{m}{D^2t} \\rfloor \\end{aligned}&emsp;&emsp;总式为 \\sum_{d=1}^{\\sqrt n}d*\\sum_{D=1}^{\\lfloor \\frac{n}{d^2} \\rfloor}\\mu(D)\\sum_{t=1}^{\\lfloor \\frac{n}{d^2D^2} \\rfloor}\\lfloor \\frac{n}{d^2D^2t} \\rfloor&emsp;&emsp;接下来用《莫比乌斯反演（宋新波）》里的一种变形。（参考wc2016课件）&emsp;&emsp;令$T=d*D$，则原式为 \\sum_{T=1}^n\\sum_{d|T}d*\\mu(\\frac{T}{d})\\sum_{t=1}^{\\lfloor \\frac{n}{T^2} \\rfloor}\\lfloor \\frac{n}{T^2t} \\rfloor&emsp;&emsp;事实上如果$T&gt;\\sqrt n$，则第三个sigma无意义。所以原式为 \\sum_{T=1}^{\\sqrt n}G(T)\\sum_{t=1}^{\\lfloor \\frac{n}{T^2} \\rfloor}\\lfloor \\frac{n}{T^2t} \\rfloor，其中G(T)=\\sum_{d|T}d*\\mu(\\frac{T}{d})&emsp;&emsp;显然 $G$ 数组是可预处理的，第二个sigma可以分块解决。&emsp;&emsp;时间复杂度：预处理为 $O(\\sqrt n \\cdot \\log(\\sqrt n))$，最终式子求值为 $O(\\sqrt n*?)$，$?$为一个不是很大的常数。（注意那个$\\lfloor \\frac{n}{T^2} \\rfloor$，由于分母以平方速度增长，所以整个分数下降速度是很快的）","categories":[{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[{"name":"算法_数论","slug":"算法-数论","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E6%95%B0%E8%AE%BA/"}]},{"title":"GDOI2016酱油记","slug":"GDOI2016","date":"2016-05-03T13:32:28.000Z","updated":"2024-04-24T03:59:22.776Z","comments":true,"path":"GDOI2016/","link":"","permalink":"http://kqp.world/GDOI2016/","excerpt":"今年轮到我写酱油记了。","text":"今年轮到我写酱油记了。 序&emsp;&emsp;高一赛季的final，落下帷幕。笑对蓝天进场，落个铁牌回家。&emsp;&emsp;高一这年，幸得志神同桌，众神环绕，学得广度知识、深度思维（人话：感觉初中三年白学了），能力提升不计其数。然距离省队水平仍路漫漫，加之去年noip失分严重，省赛只得酱油一波。&emsp;&emsp;总的来说就是，无论如何赛季结束了，虽然结果不好，但这一年的积累算是为高二铺路了吧。 赛程概括一句话概括&emsp;&emsp;day1全炸，day2怒考一波，拼命扳回，压线进day3，day3发挥正常，却已无力回天。 Day0&emsp;&emsp;辣鸡宾馆，四面环山，空洞简陋，wifi若无。 Day1&emsp;&emsp;第一场，没进入状态，找不到思维运转的感觉。t1看到下取整后居然一脸懵逼，t2脑洞良久最后只会一种在随机数据下表现良好的n\\^3log。t3概率题也是一脸懵逼，t4狗屎链剖题果断暴力。&emsp;&emsp;最终结果：0+10+0+20，考了跟没考似的，白白让了别人一场。t1最大的问题就是死钻在去掉下取整和三分上了，连初中生最基本的画图技能都没用上。最衰是t2，算法虽渣但出题人最多只能卡3-5个点，最后结果出来T的真的只有3个点，剩余6个是WA！！！嫌暴力麻烦而没拍的结果。而且还嫌麻烦没去复评，怎么错的都不知道。&emsp;&emsp;心情：我强行让自己开心起来，因为第一场让掉了，我意识到自己已经走到必须逆袭的不归路了。忽然变得对day2无比坚定，烙下了“day2一定要翻盘”的决心。 Day2&emsp;&emsp;如我所料，今天终于出现了day1应有的状态。t1分层最短路一眼题，但是打起来各种强迫症，拍完之后就10点了。t3狗屎点剖题还带环果断暴力。t4地图题果断no。t2打了奇怪的暴力之后发现n=8带6个=还是跑的飞快就不管了。&emsp;&emsp;最终结果：100+50+20+0，算是最稳的一场了，cyc说能进前25。&emsp;&emsp;心情：很开心，毕竟真的翻盘了，虽然进day3是压线的，但是今天170说明实力尚在。想起昨天坚定的信念，顿时领悟到了梦♂想的力量。 Day3&emsp;&emsp;人生首次day3，虽然知道自己只有3=而且省队无望。t1一看是某种高超的反演技巧，推着推着推了个50分的反演，但是中途出现了双 $\\sum$ 带个 $\\gcd$ 的形式，于是我强上mobius，10点钟后果断弃疗。t2又是环套树果断暴力。t4写了个随机小数据表现良好的贪心，我知道水的分不会低。&emsp;&emsp;最后结果：50+20+0+40，发挥正常，没有预计外丢分。但是t1连初中生都说是裸的mobius那我就没办法了，反演技术不过关。&emsp;&emsp;心情：三天结束，总排42。这样的名次对于冲省队来讲是没有用的。晚上怒刷三维弹球。 Day4&emsp;&emsp;照两张相，大吃一顿，铁牌回家。 经验1.一定要拍，day1t2只测手出小数据于是挂了。2.复习的话模板只需要在第一轮之前复习，然后每一轮（包括第一轮）之前都要随机选几道题（我选10个题），每个想最多10分钟然后看题解，很有助于第二天的状态。刚好这次没街逛，复习时间多的很。3.上述做法是对脑洞状态的一个临时抱佛脚，效果很好。但是对于脑洞能力的话，还是靠平时的阅历，平时多看题多想题，也不一定是题，可以是算法的性质之类的。“算法可以一天学完，但是思维能力是长期的。”——cyc。4.对于day数&gt;1的比赛，可持久化心态很重要。我这次最有感触的就是这点，day1我为了强行让自己乐观起来，无比坚定地相信day2会逆袭，结果真的掰回来了（虽然不是李成杰那种掰到进省队的逆袭，但是170对于day2来说真的不错了，没排到前面要怪只能怪day1炸了）。 后记&emsp;&emsp;这篇总结贯彻的精神思想其实是对整个高一赛季的总结。毕竟高一赛季结束了，以这次GDOI为结尾。高一学到的东西比初中三年多得多，也深得多，比赛成熟度的话，该不会的好像还是不会（难题想到的东西确实是多了，但是打出来的依然只是暴力），不过学会了拍（然而经常拍了也错）。算是为高二做好准备了。&emsp;&emsp;接下来就还有个apio，完了之后就是漫长的补课生涯，一个月后还有二段考，两个月后还有期末考，然后高二赛季就开始了。&emsp;&emsp;最后一年，加油吧。","categories":[{"name":"总结与游记","slug":"总结与游记","permalink":"http://kqp.world/categories/%E6%80%BB%E7%BB%93%E4%B8%8E%E6%B8%B8%E8%AE%B0/"},{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[]},{"title":"GDOI2016模拟2总结","slug":"GDOI2016模拟2总结","date":"2016-04-27T14:31:41.000Z","updated":"2024-04-24T03:59:22.777Z","comments":true,"path":"GDOI2016模拟2总结/","link":"","permalink":"http://kqp.world/GDOI2016%E6%A8%A1%E6%8B%9F2%E6%80%BB%E7%BB%93/","excerpt":"$\\ \\ $","text":"$\\ \\ $ Day1——手速渣+脑速渣&emsp;&emsp;曾经我自以为手速足够快，现在才发现根本是弱鸡。手速渣不仅指代码速度慢，而且指模板熟练度低。 首先第一题是SA的几乎模板题，先是写SA+调SA用了半个钟，然后各种调试各种错误思路，最终压线写了t3的dp，直到考试结束后才意识到要加斜率优化。&emsp;&emsp;手速与脑速一起渣，直接导致的就是t3超时4个点，以及第四题没打。本来这是很水的一场，就因为速度慢，排名靠后。 Day2——脑洞小+状态渣&emsp;&emsp;Day2最最典型的特征就是脑洞突然变小了。就t2来说，n是百级的，又有使用上限又有代价，一看就是费用流。于是开始建模，建了半天没成功，其中包括把它弄成二分图，但因为惯性思维导致一画成二分图我就拆点，拆了又联系不起来，就是没意识到点集本身满足二分性质。t1我打了个表，半天没找到有用的东西，看着像化成二进制每一位单独考虑，又做不出来。t3和t4同理。&emsp;&emsp;感觉做这种题真的想睡觉，而且机房的温度刚好适合睡觉，于是做这一场比赛都没什么做题状态。但是真正的考场上，空调温度可能比现在更适合睡觉，那省赛我会不会真的睡过去？即使睡不了，或者脑洞会无限缩小？这就表明我现在的做题状态、思维速度很依赖环境，这将是极大的缺点。 Day3——暴力渣&emsp;&emsp;像day3这样的题，基本不可做，打t1和t3的暴力就可以进前10。而我居然没打t1的暴力！！丢了20分，排名一下退了几位。按省赛人数比例放大，超级可观。 马上省赛了 通过练打字提高打字速度？不重要，现在的打字速度还是够的。 通过各种方法使得做题状态和思维速度不依赖环境？不现实，省赛就剩两天了，怎么会就把困扰我几百年的问题解决掉了呢？考场上多上厕所多吃糖能解决60\\%由环境引起的问题。 练脑洞？不现实。只剩两天0场模拟，练不出大的改变。这三天有很多递推题，我都接近正解，且之前的比赛也试过脑洞大开，这说明思维实力是有的。 练模板熟练度？很现实，很重要，至于如何现实如何重要，不解释。我的模板文件夹里有很多东西，oj上各种标记的题也很多，资料文件夹的模板也有无数，大把东西复习，以讲课的分类来复习。 各种经典技巧？很现实，很重要，单靠模板可能只能拿50-70左右的部分分，例如网络流要顺便复习动态加边和和各种优化技巧，一些经典问题（例如动静态区间k大、k短路、二维区域内点数等）的求法。","categories":[{"name":"总结与游记","slug":"总结与游记","permalink":"http://kqp.world/categories/%E6%80%BB%E7%BB%93%E4%B8%8E%E6%B8%B8%E8%AE%B0/"},{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[]},{"title":"【JZOJ4473】Incantation Solution","slug":"【JZOJ4473】Incantation Solution","date":"2016-04-27T13:26:08.000Z","updated":"2024-04-24T03:59:22.848Z","comments":true,"path":"【JZOJ4473】Incantation Solution/","link":"","permalink":"http://kqp.world/%E3%80%90JZOJ4473%E3%80%91Incantation%20Solution/","excerpt":"题目大意&emsp;&emsp;有 n 次操作，每次往序列 A 末尾插入一个元素，问每次插入后，新产生了多少个本质不同的连续子序列。","text":"题目大意&emsp;&emsp;有 n 次操作，每次往序列 A 末尾插入一个元素，问每次插入后，新产生了多少个本质不同的连续子序列。 【30%】n&lt;=100&emsp;&emsp;注意新产生的子序列必然是当前 A 的后缀序列，因此我们枚举当前 A 的后缀序列 S，然后再枚举 A 的所有除 S 以外的连续子序列，看看有没有相同，如果都没有相同，那么 ans+1。&emsp;&emsp;时间复杂度 O(n^4) 【60%】n&lt;=1000&emsp;&emsp;暴力枚举 A 的所有连续子序列是 30 分做法慢的主要原因，因此我们采用哈希判重。还是枚举当前 A 的后缀序列 S，然后哈希判一下有没有出现过，再把 S加到哈希中。 &emsp;&emsp;如果把哈希看成是 O(1)的话，那么时间复杂度是 O(n^2) 【100%解法 1】n&lt;=10^5&emsp;&emsp;上述文字中出现了“本质不同”“后缀”等字眼，各位应当联想到，我们要把序列抽象成字符串。&emsp;&emsp;对于 i 位置插入的元素，新产生的子串是 A[1..i]、A[2..i]、A[3..i]……A[i]，不考虑本质不同的话贡献就是 i 个。假设存在 j&lt;i，使得 A[j’..j]=A[i’..i]，那么对于任意 k∈[i’..i]，A[k..i]都是没有贡献的。即如果我们找到了最小的 i’，那么 i’及以后的位置是没贡献的，而 i’以前的位置是有贡献的。如何找这个最小的 i’？我们把A 反序，就会发现，我们实际上是在找 i 开头的后缀与 i’（i&lt;i’）开头的后缀的 LCP（最长公共前缀）。&emsp;&emsp;我们把 A 反序后建立后缀数组，然后从大到小枚举 i，对于位置 i 的插入操作，我们找后缀 i 与所有后缀 j（i&lt;j）的 LCP，然后 n-i+1-LCP 就是 i 位置新产生的贡献。如何找后缀 i 与后缀 j 的 LCP？可以以 SA 为下标弄一棵线段树，每插入一个位置 i，就在 rank[i]的位置打个标记。当我们要找 LCP 的时候，就从 rank[i]开始，往前找到最近的标记点 j，往后找到最近的标记点 k，那么 max(LCP(i,j),LCP(i,k))就是我们要找的 LCP。这个东西可以用任意一种 log 的数据结构维护，比如线段树、树状数组什么的。 &emsp;&emsp;时间复杂度 O(nlogn) 【100%解法 2】n&lt;=10^5&emsp;&emsp;既然要找后缀 i 与所有后缀 j（i&lt;j）的 LCP，我们可以直接用后缀自动机，该后缀与之前后缀的最大 LCP 即为其 father 的 maxlen，那么该后缀的贡献应为该点的 maxlen 减 father 的 maxlen。&emsp;&emsp;时间复杂度 O(n)","categories":[{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[{"name":"算法_字符串","slug":"算法-字符串","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"GDOI2016模拟1总结","slug":"GDOI2016模拟1总结","date":"2016-04-23T13:39:44.000Z","updated":"2024-04-24T03:59:22.777Z","comments":true,"path":"GDOI2016模拟1总结/","link":"","permalink":"http://kqp.world/GDOI2016%E6%A8%A1%E6%8B%9F1%E6%80%BB%E7%BB%93/","excerpt":"$\\ \\ $","text":"$\\ \\ $ 1、论看样例的重要性day1t1光对着式子推了两个钟，实在不想搞了，于是边推边敲的敲了个猜想，总共两个半钟以后发现样例与题目不符。解决完这一切以后已过去3个小时。由于各种不爽导致各种bug。 2、论数据生成器正确性的重要性day2t1一开始认为暴力很难打，不好拍，于是先手动出了几个小数据，因为是手打的，所以航线默认按时间拍了个序。后来强行打了暴力和数据生成器。居然也默认按时间排序了。于是巧妙的拍对了。 然而不管拍有多坑多难打，还是要打的。像day1t1就是觉得耗时太长所以没拍，于是真的没发现算法错误。 3、论暴力上优化的重要性看到部分分按部就班的打暴力，这种事情我一年前也会，而一年之后居然一点变化都没有，30\\%该拿的拿，剩下的一分都没多，那我这一年都学了些啥？又一年了，就算是暴力也该有代表一年学识的优化了，像day2t4的暴力，很多部分都可以上线段树的，比如维护重树减轻树这些，考场上都想到了，结果嫌麻烦没打。下午讨论时听到ganxi讲到这个，别提多后悔了。 到了比赛时，暴力和水法和各种优化都是对大众分的重要升格。一生的学识不是只能够在切题中体现的，暴力水法优化也可以的。 4、论注意时间的重要性推day1t1和day3的时候，我很专心，很专心，很专心，以至于时间像开了挂似的疾走，敲代码时手速自我感觉良好，可是打个void居然用了10分钟，已经开始怀疑我的表是不是32倍速的在走，还是我相比世界满了32倍速。 感觉day2的时间安排还是挺好的，于是有时间把每个暴力都打了，最后还强行打了t1的暴力和拍。现在打字速度已经上去了，关键是思考速度一直是个卡。前些天停课时的比赛试过脑洞大开，那种状态感觉可遇不可求。所以只能够不断提升学识，使自己即使是脑洞没打开的情况下也能通过经验很好地分析题目。 5、论梦♂想的重要性人要有梦♂想，哪怕是垫底也坚决不能连垫三场。","categories":[{"name":"总结与游记","slug":"总结与游记","permalink":"http://kqp.world/categories/%E6%80%BB%E7%BB%93%E4%B8%8E%E6%B8%B8%E8%AE%B0/"},{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[]},{"title":"【CQTSC2016】路由表 题解","slug":"【CQTSC2016】路由表 题解","date":"2016-04-20T01:14:17.000Z","updated":"2024-04-24T03:59:22.840Z","comments":true,"path":"【CQTSC2016】路由表 题解/","link":"","permalink":"http://kqp.world/%E3%80%90CQTSC2016%E3%80%91%E8%B7%AF%E7%94%B1%E8%A1%A8%20%E9%A2%98%E8%A7%A3/","excerpt":"题目大意&emsp;&emsp;有 n 个操作，分Add和Ask两种。&emsp;&emsp;Add操作就是添加一个字符串（把 IPv4 地址转成 32 位的二进制串，取前L位，L为掩码），保证每次Add都不相同。&emsp;&emsp;Ask操作给出询问串S（同样是IPv4地址转成32位二进制串）和区间[L, R]，对于这次Ask之前的Add操作，从头开始，每Add一次，S就会找已经Add的串中最长的并且是S前缀的串作为匹配。询问第L个Add操作到第R个Add操作中，S的匹配更新了多少次。","text":"题目大意&emsp;&emsp;有 n 个操作，分Add和Ask两种。&emsp;&emsp;Add操作就是添加一个字符串（把 IPv4 地址转成 32 位的二进制串，取前L位，L为掩码），保证每次Add都不相同。&emsp;&emsp;Ask操作给出询问串S（同样是IPv4地址转成32位二进制串）和区间[L, R]，对于这次Ask之前的Add操作，从头开始，每Add一次，S就会找已经Add的串中最长的并且是S前缀的串作为匹配。询问第L个Add操作到第R个Add操作中，S的匹配更新了多少次。 【30%】n&lt;=1000&emsp;&emsp;n太小了，对于每个询问，直接暴力枚举前R个Add操作中，S的匹配更新了多少次，然后这么多次更新中，有多少次是在L以后的。 &emsp;&emsp;时间复杂度O(n^2) 【100%】n&lt;=10^6&emsp;&emsp;不能枚举操作了。但是注意到S的匹配必须是S的前缀，因此我们考虑构一棵trie。 &emsp;&emsp;注意这棵trie有个很鲜明的特征：由于每次Add都不相同，所以trie上的每个节点最多代表一个字符串。 &emsp;&emsp;因此S在trie上走的时候，最多遇到32个字符串，也就是说，S的匹配最多只有32个，这就是该算法比上一个算法优的关键因素。 &emsp;&emsp;有了这个trie，我们可以轻松把32个匹配全部取出来，然后按时间戳排个序，看看哪次会更新，然后这么多次更新中，有多少次是在L以后、R以前的。 &emsp;&emsp;时间复杂度 $O(32 \\cdot n)$","categories":[{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[{"name":"算法_字符串","slug":"算法-字符串","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"GDKOI2016总结","slug":"GDKOI2016","date":"2016-02-29T14:02:39.000Z","updated":"2024-04-24T03:59:22.775Z","comments":true,"path":"GDKOI2016/","link":"","permalink":"http://kqp.world/GDKOI2016/","excerpt":"&emsp;&emsp;现在我倒数第二次gdkoi挂了。只剩明年的一次了。&emsp;&emsp;看了成绩和排名之后，发现许多神奇的地方，比如两天总排51，这意味着我是进不了第三天的第一名。。。。比如初中150都有一等奖（高一大老男人跑去看初中好意思吗你）。。。。","text":"&emsp;&emsp;现在我倒数第二次gdkoi挂了。只剩明年的一次了。&emsp;&emsp;看了成绩和排名之后，发现许多神奇的地方，比如两天总排51，这意味着我是进不了第三天的第一名。。。。比如初中150都有一等奖（高一大老男人跑去看初中好意思吗你）。。。。 &emsp;&emsp;额。。这几天大概是这样挂的。&emsp;&emsp;day1：t1一看是数据结构直接跳过（心想这种题从来都是放在t4的位置而且都是很bt超出我能力的数据结构），t2一看是概率dp然后范围什么的都很正常，t3一看觉得是简单拓扑但又长得像网络流，t4一看显然是状压。看完题，傻眼了——今天没有sb题！！！没办法那就做吧。t1没接触过这类线段树的做法于是没思路，果断暴力。t3我有印象这种题是网络流但是考场上推不出为什么它不是简单拓扑。然后开始推t2一个半钟多后调不出样例，才发现看错题。此时剩45分钟，由于t4不是简单状压（而是要打很久的插头），赶紧暴力。完事还剩半个钟，改t2结果没改完。&emsp;&emsp;day1拿了100分好像不算差（据说有前50）。然而噩梦刚刚开始。&emsp;&emsp;day2：t1一看是博弈问题毫无思路，t2一看数位dp然后范围有点bt，t3一看是回文串但是要删删减减不简单，t4一看是数论题。看完题，傻眼了——今天又没有sb题！！！没办法那就做吧。t4兴高采烈打完后发现模数不是质数，手推模非质数许久未果。t2和t3由于各种脑抽耗了3h左右最终只得上暴力。t1最终没有打。&emsp;&emsp;day2最终暴力得还算可以拿了70，但是毕竟是全暴力，相比起其他一堆人200+，这成绩不仅没有竞争力，反而拖低了day1的竞争力。&emsp;&emsp;然后我发现各种比赛最终都会死于day2。 &emsp;&emsp;大概题解：day1：t1：每一个位1棵线段树共10棵；t2：简单概率dp；t3：最大权闭合子图；t4：插头dp；day2：t1：记忆化搜索；t2：简单数位dp；t3：两个回文串拼起来的脑洞问题；t4：数论各种变式然后各种逆元方法。&emsp;&emsp;然后就发现挂的原因是几乎每道题都被一个致命的东西卡住了：day1：t1：每一位单独做不会实现；t2：太晚发现看错题（否则真的可以调出来）；t3：脑抽没发现终点可以不止一个；day2：t1：没有意识到先手和后手其实在干同一件事，就是让自己分数最大化、对手分数最小化，因此既没有先后手区别也没有特殊的最优策略；t2：居然没有意识到3的倍数各位加起来是3！！！（直接导致dp过于复杂而放弃）；t3：没看出来是两个回文串拼起来；t4：模纠结了很久。。&emsp;&emsp;然后可以发现t1主要是粗心问题，t2主要是脑洞问题。 &emsp;&emsp;过去的就过去了，现在的问题是要在5月份省赛到来之前解决两件事：一当然还是扩充阅历多做题，避免d1t1、d2t1这类“别人都会的经典思路自己不会”的问题；二是把脑洞打开，现在的思维很僵，脑洞题几乎都不会做。","categories":[{"name":"总结与游记","slug":"总结与游记","permalink":"http://kqp.world/categories/%E6%80%BB%E7%BB%93%E4%B8%8E%E6%B8%B8%E8%AE%B0/"},{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[]},{"title":"gdkoi2016赛前总结","slug":"gdkoi2016赛前总结","date":"2016-02-29T14:00:52.000Z","updated":"2024-04-24T03:59:22.775Z","comments":true,"path":"gdkoi2016赛前总结/","link":"","permalink":"http://kqp.world/gdkoi2016%E8%B5%9B%E5%89%8D%E6%80%BB%E7%BB%93/","excerpt":"&emsp;&emsp;一开始选gdkoi组是有点忐忑的，day1都挂的这么死，本来是想选noip组的，但是有两件事情改变了这个看法。第一是day1晚上发现koi的题还是可改的，第二是看了day2的noip组发现两个一眼题，这不利培养手感。&emsp;&emsp;然后就这样走上了不归路。","text":"&emsp;&emsp;一开始选gdkoi组是有点忐忑的，day1都挂的这么死，本来是想选noip组的，但是有两件事情改变了这个看法。第一是day1晚上发现koi的题还是可改的，第二是看了day2的noip组发现两个一眼题，这不利培养手感。&emsp;&emsp;然后就这样走上了不归路。 &emsp;&emsp;然后这几天跪成什么样就不用说啦，反正打开排名要向下拉才能看见我。&emsp;&emsp;大部分的题对于我来说，现场都是不可做的，偶尔有两三题我会直接看100%的数据范围，剩下的就只能看部分分，甚至只能看10%的部分分。（事实说明每题拿10分的话排名都是可以很前的，论部分分的重要性）&emsp;&emsp;然后这些题涉及的知识很多都是以前接触过但是基本没碰过的东西，所以我知道大概要解决什么东西但是不会下手（比如费用流，很明显的知道上下界要用超级源和超级汇，却不会连边）（又例如有一个在树上记录路径差值的题，以前做类似题的时候好像没改出来）（好像这两个东西都是ganxi讲的）。&emsp;&emsp;然后这些题很多又有这样一个特点——代码贼长。它往往组合了很多很多东西。代码长的话风险性是很大的，首先调试就很麻烦，往往写完一块就要调一调，然后写长代码往往思路就很乱，本来思考题目就已经使思维比较干了，然后就跪啦。&emsp;&emsp;然后这几场比赛在纸上的时间远大于在电脑上的时间，并不知道是好是坏。 &emsp;&emsp;改掉全部题显然是不可能的（对于这个星期），但是改多少是多少，反正都是我不熟或者没练过的，每做一题都是赤裸裸的收获。这些没改完的题以后还是要继续改的。&emsp;&emsp;做这些难题有很多收获，扩充知识面，学会看范围，学会打暴力，熟练了一些专题，有了koi的手感。&emsp;&emsp;现在做题还是太少了，所以看一个题要么不知道往哪想，要么知道是哪个方面的问题但不知道用什么来实现。提升阅历是重点。","categories":[{"name":"总结与游记","slug":"总结与游记","permalink":"http://kqp.world/categories/%E6%80%BB%E7%BB%93%E4%B8%8E%E6%B8%B8%E8%AE%B0/"},{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[]},{"title":"noip2015总结","slug":"noip2015","date":"2015-11-21T14:34:36.000Z","updated":"2024-04-24T03:59:22.785Z","comments":true,"path":"noip2015/","link":"","permalink":"http://kqp.world/noip2015/","excerpt":"&emsp;&emsp;考得非常差。","text":"&emsp;&emsp;考得非常差。 &emsp;&emsp;有该拿的分没拿到，看着旁边的人都上了400或者500心里很不爽，自己明明都可以的。&emsp;&emsp;考前放松做的很好，跟fzr到处浪，然而对于day2并没有效果。&emsp;&emsp;day1拿了230也算这样了。前两题没有失误很好。t3一直在想一些奇怪的方法，想完都快11点了，当然不够时间打。打得差不多了，没调完。（太把考试当作训练不好，这样感觉时间花在多余的思考上无所谓，但是这样做并不能尽力去拿分）。当时看到n只有23就大概明白是跟状态有关的东西，于是状压dp、贪心什么的都出来了（这其实是好事，说明思路很广）。但是这个题的最大的问题就是花了近一个小时在思考如何枚举，可见思维混乱度其实特别高。（一看到数据小就乱创新，一看到数据大就只想到传统方法。）&emsp;&emsp;day2我一直在想，如果不是在noi题库上看了t1，我在考场上能不能想到二分？我估计不太行，最大值最小化和最小值最大化我都不太敏感，例如t3就没看出来这是最大值最小化的二分。所以如果不是看过t1，可能分数就更低了。&emsp;&emsp;day2t2是这次失分的最大的环节，nmk的dp不是没想过，而是推转移的过程中从未想过只与变量-1的状态有关。然后弄了一个钟的组合数优化暴力，根本没用。当时我已经完全否决了除dp外的任何做法（就这么个简单dp你都想这么多奇怪的东西出来，思路真的是广得不得了，然而并没有价值），却已经没有时间了。恰好第三题又看错了，以为很容易，于是赶紧打第三题，打到11点半，发现第三题理解是错的，于是胡乱输出点东西就去搞第二题的部分分。急急忙忙打了几个k取特殊值的点，然后因为是急急忙忙的，所以没时间调试，所以就这样完挂day2。&emsp;&emsp;所以dp推转移的思路一直都很混乱（这是致命弱点），这相当于考场上出的任何dp我都要搞很久甚至搞不出来。不知道什么时候起我想问题总是从最原始的东西入手然后逐步优化，好像是之前一直做难题搞到练成了这么一种做题思路。其实每次都从最最原始的暴力入手反而不好推，因为有些题必须走捷径，而这些捷径可以是一些特殊性质，是原始暴力根本推不出来的，所以观察力不敏锐、阅历太少是不行的。对于d2t2，阅历太少不是问题，我总是在想每次枚举一段连续的，而没想过直接从上一个状态推下来。头脑总是太死了，一个方法是错的时候，都不知道该从哪个圈里跳出来。拼命让自己头脑活起来，却只活了表面，胡思乱想了许多表面上是对的但实际上根本不是一回事的算法。&emsp;&emsp;由各种脑抽浪费时间导致整场比赛时间崩溃。这就是直观的问题所在。具体到细节，就是上面的分析。都是noip就是一场看你脑洞开不开的比赛，事实证明这个脑洞开没开并不是考试状态的原因，而是自己“独特”的思维模式造成的。","categories":[{"name":"总结与游记","slug":"总结与游记","permalink":"http://kqp.world/categories/%E6%80%BB%E7%BB%93%E4%B8%8E%E6%B8%B8%E8%AE%B0/"},{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[]},{"title":"noip2015五校联考1、9.12模拟总结","slug":"noip2015五校联考1、9.12模拟总结","date":"2015-09-14T14:12:59.000Z","updated":"2024-04-24T03:59:22.786Z","comments":true,"path":"noip2015五校联考1、9.12模拟总结/","link":"","permalink":"http://kqp.world/noip2015%E4%BA%94%E6%A0%A1%E8%81%94%E8%80%831%E3%80%819.12%E6%A8%A1%E6%8B%9F%E6%80%BB%E7%BB%93/","excerpt":"其实以前有写总结的习惯，但是没有博客，从没发表过。但是不管写没写，发表不发表，脑子里都会进行总结，不过写出来效果应该好点。","text":"其实以前有写总结的习惯，但是没有博客，从没发表过。但是不管写没写，发表不发表，脑子里都会进行总结，不过写出来效果应该好点。 这两场其实可以放在一块总结，问题都差不多，状态低迷，思维混乱，脑子不知道在想什么，反正三场都没什么起色，三等奖都不知道有没有了。 像第一场day1，第三题哈夫曼树确实难想，第一时间不够，第二没这个经验，根本不知道这个方向。但是前两题，也是这两天的重要错误，估分100的题全部都10分或者0分。其问题有二，第一，小错误。最近小错误犯得很多，各种各样的没注意。有时候想到了什么思路和一些注意事项，在草稿纸上把思路列好后就忘了注意事项，比如推了个公式就忘了适用范围。这样的问题其实可以通过拍来解决，但是有时候只测一些小数据而懒得测大数据，又或者小数据都是错的，又或者拍也是错的，各种各样的小错误叠加，不要说没分，就是改题都要花很长时间，这也是我改题慢的一个主要原因。 其二，算法基本方向很容易想到，但是想到方向之后的细节却很乱来。比如第一场day2t3，明知道绝对有规律，却总是被那个无关的n迷惑，心中总想着二维二维，于是抛弃了找规律这条路。又比如那个概率dp，明知道是dp，心中却总认为它不是一棵树做不了dp。又比如912模拟最后一题，看着很像线段树，几乎都搞定所有细节了不会解决数据太大的问题，却没想过把它倒过来做就没问题了……凡此种种似乎每次想这种东西都是什么都想到了就缺少关键一环，这关键一环决定着算法的成败，但可能非常弱智，也可能说稍微退一步思路就能想到，但不管怎样，弱智也好，需要一些推理也好，总有什么地方可以卡死我。一来可能是对算法的深度推广不熟，二来总是看了一遍题目就产生一些惯性思维牵制思想。 怎么解决？说实话这种东西我从初中写到现在也没什么很好的解决方法。关于小错误，只能说把想到的要注意的全部写下来，然后拍的时候一定要全面，首先必须保证拍不会错。然后对于第二个问题，扩大自己的见识，熟悉常用的数据结构、算法推广应用，然后题目一定要多读几遍。","categories":[{"name":"总结与游记","slug":"总结与游记","permalink":"http://kqp.world/categories/%E6%80%BB%E7%BB%93%E4%B8%8E%E6%B8%B8%E8%AE%B0/"},{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"}],"tags":[]}],"categories":[{"name":"玩","slug":"玩","permalink":"http://kqp.world/categories/%E7%8E%A9/"},{"name":"总结与游记","slug":"总结与游记","permalink":"http://kqp.world/categories/%E6%80%BB%E7%BB%93%E4%B8%8E%E6%B8%B8%E8%AE%B0/"},{"name":"OI/XCPC","slug":"OI-XCPC","permalink":"http://kqp.world/categories/OI-XCPC/"},{"name":"TCS","slug":"TCS","permalink":"http://kqp.world/categories/TCS/"},{"name":"杂写","slug":"杂写","permalink":"http://kqp.world/categories/%E6%9D%82%E5%86%99/"},{"name":"project","slug":"project","permalink":"http://kqp.world/categories/project/"},{"name":"随手academy","slug":"随手academy","permalink":"http://kqp.world/categories/%E9%9A%8F%E6%89%8Bacademy/"}],"tags":[{"name":"算法_图论","slug":"算法-图论","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E5%9B%BE%E8%AE%BA/"},{"name":"算法_树链剖分","slug":"算法-树链剖分","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/"},{"name":"complexity","slug":"complexity","permalink":"http://kqp.world/tags/complexity/"},{"name":"ZKP","slug":"ZKP","permalink":"http://kqp.world/tags/ZKP/"},{"name":"算法_网络流/匹配","slug":"算法-网络流-匹配","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E7%BD%91%E7%BB%9C%E6%B5%81-%E5%8C%B9%E9%85%8D/"},{"name":"算法_神奇的脑洞","slug":"算法-神奇的脑洞","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E7%A5%9E%E5%A5%87%E7%9A%84%E8%84%91%E6%B4%9E/"},{"name":"算法_平衡树/set","slug":"算法-平衡树-set","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E5%B9%B3%E8%A1%A1%E6%A0%91-set/"},{"name":"算法_DP","slug":"算法-DP","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-DP/"},{"name":"算法_数论","slug":"算法-数论","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E6%95%B0%E8%AE%BA/"},{"name":"算法_最短路模型","slug":"算法-最短路模型","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E6%9C%80%E7%9F%AD%E8%B7%AF%E6%A8%A1%E5%9E%8B/"},{"name":"算法_莫队/分块","slug":"算法-莫队-分块","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E8%8E%AB%E9%98%9F-%E5%88%86%E5%9D%97/"},{"name":"算法_分治","slug":"算法-分治","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E5%88%86%E6%B2%BB/"},{"name":"算法_位运算","slug":"算法-位运算","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"name":"编译器","slug":"编译器","permalink":"http://kqp.world/tags/%E7%BC%96%E8%AF%91%E5%99%A8/"},{"name":"算法_数学","slug":"算法-数学","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E6%95%B0%E5%AD%A6/"},{"name":"算法_并查集","slug":"算法-并查集","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"name":"算法_偏序关系","slug":"算法-偏序关系","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E5%81%8F%E5%BA%8F%E5%85%B3%E7%B3%BB/"},{"name":"算法_随机大法","slug":"算法-随机大法","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E9%9A%8F%E6%9C%BA%E5%A4%A7%E6%B3%95/"},{"name":"算法_构造题","slug":"算法-构造题","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E6%9E%84%E9%80%A0%E9%A2%98/"},{"name":"算法_贪心","slug":"算法-贪心","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E8%B4%AA%E5%BF%83/"},{"name":"算法_字符串","slug":"算法-字符串","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"算法_矩阵乘法","slug":"算法-矩阵乘法","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95/"},{"name":"RNN","slug":"RNN","permalink":"http://kqp.world/tags/RNN/"},{"name":"算法_计数","slug":"算法-计数","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E8%AE%A1%E6%95%B0/"},{"name":"算法_根号平衡","slug":"算法-根号平衡","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E6%A0%B9%E5%8F%B7%E5%B9%B3%E8%A1%A1/"},{"name":"算法_启发式合并","slug":"算法-启发式合并","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E5%90%AF%E5%8F%91%E5%BC%8F%E5%90%88%E5%B9%B6/"},{"name":"算法_多项式/生成函数","slug":"算法-多项式-生成函数","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E5%A4%9A%E9%A1%B9%E5%BC%8F-%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/"},{"name":"算法_概率与期望","slug":"算法-概率与期望","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E6%A6%82%E7%8E%87%E4%B8%8E%E6%9C%9F%E6%9C%9B/"},{"name":"操作系统","slug":"操作系统","permalink":"http://kqp.world/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"算法_博弈","slug":"算法-博弈","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E5%8D%9A%E5%BC%88/"},{"name":"算法_线段树","slug":"算法-线段树","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"name":"算法_析合树","slug":"算法-析合树","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E6%9E%90%E5%90%88%E6%A0%91/"},{"name":"算法_几何","slug":"算法-几何","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E5%87%A0%E4%BD%95/"},{"name":"算法_线性代数","slug":"算法-线性代数","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"},{"name":"CPU","slug":"CPU","permalink":"http://kqp.world/tags/CPU/"},{"name":"算法_2-SAT","slug":"算法-2-SAT","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-2-SAT/"},{"name":"算法_FFT/NTT","slug":"算法-FFT-NTT","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-FFT-NTT/"},{"name":"程设","slug":"程设","permalink":"http://kqp.world/tags/%E7%A8%8B%E8%AE%BE/"},{"name":"算法_点分治","slug":"算法-点分治","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E7%82%B9%E5%88%86%E6%B2%BB/"},{"name":"算法_扫描线","slug":"算法-扫描线","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E6%89%AB%E6%8F%8F%E7%BA%BF/"},{"name":"算法_环套树","slug":"算法-环套树","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E7%8E%AF%E5%A5%97%E6%A0%91/"},{"name":"算法_群论","slug":"算法-群论","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E7%BE%A4%E8%AE%BA/"},{"name":"算法_平衡规划（定期重构）","slug":"算法-平衡规划（定期重构）","permalink":"http://kqp.world/tags/%E7%AE%97%E6%B3%95-%E5%B9%B3%E8%A1%A1%E8%A7%84%E5%88%92%EF%BC%88%E5%AE%9A%E6%9C%9F%E9%87%8D%E6%9E%84%EF%BC%89/"}]}