<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1,user-scalable=no,minimal-ui"><meta name="renderer" content="webkit"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><meta name="format-detection" content="telephone=no,email=no,adress=no"><meta name="theme-color" content="#000000"><meta http-equiv="window-target" content="_top"><title>【编译原理大作业】Tiny+的语法树 | Four&#39;s</title><meta name="description" content="&amp;emsp;&amp;emsp;这是编译原理大作业的第一步：词法分析与语法分析，最终效果是构建出语法树。"><meta property="og:type" content="article"><meta property="og:title" content="【编译原理大作业】Tiny+的语法树"><meta property="og:url" content="http://kqp.world/Tiny+syntaxtree/index.html"><meta property="og:site_name" content="Four&#39;s"><meta property="og:description" content="&amp;emsp;&amp;emsp;这是编译原理大作业的第一步：词法分析与语法分析，最终效果是构建出语法树。"><meta property="og:locale" content="en_US"><meta property="og:image" content="http://kqp.world/images/flexbison.png"><meta property="article:published_time" content="2021-04-17T14:17:24.000Z"><meta property="article:modified_time" content="2023-08-23T05:57:15.470Z"><meta property="article:author" content="kqp"><meta property="article:tag" content="编译器"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="http://kqp.world/images/flexbison.png"><link rel="canonical" href="http://kqp.world/Tiny+syntaxtree/index.html"><link rel="alternate" href="/atom.xml" title="Four&#39;s" type="application/atom+xml"><link rel="icon" href="/favicon_you_3.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link href="//cdn.jsdelivr.net/npm/katex@0.9.0/dist/katex.min.css" rel="stylesheet"><meta name="generator" content="Hexo 6.2.0"></head><body class="main-center" itemscope itemtype="http://schema.org/WebPage"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="slimContent"><div class="navbar-header"><div class="profile-block text-center"><a id="avatar" href="" target="_blank"><img class="img-circle img-rotate" src="/images/avatar.png" width="200" height="200"></a><h2 id="name" class="hidden-xs hidden-sm">kqp</h2><h3 id="title" class="hidden-xs hidden-sm hidden-md">OIACMer / HKU_CS / LLer / TCS</h3><small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i></small></div><div class="search" id="search-form-wrap"><form class="search-form sidebar-form"><div class="input-group"><input type="text" class="search-form-input form-control" placeholder="Search"> <span class="input-group-btn"><button type="submit" class="search-form-submit btn btn-flat" onclick="return!1"><i class="icon icon-search"></i></button></span></div></form><div class="ins-search"><div class="ins-search-mask"></div><div class="ins-search-container"><div class="ins-input-wrapper"><input type="text" class="ins-search-input" placeholder="Type something..." x-webkit-speech> <button type="button" class="close ins-close ins-selectable" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button></div><div class="ins-section-wrapper"><div class="ins-section-container"></div></div></div></div></div><button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false"><span class="sr-only">Toggle navigation</span> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span></button></div><nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation"><ul class="nav navbar-nav main-nav"><li class="menu-item menu-item-home"><a href="/."><i class="icon icon-home-fill"></i> <span class="menu-title">Home</span></a></li><li class="menu-item menu-item-archives"><a href="/archives"><i class="icon icon-archives-fill"></i> <span class="menu-title">Archives</span></a></li><li class="menu-item menu-item-categories"><a href="/categories"><i class="icon icon-folder"></i> <span class="menu-title">Categories</span></a></li><li class="menu-item menu-item-tags"><a href="/tags"><i class="icon icon-tags"></i> <span class="menu-title">Tags</span></a></li><li class="menu-item menu-item-links"><a href="/links"><i class="icon icon-friendship"></i> <span class="menu-title">Links</span></a></li><li class="menu-item menu-item-about"><a href="/personal/index"><i class="icon icon-cup-fill"></i> <span class="menu-title">About</span></a></li></ul><ul class="social-links"><li><a href="mailto:kuangqp1217@qq.com" target="_blank" title="Email" data-toggle="tooltip" data-placement="top"><i class="icon icon-email"></i></a></li><li><a href="http://wpa.qq.com/msgrd?v=3&uin=940240973&site=qq&menu=yes" target="_blank" title="Qq" data-toggle="tooltip" data-placement="top"><i class="icon icon-qq"></i></a></li><li><a href="https://twitter.com/yuan_four" target="_blank" title="Twitter" data-toggle="tooltip" data-placement="top"><i class="icon icon-twitter"></i></a></li><li><a href="https://github.com/l2l7l9p" target="_blank" title="Github" data-toggle="tooltip" data-placement="top"><i class="icon icon-github"></i></a></li><li><a href="/atom.xml" target="_blank" title="Rss" data-toggle="tooltip" data-placement="top"><i class="icon icon-rss"></i></a></li></ul></nav></div></header><aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar"><div class="slimContent"><div class="widget"><h3 class="widget-title">Board</h3><div class="widget-body"><div id="board"><div class="content"><p>总有一天会学习前端，亲自操刀改造博客的。（发出鸽子的声音）</p></div></div></div></div><div class="widget"><h3 class="widget-title">Categories</h3><div class="widget-body"><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/OI-ACM/">OI/ACM</a><span class="category-list-count">199</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/TCS/">TCS</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/project/">project</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%80%BB%E7%BB%93%E4%B8%8E%E6%B8%B8%E8%AE%B0/">总结与游记</a><span class="category-list-count">37</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9D%82%E5%86%99/">杂写</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%8E%A9/">玩</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9A%8F%E6%89%8Bacademy/">随手academy</a><span class="category-list-count">2</span></li></ul></div></div><div class="widget"><h3 class="widget-title">Tag Cloud</h3><div class="widget-body tagcloud"><a href="/tags/CPU/" style="font-size:13px">CPU</a> <a href="/tags/RNN/" style="font-size:13px">RNN</a> <a href="/tags/ZKP/" style="font-size:13.08px">ZKP</a> <a href="/tags/complexity/" style="font-size:13.15px">complexity</a> <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" style="font-size:13px">操作系统</a> <a href="/tags/%E7%A8%8B%E8%AE%BE/" style="font-size:13.08px">程设</a> <a href="/tags/%E7%AE%97%E6%B3%95-2-SAT/" style="font-size:13.08px">算法_2-SAT</a> <a href="/tags/%E7%AE%97%E6%B3%95-DP/" style="font-size:13.92px">算法_DP</a> <a href="/tags/%E7%AE%97%E6%B3%95-FFT-NTT/" style="font-size:13.46px">算法_FFT/NTT</a> <a href="/tags/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/" style="font-size:13.69px">算法_位运算</a> <a href="/tags/%E7%AE%97%E6%B3%95-%E5%81%8F%E5%BA%8F%E5%85%B3%E7%B3%BB/" style="font-size:13.08px">算法_偏序关系</a> <a href="/tags/%E7%AE%97%E6%B3%95-%E5%87%A0%E4%BD%95/" style="font-size:13.08px">算法_几何</a> <a href="/tags/%E7%AE%97%E6%B3%95-%E5%88%86%E6%B2%BB/" style="font-size:13.15px">算法_分治</a> <a href="/tags/%E7%AE%97%E6%B3%95-%E5%8D%9A%E5%BC%88/" style="font-size:13.08px">算法_博弈</a> <a href="/tags/%E7%AE%97%E6%B3%95-%E5%90%AF%E5%8F%91%E5%BC%8F%E5%90%88%E5%B9%B6/" style="font-size:13.08px">算法_启发式合并</a> <a href="/tags/%E7%AE%97%E6%B3%95-%E5%9B%BE%E8%AE%BA/" style="font-size:13.54px">算法_图论</a> <a href="/tags/%E7%AE%97%E6%B3%95-%E5%A4%9A%E9%A1%B9%E5%BC%8F-%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/" style="font-size:13.54px">算法_多项式/生成函数</a> <a href="/tags/%E7%AE%97%E6%B3%95-%E5%AD%97%E7%AC%A6%E4%B8%B2/" style="font-size:13.38px">算法_字符串</a> <a href="/tags/%E7%AE%97%E6%B3%95-%E5%B9%B3%E8%A1%A1%E6%A0%91-set/" style="font-size:13.08px">算法_平衡树/set</a> <a href="/tags/%E7%AE%97%E6%B3%95-%E5%B9%B3%E8%A1%A1%E8%A7%84%E5%88%92%EF%BC%88%E5%AE%9A%E6%9C%9F%E9%87%8D%E6%9E%84%EF%BC%89/" style="font-size:13px">算法_平衡规划（定期重构）</a> <a href="/tags/%E7%AE%97%E6%B3%95-%E5%B9%B6%E6%9F%A5%E9%9B%86/" style="font-size:13.31px">算法_并查集</a> <a href="/tags/%E7%AE%97%E6%B3%95-%E6%89%AB%E6%8F%8F%E7%BA%BF/" style="font-size:13.08px">算法_扫描线</a> <a href="/tags/%E7%AE%97%E6%B3%95-%E6%95%B0%E5%AD%A6/" style="font-size:13.08px">算法_数学</a> <a href="/tags/%E7%AE%97%E6%B3%95-%E6%95%B0%E8%AE%BA/" style="font-size:13.85px">算法_数论</a> <a href="/tags/%E7%AE%97%E6%B3%95-%E6%9C%80%E7%9F%AD%E8%B7%AF%E6%A8%A1%E5%9E%8B/" style="font-size:13.23px">算法_最短路模型</a> <a href="/tags/%E7%AE%97%E6%B3%95-%E6%9E%84%E9%80%A0%E9%A2%98/" style="font-size:13.62px">算法_构造题</a> <a href="/tags/%E7%AE%97%E6%B3%95-%E6%9E%90%E5%90%88%E6%A0%91/" style="font-size:13px">算法_析合树</a> <a href="/tags/%E7%AE%97%E6%B3%95-%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/" style="font-size:13.08px">算法_树链剖分</a> <a href="/tags/%E7%AE%97%E6%B3%95-%E6%A0%B9%E5%8F%B7%E5%B9%B3%E8%A1%A1/" style="font-size:13.23px">算法_根号平衡</a> <a href="/tags/%E7%AE%97%E6%B3%95-%E6%A6%82%E7%8E%87%E4%B8%8E%E6%9C%9F%E6%9C%9B/" style="font-size:13.31px">算法_概率与期望</a> <a href="/tags/%E7%AE%97%E6%B3%95-%E7%82%B9%E5%88%86%E6%B2%BB/" style="font-size:13.15px">算法_点分治</a> <a href="/tags/%E7%AE%97%E6%B3%95-%E7%8E%AF%E5%A5%97%E6%A0%91/" style="font-size:13.08px">算法_环套树</a> <a href="/tags/%E7%AE%97%E6%B3%95-%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95/" style="font-size:13.31px">算法_矩阵乘法</a> <a href="/tags/%E7%AE%97%E6%B3%95-%E7%A5%9E%E5%A5%87%E7%9A%84%E8%84%91%E6%B4%9E/" style="font-size:14px">算法_神奇的脑洞</a> <a href="/tags/%E7%AE%97%E6%B3%95-%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/" style="font-size:13.23px">算法_线性代数</a> <a href="/tags/%E7%AE%97%E6%B3%95-%E7%BA%BF%E6%AE%B5%E6%A0%91/" style="font-size:13.77px">算法_线段树</a> <a href="/tags/%E7%AE%97%E6%B3%95-%E7%BD%91%E7%BB%9C%E6%B5%81-%E5%8C%B9%E9%85%8D/" style="font-size:13.54px">算法_网络流/匹配</a> <a href="/tags/%E7%AE%97%E6%B3%95-%E7%BE%A4%E8%AE%BA/" style="font-size:13.08px">算法_群论</a> <a href="/tags/%E7%AE%97%E6%B3%95-%E8%8E%AB%E9%98%9F-%E5%88%86%E5%9D%97/" style="font-size:13.46px">算法_莫队/分块</a> <a href="/tags/%E7%AE%97%E6%B3%95-%E8%AE%A1%E6%95%B0/" style="font-size:13.23px">算法_计数</a> <a href="/tags/%E7%AE%97%E6%B3%95-%E8%B4%AA%E5%BF%83/" style="font-size:13.23px">算法_贪心</a> <a href="/tags/%E7%AE%97%E6%B3%95-%E9%9A%8F%E6%9C%BA%E5%A4%A7%E6%B3%95/" style="font-size:13.38px">算法_随机大法</a> <a href="/tags/%E7%BC%96%E8%AF%91%E5%99%A8/" style="font-size:13.08px">编译器</a></div></div><div class="widget"><h3 class="widget-title">Archive</h3><div class="widget-body"><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/08/">August 2023</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/06/">June 2023</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/05/">May 2023</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/01/">January 2023</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/10/">October 2022</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/09/">September 2022</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/08/">August 2022</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/07/">July 2022</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/06/">June 2022</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/05/">May 2022</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/04/">April 2022</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/02/">February 2022</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/01/">January 2022</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/12/">December 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/11/">November 2021</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/10/">October 2021</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">August 2021</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">July 2021</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">May 2021</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">April 2021</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">February 2021</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">December 2020</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">November 2020</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">October 2020</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a><span class="archive-list-count">8</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">February 2020</a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">January 2020</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">December 2019</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">June 2019</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">May 2019</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">February 2019</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">October 2018</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">September 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">July 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">June 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">July 2017</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">June 2017</a><span class="archive-list-count">8</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">May 2017</a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">April 2017</a><span class="archive-list-count">13</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">March 2017</a><span class="archive-list-count">17</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">February 2017</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">January 2017</a><span class="archive-list-count">8</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">December 2016</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">November 2016</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">October 2016</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/09/">September 2016</a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">August 2016</a><span class="archive-list-count">13</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">July 2016</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">May 2016</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">April 2016</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/02/">February 2016</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/11/">November 2015</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/09/">September 2015</a><span class="archive-list-count">1</span></li></ul></div></div><div class="widget"><h3 class="widget-title">Recent Posts</h3><div class="widget-body"><ul class="recent-post-list list-unstyled no-thumbnail"><li><div class="item-inner"><p class="item-category"><a class="category-link" href="/categories/%E7%8E%A9/">玩</a></p><p class="item-title"><a href="/liella_4th_chiba/" class="title">Liella 4th 千叶场</a></p><p class="item-date"><time datetime="2023-08-21T15:15:56.000Z" itemprop="datePublished">2023-08-21</time></p></div></li><li><div class="item-inner"><p class="item-category"><a class="category-link" href="/categories/TCS/">TCS</a></p><p class="item-title"><a href="/%5BSTOC2018%5DFine-grained-Reductions-from-Approximate-Counting-to-Decision/" class="title">【STOC2018】Fine-grained Reductions from Approximate Counting to Decision</a></p><p class="item-date"><time datetime="2023-06-17T03:24:12.000Z" itemprop="datePublished">2023-06-17</time></p></div></li><li><div class="item-inner"><p class="item-category"><a class="category-link" href="/categories/%E7%8E%A9/">玩</a></p><p class="item-title"><a href="/liyuu_2nd_guangzhou/" class="title">Liyuu 2nd 巡演广州场</a></p><p class="item-date"><time datetime="2023-05-15T13:12:56.000Z" itemprop="datePublished">2023-05-15</time></p></div></li><li><div class="item-inner"><p class="item-category"><a class="category-link" href="/categories/%E7%8E%A9/">玩</a></p><p class="item-title"><a href="/japan202302/" class="title">Liella 3rd 东京场 + AZUNA 1st + 沼津台场原宿圣地巡礼！</a></p><p class="item-date"><time datetime="2023-01-23T14:14:55.000Z" itemprop="datePublished">2023-01-23</time></p></div></li><li><div class="item-inner"><p class="item-category"><a class="category-link" href="/categories/%E6%80%BB%E7%BB%93%E4%B8%8E%E6%B8%B8%E8%AE%B0/">总结与游记</a></p><p class="item-title"><a href="/sum2022/" class="title">未来は風のように</a></p><p class="item-date"><time datetime="2023-01-17T15:39:54.000Z" itemprop="datePublished">2023-01-17</time></p></div></li></ul></div></div></div></aside><main class="main" role="main"><div class="content"><article id="post-Tiny+syntaxtree" class="article article-type-post" itemscope itemtype="http://schema.org/BlogPosting"><div class="article-header"><h1 class="article-title" itemprop="name">【编译原理大作业】Tiny+的语法树</h1><div class="article-meta"><span class="article-date"><i class="icon icon-calendar-check"></i> <a href="/Tiny+syntaxtree/" class="article-date"><time datetime="2021-04-17T14:17:24.000Z" itemprop="datePublished">2021-04-17</time> </a></span><span class="article-category"><i class="icon icon-folder"></i> <a class="article-category-link" href="/categories/project/">project</a> </span><span class="article-tag"><i class="icon icon-tags"></i> <a class="article-tag-link-link" href="/tags/%E7%BC%96%E8%AF%91%E5%99%A8/" rel="tag">编译器</a> </span><span class="article-read hidden-xs"><i class="icon icon-eye-fill" aria-hidden="true"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span> </span></span><span class="post-comment"><i class="icon icon-comment"></i> <a href="/Tiny+syntaxtree/#comments" class="article-comment-link">Comments</a></span></div></div><div class="article-entry marked-body" itemprop="articleBody"><p>&emsp;&emsp;这是编译原理大作业的第一步：词法分析与语法分析，最终效果是构建出语法树。<br><span id="more"></span><br>&emsp;&emsp;学过编译原理都知道，词法分析要用自动机，语法分析要用 CFG。善良的老师说，我们可以不用手写自动机和 CFG，可以用工具。然后又看到实验室里做逻辑公式求解器的代码也用的是 flex 和 bison，于是我就需要学习 flex+bison 这一套现代工具链。<br>&emsp;&emsp;<del>过程中我发誓我一定要写一篇 flex 和 bison 踩坑记</del></p><p>&emsp;&emsp;推荐资料：《flex&amp;bison》（中文版叫《flex与bison(中文版)》）、<a target="_blank" rel="noopener" href="https://www.gnu.org/software/bison/manual/bison.html">bison官方文档</a>，做的过程中遇到问题在谷歌里搜索，StackOverflow 的解答还是相当不错的，也有些国内的博客回答问题也很 nice，这是少有的。<br>&emsp;&emsp;环境：Ubuntu18，flex 2.6.4，bison 3.0.4。强烈推荐 Windows 用户使用 WSL，右键即可打开当前目录下的 Linux 环境，妈妈再也不用担心我没有 Linux。</p><p>&emsp;&emsp;<a target="_blank" rel="noopener" href="https://github.com/l2l7l9p/Tiny">项目地址</a>。</p><h2 id="Task"><a href="#Task" class="headerlink" title="Task"></a>Task</h2><p>&emsp;&emsp;有一个语言叫 Tiny，具体规则在<a target="_blank" rel="noopener" href="https://jlu.myweb.cs.uwindsor.ca/214/language.htm">这里</a>。</p><ol><li>将 Tiny 扩展成 Tiny+，用 EBNF 描述 Tiny＋ 的语法；</li><li>将 Tiny＋ 源程序翻译成对应的 token 序列，并能检查一定的词法错误；</li><li>将 token 序列转换成语法分析树，并能检查一定的语法错误。</li></ol><p>&emsp;&emsp;（听说有标准的 Tiny+ 语言，但是我没找到，老师的要求是自行扩展，那么我就自行扩展了，主要让它尽量完备。<a target="_blank" rel="noopener" href="https://github.com/l2l7l9p/Tiny/blob/master/Tiny+EBNF.md">放在这里</a>）</p><h2 id="flex-与-bison-的组合"><a href="#flex-与-bison-的组合" class="headerlink" title="flex 与 bison 的组合"></a>flex 与 bison 的组合</h2><p>&emsp;&emsp;flex 是用来做词法分析的，bison 是用来做语法分析的。<br>&emsp;&emsp;最早的组合版本叫 lex+yacc，然后 lex 升级成了 flex，yacc 升级成了 bison，于是现代工具链就变成了 flex+bison。<br>&emsp;&emsp;flex 需要编写一个 <code>.l</code> 文件，然后用 flex 根据它生成一个 <code>lex.yy.c</code> 文件，用 C 编译器编译就可以了。这个文件读入字符串，通过调用 <code>int yylex()</code> 每次返回一个 token。<br>&emsp;&emsp;bison 需要编写一个 <code>.y</code> 文件，然后用 bison 根据它生成一个 <code>.tab.h</code> 和 <code>.tab.c</code> 文件。后者实现了一个过程 <code>yyparse()</code>，每次读入一个 token，根据 CFG 规则进行归约；前者则给出了相关接口（如 token 的定义）。<br>&emsp;&emsp;组合使用的方法为：<code>lex.yy.c</code> 里面 <code>#include&quot;xxx.tab.h&quot;</code>；在 <code>xxx.tab.c</code> 里实现 <code>main</code> 函数或者单开一个文件实现 <code>main</code> 函数并 <code>#include&quot;xxx.tab.h&quot;</code>（推荐后者），然后使用 C/C++ 编译器联合编译。<br><img src="/images/flexbison.png" alt=""><br>&emsp;&emsp;所以编译的时候最好写个 Makefile。</p><h2 id="bison"><a href="#bison" class="headerlink" title="bison"></a>bison</h2><p>&emsp;&emsp;bison 的基本格式是<br></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">%&#123;</span><br><span class="line">/* part 1 */</span><br><span class="line">%&#125;</span><br><span class="line">%%</span><br><span class="line">/* part 2 */</span><br><span class="line">%%</span><br><span class="line">/* part 3 */</span><br></pre></td></tr></table></figure><br>&emsp;&emsp;part 1 将原封不动抄到生成代码的开头，part 3 将原封不动抄到生成代码的结尾，part 2 是 CFG 规则描述区，其余部分可以用来设置一些有用的开关和定义。<code>/*</code> 和 <code>*/</code> 是注释。<p></p><h3 id="bison-part-1"><a href="#bison-part-1" class="headerlink" title="bison - part 1"></a>bison - part 1</h3><p>&emsp;&emsp;part 1 一般用来声明头文件和接口，例如<br></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">%&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;syntax_tree.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">int</span> <span class="title">yylex</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">yyerror</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s)</span></span>;</span><br><span class="line">node *root;</span><br><span class="line">%&#125;</span><br></pre></td></tr></table></figure><br>&emsp;&emsp;前面说过 <code>int yylex()</code> 是每次调用返回一个 token，这是与 flex 的接口之一。<br>&emsp;&emsp;这里有个坑，<code>yyerror</code> 过程是它生成的代码里会用到的，但是它自己没有声明！！还得我们用户来声明！！<br>&emsp;&emsp;<code>root</code> 则是我们要构建的语法树的根。语法树的结点基类是 <code>node</code>，而语法规则里的每一个非终结符对应一个自己特有的派生类。这些定义放在 <code>syntax_tree.h</code> 里。<br>&emsp;&emsp;这个写法比较工程，每个非终结符对应自己特有的派生类，就既可以在基类定义公有方法，也可以定义自己特有的变量和方法。比如“表达式 Expression”需要记录该表达式的类型，或者值，但是“区块 Block”就不用这些东西。同时，还可以用虚函数等多态特性，避免臃肿的 <code>switch</code>。<p></p><h3 id="bison-part-1-5"><a href="#bison-part-1-5" class="headerlink" title="bison - part 1.5"></a>bison - part 1.5</h3><p>&emsp;&emsp;在 part 2 之前，我们需要先定义 token 和所有标识符。<br></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/* part 1 */</span><br><span class="line">%&#125;</span><br><span class="line"></span><br><span class="line">%define api.value.type union</span><br><span class="line"></span><br><span class="line">%token&lt;int&gt; Number_Integer</span><br><span class="line">%token&lt;double&gt; Number_Float</span><br><span class="line">%token&lt;char*&gt; IdString QString</span><br><span class="line">%token IF ELSE FOR WRITE READ RETURN tkBEGIN END MAIN INT REAL CHAR Assign &quot;:=&quot; Equal &quot;==&quot; NEqual &quot;!=&quot; LE &quot;&lt;=&quot;</span><br><span class="line"></span><br><span class="line">%type&lt;node_Program*&gt; Program</span><br><span class="line">%type&lt;node_MethodDecls*&gt; MethodDecls MethodDeclsWithMain</span><br><span class="line">%type&lt;node_MethodDecl*&gt; MethodDecl MethodDeclMain</span><br><span class="line">%type&lt;node_FormalParams*&gt; FormalParams</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">%%</span><br><span class="line">/* part 2 */</span><br></pre></td></tr></table></figure><br>&emsp;&emsp;这里用 <code>token</code> 来定义终止标识符，用 <code>type</code> 来定义非终止标识符，后面尖括号是它的类型，无类型则不用加括号。<code>&quot;:=&quot;</code> 这样的用引号括起来的表示别名。<br>&emsp;&emsp;类型是这么回事：CFG 的每条产生式在进行归约的时候，可以让你返回一个值，比如返回语法树结点的指针。从词法分析器来的 token，也可以带有值，比如常数值。<br>&emsp;&emsp;在 bison 3.0 以上的版本，可以用 <code>%define api.value.type union</code> 开关然后在下面尖括号里面直接写变量类型。否则，需要手动写一个 <code>union</code> 来把这些类型合并起来。注意这里需要使用能被 <code>union</code> 起来的类型，像 <code>std::string</code> 这类变长的就不行。<br>&emsp;&emsp;（更高级的版本特性支持 <code>std::string</code>，详见官方文档。）<br>&emsp;&emsp;有些 token 如果只是单个字符，则可以不用专门起名字，不用在这里声明。例如加号“+”，要用的时候用单引号引起来即可。<p></p><h3 id="bison-part-2"><a href="#bison-part-2" class="headerlink" title="bison - part 2"></a>bison - part 2</h3><p>&emsp;&emsp;part 2 用来写 CFG 规则，形式如<br></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">%%</span><br><span class="line">&lt;标识符&gt;: &lt;产生式<span class="number">1</span>&gt; &#123;产生式<span class="number">1</span>要做的事&#125; | &lt;产生式<span class="number">2</span>&gt; &#123;产生式<span class="number">2</span>要做的事&#125; ;</span><br><span class="line">%%</span><br></pre></td></tr></table></figure><br>&emsp;&emsp;例如<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">%%</span><br><span class="line">Program:</span><br><span class="line">	MethodDeclsWithMain &#123;$$ = <span class="keyword">new</span> <span class="built_in">node_Program</span>(<span class="number">1</span>,$<span class="number">1</span>); root=$$;&#125;</span><br><span class="line">	;</span><br><span class="line">MethodDecls:</span><br><span class="line">	  MethodDecl &#123;$$ = <span class="keyword">new</span> <span class="built_in">node_MethodDecls</span>(<span class="number">1</span>,$<span class="number">1</span>);&#125;</span><br><span class="line">	| MethodDecl MethodDecls &#123;$$ = <span class="keyword">new</span> <span class="built_in">node_MethodDecls</span>(<span class="number">2</span>,$<span class="number">1</span>,$<span class="number">2</span>);&#125;</span><br><span class="line">	;</span><br><span class="line">...</span><br><span class="line">%%</span><br></pre></td></tr></table></figure><br>&emsp;&emsp;<code>\$\$</code> 表示当前标识符的返回值，<code>$1,$2...</code> 分别表示当前产生式的各标识符的返回值（无论是终止标识符还是非终止标识符都是有返回值的）。<br>&emsp;&emsp;把程序语言的规则逐条抄下来，这就可以把整个语法树构建起来了。<br>&emsp;&emsp;由于每个结点的子结点数量不相同，为方便维护，推荐使用可变参列表来传递子结点信息。可以在基类写一个统一的构造函数，子类的构造函数就把可变参列表传递给基类。<p></p><h3 id="bison-part-3"><a href="#bison-part-3" class="headerlink" title="bison - part 3"></a>bison - part 3</h3><p>&emsp;&emsp;part 3 没啥要写的，调试的时候可以在这里写个 <code>main</code> 函数，但最终还是分离出去好些。<br>&emsp;&emsp;这里要实现的是 <code>void yyerror(const char *s)</code> 函数，这玩意在 part 1 被声明，在它生成的代码里被调用，那么就在 part 3 这里实现。这个是语法分析出错时向用户输出报错信息的，把 <code>s</code> 输出就可以了。<br></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* part 2 */</span></span><br><span class="line">%%</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">yyerror</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *msg)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="bison-编译"><a href="#bison-编译" class="headerlink" title="bison 编译"></a>bison 编译</h3><p>&emsp;&emsp;编译命令是 <code>bison -d xxx.y</code>，要加上 <code>-d</code> 才能生成 <code>xxx.tab.h</code> 头文件。</p><h2 id="flex"><a href="#flex" class="headerlink" title="flex"></a>flex</h2><p>&emsp;&emsp;flex 的基本格式与 bison 相同：<br></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">%&#123;</span><br><span class="line">/* part 1 */</span><br><span class="line">%&#125;</span><br><span class="line">%%</span><br><span class="line">/* part 2 */</span><br><span class="line">%%</span><br><span class="line">/* part 3 */</span><br></pre></td></tr></table></figure><br>&emsp;&emsp;part 1 将原封不动抄到生成代码的开头，part 3 将原封不动抄到生成代码的结尾，part 2 是 token 的规则描述区，其余部分可以用来设置一些有用的开关和定义。<code>/*</code> 和 <code>*/</code> 是注释。<p></p><h3 id="flex-part-1"><a href="#flex-part-1" class="headerlink" title="flex - part 1"></a>flex - part 1</h3><p>&emsp;&emsp;part 1 一般用来声明头文件，比如<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">%&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;syntax_tree.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;tiny.tab.h&quot;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line">%&#125;</span><br></pre></td></tr></table></figure><br>&emsp;&emsp;这里要引用 bison 生成的头文件 <code>xxx.tab.h</code>，里面用 <code>enum</code> 定义了 token。因为 part 2 是要完善 <code>int yylex()</code>，这个的返回值就是 token 的 <code>enum</code>。<p></p><h3 id="flex-part-1-5"><a href="#flex-part-1-5" class="headerlink" title="flex - part 1.5"></a>flex - part 1.5</h3><p>&emsp;&emsp;这里可以用正则表达式定义一些记号，避免后面过于繁琐，比如<br></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Integer ([1-9][0-9]*|[0])</span><br></pre></td></tr></table></figure><p></p><h3 id="flex-part-2"><a href="#flex-part-2" class="headerlink" title="flex - part 2"></a>flex - part 2</h3><p>&emsp;&emsp;part 2 写 token 规则。基本格式是<br></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;正则表达式&gt; &#123;要做的事&#125;</span><br></pre></td></tr></table></figure><br>&emsp;&emsp;例如<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">%%</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;IF&quot;</span> &#123;<span class="keyword">return</span> IF;&#125;</span><br><span class="line"><span class="string">&quot;ELSE&quot;</span> &#123;<span class="keyword">return</span> ELSE;&#125;</span><br><span class="line"><span class="string">&quot;FOR&quot;</span> &#123;<span class="keyword">return</span> FOR;&#125;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;+&quot;</span> |</span><br><span class="line"><span class="string">&quot;-&quot;</span> |</span><br><span class="line"><span class="string">&quot;;&quot;</span> &#123;<span class="keyword">return</span> yytext[<span class="number">0</span>];&#125;</span><br><span class="line"><span class="string">&quot;:=&quot;</span> &#123;<span class="keyword">return</span> Assign;&#125;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">&#123;Integer&#125; &#123;yylval.Number_Integer=atoi(yytext); <span class="keyword">return</span> Number_Integer;&#125;</span><br><span class="line">&#123;Integer&#125;<span class="string">&quot;.&quot;</span>[<span class="number">0</span><span class="number">-9</span>]+ &#123;yylval.Number_Float=atof(yytext); <span class="keyword">return</span> Number_Float;&#125;</span><br><span class="line">[a-zA-Z_][a-zA-Z_0<span class="number">-9</span>]* &#123;yylval.IdString=yytext; <span class="keyword">return</span> IdString;&#125;</span><br><span class="line">\<span class="string">&quot;..*\&quot; &#123;yylval.QString=yytext; return QString;&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[ \t\n\r]+</span></span><br><span class="line"><span class="string">&quot;</span><span class="comment">/**&quot;.*&quot;**/</span><span class="string">&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">. &#123;printf(&quot;</span>%d: Undefined token\n<span class="string">&quot;,yylineno);&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">%%</span></span><br></pre></td></tr></table></figure><br>&emsp;&emsp;<code>return</code> 的值是该 token 的 <code>enum</code> 值；变量 <code>yylval</code> 用来记录这个 token 的值，在 bison 里的 <code>$1,$2...</code> 被用到；变量 <code>yytext</code> 记录了当前匹配到的输入字符串。<br>&emsp;&emsp;第一部分用引号引起来的是关键字，直接返回相应的无类型 token。<br>&emsp;&emsp;第二部分是字符 token，如果是单个字符，在 bison 里没有声明，就直接返回字符本身即可（也就是 <code>yytext[0]</code>）。<br>&emsp;&emsp;注意有个坑，每个正则表达式都要放在行首，不能因为 <code>|</code> 符号就接在别人后面，一定要另起一行。<br>&emsp;&emsp;第三部分是复杂一点的 token：整数、浮点数、变量名函数名、双引号非空字符串。这里不仅要返回 token 的 <code>enum</code>，还要记录 token 的值，token 的值的类型就是 bison part 1.5 里的大 union，如果用了 <code>%define api.value.type union</code> 开关的话，标识符的名称就是值的类型的名称。<br>&emsp;&emsp;第四部分是空白字符和注释，它们不做任何操作。<br>&emsp;&emsp;第五部分是一个简单的词法分析报错，如果匹配不上以上规则，就输出非法字符。<p></p><h3 id="flex-part-3"><a href="#flex-part-3" class="headerlink" title="flex - part 3"></a>flex - part 3</h3><p>&emsp;&emsp;没啥做的。调试的话可以在这里写 <code>main</code> 函数。</p><h3 id="flex-编译"><a href="#flex-编译" class="headerlink" title="flex 编译"></a>flex 编译</h3><p>&emsp;&emsp;<code>flex xxx.l</code></p><h2 id="余下的事情"><a href="#余下的事情" class="headerlink" title="余下的事情"></a>余下的事情</h2><p>&emsp;&emsp;经过上面两步，已经生成好词法分析和语法分析的 C 代码了，接下来只要把 <code>syntax_tree.h</code> 和 <code>main.c/cpp</code> 完成，就可以编译了。<br>&emsp;&emsp;<code>main</code> 里要做的，就是调用 <code>int yyparse()</code> 函数，进行语法分析。该函数正常结束时返回 0。当然，还有必要的用户交互要在这里写。<br>&emsp;&emsp;如果要画出语法树，那么就在基类里写一个 dfs 就好了，每个子类实现一个虚函数 <code>get_type</code> 返回它的类型和相关信息即可。<br>&emsp;&emsp;简单的 Makefile 如下：<br></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">tiny: tiny.tab.c lex.yy.c main.cpp syntax_tree.h syntax_tree.cpp</span></span><br><span class="line">	g++ main.cpp syntax_tree.cpp tiny.tab.c lex.yy.c -o tiny -g</span><br><span class="line"><span class="section">tiny.tab.c: tiny.y</span></span><br><span class="line">	bison -d tiny.y</span><br><span class="line"><span class="section">lex.yy.c: tiny.l</span></span><br><span class="line">	flex tiny.l</span><br></pre></td></tr></table></figure><p></p><h2 id="高级特性"><a href="#高级特性" class="headerlink" title="高级特性"></a>高级特性</h2><h3 id="使用-g-编译"><a href="#使用-g-编译" class="headerlink" title="使用 g++ 编译"></a>使用 g++ 编译</h3><p>&emsp;&emsp;flex 里使用开关 <code>%option noyywrap</code>。写在 part 1.5 的地方。<br>&emsp;&emsp;因为 flex 生成的代码用到了 <code>yywrap</code> 这个东西，这个东西在动态链接库 <code>-lfl</code> 中，而这个库会导致不能用 g++。<br>&emsp;&emsp;因此直接把 <code>yywrap</code> 禁了就好了。这个东西是历史遗留功能，用不上的。</p><h3 id="flex-文件读入"><a href="#flex-文件读入" class="headerlink" title="flex 文件读入"></a>flex 文件读入</h3><p>&emsp;&emsp;flex 生成的代码里有个 <code>FILE *yyin</code> 变量，默认是指向 <code>stdin</code>。在 <code>main.cpp</code> 里 <code>extern</code> 出来，然后指向一个文件，就可以文件读入了。<br>&emsp;&emsp;通常应该像命令行操作的编译器一样，由运行参数指定文件名。</p><h3 id="语法分析器的-debug"><a href="#语法分析器的-debug" class="headerlink" title="语法分析器的 debug"></a>语法分析器的 debug</h3><p>&emsp;&emsp;观察 bison 生成的 <code>.tab.c</code> 文件，发现它 printf 了很多调试信息，怎么把它们用起来呢？<br>&emsp;&emsp;在 bison 里打开两个开关，一个是 <code>%define parse.trace</code>，写在 part 1.5 的地方；另一个是将 <code>yydebug</code> 这个变量赋一个非零值（这个变量在 <code>.tab.h</code> 里声明了，因此随时随地可以直接赋值）。<br>&emsp;&emsp;这个 debug 信息非常详细，bison 是用 LALR 的，它把它每一步进入了什么状态、栈里有什么、移进归约选择全部列出来了，十分好用，<del>就是有点长。</del></p><h3 id="查看-LALR-状态以及哪个规则发生冲突"><a href="#查看-LALR-状态以及哪个规则发生冲突" class="headerlink" title="查看 LALR 状态以及哪个规则发生冲突"></a>查看 LALR 状态以及哪个规则发生冲突</h3><p>&emsp;&emsp;有时候 bison 编译 warning 说有移进归约冲突 / 归约归约冲突，所以想看看是哪条规则搞的。<br>&emsp;&emsp;bison 编译的时候加个 <code>-v</code>，即可生成一个 <code>.output</code> 文件，里面列出了 LALR 的详细信息，包括状态、移进归约指示。被方括号括起来的规则，就是因冲突而弃用的规则。</p><h3 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h3><p>&emsp;&emsp;这是个比较大的话题。<br>&emsp;&emsp;flex 的默认冲突处理是：匹配尽量长的输入字符串，等长时匹配写在最前面的规则。<br>&emsp;&emsp;bison 的默认冲突处理是：移进归约冲突优先移进。<br>&emsp;&emsp;一般来说，出现二义性，多数情况下是语法本身有问题，应当优先修改语法。<br>&emsp;&emsp;但是也有例外，例如运算表达式，虽然可以修改语法使得加减乘除之间不具有二义性，但是运算符变多了以后这个方法就很蠢了。例如 if-else，可以用龙书的 matched_stmt 和 open_stmt 来使得它没有歧义，但是相关的 stmt 的定义会变得很丑。</p><p>&emsp;&emsp;运算表达式的解决方法：优先级符号，在 bison part 1.5 的部分定义优先级<br></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">%nonassoc &quot;==&quot; &quot;!=&quot; &#x27;&lt;&#x27; &quot;&lt;=&quot;</span><br><span class="line">%left &#x27;+&#x27; &#x27;-&#x27;</span><br><span class="line">%left &#x27;*&#x27; &#x27;/&#x27;</span><br><span class="line">%nonassoc UMINUS</span><br></pre></td></tr></table></figure><br>&emsp;&emsp;优先级从上往下依次递增，同一行优先级相同。<code>left</code> 表示该符号左结合，<code>right</code> 表示该符号右结合，<code>nonassoc</code> 表示不具有结合性。<br>&emsp;&emsp;一个规则的优先级取决于该规则最右边的 token 的优先级。于是就可以直接像下面这么写了：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Expression:</span><br><span class="line">	| Expression <span class="string">&#x27;+&#x27;</span> Expression &#123;$$ = <span class="keyword">new</span> <span class="built_in">node_Expression</span>(OP_PLUS,<span class="number">2</span>,$<span class="number">1</span>,$<span class="number">3</span>);&#125;</span><br><span class="line">	| Expression <span class="string">&#x27;-&#x27;</span> Expression &#123;$$ = <span class="keyword">new</span> <span class="built_in">node_Expression</span>(OP_MINUS,<span class="number">2</span>,$<span class="number">1</span>,$<span class="number">3</span>);&#125;</span><br><span class="line">	| Expression <span class="string">&#x27;*&#x27;</span> Expression &#123;$$ = <span class="keyword">new</span> <span class="built_in">node_Expression</span>(OP_MUL,<span class="number">2</span>,$<span class="number">1</span>,$<span class="number">3</span>);&#125;</span><br><span class="line">	| Expression <span class="string">&#x27;/&#x27;</span> Expression &#123;$$ = <span class="keyword">new</span> <span class="built_in">node_Expression</span>(OP_DIV,<span class="number">2</span>,$<span class="number">1</span>,$<span class="number">3</span>);&#125;</span><br><span class="line">	| Expression Equal Expression &#123;$$ = <span class="keyword">new</span> <span class="built_in">node_Expression</span>(OP_EQUAL,<span class="number">2</span>,$<span class="number">1</span>,$<span class="number">3</span>);&#125;</span><br><span class="line">	| Expression LE Expression &#123;$$ = <span class="keyword">new</span> <span class="built_in">node_Expression</span>(OP_LE,<span class="number">2</span>,$<span class="number">1</span>,$<span class="number">3</span>);&#125;</span><br><span class="line">	| <span class="string">&#x27;-&#x27;</span> Expression %prec UMINUS &#123;$$ = <span class="keyword">new</span> <span class="built_in">node_Expression</span>(OP_UMINUS,<span class="number">1</span>,$<span class="number">2</span>);&#125;</span><br><span class="line">	...</span><br><span class="line">	;</span><br></pre></td></tr></table></figure><br>&emsp;&emsp;这里还定义了负数。<code>&#39;-&#39; Expression</code> 这里用了 <code>%prec</code>，这表示规定这条规则的优先级是后面那个符号，而不是减号的优先级。<p></p><p>&emsp;&emsp;if-else 的解决方法：一般来说不用解决，因为有默认规则“移进归约冲突优先移进”。如果看 warning 不顺眼非要消除，可以用优先级符号把 else 的优先级抬高。</p><h3 id="报错输出行号"><a href="#报错输出行号" class="headerlink" title="报错输出行号"></a>报错输出行号</h3><p>&emsp;&emsp;可以在 flex 里使用开关 <code>%option yylineno</code>，这样你就拥有了一个变量 <code>yylineno</code> 记录当前的行号。<br>&emsp;&emsp;在 <code>void yyerror(const char *s)</code> 过程里，就可以输出行号了：<br></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">yyerror</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *msg)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d: %s\n&quot;</span>,yylineno,msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>&emsp;&emsp;但是要在 bison 的 part 1 的部分 <code>extern int yylineno;</code>。<p></p><h3 id="输出更多报错信息"><a href="#输出更多报错信息" class="headerlink" title="输出更多报错信息"></a>输出更多报错信息</h3><p>&emsp;&emsp;传给 <code>yyerror</code> 的报错信息默认只有 “syntax error”。但是观察 <code>.tab.c</code>，发现它还有诸如这样的代码：<br></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (yycount)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">YYCASE_</span>(<span class="number">0</span>, <span class="built_in">YY_</span>(<span class="string">&quot;syntax error&quot;</span>));</span><br><span class="line">    <span class="built_in">YYCASE_</span>(<span class="number">1</span>, <span class="built_in">YY_</span>(<span class="string">&quot;syntax error, unexpected %s&quot;</span>));</span><br><span class="line">    <span class="built_in">YYCASE_</span>(<span class="number">2</span>, <span class="built_in">YY_</span>(<span class="string">&quot;syntax error, unexpected %s, expecting %s&quot;</span>));</span><br><span class="line">    <span class="built_in">YYCASE_</span>(<span class="number">3</span>, <span class="built_in">YY_</span>(<span class="string">&quot;syntax error, unexpected %s, expecting %s or %s&quot;</span>));</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><br>&emsp;&emsp;于是我们知道又有开关没用起来。<br>&emsp;&emsp;这个只需要在 bison 使用 <code>%error-verbose</code>（写在 part 1.5）即可。这样，我们的报错信息就又稍微丰富了些。<p></p><h3 id="error-标识符"><a href="#error-标识符" class="headerlink" title="error 标识符"></a>error 标识符</h3><p>&emsp;&emsp;但是这个报错信息还是简陋了些，怎样才能像 g++ 那样有丰富的报错信息呢？<br>&emsp;&emsp;在 bison 中可以使用 <code>error</code> 标识符，它不用提前声明，作用有点类似万能匹配符。在语法分析出现错误的时候，它就开始退栈，直到能匹配带有 <code>error</code> 标识符的规则。<br>&emsp;&emsp;因此可以针对性地输出错误信息了：<br></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">AssignStatement:</span><br><span class="line">	...</span><br><span class="line">	| Id error Expression <span class="string">&#x27;;&#x27;</span> &#123;<span class="built_in">yyerror</span>(“expect \<span class="string">&quot;:=\&quot; before Expression.&quot;</span>); $$ = <span class="literal">nullptr</span>;&#125;</span><br><span class="line">	| Id <span class="string">&#x27;:=&#x27;</span> Expression &#123;<span class="built_in">yyerror</span>(<span class="string">&quot;expect \&quot;;\&quot; at the end of the statement.&quot;</span>); $$ = <span class="literal">nullptr</span>;&#125;</span><br></pre></td></tr></table></figure><br>&emsp;&emsp;可以自行搞一些交互变量来阻止默认的 <code>yyerror</code> 调用以避免重复报错。详见《flex&amp;bison》得到更加丰富的报错信息，例如加上当前所在文件、错误发生的列号等。<p></p><h3 id="destructor"><a href="#destructor" class="headerlink" title="destructor"></a>destructor</h3><p>&emsp;&emsp;上面还存在一个问题：语法分析出错要退栈的时候，树结点是要析构的！<br>&emsp;&emsp;因此在 bison part 1.5 要写有 <code>%destructor&#123;要做的事&#125; 标识符或&lt;类型&gt;</code>，例如<br></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">%destructor&#123;&#125; &lt;<span class="type">int</span>&gt; &lt;<span class="type">double</span>&gt; &lt;<span class="type">char</span>*&gt;</span><br><span class="line">%destructor&#123; <span class="built_in">clear</span>($$); &#125; &lt;*&gt;</span><br></pre></td></tr></table></figure><br>&emsp;&emsp;<code>&lt;*&gt;</code> 表示匹配任意类型，因为每个标识符有自己的子类所以类型挺多的。然后普通的类型不用析构，所以把普通类型又单列了出来。<code>clear(node*)</code> 是自己写的递归析构。<p></p><h3 id="yynerrs"><a href="#yynerrs" class="headerlink" title="yynerrs"></a>yynerrs</h3><p>&emsp;&emsp;直接上面这样写是有问题的。凡是非归约退栈都会调用 <code>destructor</code>，这不仅包括遇到错误退栈，还包括整个语法分析完成后的根节点退栈。于是你发现，根节点被析构了。。。<br>&emsp;&emsp;因此要加一点判断，只有遇到错误时才进行析构。<code>.tab.c</code> 里有一个 <code>yynerrs</code> 变量记录了当前总共发生了多少次错误，把它 <code>extern</code> 出来，将它作为析构条件。<br></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%destructor&#123; <span class="keyword">if</span> (yynerrs) <span class="built_in">clear</span>($$); &#125; &lt;*&gt;</span><br></pre></td></tr></table></figure><p></p></div><div class="article-footer"><blockquote class="mt-2x"><ul class="post-copyright list-unstyled"><li class="post-copyright-link hidden-xs"><strong>本文链接：</strong> <a href="http://kqp.world/Tiny+syntaxtree/" title="【编译原理大作业】Tiny+的语法树" target="_blank" rel="external">http://kqp.world/Tiny+syntaxtree/</a></li><li class="post-copyright-license"><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN协议</a> 许可协议。转载请注明出处！</li></ul></blockquote><div class="panel panel-default panel-badger"><div class="panel-body"><figure class="media"><div class="media-left"><a href="" target="_blank" class="img-burn thumb-sm visible-lg"><img src="/images/avatar.png" class="img-rounded w-full" alt=""></a></div><div class="media-body"><h3 class="media-heading"><a href="" target="_blank"><span class="text-dark">kqp</span><small class="ml-1x">OIACMer / HKU_CS / LLer / TCS</small></a></h3><div>糖少许，盐少许</div></div></figure></div></div></div></article><section id="comments"><div id="vcomments"></div></section></div><nav class="bar bar-footer clearfix" data-stick-bottom><div class="bar-inner"><ul class="pager pull-left"><li class="prev"><a href="/2020_EC_Final/" title="2020 EC Final 诸事不顺记"><i class="icon icon-angle-left" aria-hidden="true"></i><span>&nbsp;&nbsp;Newer</span></a></li><li class="next"><a href="/%E3%80%90Ozon%20Tech%20Challenge%202020%20F%E3%80%91Kuroni%20and%20the%20Punishment%20%E9%A2%98%E8%A7%A3/" title="【Ozon Tech Challenge 2020 F】Kuroni and the Punishment 题解"><span>Older&nbsp;&nbsp;</span><i class="icon icon-angle-right" aria-hidden="true"></i></a></li></ul><div class="bar-right"><div class="share-component" data-sites="weibo,qq,wechat,facebook,twitter" data-mobile-sites="weibo,qq,qzone"></div></div></div></nav></main><footer class="footer" itemscope itemtype="http://schema.org/WPFooter"><ul class="social-links"><li><a href="mailto:kuangqp1217@qq.com" target="_blank" title="Email" data-toggle="tooltip" data-placement="top"><i class="icon icon-email"></i></a></li><li><a href="http://wpa.qq.com/msgrd?v=3&uin=940240973&site=qq&menu=yes" target="_blank" title="Qq" data-toggle="tooltip" data-placement="top"><i class="icon icon-qq"></i></a></li><li><a href="https://twitter.com/yuan_four" target="_blank" title="Twitter" data-toggle="tooltip" data-placement="top"><i class="icon icon-twitter"></i></a></li><li><a href="https://github.com/l2l7l9p" target="_blank" title="Github" data-toggle="tooltip" data-placement="top"><i class="icon icon-github"></i></a></li><li><a href="/atom.xml" target="_blank" title="Rss" data-toggle="tooltip" data-placement="top"><i class="icon icon-rss"></i></a></li></ul><div class="copyright"><div class="publishby">Theme by <a href="https://github.com/cofess" target="_blank">cofess </a>base on <a href="https://github.com/cofess/hexo-theme-pure" target="_blank">pure</a>.</div></div></footer><script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script><script>window.jQuery||document.write('<script src="js/jquery.min.js"><\/script>')</script><script src="/js/plugin.min.js"></script><script src="/js/application.js"></script><script>window.INSIGHT_CONFIG={TRANSLATION:{POSTS:"Posts",PAGES:"Pages",CATEGORIES:"Categories",TAGS:"Tags",UNTITLED:"(Untitled)"},ROOT_URL:"/",CONTENT_URL:"/content.json"}</script><script src="/js/insight.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//cdn.jsdelivr.net/npm/valine"></script><script type="text/javascript">var GUEST=["nick","mail","link"],meta=(meta="nick,mail,link").split(",").filter(function(e){return-1<GUEST.indexOf(e)});new Valine({el:"#vcomments",verify:!1,notify:!0,appId:"YsBbwGr5CQ2WyuobqGxOedtu-gzGzoHsz",appKey:"Wplm0hz1L65wFVye5hE8tOTf",placeholder:"Just go go",avatar:"mm",meta:meta,pageSize:"10",visitor:!1})</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });</script><script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script></body></html>